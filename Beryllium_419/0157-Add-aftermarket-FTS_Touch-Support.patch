From 0de5ee9d36ebd6f358b4c65511afcf72bff056f7 Mon Sep 17 00:00:00 2001
From: duckyduckG <duckyduckg65@gmail.com>
Date: Fri, 10 Jan 2025 12:58:22 +0500
Subject: [PATCH 157/175] Add aftermarket FTS_Touch Support

---
 .../configs/vendor/xiaomi/beryllium.config    |    2 +
 drivers/gpu/drm/Makefile                      |    3 +-
 drivers/gpu/drm/drm_bridge.c                  |   12 +
 drivers/gpu/drm/drm_internal_mi.h             |   65 +
 drivers/gpu/drm/drm_ioctl.c                   |   30 +-
 drivers/gpu/drm/drm_mipi_dsi.c                |   21 +
 drivers/gpu/drm/drm_notifier_mi.c             |   57 +
 drivers/gpu/drm/drm_sysfs.c                   |  298 ++
 drivers/input/touchscreen/Kconfig             |   11 +
 drivers/input/touchscreen/Makefile            |    2 +
 drivers/input/touchscreen/tp_common.c         |   29 +
 drivers/input/touchscreen/xiaomi/Kconfig      |    9 +
 drivers/input/touchscreen/xiaomi/Makefile     |    1 +
 .../input/touchscreen/xiaomi/xiaomi_touch.c   |  746 ++++
 .../input/touchscreen/xiaomi/xiaomi_touch.h   |  160 +
 drivers/video/backlight/backlight.c           |   33 +
 include/drm/drm_bridge.h                      |    3 +
 include/drm/drm_mipi_dsi.h                    |    2 +
 include/drm/drm_notifier_mi.h                 |   55 +
 include/linux/backlight.h                     |    4 +
 include/linux/input/tp_common.h               |   15 +
 include/uapi/drm/sde_drm.h                    |    6 +
 techpack/display/config/konadisp.conf         |    1 +
 techpack/display/config/konadispconf.h        |    1 +
 techpack/display/msm/Makefile                 |    6 +
 techpack/display/msm/dp/dp_display.c          |    1 +
 techpack/display/msm/dsi/dsi_defs.h           |   70 +
 techpack/display/msm/dsi/dsi_display.c        |  376 +-
 techpack/display/msm/dsi/dsi_display.h        |   12 +
 techpack/display/msm/dsi/dsi_display_mi.c     |  489 +++
 techpack/display/msm/dsi/dsi_drm.c            |  148 +-
 techpack/display/msm/dsi/dsi_drm.h            |    1 +
 techpack/display/msm/dsi/dsi_mi_feature.h     |   99 +
 techpack/display/msm/dsi/dsi_panel.c          |  758 +++-
 techpack/display/msm/dsi/dsi_panel.h          |   43 +-
 techpack/display/msm/dsi/dsi_panel_mi.c       | 3146 +++++++++++++++++
 techpack/display/msm/dsi/dsi_panel_mi.h       |  298 ++
 techpack/display/msm/dsi/dsi_phy.c            |    1 +
 techpack/display/msm/dsi/dsi_phy_hw.h         |    1 +
 techpack/display/msm/dsi/dsi_phy_hw_v4_0.c    |   21 +-
 techpack/display/msm/msm_atomic.c             |   20 +
 techpack/display/msm/msm_drv.c                |   18 +
 techpack/display/msm/msm_drv.h                |   10 +
 techpack/display/msm/msm_notifier.c           |    2 +
 .../display/msm/sde/clone_cooling_device.c    |  162 +
 .../display/msm/sde/clone_cooling_device.h    |   19 +
 .../display/msm/sde/sde_color_processing.c    |   13 +-
 techpack/display/msm/sde/sde_connector.c      |  561 ++-
 techpack/display/msm/sde/sde_connector.h      |   36 +
 techpack/display/msm/sde/sde_crtc.c           |  428 ++-
 techpack/display/msm/sde/sde_crtc.h           |   79 +
 techpack/display/msm/sde/sde_encoder.c        |  159 +-
 techpack/display/msm/sde/sde_encoder_phys.h   |   10 +-
 .../display/msm/sde/sde_encoder_phys_cmd.c    |   18 +-
 .../display/msm/sde/sde_encoder_phys_vid.c    |    4 +
 techpack/display/msm/sde/sde_expo_dim_layer.c |  102 +
 techpack/display/msm/sde/sde_expo_dim_layer.h |   54 +
 techpack/display/msm/sde/sde_hw_intf.c        |    3 -
 techpack/display/msm/sde/sde_hw_mdss.h        |   13 +-
 techpack/display/msm/sde/sde_hw_top.c         |   32 +
 techpack/display/msm/sde/sde_hw_top.h         |   25 +
 techpack/display/msm/sde/sde_kms.c            |   43 +-
 techpack/display/msm/sde/sde_kms.h            |    4 +-
 techpack/display/msm/sde/sde_plane.c          |   67 +-
 techpack/display/msm/sde/sde_plane.h          |    8 +
 techpack/display/msm/sde/sde_rm.c             |   38 +
 techpack/display/msm/xiaomi_frame_stat.c      |  171 +
 techpack/display/msm/xiaomi_frame_stat.h      |   69 +
 68 files changed, 9044 insertions(+), 160 deletions(-)
 create mode 100644 drivers/gpu/drm/drm_internal_mi.h
 create mode 100644 drivers/gpu/drm/drm_notifier_mi.c
 create mode 100644 drivers/input/touchscreen/tp_common.c
 create mode 100644 drivers/input/touchscreen/xiaomi/Kconfig
 create mode 100644 drivers/input/touchscreen/xiaomi/Makefile
 create mode 100644 drivers/input/touchscreen/xiaomi/xiaomi_touch.c
 create mode 100644 drivers/input/touchscreen/xiaomi/xiaomi_touch.h
 create mode 100644 include/drm/drm_notifier_mi.h
 create mode 100644 include/linux/input/tp_common.h
 create mode 100644 techpack/display/msm/dsi/dsi_display_mi.c
 create mode 100644 techpack/display/msm/dsi/dsi_mi_feature.h
 create mode 100755 techpack/display/msm/dsi/dsi_panel_mi.c
 create mode 100755 techpack/display/msm/dsi/dsi_panel_mi.h
 create mode 100644 techpack/display/msm/sde/clone_cooling_device.c
 create mode 100644 techpack/display/msm/sde/clone_cooling_device.h
 create mode 100644 techpack/display/msm/sde/sde_expo_dim_layer.c
 create mode 100644 techpack/display/msm/sde/sde_expo_dim_layer.h
 create mode 100644 techpack/display/msm/xiaomi_frame_stat.c
 create mode 100644 techpack/display/msm/xiaomi_frame_stat.h

diff --git a/arch/arm64/configs/vendor/xiaomi/beryllium.config b/arch/arm64/configs/vendor/xiaomi/beryllium.config
index 4f1c73cdc332..2c35827ecc89 100644
--- a/arch/arm64/configs/vendor/xiaomi/beryllium.config
+++ b/arch/arm64/configs/vendor/xiaomi/beryllium.config
@@ -8,3 +8,5 @@ CONFIG_TOUCHSCREEN_FTS_MI=y
 CONFIG_TOUCHSCREEN_NT36XXX_LOS=y
 CONFIG_USE_BU64748=y
 CONFIG_LEDS_LM3644=y
+CONFIG_TOUCHSCREEN_XIAOMI_TOUCHFEATURE=y
+CONFIG_TOUCHSCREEN_COMMON=y
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index a6771cef85e2..d156336d8c96 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -18,7 +18,8 @@ drm-y       :=	drm_auth.o drm_bufs.o drm_cache.o \
 		drm_encoder.o drm_mode_object.o drm_property.o \
 		drm_plane.o drm_color_mgmt.o drm_print.o \
 		drm_dumb_buffers.o drm_mode_config.o drm_vblank.o \
-		drm_syncobj.o drm_lease.o drm_writeback.o drm_client.o
+		drm_syncobj.o drm_lease.o drm_writeback.o drm_client.o \
+		drm_notifier_mi.o
 
 drm-$(CONFIG_DRM_LIB_RANDOM) += lib/drm_random.o
 drm-$(CONFIG_DRM_VM) += drm_vm.o
diff --git a/drivers/gpu/drm/drm_bridge.c b/drivers/gpu/drm/drm_bridge.c
index 1638bfe9627c..450edc440fd9 100644
--- a/drivers/gpu/drm/drm_bridge.c
+++ b/drivers/gpu/drm/drm_bridge.c
@@ -269,9 +269,15 @@ void drm_bridge_post_disable(struct drm_bridge *bridge)
 {
 	if (!bridge)
 		return;
+	
+	if (bridge->is_dsi_drm_bridge)
+		mutex_lock(&bridge->lock);
 
 	if (bridge->funcs->post_disable)
 		bridge->funcs->post_disable(bridge);
+	
+	if (bridge->is_dsi_drm_bridge)
+		mutex_unlock(&bridge->lock);
 
 	drm_bridge_post_disable(bridge->next);
 }
@@ -320,9 +326,15 @@ void drm_bridge_pre_enable(struct drm_bridge *bridge)
 		return;
 
 	drm_bridge_pre_enable(bridge->next);
+	
+	if (bridge->is_dsi_drm_bridge)
+		mutex_lock(&bridge->lock);
 
 	if (bridge->funcs->pre_enable)
 		bridge->funcs->pre_enable(bridge);
+	
+	if (bridge->is_dsi_drm_bridge)
+		mutex_unlock(&bridge->lock);
 }
 EXPORT_SYMBOL(drm_bridge_pre_enable);
 
diff --git a/drivers/gpu/drm/drm_internal_mi.h b/drivers/gpu/drm/drm_internal_mi.h
new file mode 100644
index 000000000000..fc077c62e391
--- /dev/null
+++ b/drivers/gpu/drm/drm_internal_mi.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2022 Xiaomi, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DRM_INTERFACE_MI_H_
+#define _DRM_INTERFACE_MI_H_
+
+/* dsi_display_mi.c */
+int dsi_display_set_disp_param(struct drm_connector *connector,
+				u32 param_type);
+int dsi_display_get_disp_param(struct drm_connector *connector,
+				u32 *param_type);
+
+ssize_t dsi_display_write_mipi_reg(struct drm_connector *connector,
+				char *buf);
+ssize_t dsi_display_read_mipi_reg(struct drm_connector *connector,
+				char *buf);
+
+ssize_t dsi_display_read_oled_pmic_id(struct drm_connector *connector,
+				char *buf);
+
+ssize_t dsi_display_read_panel_info(struct drm_connector *connector,
+				char *buf);
+
+ssize_t dsi_display_read_wp_info(struct drm_connector *connector,
+				char *buf);
+
+ssize_t dsi_display_read_dynamic_fps(struct drm_connector *connector,
+				char *buf);
+
+int dsi_display_set_doze_brightness(struct drm_connector *connector,
+				int doze_brightness);
+ssize_t dsi_display_get_doze_brightness(struct drm_connector *connector,
+				char *buf);
+
+int dsi_display_read_gamma_param(struct drm_connector *connector);
+ssize_t dsi_display_print_gamma_param(struct drm_connector *connector,
+				char *buf);
+
+int dsi_display_count_set(struct drm_connector *connector, const char *buf);
+ssize_t dsi_display_count_get(struct drm_connector *connector,	char *buf);
+ssize_t dsi_display_fod_get(struct drm_connector *connector, char *buf);
+
+ssize_t complete_commit_time_get(struct drm_connector *connector, char *buf);
+
+int dsi_display_set_thermal_hbm_disabled(struct drm_connector *connector,
+				bool thermal_hbm_disabled);
+int dsi_display_get_thermal_hbm_disabled(struct drm_connector *connector,
+				bool *thermal_hbm_disabled);
+
+ssize_t dsi_display_get_hw_vsync_info(struct drm_connector *connector,
+				char *buf);
+
+#endif /*_DRM_INTERFACE_MI_H_*/
diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
index 5a672aaa110b..a92bb4e13d5c 100644
--- a/drivers/gpu/drm/drm_ioctl.c
+++ b/drivers/gpu/drm/drm_ioctl.c
@@ -514,6 +514,28 @@ int drm_version(struct drm_device *dev, void *data,
 	return err;
 }
 
+const char *support_list[] = {
+	"displayfeature",
+	"DisplayFeature",
+	"disp_pcc",
+	"displayeffect",
+	"factoryreset",
+	"recovery",
+	NULL
+};
+static bool drm_master_filter(char *task_name)
+{
+	unsigned int i = 0;
+	bool ret = false;
+	for (i = 0; support_list[i] != NULL; i++) {
+		if (!strncmp(task_name, support_list[i], strlen(support_list[i]))) {
+			ret = true;
+			break;
+		}
+	}
+	return ret;
+}
+
 /**
  * drm_ioctl_permit - Check ioctl permissions against caller
  *
@@ -528,6 +550,7 @@ int drm_version(struct drm_device *dev, void *data,
  */
 int drm_ioctl_permit(u32 flags, struct drm_file *file_priv)
 {
+	struct task_struct *task = get_current();
 	/* ROOT_ONLY is only for CAP_SYS_ADMIN */
 	if (unlikely((flags & DRM_ROOT_ONLY) && !capable(CAP_SYS_ADMIN)))
 		return -EACCES;
@@ -539,8 +562,11 @@ int drm_ioctl_permit(u32 flags, struct drm_file *file_priv)
 
 	/* MASTER is only for master or control clients */
 	if (unlikely((flags & DRM_MASTER) &&
-		     !drm_is_current_master(file_priv)))
-		return -EACCES;
+		     !drm_is_current_master(file_priv))) {
+		if (!drm_master_filter(task->comm)) {
+			return -EACCES;
+		}
+	}
 
 	/* Render clients must be explicitly allowed */
 	if (unlikely(!(flags & DRM_RENDER_ALLOW) &&
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index b15d5e4320d6..9d3a4d6337e5 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -1084,6 +1084,27 @@ int mipi_dsi_dcs_set_display_brightness(struct mipi_dsi_device *dsi,
 }
 EXPORT_SYMBOL(mipi_dsi_dcs_set_display_brightness);
 
+/**
+ * mipi_dsi_dcs_set_display_brightness_bigendian() - sets the brightness value of the
+ * display with big endian, high byte to 1st parameter, low byte to 2nd parameter
+ * @dsi: DSI peripheral device
+ * @brightness: brightness value
+ *
+ * Return: 0 on success or a negative error code on failure.
+ */
+int mipi_dsi_dcs_set_display_brightness_big_endian(struct mipi_dsi_device *dsi,
+					u16 brightness)
+{
+	u8 payload[2] = { brightness >> 8, brightness & 0xff};
+	ssize_t err;
+	err = mipi_dsi_dcs_write(dsi, MIPI_DCS_SET_DISPLAY_BRIGHTNESS,
+				 payload, sizeof(payload));
+	if (err < 0)
+		return err;
+	return 0;
+}
+EXPORT_SYMBOL(mipi_dsi_dcs_set_display_brightness_big_endian);
+
 /**
  * mipi_dsi_dcs_get_display_brightness() - gets the current brightness value
  *    of the display
diff --git a/drivers/gpu/drm/drm_notifier_mi.c b/drivers/gpu/drm/drm_notifier_mi.c
new file mode 100644
index 000000000000..30c5bfad85bc
--- /dev/null
+++ b/drivers/gpu/drm/drm_notifier_mi.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/notifier.h>
+
+static BLOCKING_NOTIFIER_HEAD(mi_drm_notifier_list);
+
+/**
+ * mi_drm_register_client - register a client notifier
+ * @nb: notifier block to callback on events
+ *
+ * This function registers a notifier callback function
+ * to msm_drm_notifier_list, which would be called when
+ * received unblank/power down event.
+ */
+int mi_drm_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&mi_drm_notifier_list, nb);
+}
+EXPORT_SYMBOL(mi_drm_register_client);
+
+/**
+ * mi_drm_unregister_client - unregister a client notifier
+ * @nb: notifier block to callback on events
+ *
+ * This function unregisters the callback function from
+ * msm_drm_notifier_list.
+ */
+int mi_drm_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&mi_drm_notifier_list, nb);
+}
+EXPORT_SYMBOL(mi_drm_unregister_client);
+
+/**
+ * mi_drm_notifier_call_chain - notify clients of drm_events
+ * @val: event MSM_DRM_EARLY_EVENT_BLANK or MSM_DRM_EVENT_BLANK
+ * @v: notifier data, inculde display id and display blank
+ *     event(unblank or power down).
+ */
+int mi_drm_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&mi_drm_notifier_list, val, v);
+}
+EXPORT_SYMBOL(mi_drm_notifier_call_chain);
+
diff --git a/drivers/gpu/drm/drm_sysfs.c b/drivers/gpu/drm/drm_sysfs.c
index ecb7b33002bb..2bc8efb29086 100644
--- a/drivers/gpu/drm/drm_sysfs.c
+++ b/drivers/gpu/drm/drm_sysfs.c
@@ -7,6 +7,7 @@
  * Copyright (c) 2004 Jon Smirl <jonsmirl@gmail.com>
  * Copyright (c) 2003-2004 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (c) 2003-2004 IBM Corp.
+ * Copyright (C) 2022 Xiaomi, Inc.
  *
  * This file is released under the GPLv2
  *
@@ -21,10 +22,13 @@
 #include <drm/drm_sysfs.h>
 #include <drm/drmP.h>
 #include "drm_internal.h"
+#include "drm_internal_mi.h"
+#include <drm/msm_drm_pp.h>
 
 #define to_drm_minor(d) dev_get_drvdata(d)
 #define to_drm_connector(d) dev_get_drvdata(d)
 
+
 /**
  * DOC: overview
  *
@@ -44,6 +48,7 @@ static struct device_type drm_sysfs_device_minor = {
 };
 
 struct class *drm_class;
+struct device *connector_kdev;
 
 static char *drm_devnode(struct device *dev, umode_t *mode)
 {
@@ -229,16 +234,306 @@ static ssize_t modes_show(struct device *device,
 	return written;
 }
 
+static ssize_t disp_param_store(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	char *input_copy, *input_dup = NULL;
+	u32 param;
+	int ret;
+	input_copy = kstrdup(buf, GFP_KERNEL);
+	if (!input_copy) {
+		DRM_ERROR("can not allocate memory\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	input_dup = input_copy;
+	/* removes leading and trailing whitespace from input_copy */
+	input_copy = strim(input_copy);
+	ret = kstrtouint(input_copy, 16, &param);
+	if (ret) {
+		DRM_ERROR("input buffer conversion failed\n");
+		ret = -EAGAIN;
+		goto exit_free;
+	}
+	ret = dsi_display_set_disp_param(connector, param);
+exit_free:
+	kfree(input_dup);
+exit:
+	return ret ? ret : count;
+}
+static ssize_t disp_param_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	u32 param;
+	dsi_display_get_disp_param(connector, &param);
+	return snprintf(buf, PAGE_SIZE, "0x%08X\n", param);
+}
+static ssize_t mipi_reg_store(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	int ret;
+	ret = dsi_display_write_mipi_reg(connector, (char *)buf);
+	return ret ? ret : count;
+}
+static ssize_t mipi_reg_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	return dsi_display_read_mipi_reg(connector, buf);
+}
+static ssize_t oled_pmic_id_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	return dsi_display_read_oled_pmic_id(connector, buf);
+}
+static ssize_t panel_info_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	return dsi_display_read_panel_info(connector, buf);
+}
+static ssize_t wp_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(dev);
+	return dsi_display_read_wp_info(connector, buf);
+}
+static ssize_t dynamic_fps_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(dev);
+	return dsi_display_read_dynamic_fps(connector, buf);
+}
+static ssize_t doze_brightness_store(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	int doze_brightness;
+	int ret;
+	ret = kstrtoint(buf, 0, &doze_brightness);
+	if (ret)
+		return ret;
+	ret = dsi_display_set_doze_brightness(connector, doze_brightness);
+	return ret ? ret : count;
+}
+static ssize_t doze_brightness_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(dev);
+	return dsi_display_get_doze_brightness(connector, buf);
+}
+static ssize_t gamma_test_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(dev);
+	int ret = 0;
+	ret = dsi_display_read_gamma_param(connector);
+	if (ret)
+		pr_err("Failed to update panel id and gamma para!\n");
+	ret = dsi_display_print_gamma_param(connector, buf);
+	return ret;
+}
+extern ssize_t smart_fps_value_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf);
+static ssize_t fod_ui_ready_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	return dsi_display_fod_get(connector, buf);
+}
+static ssize_t complete_commit_time_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(dev);
+	return complete_commit_time_get(connector, buf);
+}
+struct drm_msm_pcc color_transform_pcc_cfg = {
+	.r.c = 0, .r.r = 32768, .r.g = 0, .r.b = 0,
+	.g.c = 0, .g.r = 0, .g.g = 32768, .g.b = 0,
+	.b.c = 0, .b.r = 0, .b.g = 0, .b.b = 32768,};
+static ssize_t disp_pcc_store(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int ret;
+	ssize_t result;
+	pr_info("[LCD] %s: begin\n", __func__);
+	result = sscanf(buf,
+		"pcc_cfg_r_c=%d\n"
+		"pcc_cfg_r_r=%d\n"
+		"pcc_cfg_r_g=%d\n"
+		"pcc_cfg_r_b=%d\n"
+		"pcc_cfg_g_c=%d\n"
+		"pcc_cfg_g_r=%d\n"
+		"pcc_cfg_g_g=%d\n"
+		"pcc_cfg_g_b=%d\n"
+		"pcc_cfg_b_c=%d\n"
+		"pcc_cfg_b_r=%d\n"
+		"pcc_cfg_b_g=%d\n"
+		"pcc_cfg_b_b=%d\n",
+		&color_transform_pcc_cfg.r.c,
+		&color_transform_pcc_cfg.r.r,
+		&color_transform_pcc_cfg.r.g,
+		&color_transform_pcc_cfg.r.b,
+		&color_transform_pcc_cfg.g.c,
+		&color_transform_pcc_cfg.g.r,
+		&color_transform_pcc_cfg.g.g,
+		&color_transform_pcc_cfg.g.b,
+		&color_transform_pcc_cfg.b.c,
+		&color_transform_pcc_cfg.b.r,
+		&color_transform_pcc_cfg.b.g,
+		&color_transform_pcc_cfg.b.b);
+	ret = 0;
+	pr_info("set pcc r_c=%d r_r=%d r_g=%d r_b=%d g_c=%d g_r=%d g_g=%d g_b=%d b_c=%d b_r=%d b_g=%d b_b=%d",
+		color_transform_pcc_cfg.r.c,
+		color_transform_pcc_cfg.r.r,
+		color_transform_pcc_cfg.r.g,
+		color_transform_pcc_cfg.r.b,
+		color_transform_pcc_cfg.g.c,
+		color_transform_pcc_cfg.g.r,
+		color_transform_pcc_cfg.g.g,
+		color_transform_pcc_cfg.g.b,
+		color_transform_pcc_cfg.b.c,
+		color_transform_pcc_cfg.b.r,
+		color_transform_pcc_cfg.b.g,
+		color_transform_pcc_cfg.b.b);
+	return ret ? ret : count;
+}
+static ssize_t disp_pcc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ret = -1;
+	if (buf == NULL) {
+		pr_err("%s is NULL!\n", __func__);
+		return -EINVAL;
+	}
+	ret = scnprintf(buf, PAGE_SIZE,
+		"pcc_cfg_r_c=%d\n"
+		"pcc_cfg_r_r=%d\n"
+		"pcc_cfg_r_g=%d\n"
+		"pcc_cfg_r_b=%d\n"
+		"pcc_cfg_g_c=%d\n"
+		"pcc_cfg_g_r=%d\n"
+		"pcc_cfg_g_g=%d\n"
+		"pcc_cfg_g_b=%d\n"
+		"pcc_cfg_b_c=%d\n"
+		"pcc_cfg_b_r=%d\n"
+		"pcc_cfg_b_g=%d\n"
+		"pcc_cfg_b_b=%d\n",
+		color_transform_pcc_cfg.r.c,
+		color_transform_pcc_cfg.r.r,
+		color_transform_pcc_cfg.r.g,
+		color_transform_pcc_cfg.r.b,
+		color_transform_pcc_cfg.g.c,
+		color_transform_pcc_cfg.g.r,
+		color_transform_pcc_cfg.g.g,
+		color_transform_pcc_cfg.g.b,
+		color_transform_pcc_cfg.b.c,
+		color_transform_pcc_cfg.b.r,
+		color_transform_pcc_cfg.b.g,
+		color_transform_pcc_cfg.b.b);
+	return ret;
+}
+static ssize_t thermal_hbm_disabled_store(struct device *device,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	char *input_copy, *input_dup = NULL;
+	bool thermal_hbm_disabled;
+	int ret;
+	input_copy = kstrdup(buf, GFP_KERNEL);
+	if (!input_copy) {
+		DRM_ERROR("can not allocate memory\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	input_dup = input_copy;
+	/* removes leading and trailing whitespace from input_copy */
+	input_copy = strim(input_copy);
+	ret = kstrtobool(input_copy, &thermal_hbm_disabled);
+	if (ret) {
+		DRM_ERROR("input buffer conversion failed\n");
+		ret = -EAGAIN;
+		goto exit_free;
+	}
+	DRM_INFO("set thermal_hbm_disabled %d\n", thermal_hbm_disabled);
+	ret = dsi_display_set_thermal_hbm_disabled(connector,
+						   thermal_hbm_disabled);
+exit_free:
+	kfree(input_dup);
+exit:
+	return ret ? ret : count;
+}
+static ssize_t thermal_hbm_disabled_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	bool thermal_hbm_disabled;
+	dsi_display_get_thermal_hbm_disabled(connector, &thermal_hbm_disabled);
+	return snprintf(buf, PAGE_SIZE, "%d\n", thermal_hbm_disabled);
+}
+static ssize_t hw_vsync_info_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	struct drm_connector *connector = to_drm_connector(device);
+	return dsi_display_get_hw_vsync_info(connector, buf);
+}
+
 static DEVICE_ATTR_RW(status);
 static DEVICE_ATTR_RO(enabled);
 static DEVICE_ATTR_RO(dpms);
 static DEVICE_ATTR_RO(modes);
+static DEVICE_ATTR_RW(disp_param);
+static DEVICE_ATTR_RW(mipi_reg);
+static DEVICE_ATTR_RO(oled_pmic_id);
+static DEVICE_ATTR_RO(panel_info);
+static DEVICE_ATTR_RO(wp_info);
+static DEVICE_ATTR_RO(dynamic_fps);
+static DEVICE_ATTR_RW(doze_brightness);
+static DEVICE_ATTR_RO(gamma_test);
+static DEVICE_ATTR_RO(fod_ui_ready);
+static DEVICE_ATTR_RO(smart_fps_value);
+static DEVICE_ATTR_RO(complete_commit_time);
+static DEVICE_ATTR_RW(thermal_hbm_disabled);
+static DEVICE_ATTR_RO(hw_vsync_info);
+static DEVICE_ATTR_RW(disp_pcc);
 
 static struct attribute *connector_dev_attrs[] = {
 	&dev_attr_status.attr,
 	&dev_attr_enabled.attr,
 	&dev_attr_dpms.attr,
 	&dev_attr_modes.attr,
+	&dev_attr_disp_param.attr,
+	&dev_attr_mipi_reg.attr,
+	&dev_attr_oled_pmic_id.attr,
+	&dev_attr_panel_info.attr,
+	&dev_attr_wp_info.attr,
+	&dev_attr_dynamic_fps.attr,
+	&dev_attr_doze_brightness.attr,
+	&dev_attr_gamma_test.attr,
+	&dev_attr_fod_ui_ready.attr,
+	&dev_attr_smart_fps_value.attr,
+	&dev_attr_complete_commit_time.attr,
+	&dev_attr_thermal_hbm_disabled.attr,
+	&dev_attr_hw_vsync_info.attr,
+	&dev_attr_disp_pcc.attr,
 	NULL
 };
 
@@ -278,6 +573,9 @@ int drm_sysfs_connector_add(struct drm_connector *connector)
 					  connector->name);
 	DRM_DEBUG("adding \"%s\" to sysfs\n",
 		  connector->name);
+		 
+    if (!connector_kdev)
+		connector_kdev = connector->kdev;
 
 	if (IS_ERR(connector->kdev)) {
 		DRM_ERROR("failed to register connector device: %ld\n", PTR_ERR(connector->kdev));
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index eb6664fc0432..b27f6a4ad170 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1310,4 +1310,15 @@ source "drivers/input/touchscreen/focaltech_touch/Kconfig"
 
 source "drivers/input/touchscreen/nt36xxx/Kconfig"
 
+source "drivers/input/touchscreen/xiaomi/Kconfig"
+
+config TOUCHSCREEN_COMMON
+	bool "Common touchscreen interface to interact with userspace"
+	default y if MACH_XIAOMI
+	help
+	  Say Y here if you want to control touchpanel features via
+	  /sys/touchpanel.
+
+	  If unsure, say N.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 8b766e754948..fa3001cc00da 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -114,3 +114,5 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX) += synaptics_dsx/
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_TCM)	+= synaptics_tcm/
 obj-$(CONFIG_TOUCHSCREEN_FTS)	+= focaltech_touch/
 obj-$(CONFIG_TOUCHSCREEN_NT36XXX)	+= nt36xxx/
+obj-$(CONFIG_TOUCHSCREEN_XIAOMI_TOUCHFEATURE) += xiaomi/
+obj-$(CONFIG_TOUCHSCREEN_COMMON)	+= tp_common.o
diff --git a/drivers/input/touchscreen/tp_common.c b/drivers/input/touchscreen/tp_common.c
new file mode 100644
index 000000000000..194a03e06aa8
--- /dev/null
+++ b/drivers/input/touchscreen/tp_common.c
@@ -0,0 +1,29 @@
+#include <linux/input/tp_common.h>
+
+bool capacitive_keys_enabled;
+struct kobject *touchpanel_kobj;
+
+#define TS_ENABLE_FOPS(type)                                                   \
+	int tp_common_set_##type##_ops(struct tp_common_ops *ops)              \
+	{                                                                      \
+		static struct kobj_attribute kattr =                           \
+			__ATTR(type, (S_IWUSR | S_IRUGO), NULL, NULL);         \
+		kattr.show = ops->show;                                        \
+		kattr.store = ops->store;                                      \
+		return sysfs_create_file(touchpanel_kobj, &kattr.attr);        \
+	}
+
+TS_ENABLE_FOPS(capacitive_keys)
+TS_ENABLE_FOPS(double_tap)
+TS_ENABLE_FOPS(reversed_keys)
+
+static int __init tp_common_init(void)
+{
+	touchpanel_kobj = kobject_create_and_add("touchpanel", NULL);
+	if (!touchpanel_kobj)
+		return -ENOMEM;
+
+	return 0;
+}
+
+core_initcall(tp_common_init);
diff --git a/drivers/input/touchscreen/xiaomi/Kconfig b/drivers/input/touchscreen/xiaomi/Kconfig
new file mode 100644
index 000000000000..bab7644f364e
--- /dev/null
+++ b/drivers/input/touchscreen/xiaomi/Kconfig
@@ -0,0 +1,9 @@
+config TOUCHSCREEN_XIAOMI_TOUCHFEATURE
+	tristate "Xiaomi Touch Feature"
+	depends on INPUT_TOUCHSCREEN
+	help
+	  Say Y here if you enable xiaomi touch feature.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here:
diff --git a/drivers/input/touchscreen/xiaomi/Makefile b/drivers/input/touchscreen/xiaomi/Makefile
new file mode 100644
index 000000000000..9ed31b6c4a73
--- /dev/null
+++ b/drivers/input/touchscreen/xiaomi/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TOUCHSCREEN_XIAOMI_TOUCHFEATURE) += xiaomi_touch.o
diff --git a/drivers/input/touchscreen/xiaomi/xiaomi_touch.c b/drivers/input/touchscreen/xiaomi/xiaomi_touch.c
new file mode 100644
index 000000000000..13c3f765a265
--- /dev/null
+++ b/drivers/input/touchscreen/xiaomi/xiaomi_touch.c
@@ -0,0 +1,746 @@
+#include "xiaomi_touch.h"
+
+static struct xiaomi_touch_pdata *touch_pdata;
+
+static int xiaomi_touch_dev_open(struct inode *inode, struct file *file)
+{
+	struct xiaomi_touch *dev = NULL;
+	int i = MINOR(inode->i_rdev);
+	struct xiaomi_touch_pdata *touch_pdata;
+
+	MI_TOUCH_LOGD(1, "%s %s: enter\n", MI_TAG, __func__);
+	dev = xiaomi_touch_dev_get(i);
+	if (!dev) {
+		MI_TOUCH_LOGE(1, "%s %s: cant get dev\n", MI_TAG, __func__);
+		return -ENOMEM;
+	}
+	touch_pdata = dev_get_drvdata(dev->dev);
+
+	file->private_data = touch_pdata;
+	return 0;
+}
+
+static ssize_t xiaomi_touch_dev_read(struct file *file, char __user *buf,
+			   size_t count, loff_t *pos)
+{
+	return 0;
+}
+
+static ssize_t xiaomi_touch_dev_write(struct file *file,
+		const char __user *buf, size_t count, loff_t *pos)
+{
+	return 0;
+}
+
+static unsigned int xiaomi_touch_dev_poll(struct file *file,
+		poll_table *wait)
+{
+	return 0;
+}
+
+static long xiaomi_touch_dev_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	int ret = -EINVAL;
+	int buf[MAX_BUF_SIZE] = {0,};
+	struct xiaomi_touch_pdata *pdata = file->private_data;
+	void __user *argp = (void __user *) arg;
+	struct xiaomi_touch_interface *touch_data = pdata->touch_data;
+	struct xiaomi_touch *dev = pdata->device;
+	int user_cmd = _IOC_NR(cmd);
+
+	if (!pdata || !touch_data || !dev) {
+		MI_TOUCH_LOGE(1, "%s %s: invalid memory\n", MI_TAG, __func__);
+		return -ENOMEM;
+	}
+
+	mutex_lock(&dev->mutex);
+	ret = copy_from_user(&buf, (int __user *)argp, sizeof(buf));
+
+	MI_TOUCH_LOGI(1, "%s %s: cmd:%d, mode:%d, value:%d\n",
+		MI_TAG, __func__, user_cmd, buf[0], buf[1]);
+
+	switch (user_cmd) {
+	case SET_CUR_VALUE:
+		if (touch_data->setModeValue)
+			buf[0] = touch_data->setModeValue(buf[0], buf[1]);
+		break;
+	case GET_CUR_VALUE:
+	case GET_DEF_VALUE:
+	case GET_MIN_VALUE:
+	case GET_MAX_VALUE:
+		if (touch_data->getModeValue)
+			buf[0] = touch_data->getModeValue(buf[0], user_cmd);
+		break;
+	case RESET_MODE:
+		if (touch_data->resetMode)
+			buf[0] = touch_data->resetMode(buf[0]);
+		break;
+	case GET_MODE_VALUE:
+		if (touch_data->getModeValue)
+			ret = touch_data->getModeAll(buf[0], buf);
+		break;
+	case SET_LONG_VALUE:
+		if (touch_data->setModeLongValue && buf[1] <= MAX_BUF_SIZE)
+			ret = touch_data->setModeLongValue(buf[0], buf[1], &buf[2]);
+		break;
+	default:
+		MI_TOUCH_LOGE(1, "%s %s: don't support mode\n", MI_TAG, __func__);
+		ret = -EINVAL;
+		break;
+	}
+
+	if (ret >= 0)
+		ret = copy_to_user((int __user *)argp, &buf, sizeof(buf));
+	else
+		MI_TOUCH_LOGE(1, "%s %s: can't get data from touch driver\n", MI_TAG, __func__);
+
+	mutex_unlock(&dev->mutex);
+
+	return ret;
+}
+
+static int xiaomi_touch_dev_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations xiaomitouch_dev_fops = {
+	.owner = THIS_MODULE,
+	.open = xiaomi_touch_dev_open,
+	.read = xiaomi_touch_dev_read,
+	.write = xiaomi_touch_dev_write,
+	.poll = xiaomi_touch_dev_poll,
+	.unlocked_ioctl = xiaomi_touch_dev_ioctl,
+	.compat_ioctl = xiaomi_touch_dev_ioctl,
+	.release = xiaomi_touch_dev_release,
+	.llseek	= no_llseek,
+};
+
+static struct xiaomi_touch xiaomi_touch_dev = {
+	.misc_dev = {
+		.minor = MISC_DYNAMIC_MINOR,
+		.name = XIAOMI_TOUCH_DEVICE_NAME,
+		.fops = &xiaomitouch_dev_fops,
+		.parent = NULL,
+	},
+	.mutex = __MUTEX_INITIALIZER(xiaomi_touch_dev.mutex),
+	.palm_mutex = __MUTEX_INITIALIZER(xiaomi_touch_dev.palm_mutex),
+	.psensor_mutex = __MUTEX_INITIALIZER(xiaomi_touch_dev.psensor_mutex),
+	.wait_queue = __WAIT_QUEUE_HEAD_INITIALIZER(xiaomi_touch_dev.wait_queue),
+};
+
+struct xiaomi_touch *xiaomi_touch_dev_get(int minor)
+{
+	if (xiaomi_touch_dev.misc_dev.minor == minor)
+		return &xiaomi_touch_dev;
+	else
+		return NULL;
+}
+
+struct class *get_xiaomi_touch_class(void)
+{
+	return xiaomi_touch_dev.class;
+}
+
+struct device *get_xiaomi_touch_dev(void)
+{
+	return xiaomi_touch_dev.dev;
+}
+
+int xiaomitouch_register_modedata(struct xiaomi_touch_interface *data)
+{
+	int ret = 0;
+	struct xiaomi_touch_interface *touch_data = NULL;
+
+	if (!touch_pdata)
+		ret = -ENOMEM;
+
+	touch_data = touch_pdata->touch_data;
+	MI_TOUCH_LOGI(1, "%s %s: \n", MI_TAG, __func__);
+
+	mutex_lock(&xiaomi_touch_dev.mutex);
+
+	touch_data->setModeValue = data->setModeValue;
+	touch_data->getModeValue = data->getModeValue;
+	touch_data->resetMode = data->resetMode;
+	touch_data->getModeAll = data->getModeAll;
+	touch_data->palm_sensor_read = data->palm_sensor_read;
+	touch_data->palm_sensor_write = data->palm_sensor_write;
+	touch_data->p_sensor_read = data->p_sensor_read;
+	touch_data->p_sensor_write = data->p_sensor_write;
+	touch_data->panel_vendor_read = data->panel_vendor_read;
+	touch_data->panel_color_read = data->panel_color_read;
+	touch_data->panel_display_read = data->panel_display_read;
+	touch_data->touch_vendor_read = data->touch_vendor_read;
+	touch_data->setModeLongValue = data->setModeLongValue;
+	touch_data->get_touch_super_resolution_factor = data->get_touch_super_resolution_factor;
+#if XIAOMI_ROI
+	touch_data->partial_diff_data_read = data->partial_diff_data_read;
+#endif
+
+	mutex_unlock(&xiaomi_touch_dev.mutex);
+
+	return ret;
+}
+
+int update_palm_sensor_value(int value)
+{
+	struct xiaomi_touch *dev = NULL;
+
+	mutex_lock(&xiaomi_touch_dev.palm_mutex);
+
+	if (!touch_pdata) {
+		mutex_unlock(&xiaomi_touch_dev.palm_mutex);
+		return -ENODEV;
+	}
+
+	dev = touch_pdata->device;
+
+	if (value != touch_pdata->palm_value) {
+		MI_TOUCH_LOGI(1, "%s %s: value:%d\n", MI_TAG, __func__, value);
+		touch_pdata->palm_value = value;
+		touch_pdata->palm_changed = true;
+		sysfs_notify(&xiaomi_touch_dev.dev->kobj, NULL,
+		     "palm_sensor");
+	}
+
+	mutex_unlock(&xiaomi_touch_dev.palm_mutex);
+	return 0;
+}
+
+static ssize_t palm_sensor_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	pdata->palm_changed = false;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata->palm_value);
+}
+
+static ssize_t palm_sensor_store(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (sscanf(buf, "%d", &input) < 0)
+			return -EINVAL;
+
+	if (pdata->touch_data->palm_sensor_write)
+		pdata->touch_data->palm_sensor_write(!!input);
+	else {
+		MI_TOUCH_LOGE(1, "%s %s: has not implement\n", MI_TAG, __func__);
+	}
+	MI_TOUCH_LOGI(1, "%s %s: value:%d\n", MI_TAG, __func__, !!input);
+
+	return count;
+}
+
+static ssize_t set_update_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata->set_update);
+}
+
+static ssize_t set_update_store(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	int input;
+	int ret;
+
+	ret = sscanf(buf, "%d", &input);
+
+	if (ret < 0)
+		return -EINVAL;
+
+	pdata->set_update = !!input;
+
+	return count;
+}
+
+static ssize_t bump_sample_rate_start(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata->bump_sample_rate);
+}
+
+static ssize_t bump_sample_rate_store(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	struct xiaomi_touch_interface *touch_data = pdata->touch_data;
+	int input;
+	int ret;
+
+	ret = sscanf(buf, "%d", &input);
+
+	if (ret < 0)
+		return -EINVAL; // Avoid possible crashes
+
+	if(input) {
+		pdata->bump_sample_rate = true;
+		pdata->set_update = true;
+		touch_data->setModeValue(0, 1);
+		touch_data->setModeValue(1, 1);
+		touch_data->setModeValue(3, 34);
+		touch_data->setModeValue(2, 99);
+		touch_data->setModeValue(7, 0);
+	} else {
+		pdata->bump_sample_rate = false;
+		pdata->set_update = false;
+		touch_data->resetMode(0);
+	}
+
+	return count;
+}
+
+int update_p_sensor_value(int value)
+{
+	struct xiaomi_touch *dev = NULL;
+
+	mutex_lock(&xiaomi_touch_dev.psensor_mutex);
+
+	if (!touch_pdata) {
+		mutex_unlock(&xiaomi_touch_dev.psensor_mutex);
+		return -ENODEV;
+	}
+
+	dev = touch_pdata->device;
+
+	if (value != touch_pdata->psensor_value) {
+		MI_TOUCH_LOGI(1, "%s %s: value:%d\n", MI_TAG, __func__, value);
+		touch_pdata->psensor_value = value;
+		touch_pdata->psensor_changed = true;
+		wake_up(&dev->wait_queue);
+	}
+
+	mutex_unlock(&xiaomi_touch_dev.psensor_mutex);
+	return 0;
+}
+
+static ssize_t p_sensor_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	struct xiaomi_touch *touch_dev = pdata->device;
+
+	wait_event_interruptible(touch_dev->wait_queue, pdata->psensor_changed);
+	pdata->psensor_changed = false;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata->psensor_value);
+}
+
+static ssize_t p_sensor_store(struct device *dev,
+struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (sscanf(buf, "%d", &input) < 0)
+			return -EINVAL;
+
+	if (pdata->touch_data->p_sensor_write)
+		pdata->touch_data->p_sensor_write(!!input);
+	else {
+		MI_TOUCH_LOGE(1, "%s %s: has not implement\n", MI_TAG, __func__);
+	}
+	MI_TOUCH_LOGI(1, "%s %s: value:%d\n", MI_TAG, __func__, !!input);
+
+	return count;
+}
+
+static ssize_t panel_vendor_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (pdata->touch_data->panel_vendor_read)
+		return snprintf(buf, PAGE_SIZE, "%c", pdata->touch_data->panel_vendor_read());
+	else
+		return -EINVAL;
+}
+
+static ssize_t panel_color_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (pdata->touch_data->panel_color_read)
+		return snprintf(buf, PAGE_SIZE, "%c", pdata->touch_data->panel_color_read());
+	else
+		return -EINVAL;
+}
+
+static ssize_t panel_display_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (pdata->touch_data->panel_display_read)
+		return snprintf(buf, PAGE_SIZE, "%c", pdata->touch_data->panel_display_read());
+	else
+		return -EINVAL;
+}
+
+#if XIAOMI_ROI
+static ssize_t xiaomi_partial_diff_data_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	int i = 0;
+
+	char *temp_buf = buf;
+	int all_str_len = PAGE_SIZE;
+	int count = 0;
+
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (pdata->touch_data->partial_diff_data_read && pdata->diff_data)  {
+		ret = pdata->touch_data->partial_diff_data_read(pdata->diff_data);
+	} else {
+		MI_TOUCH_LOGE(1, "null pointer return");
+		return -EINVAL;
+	}
+
+	if (ret > 0 && pdata->debug_roi_flag) {
+
+		count = snprintf(temp_buf, all_str_len, "flag=%d,frame=%d,x=%d,y=%d\n",
+			pdata->diff_data->flag, pdata->diff_data->frame,
+			pdata->diff_data->x, pdata->diff_data->y);
+
+		all_str_len -= count;
+		temp_buf += count;
+
+		for (i = 0; i < DIFF_SENSE_NODE * DIFF_SENSE_NODE; i++) {
+			count = snprintf(temp_buf, all_str_len, "%4d,",
+				pdata->diff_data->data[i]);
+			all_str_len -= count;
+			temp_buf += count;
+
+			if (((i + 1) % DIFF_SENSE_NODE) == 0) {
+				count = snprintf(temp_buf, all_str_len, "\n");
+				all_str_len -= count;
+				temp_buf += count;
+			}
+		}
+		count = snprintf(temp_buf, all_str_len, "\n");
+		all_str_len -= count;
+		temp_buf += count;
+
+		return (temp_buf - buf);
+	}
+
+	if (ret > 0) {
+		memcpy(buf, pdata->diff_data, sizeof(struct xiaomi_diff_data));
+	}
+
+	return sizeof(struct xiaomi_diff_data);
+}
+
+static ssize_t xiaomi_partial_diff_data_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	int command = -1;
+
+	sscanf(buf, "%d", &command);
+	MI_TOUCH_LOGE(1, "[xiaomi] command is: %d", command);
+
+	if (command == 0)
+		pdata->debug_roi_flag = false;
+	else if (command == 1)
+		pdata->debug_roi_flag = true;
+
+	return count;
+}
+#endif
+
+static ssize_t touch_vendor_show(struct device *dev,
+struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+
+	if (pdata->touch_data->touch_vendor_read)
+		return snprintf(buf, PAGE_SIZE, "%c", pdata->touch_data->touch_vendor_read());
+	else
+		return -EINVAL;
+}
+
+static ssize_t xiaomi_touch_log_debug_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	if (!pdata) {
+		MI_TOUCH_LOGE(1, "%s %s: xiaomi touch pdata is null\n", MI_TAG, __func__);
+		return -EINVAL;
+	}
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata->debug_log);
+}
+
+static ssize_t xiaomi_touch_log_debug_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	u8 input = 0;
+	struct xiaomi_touch_pdata *pdata = dev_get_drvdata(dev);
+	if (sscanf(buf, "%d", &input) < 0)
+			return -EINVAL;
+	if (!pdata) {
+		MI_TOUCH_LOGE(1, "%s %s: xiaomi touch pdata is null\n",
+			MI_TAG, __func__);
+		return -EINVAL;
+	}
+	pdata->debug_log = input;
+	MI_TOUCH_LOGI(1, "%s %s: Set touch driver debug level: %d\n",
+		MI_TAG, __func__, pdata->debug_log);
+	return count;
+}
+
+static ssize_t resolution_factor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int factor = 1;
+
+	if (!touch_pdata) {
+		return -ENODEV;
+	}
+	if (touch_pdata->touch_data->get_touch_super_resolution_factor) {
+		factor = touch_pdata->touch_data->get_touch_super_resolution_factor();
+	}
+	return snprintf(buf, PAGE_SIZE, "%d", factor);
+}
+
+static DEVICE_ATTR(palm_sensor, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   palm_sensor_show, palm_sensor_store);
+
+static DEVICE_ATTR(p_sensor, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   p_sensor_show, p_sensor_store);
+
+static DEVICE_ATTR(panel_vendor, (S_IRUGO),
+		   panel_vendor_show, NULL);
+
+static DEVICE_ATTR(panel_color, (S_IRUGO),
+		   panel_color_show, NULL);
+
+static DEVICE_ATTR(panel_display, (S_IRUGO),
+		   panel_display_show, NULL);
+
+static DEVICE_ATTR(touch_vendor, (S_IRUGO),
+		   touch_vendor_show, NULL);
+
+static DEVICE_ATTR(set_update, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   set_update_show, set_update_store);
+
+static DEVICE_ATTR(bump_sample_rate, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   bump_sample_rate_start, bump_sample_rate_store);
+
+static DEVICE_ATTR(log_debug, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   xiaomi_touch_log_debug_show, xiaomi_touch_log_debug_store);
+#if XIAOMI_ROI
+static DEVICE_ATTR(partial_diff_data, (S_IRUGO | S_IWUSR | S_IWGRP),
+	xiaomi_partial_diff_data_show, xiaomi_partial_diff_data_store);
+#endif
+
+static DEVICE_ATTR(resolution_factor, 0644, resolution_factor_show, NULL);
+
+static struct attribute *touch_attr_group[] = {
+	&dev_attr_palm_sensor.attr,
+	&dev_attr_p_sensor.attr,
+	&dev_attr_panel_vendor.attr,
+	&dev_attr_panel_color.attr,
+	&dev_attr_set_update.attr,
+	&dev_attr_bump_sample_rate.attr,
+	&dev_attr_panel_display.attr,
+	&dev_attr_touch_vendor.attr,
+	&dev_attr_log_debug.attr,
+#if XIAOMI_ROI
+	&dev_attr_partial_diff_data.attr,
+#endif
+	&dev_attr_resolution_factor.attr,
+	NULL,
+};
+
+static const struct of_device_id xiaomi_touch_of_match[] = {
+	{ .compatible = "xiaomi-touch", },
+	{ },
+};
+
+static int xiaomi_touch_parse_dt(struct device *dev, struct xiaomi_touch_pdata *data)
+{
+	int ret;
+	struct device_node *np;
+
+	np = dev->of_node;
+	if (!np)
+		return -ENODEV;
+
+	ret = of_property_read_string(np, "touch,name", &data->name);
+	if (ret)
+		return ret;
+
+	MI_TOUCH_LOGI(1, "%s %s: touch,name:%s\n", MI_TAG, __func__, data->name);
+
+	return 0;
+}
+
+#if XIAOMI_ROI
+void xiaomi_touch_send_btn_tap_key(int status)
+{
+	if (xiaomi_touch_dev.key_input_dev) {
+		if (!status) {
+			input_report_key(xiaomi_touch_dev.key_input_dev, BTN_TAP, 1);
+			input_report_key(xiaomi_touch_dev.key_input_dev, BTN_TAP, 0);
+		} else {
+			input_report_key(xiaomi_touch_dev.key_input_dev, BTN_TAP, 1);
+		}
+		input_sync(xiaomi_touch_dev.key_input_dev);
+	}
+}
+EXPORT_SYMBOL(xiaomi_touch_send_btn_tap_key);
+#endif
+
+static int xiaomi_touch_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+	struct xiaomi_touch_pdata *pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(struct xiaomi_touch_pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+#if XIAOMI_ROI
+	pdata->diff_data = devm_kzalloc(dev, sizeof(struct xiaomi_diff_data), GFP_KERNEL);
+	if (!pdata->diff_data)
+		return -ENOMEM;
+#endif
+
+	MI_TOUCH_LOGI(1, "%s %s: enter\n", MI_TAG, __func__);
+	ret = xiaomi_touch_parse_dt(dev, pdata);
+	if (ret < 0) {
+		MI_TOUCH_LOGE(1, "%s %s: parse dt error:%d\n", MI_TAG, __func__, ret);
+		goto parse_dt_err;
+	}
+
+	ret = misc_register(&xiaomi_touch_dev.misc_dev);
+	if (ret) {
+		MI_TOUCH_LOGE(1, "%s %s: create misc device err:%d\n", MI_TAG, __func__, ret);
+		goto parse_dt_err;
+	}
+
+	/* key input device init and register */
+	xiaomi_touch_dev.key_input_dev = input_allocate_device();
+	if (xiaomi_touch_dev.key_input_dev == NULL) {
+		MI_TOUCH_LOGE(1, "%s %s: alloc input device err\n", MI_TAG, __func__);
+		goto input_device_create_err;
+	}
+
+	xiaomi_touch_dev.key_input_dev->name = XIAOMI_TOUCH_DEVICE_NAME;
+	xiaomi_touch_dev.key_input_dev->phys = KEY_INPUT_DEVICE_PHYS;
+	xiaomi_touch_dev.key_input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY);
+	__set_bit(BTN_TAP, xiaomi_touch_dev.key_input_dev->keybit);
+	__set_bit(BTN_MISC, xiaomi_touch_dev.key_input_dev->keybit);
+
+	ret = input_register_device(xiaomi_touch_dev.key_input_dev);
+	if (ret) {
+		MI_TOUCH_LOGE(1, "%s %s: register input device err:%d\n", MI_TAG, __func__, ret);
+		goto input_device_create_err;
+	}
+
+	if (!xiaomi_touch_dev.class)
+		xiaomi_touch_dev.class = class_create(THIS_MODULE, "touch");
+
+	if (!xiaomi_touch_dev.class) {
+		MI_TOUCH_LOGE(1, "%s %s: create device class err\n", MI_TAG, __func__);
+		goto class_create_err;
+	}
+
+	xiaomi_touch_dev.dev = device_create(xiaomi_touch_dev.class, NULL, 'T', NULL, "touch_dev");
+	if (!xiaomi_touch_dev.dev) {
+		MI_TOUCH_LOGE(1, "%s %s: create device dev err\n", MI_TAG, __func__);
+		goto device_create_err;
+	}
+
+	pdata->touch_data = (struct xiaomi_touch_interface *)kzalloc(sizeof(struct xiaomi_touch_interface), GFP_KERNEL);
+	if (pdata->touch_data == NULL) {
+		ret = -ENOMEM;
+		MI_TOUCH_LOGE(1, "%s %s: alloc mem for touch_data\n", MI_TAG, __func__);
+		goto data_mem_err;
+	}
+
+	pdata->device = &xiaomi_touch_dev;
+	dev_set_drvdata(xiaomi_touch_dev.dev, pdata);
+
+	touch_pdata = pdata;
+
+	xiaomi_touch_dev.attrs.attrs = touch_attr_group;
+	ret = sysfs_create_group(&xiaomi_touch_dev.dev->kobj, &xiaomi_touch_dev.attrs);
+	if (ret) {
+		MI_TOUCH_LOGE(1, "%s %s: Cannot create sysfs structure!:%d\n", MI_TAG, __func__, ret);
+		ret = -ENODEV;
+		goto sys_group_err;
+	}
+
+	MI_TOUCH_LOGI(1, "%s %s: over\n", MI_TAG, __func__);
+
+	return ret;
+
+sys_group_err:
+	if (pdata->touch_data) {
+		kfree(pdata->touch_data);
+		pdata->touch_data = NULL;
+	}
+data_mem_err:
+	device_destroy(xiaomi_touch_dev.class, 0);
+device_create_err:
+	class_destroy(xiaomi_touch_dev.class);
+class_create_err:
+	input_unregister_device(xiaomi_touch_dev.key_input_dev);
+input_device_create_err:
+	misc_deregister(&xiaomi_touch_dev.misc_dev);
+parse_dt_err:
+	MI_TOUCH_LOGE(1, "%s %s: fail!\n", MI_TAG, __func__);
+	return ret;
+}
+
+static int xiaomi_touch_remove(struct platform_device *pdev)
+{
+	device_destroy(xiaomi_touch_dev.class, 0);
+	class_destroy(xiaomi_touch_dev.class);
+	misc_deregister(&xiaomi_touch_dev.misc_dev);
+	input_unregister_device(xiaomi_touch_dev.key_input_dev);
+	if (touch_pdata->touch_data) {
+		kfree(touch_pdata->touch_data);
+		touch_pdata->touch_data = NULL;
+	}
+
+	return 0;
+}
+
+static struct platform_driver xiaomi_touch_device_driver = {
+	.probe		= xiaomi_touch_probe,
+	.remove		= xiaomi_touch_remove,
+	.driver		= {
+		.name	= "xiaomi-touch",
+		.of_match_table = of_match_ptr(xiaomi_touch_of_match),
+	}
+};
+
+static int __init xiaomi_touch_init(void)
+{
+	return platform_driver_register(&xiaomi_touch_device_driver);
+
+}
+
+static void __exit xiaomi_touch_exit(void)
+{
+	platform_driver_unregister(&xiaomi_touch_device_driver);
+}
+
+subsys_initcall(xiaomi_touch_init);
+module_exit(xiaomi_touch_exit);
diff --git a/drivers/input/touchscreen/xiaomi/xiaomi_touch.h b/drivers/input/touchscreen/xiaomi/xiaomi_touch.h
new file mode 100644
index 000000000000..db5f81f2dc15
--- /dev/null
+++ b/drivers/input/touchscreen/xiaomi/xiaomi_touch.h
@@ -0,0 +1,160 @@
+#ifndef __XIAOMI__TOUCH_H
+#define __XIAOMI__TOUCH_H
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+
+#define MI_TAG  "[mi-touch]"
+
+#define XIAOMI_TOUCH_DEVICE_NAME "xiaomi-touch"
+#define KEY_INPUT_DEVICE_PHYS "xiaomi-touch/input0"
+/*Xiaomi Special Touch Event Code*/
+#define BTN_TAP 0x153
+
+#define MI_TOUCH_LOGD(level, fmt, args...) ((void)0)
+#define MI_TOUCH_LOGN(level, fmt, args...) ((void)0)
+#define MI_TOUCH_LOGI(level, fmt, args...) ((void)0)
+#define MI_TOUCH_LOGE(level, fmt, args...) ((void)0)
+
+#define XIAOMI_ROI 0
+
+#if XIAOMI_ROI
+#define DIFF_SENSE_NODE 7
+#define DIFF_FORCE_NODE 7
+
+struct xiaomi_diff_data {
+	u8 flag;
+	u8 x;
+	u8 y;
+	u8 frame;
+	s16 data[DIFF_SENSE_NODE * DIFF_FORCE_NODE];
+};
+#endif
+
+/*CUR,DEFAULT,MIN,MAX*/
+#define VALUE_TYPE_SIZE 6
+#define VALUE_GRIP_SIZE 9
+#define MAX_BUF_SIZE 256
+enum MODE_CMD {
+	SET_CUR_VALUE = 0,
+	GET_CUR_VALUE,
+	GET_DEF_VALUE,
+	GET_MIN_VALUE,
+	GET_MAX_VALUE,
+	GET_MODE_VALUE,
+	RESET_MODE,
+	SET_LONG_VALUE,
+};
+
+enum MODE_TYPE {
+	Touch_Game_Mode        = 0,
+	Touch_Active_MODE      = 1,
+	Touch_UP_THRESHOLD     = 2,
+	Touch_Tolerance        = 3,
+#ifdef CONFIG_TOUCHSCREEN_SUPPORT_NEW_GAME_MODE
+	Touch_Aim_Sensitivity	= 4,
+	Touch_Tap_Stability	= 5,
+	Touch_Expert_Mode	= 6,
+#else
+	Touch_Wgh_Min          = 4,
+	Touch_Wgh_Max          = 5,
+	Touch_Wgh_Step         = 6,
+#endif
+	Touch_Edge_Filter      = 7,
+	Touch_Panel_Orientation = 8,
+	Touch_Report_Rate      = 9,
+	Touch_Fod_Enable       = 10,
+	Touch_Aod_Enable       = 11,
+	Touch_Resist_RF        = 12,
+	Touch_Idle_Time        = 13,
+	Touch_Doubletap_Mode   = 14,
+	Touch_Grip_Mode        = 15,
+	Touch_FodIcon_Enable   = 16,
+	Touch_Nonui_Mode       = 17,
+	Touch_Debug_Level      = 18,
+	Touch_Power_Status     = 19,
+	Touch_Mode_NUM         = 20,
+};
+
+struct xiaomi_touch_interface {
+	int touch_mode[Touch_Mode_NUM][VALUE_TYPE_SIZE];
+	int (*setModeValue)(int Mode, int value);
+	int (*setModeLongValue)(int Mode, int value_len, int *value);
+	int (*getModeValue)(int Mode, int value_type);
+	int (*getModeAll)(int Mode, int *modevalue);
+	int (*resetMode)(int Mode);
+	int (*p_sensor_read)(void);
+	int (*p_sensor_write)(int on);
+	int (*palm_sensor_read)(void);
+	int (*palm_sensor_write)(int on);
+	u8 (*panel_vendor_read)(void);
+	u8 (*panel_color_read)(void);
+	u8 (*panel_display_read)(void);
+	char (*touch_vendor_read)(void);
+	int (*get_touch_super_resolution_factor)(void);
+#if XIAOMI_ROI
+	int (*partial_diff_data_read)(struct xiaomi_diff_data *data);
+#endif
+	int long_mode_len;
+	int long_mode_value[MAX_BUF_SIZE];
+};
+
+struct xiaomi_touch {
+	struct miscdevice 	misc_dev;
+	struct input_dev *key_input_dev;
+	struct device *dev;
+	struct class *class;
+	struct attribute_group attrs;
+	struct mutex  mutex;
+	struct mutex  palm_mutex;
+	struct mutex  psensor_mutex;
+	wait_queue_head_t 	wait_queue;
+};
+
+struct xiaomi_touch_pdata{
+	struct xiaomi_touch *device;
+	struct xiaomi_touch_interface *touch_data;
+	int palm_value;
+	bool palm_changed;
+	bool set_update;
+	bool bump_sample_rate;
+	int psensor_value;
+	bool psensor_changed;
+	const char *name;
+	u8 debug_log;
+#if XIAOMI_ROI
+	struct xiaomi_diff_data *diff_data;
+	bool debug_roi_flag;
+#endif
+};
+
+struct xiaomi_touch *xiaomi_touch_dev_get(int minor);
+
+extern struct class *get_xiaomi_touch_class(void);
+
+extern struct device *get_xiaomi_touch_dev(void);
+
+extern int update_palm_sensor_value(int value);
+
+extern int update_p_sensor_value(int value);
+
+int xiaomitouch_register_modedata(struct xiaomi_touch_interface *data);
+
+#endif
diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index 9429f42ae8da..a1b6948f0b64 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -291,6 +291,39 @@ static void bl_device_release(struct device *dev)
 	kfree(bd);
 }
 
+static ssize_t brightness_clone_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct backlight_device *bd = to_backlight_device(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", bd->props.brightness_clone);
+}
+
+static ssize_t brightness_clone_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc;
+	struct backlight_device *bd = to_backlight_device(dev);
+	unsigned long brightness;
+	char *envp[2];
+
+	rc = kstrtoul(buf, 0, &brightness);
+	if (rc)
+		return rc;
+
+	bd->props.brightness_clone_backup = brightness;
+	bd->props.brightness_clone = brightness;
+
+	envp[0] = "SOURCE=sysfs";
+	envp[1] = NULL;
+	kobject_uevent_env(&bd->dev.kobj, KOBJ_CHANGE, envp);
+	sysfs_notify(&bd->dev.kobj, NULL, "brightness_clone");
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(brightness_clone);
+
 static struct attribute *bl_device_attrs[] = {
 	&dev_attr_bl_power.attr,
 	&dev_attr_brightness.attr,
diff --git a/include/drm/drm_bridge.h b/include/drm/drm_bridge.h
index 6849e88cd75b..7862cf9329a0 100644
--- a/include/drm/drm_bridge.h
+++ b/include/drm/drm_bridge.h
@@ -294,6 +294,8 @@ struct drm_bridge {
 	const struct drm_bridge_funcs *funcs;
 	/** @driver_private: pointer to the bridge driver's internal context */
 	void *driver_private;
+	struct mutex lock;
+	bool is_dsi_drm_bridge;
 };
 
 void drm_bridge_add(struct drm_bridge *bridge);
@@ -314,6 +316,7 @@ void drm_bridge_mode_set(struct drm_bridge *bridge,
 			 struct drm_display_mode *adjusted_mode);
 void drm_bridge_pre_enable(struct drm_bridge *bridge);
 void drm_bridge_enable(struct drm_bridge *bridge);
+int dsi_bridge_interface_enable(int timeout);
 
 #ifdef CONFIG_DRM_PANEL_BRIDGE
 struct drm_bridge *drm_panel_bridge_add(struct drm_panel *panel,
diff --git a/include/drm/drm_mipi_dsi.h b/include/drm/drm_mipi_dsi.h
index d80635d66bef..42b01879b795 100644
--- a/include/drm/drm_mipi_dsi.h
+++ b/include/drm/drm_mipi_dsi.h
@@ -286,6 +286,8 @@ int mipi_dsi_dcs_set_pixel_format(struct mipi_dsi_device *dsi, u8 format);
 int mipi_dsi_dcs_set_tear_scanline(struct mipi_dsi_device *dsi, u16 scanline);
 int mipi_dsi_dcs_set_display_brightness(struct mipi_dsi_device *dsi,
 					u16 brightness);
+int mipi_dsi_dcs_set_display_brightness_big_endian(struct mipi_dsi_device *dsi,
+					u16 brightness);
 int mipi_dsi_dcs_get_display_brightness(struct mipi_dsi_device *dsi,
 					u16 *brightness);
 int mipi_dsi_dcs_set_display_brightness_large(struct mipi_dsi_device *dsi,
diff --git a/include/drm/drm_notifier_mi.h b/include/drm/drm_notifier_mi.h
new file mode 100644
index 000000000000..7338aff6ae13
--- /dev/null
+++ b/include/drm/drm_notifier_mi.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DRM_NOTIFIER_MI_H_
+#define _DRM_NOTIFIER_MI_H_
+
+#include <linux/notifier.h>
+
+/* A hardware display blank change occurred */
+#define MI_DRM_EVENT_BLANK              0x01
+/* A hardware display blank early change occurred */
+#define MI_DRM_EARLY_EVENT_BLANK        0x02
+/* A hardware display blank more early change occured */
+#define MI_DRM_PRE_EVENT_BLANK          0x03
+
+enum msm_drm_display_id {
+	/* primary display */
+	MSM_DRM_PRIMARY_DISPLAY,
+	/* external display */
+	MSM_DRM_EXTERNAL_DISPLAY,
+	MSM_DRM_DISPLAY_MAX
+};
+
+enum {
+	/* panel: power on */
+	MI_DRM_BLANK_UNBLANK   = 0,
+	MI_DRM_BLANK_LP1       = 1,
+	MI_DRM_BLANK_LP2       = 2,
+	MI_DRM_BLANK_STANDBY   = 3,
+	MI_DRM_BLANK_SUSPEND   = 4,
+	/* panel: power off */
+	MI_DRM_BLANK_POWERDOWN = 5,
+};
+
+struct mi_drm_notifier {
+	enum msm_drm_display_id id;
+	void *data;
+};
+
+int mi_drm_register_client(struct notifier_block *nb);
+int mi_drm_unregister_client(struct notifier_block *nb);
+int mi_drm_notifier_call_chain(unsigned long val, void *v);
+
+#endif /*_DRM_NOTIFIER_MI_H*/
diff --git a/include/linux/backlight.h b/include/linux/backlight.h
index a5a50e784548..9e0bc565bdfd 100644
--- a/include/linux/backlight.h
+++ b/include/linux/backlight.h
@@ -69,6 +69,8 @@ struct backlight_ops {
 struct backlight_properties {
 	/* Current User requested brightness (0 - max_brightness) */
 	int brightness;
+	int brightness_clone;
+	int brightness_clone_backup;
 	/* Maximal value for brightness (read-only) */
 	int max_brightness;
 	/* Current FB Power mode (0: full on, 1..3: power saving
@@ -111,6 +113,8 @@ struct backlight_device {
 	struct thermal_cooling_device *cdev;
 	/* Thermally limited max brightness */
 	int thermal_brightness_limit;
+	/* Thermally limited max brightness clone for 8192 hbm*/
+	int thermal_brightness_clone_limit;
 	/* User brightness request */
 	int usr_brightness_req;
 
diff --git a/include/linux/input/tp_common.h b/include/linux/input/tp_common.h
new file mode 100644
index 000000000000..4b038a579fe3
--- /dev/null
+++ b/include/linux/input/tp_common.h
@@ -0,0 +1,15 @@
+#include <linux/kobject.h>
+
+extern bool capacitive_keys_enabled;
+extern struct kobject *touchpanel_kobj;
+
+struct tp_common_ops {
+	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count);
+};
+
+int tp_common_set_capacitive_keys_ops(struct tp_common_ops *ops);
+int tp_common_set_double_tap_ops(struct tp_common_ops *ops);
+int tp_common_set_reversed_keys_ops(struct tp_common_ops *ops);
diff --git a/include/uapi/drm/sde_drm.h b/include/uapi/drm/sde_drm.h
index 029393041408..5aae512709aa 100644
--- a/include/uapi/drm/sde_drm.h
+++ b/include/uapi/drm/sde_drm.h
@@ -501,4 +501,10 @@ struct sde_drm_roi_v1 {
  * Implementation may be platform and base-format specific.
  */
 #define DRM_FORMAT_MOD_QCOM_FSC_TILE       fourcc_mod_code(QCOM, 0x10)
+
+/**
+ * sde fod dim layer
+ */
+#define FOD_PRESSED_LAYER_ZORDER 0x20000000u
+
 #endif /* _SDE_DRM_H_ */
diff --git a/techpack/display/config/konadisp.conf b/techpack/display/config/konadisp.conf
index dbbf3c847dbb..f87163cd371f 100644
--- a/techpack/display/config/konadisp.conf
+++ b/techpack/display/config/konadisp.conf
@@ -11,3 +11,4 @@ export CONFIG_QCOM_MDSS_PLL=y
 export CONFIG_MSM_SDE_ROTATOR=y
 export CONFIG_MSM_SDE_ROTATOR_EVTLOG_DEBUG=y
 export CONFIG_DRM_SDE_RSC=y
+export CONFIG_DRM_SDE_EXPO=y
diff --git a/techpack/display/config/konadispconf.h b/techpack/display/config/konadispconf.h
index 690d4ec79f41..01998430c63b 100644
--- a/techpack/display/config/konadispconf.h
+++ b/techpack/display/config/konadispconf.h
@@ -17,4 +17,5 @@
 #define CONFIG_MSM_SDE_ROTATOR 1
 #define CONFIG_MSM_SDE_ROTATOR_EVTLOG_DEBUG 1
 #define CONFIG_DRM_SDE_RSC 1
+#define CONFIG_DRM_SDE_EXPO 1
 
diff --git a/techpack/display/msm/Makefile b/techpack/display/msm/Makefile
index 18eb12c35530..9a85d35ec651 100644
--- a/techpack/display/msm/Makefile
+++ b/techpack/display/msm/Makefile
@@ -35,8 +35,10 @@ msm_drm-$(CONFIG_DRM_MSM_SDE) += sde/sde_crtc.o \
 	sde/sde_kms.o \
 	sde/sde_plane.o \
 	sde/sde_connector.o \
+	sde/clone_cooling_device.o \
 	sde/sde_color_processing.o \
 	sde/sde_vbif.o \
+	xiaomi_frame_stat.o \
 	sde_io_util.o \
 	sde/sde_hw_reg_dma_v1_color_proc.o \
 	sde/sde_hw_color_proc_v4.o \
@@ -79,6 +81,8 @@ msm_drm-$(CONFIG_DRM_SDE_RSC) += sde_rsc.o \
 	sde_rsc_hw.o \
 	sde_rsc_hw_v3.o \
 
+msm_drm-$(CONFIG_DRM_SDE_EXPO) += sde/sde_expo_dim_layer.o
+
 msm_drm-$(CONFIG_DRM_MSM_DSI) += dsi/dsi_phy.o \
 	dsi/dsi_pwr.o \
 	dsi/dsi_phy.o \
@@ -100,6 +104,8 @@ msm_drm-$(CONFIG_DRM_MSM_DSI) += dsi/dsi_phy.o \
 	dsi/dsi_panel.o \
 	dsi/dsi_clk_manager.o \
 	dsi/dsi_display_test.o \
+	dsi/dsi_display_mi.o \
+	dsi/dsi_panel_mi.o \
 
 msm_drm-$(CONFIG_DSI_PARSER) += dsi/dsi_parser.o \
 
diff --git a/techpack/display/msm/dp/dp_display.c b/techpack/display/msm/dp/dp_display.c
index 26554a453a65..4a291a5478fa 100644
--- a/techpack/display/msm/dp/dp_display.c
+++ b/techpack/display/msm/dp/dp_display.c
@@ -1302,6 +1302,7 @@ static int dp_display_usbpd_disconnect_cb(struct device *dev)
 
 	SDE_EVT32_EXTERNAL(SDE_EVTLOG_FUNC_EXIT, dp->state);
 end:
+	SDE_EVT32_EXTERNAL(SDE_EVTLOG_FUNC_EXIT, dp->state);
 	return rc;
 }
 
diff --git a/techpack/display/msm/dsi/dsi_defs.h b/techpack/display/msm/dsi/dsi_defs.h
index 7922a2c54d56..c991228a1a27 100644
--- a/techpack/display/msm/dsi/dsi_defs.h
+++ b/techpack/display/msm/dsi/dsi_defs.h
@@ -307,6 +307,75 @@ enum dsi_cmd_set_type {
 	DSI_CMD_SET_POST_TIMING_SWITCH,
 	DSI_CMD_SET_QSYNC_ON,
 	DSI_CMD_SET_QSYNC_OFF,
+	/* xiaomi add start */
+	DSI_CMD_SET_MI_CEON,
+	DSI_CMD_SET_MI_CEOFF,
+	DSI_CMD_SET_MI_CABCUION,
+	DSI_CMD_SET_MI_CABCSTILLON,
+	DSI_CMD_SET_MI_CABCMOVIEON,
+	DSI_CMD_SET_MI_CABCOFF,
+	DSI_CMD_SET_MI_SKINCE_CABCUION,
+	DSI_CMD_SET_MI_SKINCE_CABCSTILLON,
+	DSI_CMD_SET_MI_SKINCE_CABCMOVIEON,
+	DSI_CMD_SET_MI_SKINCE_CABCOFF,
+	DSI_CMD_SET_MI_DIMMINGON,
+	DSI_CMD_SET_MI_DIMMINGOFF,
+	DSI_CMD_SET_MI_ACL_OFF,
+	DSI_CMD_SET_MI_ACL_L1,
+	DSI_CMD_SET_MI_ACL_L2,
+	DSI_CMD_SET_MI_ACL_L3,
+	DSI_CMD_SET_DISP_LCD_HBM_L1_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_L2_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_L3_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_OFF,
+	DSI_CMD_SET_MI_HBM_ON,
+	DSI_CMD_SET_MI_HBM_OFF,
+	DSI_CMD_SET_MI_HBM_FOD_ON,
+	DSI_CMD_SET_MI_HBM_FOD_OFF,
+	DSI_CMD_SET_MI_HBM_HDR_ON,
+	DSI_CMD_SET_MI_HBM_HDR_OFF,
+	DSI_CMD_SET_MI_HBM_FOD2NORM,
+	DSI_CMD_SET_MI_NORMAL1,
+	DSI_CMD_SET_MI_CRC_DCIP3,
+	DSI_CMD_SET_MI_SRGB,
+	DSI_CMD_SET_MI_DOZE_HBM,
+	DSI_CMD_SET_MI_DOZE_LBM,
+	DSI_CMD_SET_MI_CRC_OFF,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_OFF,
+	DSI_CMD_SET_MI_FLAT_MODE_ON,
+	DSI_CMD_SET_MI_FLAT_MODE_OFF,
+	DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_C8,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_C9,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_B3,
+	DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE,
+	DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE,
+	DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB,
+	DSI_CMD_SET_MI_WHITE_POINT_READ,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_READ,
+	DSI_CMD_SET_MI_DC_ON,
+	DSI_CMD_SET_MI_DC_OFF,
+	DSI_CMD_SET_MI_VI_SETTING_LOW,
+	DSI_CMD_SET_MI_VI_SETTING_HIGH,
+	DSI_CMD_SET_MI_SWITCH_PAGE4,
+	DSI_CMD_SET_MI_DC_READ,
+	DSI_CMD_SET_MI_AOD_TO_DC_ON,
+	DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON,
+	DSI_CMD_SET_MI_DYNAMIC_ELVSS_OFF,
+	DSI_CMD_SET_MI_GAMMA_PRE_READ,
+	DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_B7,
+	DSI_CMD_SET_MI_GAMMA_B7,
+	DSI_CMD_SET_MI_BLACK_SETTING,
+	DSI_CMD_SET_MI_READ_LOCKDOWN_INFO,
+	/* xiaomi add end */
 	DSI_CMD_SET_MAX
 };
 
@@ -520,6 +589,7 @@ struct dsi_host_common_cfg {
 	enum dsi_phy_type phy_type;
 	struct dsi_split_link_config split_link;
 	u32 byte_intf_clk_div;
+	u32 clk_strength;
 	u32 dma_sched_line;
 	u32 dma_sched_window;
 };
diff --git a/techpack/display/msm/dsi/dsi_display.c b/techpack/display/msm/dsi/dsi_display.c
index 903238ac8d11..b69bb6e3452b 100644
--- a/techpack/display/msm/dsi/dsi_display.c
+++ b/techpack/display/msm/dsi/dsi_display.c
@@ -7,6 +7,7 @@
 #include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <linux/err.h>
+#include <drm/drm_notifier_mi.h>
 
 #include "msm_drv.h"
 #include "sde_connector.h"
@@ -21,6 +22,10 @@
 #include "sde_dbg.h"
 #include "dsi_parser.h"
 
+#ifdef CONFIG_DRM_SDE_EXPO
+#include "sde_expo_dim_layer.h"
+#endif
+
 #define to_dsi_display(x) container_of(x, struct dsi_display, host)
 #define INT_BASE_10 10
 
@@ -33,6 +38,8 @@
 #define DSI_CLOCK_BITRATE_RADIX 10
 #define MAX_TE_SOURCE_ID  2
 
+DEFINE_MUTEX(dsi_display_clk_mutex);
+
 u8 dbgfs_tx_cmd_buf[SZ_4K];
 static char dsi_display_primary[MAX_CMDLINE_PARAM_LEN];
 static char dsi_display_secondary[MAX_CMDLINE_PARAM_LEN];
@@ -48,6 +55,14 @@ static const struct of_device_id dsi_display_dt_match[] = {
 
 struct dsi_display *primary_display;
 
+const char *dsi_get_display_name(void)
+{
+	if (primary_display)
+		return primary_display->name;
+	else
+		return NULL;
+}
+
 static void dsi_display_mask_ctrl_error_interrupts(struct dsi_display *display,
 			u32 mask, bool enable)
 {
@@ -232,6 +247,12 @@ int dsi_display_set_backlight(struct drm_connector *connector,
 		goto error;
 	}
 
+#ifdef CONFIG_DRM_SDE_EXPO
+	if(panel->dimlayer_exposure) {
+		bl_temp = expo_map_dim_level((u32)bl_temp, dsi_display);
+	}
+#endif
+
 	rc = dsi_panel_set_backlight(panel, (u32)bl_temp);
 	if (rc)
 		DSI_ERR("unable to set backlight\n");
@@ -249,7 +270,7 @@ int dsi_display_set_backlight(struct drm_connector *connector,
 	return rc;
 }
 
-static int dsi_display_cmd_engine_enable(struct dsi_display *display)
+int dsi_display_cmd_engine_enable(struct dsi_display *display)
 {
 	int rc = 0;
 	int i;
@@ -293,7 +314,7 @@ static int dsi_display_cmd_engine_enable(struct dsi_display *display)
 	return rc;
 }
 
-static int dsi_display_cmd_engine_disable(struct dsi_display *display)
+int dsi_display_cmd_engine_disable(struct dsi_display *display)
 {
 	int rc = 0;
 	int i;
@@ -479,7 +500,7 @@ static void dsi_display_register_te_irq(struct dsi_display *display)
 }
 
 /* Allocate memory for cmd dma tx buffer */
-static int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display)
+int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display)
 {
 	int rc = 0, cnt = 0;
 	struct dsi_display_ctrl *display_ctrl;
@@ -1198,24 +1219,56 @@ int dsi_display_set_power(struct drm_connector *connector,
 		int power_mode, void *disp)
 {
 	struct dsi_display *display = disp;
+	struct dsi_panel_mi_cfg *mi_cfg;
 	int rc = 0;
+	struct mi_drm_notifier notify_data;
+	const char *sde_power_mode_str[] = {
+		[SDE_MODE_DPMS_ON] = "SDE_MODE_DPMS_ON",
+		[SDE_MODE_DPMS_LP1] = "SDE_MODE_DPMS_LP1",
+		[SDE_MODE_DPMS_LP2] = "SDE_MODE_DPMS_LP2",
+		[SDE_MODE_DPMS_STANDBY] = "SDE_MODE_DPMS_STANDBY",
+		[SDE_MODE_DPMS_SUSPEND] = "SDE_MODE_DPMS_SUSPEND",
+		[SDE_MODE_DPMS_OFF] = "SDE_MODE_DPMS_OFF",
+	};
 
 	if (!display || !display->panel) {
 		DSI_ERR("invalid display/panel\n");
 		return -EINVAL;
 	}
 
+	mi_cfg = &display->panel->mi_cfg;
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+
+	DSI_INFO("power_mode = %s\n", sde_power_mode_str[power_mode]);
+
 	switch (power_mode) {
 	case SDE_MODE_DPMS_LP1:
+		mi_cfg->in_aod = true;
+		mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 		rc = dsi_panel_set_lp1(display->panel);
+		if (mi_cfg->unset_doze_brightness)
+			dsi_panel_set_doze_brightness(display->panel,
+				mi_cfg->unset_doze_brightness, true);
+		mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 		break;
 	case SDE_MODE_DPMS_LP2:
+		mi_cfg->in_aod = true;
+		mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 		rc = dsi_panel_set_lp2(display->panel);
+		if (mi_cfg->unset_doze_brightness)
+			dsi_panel_set_doze_brightness(display->panel,
+				mi_cfg->unset_doze_brightness, true);
+		mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 		break;
 	case SDE_MODE_DPMS_ON:
 		if ((display->panel->power_mode == SDE_MODE_DPMS_LP1) ||
-			(display->panel->power_mode == SDE_MODE_DPMS_LP2))
+			(display->panel->power_mode == SDE_MODE_DPMS_LP2)) {
+			mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 			rc = dsi_panel_set_nolp(display->panel);
+			mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
+		}
 		break;
 	case SDE_MODE_DPMS_OFF:
 	default:
@@ -5301,6 +5354,224 @@ static int dsi_display_validate_split_link(struct dsi_display *display)
 	return rc;
 }
 
+static ssize_t sysfs_dynamic_dsi_clk_read(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int rc = 0;
+	struct dsi_display *display;
+	struct dsi_display_ctrl *m_ctrl;
+	struct dsi_ctrl *ctrl;
+
+	display = dev_get_drvdata(dev);
+	if (!display) {
+		DSI_ERR("Invalid display\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&display->display_lock);
+
+	m_ctrl = &display->ctrl[display->cmd_master_idx];
+	ctrl = m_ctrl->ctrl;
+	if (ctrl)
+		display->cached_clk_rate = ctrl->clk_freq.byte_clk_rate
+					     * 8;
+
+	rc = snprintf(buf, PAGE_SIZE, "%d\n", display->cached_clk_rate);
+	DSI_DEBUG("%s: read dsi clk rate %d\n", __func__,
+		display->cached_clk_rate);
+
+	mutex_unlock(&display->display_lock);
+
+	return rc;
+}
+
+static ssize_t sysfs_dynamic_dsi_clk_write(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int rc = 0;
+	int clk_rate;
+	struct dsi_display *display;
+
+	display = dev_get_drvdata(dev);
+	if (!display) {
+		DSI_ERR("Invalid display\n");
+		return -EINVAL;
+	}
+
+	rc = kstrtoint(buf, DSI_CLOCK_BITRATE_RADIX, &clk_rate);
+	if (rc) {
+		DSI_ERR("%s: kstrtoint failed. rc=%d\n", __func__, rc);
+		return rc;
+	}
+
+	if (display->panel->panel_mode != DSI_OP_CMD_MODE) {
+		DSI_ERR("only supported for command mode\n");
+		return -ENOTSUPP;
+	}
+
+	DSI_INFO("%s: bitrate param value: '%d'\n", __func__, clk_rate);
+
+	mutex_lock(&display->display_lock);
+	mutex_lock(&dsi_display_clk_mutex);
+
+	rc = dsi_display_dynamic_clk_configure_cmd(display, clk_rate);
+	if (rc)
+		DSI_ERR("Failed to configure dynamic clk\n");
+	else
+		rc = count;
+
+	mutex_unlock(&dsi_display_clk_mutex);
+	mutex_unlock(&display->display_lock);
+
+	return rc;
+
+}
+
+static DEVICE_ATTR(dynamic_dsi_clock, 0644,
+			sysfs_dynamic_dsi_clk_read,
+			sysfs_dynamic_dsi_clk_write);
+
+static struct attribute *dynamic_dsi_clock_fs_attrs[] = {
+	&dev_attr_dynamic_dsi_clock.attr,
+	NULL,
+};
+static struct attribute_group dynamic_dsi_clock_fs_attrs_group = {
+	.attrs = dynamic_dsi_clock_fs_attrs,
+};
+
+static ssize_t sysfs_fod_ui_read(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dsi_display *display;
+	bool status;
+
+	display = dev_get_drvdata(dev);
+	if (!display) {
+		pr_err("Invalid display\n");
+		return -EINVAL;
+	}
+
+	status = atomic_read(&display->fod_ui);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", status);
+}
+
+static DEVICE_ATTR(fod_ui, 0444,
+			sysfs_fod_ui_read,
+			NULL);
+
+#ifdef CONFIG_DRM_SDE_EXPO
+static ssize_t sysfs_dimlayer_exposure_read(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct dsi_display *display;
+	struct dsi_panel *panel;
+	bool status;
+
+	display = dev_get_drvdata(dev);
+	if (!display) {
+		pr_err("Invalid display\n");
+		return -EINVAL;
+	}
+
+	panel = display->panel;
+
+	mutex_lock(&panel->panel_lock);
+	status = panel->dimlayer_exposure;
+	mutex_unlock(&panel->panel_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", status);
+}
+
+static ssize_t sysfs_dimlayer_exposure_write(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct dsi_display *display;
+	struct dsi_panel *panel;
+	struct drm_connector *connector = NULL;
+	bool status;
+	int rc = 0;
+
+	display = dev_get_drvdata(dev);
+	if (!display) {
+		pr_err("Invalid display\n");
+		return -EINVAL;
+	}
+
+	rc = kstrtobool(buf, &status);
+	if (rc) {
+		pr_err("%s: kstrtobool failed. rc=%d\n", __func__, rc);
+		return rc;
+	}
+
+	panel = display->panel;
+
+	panel->dimlayer_exposure = status;
+	dsi_display_set_backlight(connector, display, panel->bl_config.bl_level);
+
+	return count;
+}
+#endif
+
+#ifdef CONFIG_DRM_SDE_EXPO
+static DEVICE_ATTR(dimlayer_exposure, 0644,
+			sysfs_dimlayer_exposure_read,
+			sysfs_dimlayer_exposure_write);
+#endif
+
+static struct attribute *display_fs_attrs[] = {
+	&dev_attr_fod_ui.attr,
+#ifdef CONFIG_DRM_SDE_EXPO
+	&dev_attr_dimlayer_exposure.attr,
+#endif
+	NULL,
+};
+
+static struct attribute_group display_fs_attrs_group = {
+	.attrs = display_fs_attrs,
+};
+
+static int dsi_display_sysfs_init(struct dsi_display *display)
+{
+	int rc = 0;
+	struct device *dev = &display->pdev->dev;
+
+	if (display->panel->panel_mode == DSI_OP_CMD_MODE)
+		rc = sysfs_create_group(&dev->kobj,
+			&dynamic_dsi_clock_fs_attrs_group);
+	if (rc) {
+		pr_err("failed to create dynamic dsi clock attributes");
+		return rc;
+	}
+
+	rc = sysfs_create_group(&dev->kobj, &display_fs_attrs_group);
+	if (rc)
+		pr_err("failed to create display device attributes");
+
+	return rc;
+}
+
+static int dsi_display_sysfs_deinit(struct dsi_display *display)
+{
+	struct device *dev = &display->pdev->dev;
+
+	if (display->panel->panel_mode == DSI_OP_CMD_MODE)
+		sysfs_remove_group(&dev->kobj,
+			&dynamic_dsi_clock_fs_attrs_group);
+
+	sysfs_remove_group(&dev->kobj,
+		&display_fs_attrs_group);
+
+	return 0;
+}
+
+void dsi_display_set_fod_ui(struct dsi_display *display, bool status)
+{
+	struct device *dev = &display->pdev->dev;
+	atomic_set(&display->fod_ui, status);
+	sysfs_notify(&dev->kobj, NULL, "fod_ui");
+}
+
 /**
  * dsi_display_bind - bind dsi device with controlling device
  * @dev:        Pointer to base of platform device
@@ -5372,6 +5643,14 @@ static int dsi_display_bind(struct device *dev,
 	atomic_set(&display->clkrate_change_pending, 0);
 	display->cached_clk_rate = 0;
 
+	rc = dsi_display_sysfs_init(display);
+	if (rc) {
+		DSI_ERR("[%s] sysfs init failed, rc=%d\n", display->name, rc);
+		goto error;
+	}
+
+	atomic_set(&display->fod_ui, false);
+
 	memset(&info, 0x0, sizeof(info));
 
 	display_for_each_ctrl(i, display) {
@@ -5521,6 +5800,7 @@ static int dsi_display_bind(struct device *dev,
 		(void)dsi_phy_drv_deinit(display_ctrl->phy);
 		(void)dsi_ctrl_drv_deinit(display_ctrl->ctrl);
 	}
+	(void)dsi_display_sysfs_deinit(display);
 	(void)dsi_display_debugfs_deinit(display);
 error:
 	mutex_unlock(&display->display_lock);
@@ -5581,6 +5861,7 @@ static void dsi_display_unbind(struct device *dev,
 	}
 
 	atomic_set(&display->clkrate_change_pending, 0);
+	(void)dsi_display_sysfs_deinit(display);
 	(void)dsi_display_debugfs_deinit(display);
 
 	mutex_unlock(&display->display_lock);
@@ -5713,6 +5994,7 @@ int dsi_display_dev_probe(struct platform_device *pdev)
 	display->panel_node = panel_node;
 	display->pdev = pdev;
 	display->boot_disp = boot_disp;
+	display->is_prim_display = true;
 
 	dsi_display_parse_cmdline_topology(display, index);
 
@@ -7076,6 +7358,11 @@ int dsi_display_set_mode(struct dsi_display *display,
 			timing.h_active, timing.v_active,
 			timing.refresh_rate);
 
+	if (display->panel->cur_mode->timing.refresh_rate != timing.refresh_rate) {
+		if (display->drm_conn && display->drm_conn->kdev)
+			sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "dynamic_fps");
+	}
+
 	memcpy(display->panel->cur_mode, &adj_mode, sizeof(adj_mode));
 error:
 	mutex_unlock(&display->display_lock);
@@ -7892,6 +8179,37 @@ int dsi_display_enable(struct dsi_display *display)
 
 		display->panel->panel_initialized = true;
 		DSI_DEBUG("cont splash enabled, display enable not required\n");
+
+		rc = dsi_panel_update_elvss_dimming(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to update elvss dimming parameter, rc=%d\n",
+			       display->name, rc);
+		}
+
+		rc = dsi_panel_read_gamma_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read gamma para, rc=%d\n",
+				display->name, rc);
+		} else {
+			rc = dsi_panel_update_gamma_param(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update gamma para, rc=%d\n",
+					display->name, rc);
+			}
+		}
+
+		rc = dsi_panel_read_dc_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read DC para, rc=%d\n",
+				display->name, rc);
+		} else {
+			rc = dsi_panel_update_dc_param(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update DC para, rc=%d\n",
+					display->name, rc);
+			}
+		}
+
 		return 0;
 	}
 
@@ -7930,10 +8248,28 @@ int dsi_display_enable(struct dsi_display *display)
 
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_switch(display->panel);
-		if (rc)
+		if (rc) {
 			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
+			goto error;
+		}
+
+		if ((display->panel->mi_cfg.panel_id >> 8) == 0x4A3153004202) {
 
+			rc = dsi_panel_dc_switch(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to set dc command, rc=%d\n",
+					display->name, rc);
+				goto error;
+			}
+		}
+
+		rc = dsi_panel_switch_disp_rate_gpio(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to set disp_rate gpio, rc=%d\n",
+				   display->name, rc);
+			goto error;
+		}
 		goto error;
 	}
 
@@ -8232,6 +8568,36 @@ static void __exit dsi_display_unregister(void)
 	dsi_ctrl_drv_unregister();
 	dsi_phy_drv_unregister();
 }
+
+char *dsi_display_get_cmdline_panel_info(void)
+{
+	char *buffer = NULL, *buffer_dup = NULL;
+	char *pname = NULL;
+	char *panel_info = NULL;
+
+	buffer = kstrdup(dsi_display_primary, GFP_KERNEL);
+	if (!buffer)
+		return NULL;
+	buffer_dup = buffer;
+
+	buffer = strrchr(buffer, ',');
+	if (buffer && *buffer) {
+		pname = ++buffer;
+	} else {
+		goto exit;
+	}
+
+	buffer = strrchr(pname, ':');
+	if (buffer)
+		*buffer = '\0';
+
+	panel_info = kstrdup(pname, GFP_KERNEL);
+
+exit:
+	kfree(buffer_dup);
+	return panel_info;
+}
+
 module_param_string(dsi_display0, dsi_display_primary, MAX_CMDLINE_PARAM_LEN,
 								0600);
 MODULE_PARM_DESC(dsi_display0,
diff --git a/techpack/display/msm/dsi/dsi_display.h b/techpack/display/msm/dsi/dsi_display.h
index 0aae1e394706..c87d2ce7fc69 100644
--- a/techpack/display/msm/dsi/dsi_display.h
+++ b/techpack/display/msm/dsi/dsi_display.h
@@ -202,6 +202,7 @@ struct dsi_display {
 	const char *display_type;
 	struct list_head list;
 	bool is_cont_splash_enabled;
+	bool is_prim_display;
 	bool sw_te_using_wd;
 	struct mutex display_lock;
 	int disp_te_gpio;
@@ -282,6 +283,7 @@ struct dsi_display {
 	struct dsi_panel_cmd_set cmd_set;
 
 	bool enabled;
+	atomic_t fod_ui;
 };
 
 int dsi_display_dev_probe(struct platform_device *pdev);
@@ -754,6 +756,16 @@ int dsi_display_cont_splash_config(void *display);
 int dsi_display_get_panel_vfp(void *display,
 	int h_active, int v_active);
 
+int dsi_display_cmd_engine_enable(struct dsi_display *display);
+int dsi_display_cmd_engine_disable(struct dsi_display *display);
+int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display);
+
+char *dsi_display_get_cmdline_panel_info(void);
+
+int dsi_display_hbm_set_disp_param(struct drm_connector *connector,
+				u32 param_type);
 struct dsi_display *get_main_display(void);
 
+void dsi_display_set_fod_ui(struct dsi_display *display, bool status);
+
 #endif /* _DSI_DISPLAY_H_ */
diff --git a/techpack/display/msm/dsi/dsi_display_mi.c b/techpack/display/msm/dsi/dsi_display_mi.c
new file mode 100644
index 000000000000..d47ea65dc8d2
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_display_mi.c
@@ -0,0 +1,489 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"mi-dsi-display:[%s] " fmt, __func__
+
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/err.h>
+
+#include "msm_drv.h"
+#include "sde_connector.h"
+#include "msm_mmu.h"
+#include "dsi_display.h"
+#include "dsi_panel.h"
+#include "dsi_panel_mi.h"
+#include "dsi_ctrl.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_drm.h"
+#include "dsi_clk.h"
+#include "dsi_pwr.h"
+#include "sde_dbg.h"
+#include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+#include "../msm_drv.h"
+
+#define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
+
+static atomic64_t g_param = ATOMIC64_INIT(0);
+
+static char oled_pmic_id_str[4] = {0};
+static char oled_wp_info_str[32] = {0};
+static bool wp_info_cmdline_flag = 0;
+
+static int __init
+oled_pmic_id_setup (char *str)
+{
+	size_t count = ((strlen(str) > sizeof(oled_pmic_id_str)) ?
+					sizeof(oled_pmic_id_str): strlen(str));
+	strncpy(oled_pmic_id_str, str, count);
+	return 1;
+}
+__setup("androidboot.oled_pmic_id=", oled_pmic_id_setup);
+
+
+static int __init
+oled_wp_info_setup (char *str)
+{
+	size_t count = ((strlen(str) > sizeof(oled_wp_info_str)) ?
+					sizeof(oled_wp_info_str): strlen(str));
+	strncpy(oled_wp_info_str, str, count);
+	pr_info("androidboot.oled_wp=%s\n", oled_wp_info_str);
+	wp_info_cmdline_flag = 1;
+	return 1;
+}
+__setup("androidboot.oled_wp=", oled_wp_info_setup);
+
+int dsi_display_set_disp_param(struct drm_connector *connector,
+			u32 param_type)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	int ret = 0;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	atomic64_set(&g_param, param_type);
+	ret = dsi_panel_set_disp_param(display->panel, param_type);
+
+	return ret;
+}
+
+int dsi_display_get_disp_param(struct drm_connector *connector,
+			u32 *param_type)
+{
+	*param_type = (u32)atomic64_read(&g_param);
+	return 0;
+}
+
+int dsi_display_write_mipi_reg(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return dsi_panel_write_mipi_reg(display->panel, buf);
+}
+
+ssize_t dsi_display_read_mipi_reg(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return dsi_panel_read_mipi_reg(display->panel, buf);
+}
+
+ssize_t dsi_display_read_oled_pmic_id(struct drm_connector *connector,
+			char *buf)
+{
+	return snprintf(buf, PAGE_SIZE , "%s\n", oled_pmic_id_str);
+}
+
+ssize_t dsi_display_read_panel_info(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	char *pname = NULL;
+	ssize_t ret = 0;
+
+	pname = dsi_display_get_cmdline_panel_info();
+	if (pname) {
+		ret = snprintf(buf, PAGE_SIZE, "panel_name=%s\n", pname);
+		kfree(pname);
+	} else {
+		if (!connector || !connector->encoder || !connector->encoder->bridge) {
+			pr_err("Invalid connector/encoder/bridge ptr\n");
+			return -EINVAL;
+		}
+
+		c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+		display = c_bridge->display;
+		if (!display || !display->panel) {
+			pr_err("Invalid display/panel ptr\n");
+			return -EINVAL;
+		}
+
+		if (display->name) {
+			/* find the last occurrence of a character in a string */
+			pname = strrchr(display->name, ',');
+			if (pname && *pname)
+				ret = snprintf(buf, PAGE_SIZE, "panel_name=%s\n", ++pname);
+			else
+				ret = snprintf(buf, PAGE_SIZE, "panel_name=%s\n", display->name);
+		} else {
+			ret = snprintf(buf, PAGE_SIZE, "panel_name=%s\n", "null");
+		}
+	}
+
+	return ret;
+}
+
+ssize_t dsi_display_read_wp_info(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (wp_info_cmdline_flag) {
+		return snprintf(buf, PAGE_SIZE , "%s\n", oled_wp_info_str);
+	} else {
+		if (!connector || !connector->encoder || !connector->encoder->bridge) {
+			pr_err("Invalid connector/encoder/bridge ptr\n");
+			return -EINVAL;
+		}
+
+		c_bridge =	to_dsi_bridge(connector->encoder->bridge);
+		display = c_bridge->display;
+		if (!display || !display->panel) {
+			pr_err("Invalid display/panel ptr\n");
+			return -EINVAL;
+		}
+
+		return dsi_panel_read_wp_info(display->panel, buf);
+	}
+}
+
+ssize_t dsi_display_read_dynamic_fps(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	struct dsi_display_mode *cur_mode = NULL;
+	ssize_t ret = 0;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&display->display_lock);
+	cur_mode = display->panel->cur_mode;
+	if (cur_mode) {
+		ret = snprintf(buf, PAGE_SIZE, "%d\n", cur_mode->timing.refresh_rate);
+
+	} else {
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "null");
+	}
+	mutex_unlock(&display->display_lock);
+
+	return ret;
+}
+
+int dsi_display_set_doze_brightness(struct drm_connector *connector,
+			int doze_brightness)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return dsi_panel_set_doze_brightness(display->panel, doze_brightness, true);
+}
+
+ssize_t dsi_display_get_doze_brightness(struct drm_connector *connector,
+			char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return dsi_panel_get_doze_brightness(display->panel, buf);
+}
+
+int dsi_display_read_gamma_param(struct drm_connector *connector)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	int rc = 0;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	rc = dsi_panel_read_gamma_param(display->panel);
+	if (rc) {
+		pr_err("Failed to read gamma para, rc=%d\n", rc);
+	}
+
+	return rc;
+}
+
+ssize_t dsi_display_print_gamma_param(struct drm_connector *connector, char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return dsi_panel_print_gamma_param(display->panel, buf);
+
+}
+
+int dsi_display_hbm_set_disp_param(struct drm_connector *connector,
+				u32 op_code)
+{
+	int rc;
+	struct sde_connector *c_conn;
+
+	c_conn = to_sde_connector(connector);
+
+	pr_debug("%s fod hbm command:0x%x \n", __func__, op_code);
+
+	if (op_code == DISPPARAM_HBM_FOD_ON) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_FOD_ON);
+	} else if (op_code == DISPPARAM_HBM_FOD_OFF) {
+		/* close HBM and restore DC */
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_FOD_OFF);
+	} else if(op_code == DISPPARAM_DIMMING_OFF) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_DIMMING_OFF);
+	} else if (op_code == DISPPARAM_HBM_BACKLIGHT_RESEND) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_BACKLIGHT_RESEND);
+	}
+
+	return rc;
+}
+
+int dsi_display_count_set(struct drm_connector *connector, const char *buf)
+{
+	return 0;
+}
+ssize_t dsi_display_count_get(struct drm_connector *connector,	char *buf)
+{
+	return 0;
+}
+
+
+ssize_t dsi_display_fod_get(struct drm_connector *connector, char *buf)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge = to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", display->panel->mi_cfg.fod_ui_ready);
+}
+
+ssize_t complete_commit_time_get(struct drm_connector *connector, char *buf)
+{
+	struct dsi_display *dsi_display = NULL;
+	struct dsi_bridge *c_bridge;
+	struct msm_drm_private *priv = NULL;
+
+	if ((connector == NULL) || (connector->encoder == NULL)
+			|| (connector->encoder->bridge == NULL))
+		return 0;
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	dsi_display = c_bridge->display;
+
+	if ((dsi_display == NULL) || (dsi_display->panel == NULL))
+		return -EINVAL;
+
+	priv = dsi_display->drm_dev->dev_private;
+
+	return snprintf(buf, PAGE_SIZE, "%lld\n", priv->complete_commit_time);
+
+}
+
+int dsi_display_set_thermal_hbm_disabled(struct drm_connector *connector,
+			bool thermal_hbm_disabled)
+{
+	struct sde_connector *c_conn = NULL;
+	struct dsi_display *display = NULL;
+
+	if (!connector) {
+		pr_err("invalid argument\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+	if (!c_conn->display) {
+		pr_err("invalid connector display\n");
+		return -EINVAL;
+	}
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		pr_err("unsupported connector (%s)\n", connector->name);
+		return -EINVAL;
+	}
+
+	display = (struct dsi_display *)c_conn->display;
+	return dsi_panel_set_thermal_hbm_disabled(display->panel, thermal_hbm_disabled);
+}
+
+int dsi_display_get_thermal_hbm_disabled(struct drm_connector *connector,
+			bool *thermal_hbm_disabled)
+{
+	struct sde_connector *c_conn = NULL;
+	struct dsi_display *display = NULL;
+
+	if (!connector) {
+		pr_err("invalid argument\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+	if (!c_conn->display) {
+		pr_err("invalid connector display\n");
+		return -EINVAL;
+	}
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		pr_err("unsupported connector (%s)\n", connector->name);
+		return -EINVAL;
+	}
+
+	display = (struct dsi_display *)c_conn->display;
+	return dsi_panel_get_thermal_hbm_disabled(display->panel, thermal_hbm_disabled);
+}
+
+ssize_t dsi_display_get_hw_vsync_info(struct drm_connector *connector,
+			char *buf)
+{
+	struct sde_connector *c_conn = NULL;
+	struct dsi_display *display = NULL;
+
+	if (!connector) {
+		pr_err("invalid argument\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+	if (!c_conn->display) {
+		pr_err("invalid connector display\n");
+		return -EINVAL;
+	}
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		pr_err("unsupported connector (%s)\n", connector->name);
+		return -EINVAL;
+	}
+
+	display = (struct dsi_display *)c_conn->display;
+
+	return calc_hw_vsync_info(display->panel, buf);
+}
diff --git a/techpack/display/msm/dsi/dsi_drm.c b/techpack/display/msm/dsi/dsi_drm.c
index ea57b890861c..a140a74fa989 100644
--- a/techpack/display/msm/dsi/dsi_drm.c
+++ b/techpack/display/msm/dsi/dsi_drm.c
@@ -6,11 +6,16 @@
 
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_atomic.h>
+#include <drm/drm_notifier_mi.h>
 
 #include "msm_kms.h"
 #include "sde_connector.h"
 #include "dsi_drm.h"
 #include "sde_trace.h"
+#include <drm/drm_bridge.h>
+#include <linux/pm_wakeup.h>
+#include "msm_drv.h"
+#include "dsi_defs.h"
 
 #define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
 #define to_dsi_state(x)      container_of((x), struct dsi_connector_state, base)
@@ -27,6 +32,13 @@ static struct dsi_display_mode_priv_info default_priv_info = {
 	.dsc_enabled = false,
 };
 
+#define WAIT_RESUME_TIMEOUT 200
+
+struct dsi_bridge *gbridge;
+static struct delayed_work prim_panel_work;
+static atomic_t prim_panel_is_on;
+static struct wakeup_source *prim_panel_wakelock;
+
 static void convert_to_dsi_mode(const struct drm_display_mode *drm_mode,
 				struct dsi_display_mode *dsi_mode)
 {
@@ -164,6 +176,9 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	int rc = 0;
 	struct dsi_bridge *c_bridge = to_dsi_bridge(bridge);
+	struct mi_drm_notifier notify_data;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	int power_mode = 0;
 
 	if (!bridge) {
 		DSI_ERR("Invalid params\n");
@@ -177,6 +192,7 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 
 	if (bridge->encoder->crtc->state->active_changed)
 		atomic_set(&c_bridge->display->panel->esd_recovery_pending, 0);
+	mi_cfg = &c_bridge->display->panel->mi_cfg;
 
 	/* By this point mode should have been validated through mode_fixup */
 	rc = dsi_display_set_mode(c_bridge->display,
@@ -187,6 +203,30 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 		return;
 	}
 
+	if (c_bridge->display->is_prim_display && atomic_read(&prim_panel_is_on) && !mi_cfg->fod_dimlayer_enabled) {
+		cancel_delayed_work_sync(&prim_panel_work);
+		__pm_relax(prim_panel_wakelock);
+		if (c_bridge->display->panel->panel_mode == DSI_OP_VIDEO_MODE) {
+			DSI_INFO("skip set display config for video panel in fpc\n");
+			return;
+		} else if (c_bridge->display->panel->panel_mode == DSI_OP_CMD_MODE &&
+		    c_bridge->dsi_mode.dsi_mode_flags != DSI_MODE_FLAG_DMS) {
+			DSI_INFO("skip set display config because timming not switch for command panel\n");
+			return;
+		}
+	}
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		power_mode = sde_connector_get_lp(c_bridge->display->drm_conn);
+	} else {
+		power_mode = MI_DRM_BLANK_UNBLANK;
+	}
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+	mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
+
+
 	if (c_bridge->dsi_mode.dsi_mode_flags &
 		(DSI_MODE_FLAG_SEAMLESS | DSI_MODE_FLAG_VRR |
 		 DSI_MODE_FLAG_DYN_CLK)) {
@@ -211,13 +251,63 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 				c_bridge->id, rc);
 		(void)dsi_display_unprepare(c_bridge->display);
 	}
+
+	mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 	SDE_ATRACE_END("dsi_display_enable");
 
 	rc = dsi_display_splash_res_cleanup(c_bridge->display);
 	if (rc)
 		DSI_ERR("Continuous splash pipeline cleanup failed, rc=%d\n",
 									rc);
+
+	if (c_bridge->display->is_prim_display)
+		atomic_set(&prim_panel_is_on, true);
+
+}
+
+/**
+ *  dsi_bridge_interface_enable - Panel light on interface for fingerprint
+ *  In order to improve panel light on performance when unlock device by
+ *  fingerprint, export this interface for fingerprint.Once finger touch
+ *  happened, it could light on LCD panel in advance of android resume.
+ *
+ *  @timeout: DSI bridge wait time for android resume and set panel on.
+ *            If timeout, dsi bridge will disable panel to avoid fingerprint
+ *            touch by mistake.
+ */
+
+int dsi_bridge_interface_enable(int timeout)
+{
+	int ret = 0;
+
+	ret = wait_event_timeout(resume_wait_q,
+		!atomic_read(&resume_pending),
+		msecs_to_jiffies(WAIT_RESUME_TIMEOUT));
+	if (!ret) {
+		pr_info("Primary fb resume timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	mutex_lock(&gbridge->base.lock);
+
+	if (atomic_read(&prim_panel_is_on)) {
+		mutex_unlock(&gbridge->base.lock);
+		return 0;
+	}
+
+	__pm_stay_awake(prim_panel_wakelock);
+	gbridge->dsi_mode.dsi_mode_flags = 0;
+	dsi_bridge_pre_enable(&gbridge->base);
+
+	if (timeout > 0)
+		schedule_delayed_work(&prim_panel_work, msecs_to_jiffies(timeout));
+	else
+		__pm_relax(prim_panel_wakelock);
+
+	mutex_unlock(&gbridge->base.lock);
+	return ret;
 }
+EXPORT_SYMBOL(dsi_bridge_interface_enable);
 
 static void dsi_bridge_enable(struct drm_bridge *bridge)
 {
@@ -252,6 +342,7 @@ static void dsi_bridge_enable(struct drm_bridge *bridge)
 			sde_connector_schedule_status_work(display->drm_conn,
 				true);
 	}
+
 }
 
 static void dsi_bridge_disable(struct drm_bridge *bridge)
@@ -290,12 +381,27 @@ static void dsi_bridge_post_disable(struct drm_bridge *bridge)
 {
 	int rc = 0;
 	struct dsi_bridge *c_bridge = to_dsi_bridge(bridge);
+	struct mi_drm_notifier notify_data;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	int power_mode = 0;
 
 	if (!bridge) {
 		DSI_ERR("Invalid params\n");
 		return;
 	}
 
+	mi_cfg = &c_bridge->display->panel->mi_cfg;
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		power_mode = sde_connector_get_lp(c_bridge->display->drm_conn);
+	} else {
+		power_mode = MI_DRM_BLANK_POWERDOWN;
+	}
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+	mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
+
 	SDE_ATRACE_BEGIN("dsi_bridge_post_disable");
 	SDE_ATRACE_BEGIN("dsi_display_disable");
 	rc = dsi_display_disable(c_bridge->display);
@@ -314,7 +420,25 @@ static void dsi_bridge_post_disable(struct drm_bridge *bridge)
 		SDE_ATRACE_END("dsi_bridge_post_disable");
 		return;
 	}
+
+	mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 	SDE_ATRACE_END("dsi_bridge_post_disable");
+
+	if (c_bridge->display->is_prim_display)
+		atomic_set(&prim_panel_is_on, false);
+
+}
+
+static void prim_panel_off_delayed_work(struct work_struct *work)
+{
+	mutex_lock(&gbridge->base.lock);
+	if (atomic_read(&prim_panel_is_on)) {
+		dsi_bridge_post_disable(&gbridge->base);
+		__pm_relax(prim_panel_wakelock);
+		mutex_unlock(&gbridge->base.lock);
+		return;
+	}
+	mutex_unlock(&gbridge->base.lock);
 }
 
 static void dsi_bridge_mode_set(struct drm_bridge *bridge,
@@ -423,7 +547,8 @@ static bool dsi_bridge_mode_fixup(struct drm_bridge *bridge,
 			(!(dsi_mode.dsi_mode_flags & DSI_MODE_FLAG_POMS)) &&
 			(!(dsi_mode.dsi_mode_flags & DSI_MODE_FLAG_DYN_CLK)) &&
 			(!crtc_state->active_changed ||
-			 display->is_cont_splash_enabled))
+			 display->is_cont_splash_enabled) &&
+			 display->config.panel_mode == DSI_OP_CMD_MODE)
 			dsi_mode.dsi_mode_flags |= DSI_MODE_FLAG_DMS;
 	}
 
@@ -1060,6 +1185,20 @@ struct dsi_bridge *dsi_drm_bridge_init(struct dsi_display *display,
 	}
 
 	encoder->bridge = &bridge->base;
+
+	encoder->bridge->is_dsi_drm_bridge = true;
+	mutex_init(&encoder->bridge->lock);
+
+	if (display->is_prim_display) {
+		gbridge = bridge;
+		atomic_set(&resume_pending, 0);
+		prim_panel_wakelock = wakeup_source_create("prim_panel_wakelock");
+		wakeup_source_add(prim_panel_wakelock);
+		atomic_set(&prim_panel_is_on, false);
+		init_waitqueue_head(&resume_wait_q);
+		INIT_DELAYED_WORK(&prim_panel_work, prim_panel_off_delayed_work);
+	}
+
 	return bridge;
 error_free_bridge:
 	kfree(bridge);
@@ -1072,5 +1211,12 @@ void dsi_drm_bridge_cleanup(struct dsi_bridge *bridge)
 	if (bridge && bridge->base.encoder)
 		bridge->base.encoder->bridge = NULL;
 
+	if (bridge == gbridge) {
+		atomic_set(&prim_panel_is_on, false);
+		cancel_delayed_work_sync(&prim_panel_work);
+		wakeup_source_remove(prim_panel_wakelock);
+		wakeup_source_destroy(prim_panel_wakelock);
+	}
+
 	kfree(bridge);
 }
diff --git a/techpack/display/msm/dsi/dsi_drm.h b/techpack/display/msm/dsi/dsi_drm.h
index ec012c2cb529..051dd6d97bf0 100644
--- a/techpack/display/msm/dsi/dsi_drm.h
+++ b/techpack/display/msm/dsi/dsi_drm.h
@@ -23,6 +23,7 @@ struct dsi_bridge {
 
 	struct dsi_display *display;
 	struct dsi_display_mode dsi_mode;
+	struct mutex lock;
 };
 
 /**
diff --git a/techpack/display/msm/dsi/dsi_mi_feature.h b/techpack/display/msm/dsi/dsi_mi_feature.h
new file mode 100644
index 000000000000..7db9281d2abb
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_mi_feature.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DSI_MI_FEATURE_H_
+#define _DSI_MI_FEATURE_H_
+
+enum DISPPARAM_MODE  {
+	DISPPARAM_WARM                 = 0x1,
+	DISPPARAM_DEFAULT              = 0x2,
+	DISPPARAM_COLD                 = 0x3,
+	DISPPARAM_PAPERMODE8           = 0x5,
+	DISPPARAM_PAPERMODE1           = 0x6,
+	DISPPARAM_PAPERMODE2           = 0x7,
+	DISPPARAM_PAPERMODE3           = 0x8,
+	DISPPARAM_PAPERMODE4           = 0x9,
+	DISPPARAM_PAPERMODE5           = 0xA,
+	DISPPARAM_PAPERMODE6           = 0xB,
+	DISPPARAM_PAPERMODE7           = 0xC,
+	DISPPARAM_WHITEPOINT_XY        = 0xE,
+
+	DISPPARAM_CE_ON                = 0x10,
+	DISPPARAM_CE_OFF               = 0xF0,
+
+	DISPPARAM_CABCUI_ON            = 0x100,
+	DISPPARAM_CABCSTILL_ON         = 0x200,
+	DISPPARAM_CABCMOVIE_ON         = 0x300,
+	DISPPARAM_CABC_OFF             = 0x400,
+	DISPPARAM_SKIN_CE_CABCUI_ON    = 0x500,
+	DISPPARAM_SKIN_CE_CABCSTILL_ON = 0x600,
+	DISPPARAM_SKIN_CE_CABCMOVIE_ON = 0x700,
+	DISPPARAM_SKIN_CE_CABC_OFF     = 0x800,
+	DISPPARAM_DIMMING_OFF          = 0xE00,
+	DISPPARAM_DIMMING              = 0xF00,
+
+	DISPPARAM_ACL_L1               = 0x1000,
+	DISPPARAM_ACL_L2               = 0x2000,
+	DISPPARAM_ACL_L3               = 0x3000,
+	DISPPARAM_ACL_OFF              = 0xF000,
+
+	DISPPARAM_HBM_ON               = 0x10000,
+	DISPPARAM_HBM_FOD_ON           = 0x20000,
+	DISPPARAM_HBM_FOD2NORM         = 0x30000,
+	DISPPARAM_DC_ON                = 0x40000,
+	DISPPARAM_DC_OFF               = 0x50000,
+	DISPPARAM_HBM_HDR_ON           = 0x60000,
+	DISPPARAM_FOD_UNLOCK_SUCCESS   = 0x70000,
+	DISPPARAM_FOD_UNLOCK_FAIL      = 0x80000,
+	DISPPARAM_HBM_HDR_OFF          = 0x90000,
+	DISPPARAM_HBM_FOD_OFF          = 0xE0000,
+	DISPPARAM_HBM_OFF              = 0xF0000,
+	DISPPARAM_LCD_HBM_OFF          = 0xA0000,
+	DISPPARAM_LCD_HBM_L1_ON        = 0xB0000,
+	DISPPARAM_LCD_HBM_L2_ON        = 0xC0000,
+	DISPPARAM_LCD_HBM_L3_ON        = 0xD0000,
+
+	DISPPARAM_NORMALMODE1          = 0x100000,
+	DISPPARAM_P3                   = 0x200000,
+	DISPPARAM_SRGB                 = 0x300000,
+	DISPPARAM_SKIN_CE              = 0x400000,
+	DISPPARAM_SKIN_CE_OFF          = 0x500000,
+	DISPPARAM_DOZE_BRIGHTNESS_HBM  = 0x600000,
+	DISPPARAM_DOZE_BRIGHTNESS_LBM  = 0x700000,
+	DISPPARAM_DOZE_OFF             = 0x800000,
+	DISPPARAM_HBM_BACKLIGHT_RESEND = 0xA00000,
+	DISPPARAM_FOD_BACKLIGHT        = 0xD00000,
+	DISPPARAM_CRC_OFF              = 0xF00000,
+
+	DISPPARAM_FOD_BACKLIGHT_ON     = 0x1000000,
+	DISPPARAM_FOD_BACKLIGHT_OFF    = 0x2000000,
+	DISPPARAM_ELVSS_DIMMING_ON     = 0x3000000,
+	DISPPARAM_ELVSS_DIMMING_OFF    = 0x4000000,
+	DISPPARAM_FLAT_MODE_ON         = 0x5000000,
+	DISPPARAM_FLAT_MODE_OFF        = 0x6000000,
+	DISPPARAM_DITHER_ON            = 0x7000000,
+	DISPPARAM_DITHER_OFF           = 0x8000000,
+	DISPPARAM_SET_THERMAL_HBM_DISABLE     = 0xA000000,
+	DISPPARAM_CLEAR_THERMAL_HBM_DISABLE   = 0xB000000,
+
+	DISPPARAM_DFPS_LEVEL1          = 0x10000000,
+	DISPPARAM_DFPS_LEVEL2          = 0x20000000,
+	DISPPARAM_DFPS_LEVEL3          = 0x30000000,
+	DISPPARAM_DFPS_LEVEL4          = 0x40000000,
+	DISPPARAM_DFPS_LEVEL5          = 0x50000000,
+	DISPPARAM_DFPS_LEVEL6          = 0x60000000,
+	DISPPARAM_DFPS_LEVEL7          = 0x70000000,
+};
+
+#endif /* _DSI_MI_FEATURE_H_ */
diff --git a/techpack/display/msm/dsi/dsi_panel.c b/techpack/display/msm/dsi/dsi_panel.c
index 8875270e6d2b..b2056a2ad89d 100644
--- a/techpack/display/msm/dsi/dsi_panel.c
+++ b/techpack/display/msm/dsi/dsi_panel.c
@@ -12,9 +12,11 @@
 #include <video/mipi_display.h>
 
 #include "dsi_panel.h"
-#include "dsi_display.h"
 #include "dsi_ctrl_hw.h"
 #include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+#include "dsi_display.h"
+#include "xiaomi_frame_stat.h"
 
 /**
  * topology is currently defined by a set of following 3 values:
@@ -34,6 +36,9 @@
 #define DEFAULT_PANEL_PREFILL_LINES	25
 #define MIN_PREFILL_LINES      35
 
+extern struct frame_stat fm_stat;
+extern void sde_crtc_fod_ui_ready(struct dsi_display *display, int type, int value);
+
 enum dsi_dsc_ratio_type {
 	DSC_8BPC_8BPP,
 	DSC_10BPC_8BPP,
@@ -73,7 +78,7 @@ static char dsi_dsc_rc_range_min_qp_1_1_scr1[][15] = {
  */
 static char dsi_dsc_rc_range_max_qp_1_1[][15] = {
 	{4, 4, 5, 6, 7, 7, 7, 8, 9, 10, 11, 12, 13, 13, 15},
-	{4, 8, 9, 10, 11, 11, 11, 12, 13, 14, 15, 16, 17, 17, 19},
+	{8, 8, 9, 10, 11, 11, 11, 12, 13, 14, 15, 16, 17, 17, 19},
 	{12, 12, 13, 14, 15, 15, 15, 16, 17, 18, 19, 20, 21, 21, 23},
 	{7, 8, 9, 10, 11, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16},
 	};
@@ -451,8 +456,28 @@ static int dsi_panel_power_on(struct dsi_panel *panel)
 {
 	int rc = 0;
 
-	if (!panel->tddi_doubleclick_flag)
-	rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+	if (g_panel->panel_reset_skip) {
+		pr_info("%s: panel reset skip\n", __func__);
+
+		if (panel->off_keep_reset) {
+			rc = dsi_panel_reset(panel);
+			if (rc) {
+				pr_err("[%s] failed to reset panel, rc=%d\n", panel->name, rc);
+			}
+		}
+		if (!panel->tddi_doubleclick_flag_old)
+			rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+		else
+			return rc;
+	} else if (panel->mi_cfg.is_tddi_flag) {
+		if (!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag) {
+			rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+			if (panel->mi_cfg.panel_dead_flag)
+				panel->mi_cfg.panel_dead_flag = false;
+		}
+	} else {
+		rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+	}
 	if (rc) {
 		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
 				panel->name, rc);
@@ -465,6 +490,10 @@ static int dsi_panel_power_on(struct dsi_panel *panel)
 		goto error_disable_vregs;
 	}
 
+	/* If LP11_INIT is set, skip panel reset here*/
+	if (panel->lp11_init)
+		goto exit;
+
 	rc = dsi_panel_reset(panel);
 	if (rc) {
 		DSI_ERR("[%s] failed to reset panel, rc=%d\n", panel->name, rc);
@@ -496,10 +525,30 @@ static int dsi_panel_power_off(struct dsi_panel *panel)
 	if (gpio_is_valid(panel->reset_config.disp_en_gpio))
 		gpio_set_value(panel->reset_config.disp_en_gpio, 0);
 
-	if (!panel->tddi_doubleclick_flag)
-	if (gpio_is_valid(panel->reset_config.reset_gpio) &&
-					!panel->reset_gpio_always_on)
-		gpio_set_value(panel->reset_config.reset_gpio, 0);
+	if (g_panel->panel_reset_skip) {
+		if (!panel->tddi_doubleclick_flag_old) {
+			if (gpio_is_valid(panel->reset_config.reset_gpio) &&
+							!panel->reset_gpio_always_on)
+				gpio_set_value(panel->reset_config.reset_gpio, 0);
+		} else {
+				pr_info("%s: panel reset skip\n", __func__);
+				return rc;
+		}
+	}
+	
+	if (!panel->off_keep_reset) {
+		if (gpio_is_valid(panel->reset_config.reset_gpio))
+			gpio_set_value(panel->reset_config.reset_gpio, 0);
+	} else if (panel->mi_cfg.is_tddi_flag) {
+		if (!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag) {
+			if (gpio_is_valid(panel->reset_config.reset_gpio))
+				gpio_set_value(panel->reset_config.reset_gpio, 0);
+		}
+	} else {
+		if (gpio_is_valid(panel->reset_config.reset_gpio) &&
+						!panel->reset_gpio_always_on)
+			gpio_set_value(panel->reset_config.reset_gpio, 0);
+	}
 
 	if (gpio_is_valid(panel->reset_config.lcd_mode_sel_gpio))
 		gpio_set_value(panel->reset_config.lcd_mode_sel_gpio, 0);
@@ -517,15 +566,26 @@ static int dsi_panel_power_off(struct dsi_panel *panel)
 		       rc);
 	}
 
-	if(!panel->tddi_doubleclick_flag)
-	rc = dsi_pwr_enable_regulator(&panel->power_info, false);
-	if (rc)
-		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
-				panel->name, rc);
+	if(!panel->tddi_doubleclick_flag_old) {
+		rc = dsi_pwr_enable_regulator(&panel->power_info, false);
+		if (rc)
+			pr_err("[%s] failed to enable vregs, rc=%d\n", panel->name, rc);
+	} else if (panel->mi_cfg.is_tddi_flag) {
+		if(!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag) {
+			rc = dsi_pwr_enable_regulator(&panel->power_info, false);
+			if (rc)
+				pr_err("[%s] failed to enable vregs, rc=%d\n", panel->name, rc);
+		}
+	} else {
+		rc = dsi_pwr_enable_regulator(&panel->power_info, false);
+		if (rc)
+			pr_err("[%s] failed to enable vregs, rc=%d\n", panel->name, rc);
+	}
 
 	return rc;
 }
-static int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
+
+int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
 				enum dsi_cmd_set_type type)
 {
 	int rc = 0, i = 0;
@@ -655,12 +715,14 @@ static int dsi_panel_dcs_set_display_brightness_c2(struct mipi_dsi_device *dsi,
 
 
 
-static int dsi_panel_update_backlight(struct dsi_panel *panel,
+int dsi_panel_update_backlight(struct dsi_panel *panel,
 	u32 bl_lvl)
 {
 	int rc = 0;
 	struct mipi_dsi_device *dsi;
 	struct dsi_backlight_config *bl;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+	static int use_count = 10;
 
 	if (!panel || (bl_lvl > 0xffff)) {
 		DSI_ERR("invalid params\n");
@@ -673,10 +735,30 @@ static int dsi_panel_update_backlight(struct dsi_panel *panel,
 	if (panel->bl_config.bl_inverted_dbv)
 		bl_lvl = (((bl_lvl & 0xff) << 8) | (bl_lvl >> 8));
 
-	if (panel->bl_config.bl_dcs_subtype == 0xc2)
+	if (panel->bl_config.bl_dcs_subtype == 0xc2) {
 		rc = dsi_panel_dcs_set_display_brightness_c2(dsi, bl_lvl);
-	else
-		rc = mipi_dsi_dcs_set_display_brightness(dsi, bl_lvl);
+	} else {
+		if (panel->mi_cfg.bl_is_big_endian) {
+			if ((!mi_cfg->last_bl_level && bl_lvl) ||
+				(mi_cfg->last_bl_level && !bl_lvl))
+				use_count = 10;
+
+			if (use_count-- > 0 && mi_cfg->last_bl_level != bl_lvl)
+				DSI_INFO("set backlight from %d to %d\n",
+					mi_cfg->last_bl_level, bl_lvl);
+
+			if (!mi_cfg->in_aod &&mi_cfg->vi_setting_enabled) {
+				if (bl_lvl >= mi_cfg->vi_switch_threshold) {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+				}
+			}
+			rc = mipi_dsi_dcs_set_display_brightness_big_endian(dsi, bl_lvl);
+		} else {
+			rc = mipi_dsi_dcs_set_display_brightness(dsi, bl_lvl);
+		}
+	}
 
 	if (rc < 0)
 		DSI_ERR("failed to update dcs backlight:%d\n", bl_lvl);
@@ -735,21 +817,110 @@ static int dsi_panel_update_pwm_backlight(struct dsi_panel *panel,
 	return rc;
 }
 
+bool dc_skip_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+/* 1. dc enable is 1;
+ * 2. bl lvl should less than dc theshold;
+ * 3. bl lvl not 0, we should not skip set 0;
+ * 4. dc type is 1 means need backlight control here, 0 means IC can switch automatically.
+ * When meet all the 4 conditions at the same time, skip set this bl.
+ */
+	if (mi_cfg->dc_enable && bl_lvl < mi_cfg->dc_threshold && bl_lvl != 0 && mi_cfg->dc_type) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static u32 dsi_panel_get_backlight(struct dsi_panel *panel)
+{
+	return panel->bl_config.bl_level;
+}
+
+static u32 interpolate(uint32_t x, uint32_t xa, uint32_t xb, uint32_t ya, uint32_t yb)
+{
+	return ya - (ya - yb) * (x - xa) / (xb - xa);
+}
+
+u32 dsi_panel_get_fod_dim_alpha(struct dsi_panel *panel)
+{
+	u32 brightness = dsi_panel_get_backlight(panel);
+	int i;
+
+	if (!panel->fod_dim_lut)
+		return 0;
+
+	for (i = 0; i < panel->fod_dim_lut_count; i++)
+		if (panel->fod_dim_lut[i].brightness >= brightness)
+			break;
+
+	if (i == 0)
+		return panel->fod_dim_lut[i].alpha;
+
+	if (i == panel->fod_dim_lut_count)
+		return panel->fod_dim_lut[i - 1].alpha;
+
+	return interpolate(brightness,
+			panel->fod_dim_lut[i - 1].brightness, panel->fod_dim_lut[i].brightness,
+			panel->fod_dim_lut[i - 1].alpha, panel->fod_dim_lut[i].alpha);
+}
+
+int dsi_panel_set_fod_hbm(struct dsi_panel *panel, bool status)
+{
+	int rc = 0;
+
+	if (status) {
+		dsi_panel_set_disp_param(panel, DISPPARAM_HBM_FOD_ON);
+	} else {
+		dsi_panel_set_disp_param(panel, DISPPARAM_HBM_FOD_OFF);
+	}
+
+	return rc;
+}
+
 int dsi_panel_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
 {
 	int rc = 0;
 	struct dsi_backlight_config *bl = &panel->bl_config;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
 
 	if (panel->host_config.ext_bridge_mode)
 		return 0;
 
 	DSI_DEBUG("backlight type:%d lvl:%d\n", bl->type, bl_lvl);
+
+	/* lmi panel must restore to last_bl_level to avoid flash high
+	 * brightness white exiting app lock with DC on (MIUI-1755728),
+	 * must make sure last_bl_level is correct. */
+	if (mi_cfg->dc_type == 2 && mi_cfg->last_bl_level != bl_lvl) {
+		mi_cfg->last_bl_level = bl_lvl;
+	}
+
+	if (dc_skip_set_backlight(panel, bl_lvl)) {
+		DSI_INFO("skip set backlight bacase dc enable %d, bl %d\n",
+			panel->mi_cfg.dc_enable, bl_lvl);
+		return rc;
+	}
+
 	switch (bl->type) {
 	case DSI_BACKLIGHT_WLED:
 		rc = backlight_device_set_brightness(bl->raw_bd, bl_lvl);
 		break;
 	case DSI_BACKLIGHT_DCS:
-		rc = dsi_panel_update_backlight(panel, bl_lvl);
+		if (mi_cfg->fod_backlight_flag) {
+			DSI_INFO("fod_backlight_flag set, skip set backlight %d\n", bl_lvl);
+		} else {
+			if (mi_cfg->hbm_51_ctrl_flag &&
+				(mi_cfg->fod_hbm_enabled || (mi_cfg->thermal_hbm_disabled && bl_lvl > 2047)
+				|| (mi_cfg->hbm_enabled && !mi_cfg->hbm_brightness))) {
+				DSI_INFO("fod_hbm_enabled(%d),hbm_enabled(%d),"
+					"skip set backlight %d\n", mi_cfg->fod_hbm_enabled,
+					mi_cfg->hbm_enabled, bl_lvl);
+			} else {
+				rc = dsi_panel_update_backlight(panel, bl_lvl);
+			}
+		}
 		break;
 	case DSI_BACKLIGHT_EXTERNAL:
 		break;
@@ -761,6 +932,25 @@ int dsi_panel_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
 		rc = -ENOTSUPP;
 	}
 
+	if ((mi_cfg->last_bl_level == 0 || (mi_cfg->dimming_state == STATE_DIM_RESTORE)) && bl_lvl) {
+		if (mi_cfg->panel_on_dimming_delay)
+			schedule_delayed_work(&mi_cfg->dimming_enable_delayed_work,
+				msecs_to_jiffies(mi_cfg->panel_on_dimming_delay));
+
+		if (mi_cfg->dimming_state == STATE_DIM_RESTORE)
+			mi_cfg->dimming_state = STATE_NONE;
+	}
+
+	if (bl_lvl > 0 && mi_cfg->last_bl_level == 0 && mi_cfg->dc_type) {
+		DSI_INFO("crc off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+	}
+	if (bl_lvl == 0 && mi_cfg->dc_type) {
+		DSI_INFO("DC off\n");
+		mi_cfg->dc_enable = false;
+	}
+	mi_cfg->last_bl_level = bl_lvl;
+	bl->real_bl_level = bl_lvl;
 	return rc;
 }
 
@@ -1236,6 +1426,16 @@ static int dsi_panel_parse_misc_host_config(struct dsi_host_common_cfg *host,
 
 	host->force_hs_clk_lane = utils->read_bool(utils->data,
 					"qcom,mdss-dsi-force-clock-lane-hs");
+
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-clk-strength", &val);
+	if (!rc) {
+		host->clk_strength = val;
+		DSI_INFO("[%s] clk_strength = %d\n", name, val);
+	} else {
+		host->clk_strength = 0;
+		DSI_INFO("[%s] clk_strength default value = %d\n", name, val);
+	}
+
 	panel_cphy_mode = utils->read_bool(utils->data,
 					"qcom,panel-cphy-mode");
 	host->phy_type = panel_cphy_mode ? DSI_PHY_TYPE_CPHY
@@ -1835,6 +2035,75 @@ const char *cmd_set_prop_map[DSI_CMD_SET_MAX] = {
 	"qcom,mdss-dsi-post-mode-switch-on-command",
 	"qcom,mdss-dsi-qsync-on-commands",
 	"qcom,mdss-dsi-qsync-off-commands",
+	/* xiaomi add start */
+	"mi,mdss-dsi-ceon-command",
+	"mi,mdss-dsi-ceoff-command",
+	"mi,mdss-dsi-cabcuion-command",
+	"mi,mdss-dsi-cabcstillon-command",
+	"mi,mdss-dsi-cabcmovieon-command",
+	"mi,mdss-dsi-cabcoff-command",
+	"mi,mdss-dsi-skince-cabcuion-command",
+	"mi,mdss-dsi-skince-cabcstillon-command",
+	"mi,mdss-dsi-skince-cabcmovieon-command",
+	"mi,mdss-dsi-skince-cabcoff-command",
+	"mi,mdss-dsi-dimmingon-command",
+	"mi,mdss-dsi-dimmingoff-command",
+	"mi,mdss-dsi-acl-off-command",
+	"mi,mdss-dsi-acl-l1-command",
+	"mi,mdss-dsi-acl-l2-command",
+	"mi,mdss-dsi-acl-l3-command",
+	"mi,mdss-dsi-lcd-hbm-l1-on-command",
+	"mi,mdss-dsi-lcd-hbm-l2-on-command",
+	"mi,mdss-dsi-lcd-hbm-l3-on-command",
+	"mi,mdss-dsi-lcd-hbm-off-command",
+	"mi,mdss-dsi-hbm-on-command",
+	"mi,mdss-dsi-hbm-off-command",
+	"mi,mdss-dsi-hbm-fod-on-command",
+	"mi,mdss-dsi-hbm-fod-off-command",
+	"mi,mdss-dsi-hbm-hdr-on-command",
+	"mi,mdss-dsi-hbm-hdr-off-command",
+	"mi,mdss-dsi-hbm-fod2norm-command",
+	"mi,mdss-dsi-normal1-command",
+	"mi,mdss-dsi-crc-dcip3-command",
+	"mi,mdss-dsi-srgb-command",
+	"mi,mdss-dsi-doze-hbm-command",
+	"mi,mdss-dsi-doze-lbm-command",
+	"mi,mdss-dsi-crc-off-command",
+	"mi,mdss-dsi-elvss-dimming-off-command",
+	"mi,mdss-dsi-flat-on-command",
+	"mi,mdss-dsi-flat-off-command",
+	"mi,mdss-dsi-level2-key-enable-command",
+	"mi,mdss-dsi-gamma-otp-read-c8-command",
+	"mi,mdss-dsi-gamma-otp-read-c9-command",
+	"mi,mdss-dsi-gamma-otp-read-b3-pre-command",
+	"mi,mdss-dsi-gamma-otp-read-b3-command",
+	"mi,mdss-dsi-level2-key-disable-command",
+	"mi,mdss-dsi-gamma-flash-read-pre-command",
+	"mi,mdss-dsi-gamma-read-fb-command",
+	"mi,mdss-dsi-white-point-read-command",
+	"mi,mdss-dsi-elvss-dimming-offset-command",
+	"mi,mdss-dsi-elvss-dimming-read-command",
+	"mi,mdss-dsi-dc-on-command",
+	"mi,mdss-dsi-dc-off-command",
+	"mi,mdss-dsi-vi-setting-low-command",
+	"mi,mdss-dsi-vi-setting-high-command",
+	"mi,mdss-dsi-switch-page4-command",
+	"mi,mdss-dsi-dc-read-command",
+	"mi,mdss-dsi-aod-to-dc-on-command",
+	"mi,mdss-dsi-dynamic-elvss-on-command",
+	"mi,mdss-dsi-dynamic-elvss-off-command",
+	"mi,mdss-dsi-update-gamma-pre-read-command",
+	"mi,mdss-dsi-update-gamma-read-1st-pre-command",
+	"mi,mdss-dsi-update-gamma-read-2nd-pre-command",
+	"mi,mdss-dsi-update-gamma-read-3rd-pre-command",
+	"mi,mdss-dsi-update-gamma-read-4th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-5th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-6th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-b7-command",
+	"mi,mdss-dsi-greenish-gamma-set-command",
+	"mi,mdss-dsi-black-setting-command",
+	"mi,mdss-dsi-read-lockdown-info-command",
+	/* xiaomi add end */
 };
 
 const char *cmd_set_state_map[DSI_CMD_SET_MAX] = {
@@ -1861,6 +2130,75 @@ const char *cmd_set_state_map[DSI_CMD_SET_MAX] = {
 	"qcom,mdss-dsi-post-mode-switch-on-command-state",
 	"qcom,mdss-dsi-qsync-on-commands-state",
 	"qcom,mdss-dsi-qsync-off-commands-state",
+	/* xiaomi add start */
+	"mi,mdss-dsi-ceon-command-state",
+	"mi,mdss-dsi-ceoff-command-state",
+	"mi,mdss-dsi-cabcuion-command-state",
+	"mi,mdss-dsi-cabcstillon-command-state",
+	"mi,mdss-dsi-cabcmovieon-command-state",
+	"mi,mdss-dsi-cabcoff-command-state",
+	"mi,mdss-dsi-skince-cabcuion-command-state",
+	"mi,mdss-dsi-skince-cabcstillon-command-state",
+	"mi,mdss-dsi-skince-cabcmovieon-command-state",
+	"mi,mdss-dsi-skince-cabcoff-command-state",
+	"mi,mdss-dsi-dimmingon-command-state",
+	"mi,mdss-dsi-dimmingoff-command-state",
+	"mi,mdss-dsi-acl-off-command-state",
+	"mi,mdss-dsi-acl-l1-command-state",
+	"mi,mdss-dsi-acl-l2-command-state",
+	"mi,mdss-dsi-acl-l3-command-state",
+	"mi,mdss-dsi-lcd-hbm-l1-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-l2-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-l3-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-off-command-state",
+	"mi,mdss-dsi-hbm-on-command-state",
+	"mi,mdss-dsi-hbm-off-command-state",
+	"mi,mdss-dsi-hbm-fod-on-command-state",
+	"mi,mdss-dsi-hbm-fod-off-command-state",
+	"mi,mdss-dsi-hbm-hdr-on-command-state",
+	"mi,mdss-dsi-hbm-hdr-off-command-state",
+	"mi,mdss-dsi-hbm-fod2norm-command-state",
+	"mi,mdss-dsi-normal1-command-state",
+	"mi,mdss-dsi-crc-dcip3-command-state",
+	"mi,mdss-dsi-srgb-command-state",
+	"mi,mdss-dsi-doze-hbm-command-state",
+	"mi,mdss-dsi-doze-lbm-command-state",
+	"mi,mdss-dsi-crc-off-command-state",
+	"mi,mdss-dsi-elvss-dimming-off-command-state",
+	"mi,mdss-dsi-flat-on-command-state",
+	"mi,mdss-dsi-flat-off-command-state",
+	"mi,mdss-dsi-level2-key-enable-command-state",
+	"mi,mdss-dsi-gamma-otp-read-c8-command-state",
+	"mi,mdss-dsi-gamma-otp-read-c9-command-state",
+	"mi,mdss-dsi-gamma-otp-read-b3-pre-command-state",
+	"mi,mdss-dsi-gamma-otp-read-b3-command-state",
+	"mi,mdss-dsi-level2-key-disable-command-state",
+	"mi,mdss-dsi-gamma-flash-read-pre-command-state",
+	"mi,mdss-dsi-gamma-read-fb-command-state",
+	"mi,mdss-dsi-white-point-read-command-state",
+	"mi,mdss-dsi-elvss-dimming-offset-command-state",
+	"mi,mdss-dsi-elvss-dimming-read-command-state",
+	"mi,mdss-dsi-dc-on-command-state",
+	"mi,mdss-dsi-dc-off-command-state",
+	"mi,mdss-dsi-vi-setting-low-command-state",
+	"mi,mdss-dsi-vi-setting-high-command-state",
+	"mi,mdss-dsi-switch-page4-command-state",
+	"mi,mdss-dsi-dc-read-command-state",
+	"mi,mdss-dsi-aod-to-dc-on-command-state",
+	"mi,mdss-dsi-dynamic-elvss-on-command-state",
+	"mi,mdss-dsi-dynamic-elvss-off-command-state",
+	"mi,mdss-dsi-update-gamma-pre-read-command-state",
+	"mi,mdss-dsi-update-gamma-read-1st-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-2nd-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-3rd-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-4th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-5th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-6th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-b7-command-state",
+	"mi,mdss-dsi-greenish-gamma-set-command-state",
+	"mi,mdss-dsi-black-setting-command-state",
+	"mi,mdss-dsi-read-lockdown-info-command-state",
+	/* xiaomi add end */
 };
 
 int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt)
@@ -2338,6 +2676,68 @@ static int dsi_panel_parse_bl_pwm_config(struct dsi_panel *panel)
 	return rc;
 }
 
+static int dsi_panel_parse_fod_dim_lut(struct dsi_panel *panel,
+		struct dsi_parser_utils *utils)
+{
+	struct brightness_alpha_pair *lut;
+	u32 *array;
+	int count;
+	int len;
+	int rc;
+	int i;
+
+	len = utils->count_u32_elems(utils->data, "mi,mdss-dsi-dimlayer-brightness-alpha-lut");
+	if (len <= 0 || len % BRIGHTNESS_ALPHA_PAIR_LEN) {
+		pr_err("[%s] invalid number of elements, rc=%d\n",
+				panel->name, rc);
+		rc = -EINVAL;
+		goto count_fail;
+	}
+
+	array = kcalloc(len, sizeof(u32), GFP_KERNEL);
+	if (!array) {
+		pr_err("[%s] failed to allocate memory, rc=%d\n",
+				panel->name, rc);
+		rc = -ENOMEM;
+		goto alloc_array_fail;
+	}
+
+	rc = utils->read_u32_array(utils->data,
+			"mi,mdss-dsi-dimlayer-brightness-alpha-lut", array, len);
+	if (rc) {
+		pr_err("[%s] failed to allocate memory, rc=%d\n",
+				panel->name, rc);
+		goto read_fail;
+	}
+
+	count = len / BRIGHTNESS_ALPHA_PAIR_LEN;
+	lut = kcalloc(count, sizeof(*lut), GFP_KERNEL);
+	if (!lut) {
+		rc = -ENOMEM;
+		goto alloc_lut_fail;
+	}
+
+	for (i = 0; i < count; i++) {
+		struct brightness_alpha_pair *pair = &lut[i];
+		pair->brightness = array[i * BRIGHTNESS_ALPHA_PAIR_LEN + 0];
+		pair->alpha = array[i * BRIGHTNESS_ALPHA_PAIR_LEN + 1];
+	}
+
+	panel->fod_dim_lut = lut;
+	panel->fod_dim_lut_count = count;
+
+alloc_lut_fail:
+read_fail:
+	kfree(array);
+alloc_array_fail:
+count_fail:
+	if (rc) {
+		panel->fod_dim_lut = NULL;
+		panel->fod_dim_lut_count = 0;
+	}
+	return rc;
+}
+
 static int dsi_panel_parse_bl_config(struct dsi_panel *panel)
 {
 	int rc = 0;
@@ -2382,6 +2782,7 @@ static int dsi_panel_parse_bl_config(struct dsi_panel *panel)
 
 	panel->bl_config.bl_scale = MAX_BL_SCALE_LEVEL;
 	panel->bl_config.bl_scale_sv = MAX_SV_BL_SCALE_LEVEL;
+	panel->bl_config.real_bl_level = 0;
 
 	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-bl-min-level", &val);
 	if (rc) {
@@ -2421,9 +2822,23 @@ static int dsi_panel_parse_bl_config(struct dsi_panel *panel)
 		panel->bl_config.bl_dcs_subtype = val;
 	}
 
+	rc = utils->read_u32(utils->data, "qcom,mdss-brightness-init-level",
+		&val);
+	if (rc) {
+		DSI_DEBUG("[%s] brigheness-init-level unspecified, defaulting to max level\n",
+			 panel->name);
+		panel->bl_config.brightness_init_level = panel->bl_config.brightness_max_level;
+	} else {
+		panel->bl_config.brightness_init_level = val;
+	}
+
 	panel->bl_config.bl_inverted_dbv = utils->read_bool(utils->data,
 		"qcom,mdss-dsi-bl-inverted-dbv");
 
+	rc = dsi_panel_parse_fod_dim_lut(panel, utils);
+	if (rc)
+		pr_err("[%s failed to parse fod dim lut\n", panel->name);
+
 	if (panel->bl_config.type == DSI_BACKLIGHT_PWM) {
 		rc = dsi_panel_parse_bl_pwm_config(panel);
 		if (rc) {
@@ -3293,6 +3708,7 @@ static int dsi_panel_parse_esd_config(struct dsi_panel *panel)
 
 	esd_config = &panel->esd_config;
 	esd_config->status_mode = ESD_MODE_MAX;
+
 	esd_config->esd_enabled = utils->read_bool(utils->data,
 		"qcom,esd-check-enabled");
 
@@ -3368,6 +3784,18 @@ static void dsi_panel_update_util(struct dsi_panel *panel,
 	utils->node = panel->panel_of_node;
 }
 
+static int dsi_panel_parse_keep_reset_config(struct dsi_panel *panel,
+				     struct device_node *of_node)
+{
+	if (panel == NULL)
+		return -EINVAL;
+
+	panel->off_keep_reset = of_property_read_bool(of_node,
+		"qcom,mdss-panel-off-keep-reset");
+
+	return 0;
+}
+
 struct dsi_panel *dsi_panel_get(struct device *parent,
 				struct device_node *of_node,
 				struct device_node *parser_node,
@@ -3475,7 +3903,15 @@ struct dsi_panel *dsi_panel_get(struct device *parent,
 	if (rc)
 		DSI_DEBUG("failed to parse esd config, rc=%d\n", rc);
 
-	panel->tddi_doubleclick_flag = false;
+	rc = dsi_panel_parse_mi_config(panel, of_node);
+	if (rc)
+		DSI_DEBUG("failed to parse mi config, rc=%d\n", rc);
+
+	rc = dsi_panel_parse_keep_reset_config(panel, of_node);
+	if (rc)
+		DSI_DEBUG("failed to parse keep reset config, rc=%d\n", rc);
+
+	panel->tddi_doubleclick_flag_old = false;
 	panel->power_mode = SDE_MODE_DPMS_OFF;
 	drm_panel_init(&panel->drm_panel);
 	panel->drm_panel.dev = &panel->mipi_device.dev;
@@ -3500,6 +3936,9 @@ void dsi_panel_put(struct dsi_panel *panel)
 	/* free resources allocated for ESD check */
 	dsi_panel_esd_config_deinit(&panel->esd_config);
 
+	wakeup_source_remove(panel->mi_cfg.aod_wakelock);
+	wakeup_source_destroy(panel->mi_cfg.aod_wakelock);
+
 	kfree(panel);
 }
 
@@ -4009,10 +4448,6 @@ int dsi_panel_pre_prepare(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
-	/* If LP11_INIT is set, panel will be powered up during prepare() */
-	if (panel->lp11_init)
-		goto error;
-
 	rc = dsi_panel_power_on(panel);
 	if (rc) {
 		DSI_ERR("[%s] panel power on failed, rc=%d\n", panel->name, rc);
@@ -4064,6 +4499,10 @@ int dsi_panel_update_pps(struct dsi_panel *panel)
 int dsi_panel_set_lp1(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	mi_cfg = &panel->mi_cfg;
+	mi_cfg->hbm_enabled = false;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4089,15 +4528,20 @@ int dsi_panel_set_lp1(struct dsi_panel *panel)
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_LP1 cmd, rc=%d\n",
 		       panel->name, rc);
+
 exit:
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_LP1");
 	return rc;
 }
 
 int dsi_panel_set_lp2(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
+	mi_cfg = &panel->mi_cfg;
+	mi_cfg->hbm_enabled = false;
 	if (!panel) {
 		DSI_ERR("invalid params\n");
 		return -EINVAL;
@@ -4111,14 +4555,17 @@ int dsi_panel_set_lp2(struct dsi_panel *panel)
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_LP2 cmd, rc=%d\n",
 		       panel->name, rc);
+
 exit:
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_LP2");
 	return rc;
 }
 
 int dsi_panel_set_nolp(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4126,9 +4573,19 @@ int dsi_panel_set_nolp(struct dsi_panel *panel)
 	}
 
 	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+
 	if (!panel->panel_initialized)
 		goto exit;
 
+	cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+
+	if (mi_cfg->fod_hbm_enabled) {
+		DSI_INFO("fod_hbm_enabled set, skip\n");
+		goto exit_skip;
+	}
+
 	/*
 	 * Consider about LP1->LP2->NOLP.
 	 */
@@ -4140,9 +4597,37 @@ int dsi_panel_set_nolp(struct dsi_panel *panel)
 	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_NOLP);
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_NOLP cmd, rc=%d\n",
-		       panel->name, rc);
+			panel->name, rc);
+
+	mi_cfg->dimming_state = STATE_DIM_RESTORE;
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_AOD_TO_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_AOD_TO_DC_ON cmd, rc=%d\n",
+				panel->name, rc);
+	}
+
+exit_skip:
+	if (mi_cfg->fod_hbm_enabled && mi_cfg->dynamic_elvss_enabled) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON);
+		if (rc)
+			DSI_ERR("Failed to send DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON command\n");
+		else
+			DSI_INFO("dynamic elvss on\n");
+	}
+
+	mi_cfg->in_aod = false;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	mi_cfg->layer_fod_unlock_success = false;
+	mi_cfg->sysfs_fod_unlock_success = false;
+	fm_stat.idle_status = false;
+
 exit:
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_NOLP");
+
 	return rc;
 }
 
@@ -4158,10 +4643,9 @@ int dsi_panel_prepare(struct dsi_panel *panel)
 	mutex_lock(&panel->panel_lock);
 
 	if (panel->lp11_init) {
-		rc = dsi_panel_power_on(panel);
+		rc = dsi_panel_reset(panel);
 		if (rc) {
-			DSI_ERR("[%s] panel power on failed, rc=%d\n",
-			       panel->name, rc);
+			pr_err("[%s] failed to reset panel, rc=%d\n", panel->name, rc);
 			goto error;
 		}
 	}
@@ -4435,6 +4919,7 @@ int dsi_panel_switch(struct dsi_panel *panel)
 		       panel->name, rc);
 
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_TIMING_SWITCH");
 	return rc;
 }
 
@@ -4458,9 +4943,42 @@ int dsi_panel_post_switch(struct dsi_panel *panel)
 	return rc;
 }
 
+int dsi_panel_dc_switch(struct dsi_panel *panel)
+{
+	int rc = 0;
+
+	if (!panel) {
+		DSI_ERR("Invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (panel->mi_cfg.dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+					panel->name, rc);
+	} else {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_OFF);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_OFF cmd, rc=%d\n",
+				panel->name, rc);
+	}
+	pr_debug("[%s] tx dc success, dc status %d",
+		panel->name, panel->mi_cfg.dc_enable);
+
+	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_DC_CMD");
+	return rc;
+}
+
 int dsi_panel_enable(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display *display = NULL;
+	struct mipi_dsi_host *host = NULL;
 
 	if (!panel) {
 		DSI_ERR("Invalid params\n");
@@ -4469,13 +4987,61 @@ int dsi_panel_enable(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
+	mi_cfg = &panel->mi_cfg;
+
 	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_ON);
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_ON cmds, rc=%d\n",
 		       panel->name, rc);
-	else
+	else {
 		panel->panel_initialized = true;
+	}
+
+	if (mi_cfg->gamma_update_flag) {
+		if (mi_cfg->gamma_cfg.update_done_60hz &&
+			(60 == panel->cur_mode->timing.refresh_rate)) {
+			rc = dsi_panel_write_gamma_cmd_set(panel,
+					DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ);
+			if (rc)
+				DSI_ERR("[%s] failed to send 60HZ GAMMA, rc=%d\n",
+						panel->name, rc);
+		}
+		if (mi_cfg->gamma_cfg.update_done_90hz &&
+			(90 == panel->cur_mode->timing.refresh_rate)) {
+			rc = dsi_panel_write_gamma_cmd_set(panel,
+					DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ);
+			if (rc)
+				DSI_ERR("[%s] failed to send 90HZ GAMMA, rc=%d\n",
+						panel->name, rc);
+		}
+	}
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+				panel->name, rc);
+	}
+
+	host = panel->host;
+	if (host && mi_cfg->fod_hbm_enabled) {
+		display = container_of(host, struct dsi_display, host);
+		sde_crtc_fod_ui_ready(display, 1, 0);
+	}
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	fm_stat.idle_status = false;
+
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_ON");
+
 	return rc;
 }
 
@@ -4498,6 +5064,64 @@ int dsi_panel_post_enable(struct dsi_panel *panel)
 	}
 error:
 	mutex_unlock(&panel->panel_lock);
+
+	if (panel->mi_cfg.gamma_update_flag) {
+		if (!panel->mi_cfg.gamma_cfg.read_done) {
+			rc = dsi_panel_read_gamma_param(panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to read gamma para, rc=%d\n",
+					panel->name, rc);
+			} else {
+				rc = dsi_panel_update_gamma_param(panel);
+				if (rc) {
+					DSI_ERR("[%s] failed to update gamma para, rc=%d\n",
+						panel->name, rc);
+				}
+			}
+		}
+
+		if (panel->mi_cfg.gamma_cfg.black_setting_flag) {
+			mutex_lock(&panel->panel_lock);
+			display_utc_time_marker("DSI_CMD_SET_MI_BLACK_SETTING");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_BLACK_SETTING);
+			if (rc) {
+				DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_BLACK_SETTING cmds, rc=%d\n",
+					panel->name, rc);
+			}
+			mutex_unlock(&panel->panel_lock);
+		}
+	}
+
+	if (panel->mi_cfg.dc_update_flag && !panel->mi_cfg.dc_cfg.read_done) {
+		rc = dsi_panel_read_dc_param(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read DC para, rc=%d\n",
+				panel->name, rc);
+		} else {
+			rc = dsi_panel_update_dc_param(panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update DC para, rc=%d\n",
+					panel->name, rc);
+			}
+		}
+	}
+
+	if (panel->mi_cfg.greenish_gamma_update_flag && !panel->mi_cfg.greenish_gamma_cfg.gamma_update_done) {
+		rc = dsi_panel_read_greenish_gamma_setting(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read greenish gamma setting, rc=%d\n",
+				panel->name, rc);
+		}
+	}
+
+	if (panel->mi_cfg.greenish_gamma_update_flag && panel->mi_cfg.greenish_gamma_cfg.gamma_update_done) {
+		rc = dsi_panel_update_greenish_gamma_setting(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to update greenish gamma setting, rc=%d\n",
+				panel->name, rc);
+		}
+	}
+
 	return rc;
 }
 
@@ -4527,6 +5151,13 @@ int dsi_panel_pre_disable(struct dsi_panel *panel)
 int dsi_panel_disable(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display *display = NULL;
+	struct mipi_dsi_host *host = NULL;
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_cmd_desc *cmds = NULL;
+	u32 count;
+	u8 *tx_buf;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4535,6 +5166,8 @@ int dsi_panel_disable(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
+	mi_cfg = &panel->mi_cfg;
+
 	/* Avoid sending panel off commands when ESD recovery is underway */
 	if (!atomic_read(&panel->esd_recovery_pending)) {
 		panel->panel_initialized = false;
@@ -4547,6 +5180,37 @@ int dsi_panel_disable(struct dsi_panel *panel)
 			panel->power_mode == SDE_MODE_DPMS_LP2))
 			dsi_pwr_panel_regulator_mode_set(&panel->power_info,
 				"ibb", REGULATOR_MODE_STANDBY);
+
+		priv_info = panel->cur_mode ? panel->cur_mode->priv_info : NULL;
+		if (mi_cfg->fod_hbm_enabled && priv_info) {
+			DSI_INFO("hbm fod off\n");
+			if (mi_cfg->hbm_51_ctrl_flag) {
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+				if (cmds && count >= mi_cfg->fod_off_51_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->fod_off_51_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0x51) {
+						tx_buf[1] = 0x00;
+						tx_buf[2] = 0x00;
+					}
+					DSI_INFO("DSI_CMD_SET_MI_HBM_FOD_OFF 0x%02X = 0x%02X 0x%02X\n",
+							tx_buf[0], tx_buf[1], tx_buf[2]);
+				} else {
+					if (tx_buf)
+						DSI_ERR("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+					else
+						DSI_ERR("tx_buf is NULL pointer\n");
+				}
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+			} else {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+			}
+			if (rc) {
+				DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_HBM_FOD_OFF cmds, rc=%d\n",
+					panel->name, rc);
+			}
+		}
+
 		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_OFF);
 		if (rc) {
 			/*
@@ -4559,11 +5223,35 @@ int dsi_panel_disable(struct dsi_panel *panel)
 					panel->name, rc);
 			rc = 0;
 		}
+	} else {
+		mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+		DSI_INFO("save doze brightness state [%d] when ESD recovery is underway\n",
+				mi_cfg->unset_doze_brightness);
 	}
 	panel->panel_initialized = false;
 	panel->power_mode = SDE_MODE_DPMS_OFF;
 
+	host = panel->host;
+	if (host && mi_cfg->fod_hbm_enabled) {
+		display = container_of(host, struct dsi_display, host);
+		sde_crtc_fod_ui_ready(display, 1, 0);
+	}
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	mi_cfg->layer_fod_unlock_success = false;
+	mi_cfg->sysfs_fod_unlock_success = false;
+	if (mi_cfg->dc_type)
+		mi_cfg->dc_enable = false;
+
 	mutex_unlock(&panel->panel_lock);
+	display_utc_time_marker("DSI_CMD_SET_OFF");
 	return rc;
 }
 
@@ -4604,7 +5292,7 @@ int dsi_panel_post_unprepare(struct dsi_panel *panel)
 	rc = dsi_panel_power_off(panel);
 	if (rc) {
 		DSI_ERR("[%s] panel power_Off failed, rc=%d\n",
-		       panel->name, rc);
+			panel->name, rc);
 		goto error;
 	}
 error:
@@ -4612,10 +5300,14 @@ int dsi_panel_post_unprepare(struct dsi_panel *panel)
 	return rc;
 }
 
-
-void dsi_panel_doubleclick_enable(bool on) {
+void dsi_panel_doubleclick_enable(bool on)
+{
 	struct dsi_display *primary_display = get_main_display();
 	if (primary_display && primary_display->panel)
-		primary_display->panel->tddi_doubleclick_flag = on;
+		primary_display->panel->tddi_doubleclick_flag_old = on;
+
+	if (g_panel)
+		g_panel->panel_reset_skip = on;
+	g_panel->mi_cfg.tddi_doubleclick_flag = on;
 }
 EXPORT_SYMBOL(dsi_panel_doubleclick_enable);
diff --git a/techpack/display/msm/dsi/dsi_panel.h b/techpack/display/msm/dsi/dsi_panel.h
index 4c2fe89c4281..6cb6fd576991 100644
--- a/techpack/display/msm/dsi/dsi_panel.h
+++ b/techpack/display/msm/dsi/dsi_panel.h
@@ -20,6 +20,7 @@
 #include "dsi_pwr.h"
 #include "dsi_parser.h"
 #include "msm_drv.h"
+#include "dsi_panel_mi.h"
 
 #define MAX_BL_LEVEL 4096
 #define MAX_BL_SCALE_LEVEL 1024
@@ -119,11 +120,13 @@ struct dsi_backlight_config {
 	u32 bl_min_level;
 	u32 bl_max_level;
 	u32 brightness_max_level;
+	u32 brightness_init_level;
 	u32 bl_level;
 	u32 bl_scale;
 	u32 bl_scale_sv;
 	bool bl_inverted_dbv;
 	u32 bl_dcs_subtype;
+	u32 real_bl_level;
 
 	int en_gpio;
 	/* PWM params */
@@ -173,6 +176,12 @@ struct drm_panel_esd_config {
 	u32 groups;
 };
 
+#define BRIGHTNESS_ALPHA_PAIR_LEN 2
+struct brightness_alpha_pair {
+	u32 brightness;
+	u32 alpha;
+};
+
 struct dsi_panel {
 	const char *name;
 	const char *type;
@@ -222,11 +231,21 @@ struct dsi_panel {
 	enum dsi_dms_mode dms_mode;
 
 	bool sync_broadcast_en;
-	bool tddi_doubleclick_flag;
+	bool tddi_doubleclick_flag_old;
 
+	struct dsi_panel_mi_cfg mi_cfg;
+ 
+	bool panel_reset_skip;
+	bool off_keep_reset;
 	int panel_test_gpio;
 	int power_mode;
 	enum dsi_panel_physical_type panel_type;
+
+	struct brightness_alpha_pair *fod_dim_lut;
+	u32 fod_dim_lut_count;
+#ifdef CONFIG_DRM_SDE_EXPO
+	bool dimlayer_exposure;
+#endif
 };
 
 static inline bool dsi_panel_ulps_feature_enabled(struct dsi_panel *panel)
@@ -332,6 +351,8 @@ int dsi_panel_switch(struct dsi_panel *panel);
 
 int dsi_panel_post_switch(struct dsi_panel *panel);
 
+int dsi_panel_dc_switch(struct dsi_panel *panel);
+
 void dsi_dsc_pclk_param_calc(struct msm_display_dsc_info *dsc, int intf_width);
 
 void dsi_panel_bl_handoff(struct dsi_panel *panel);
@@ -347,15 +368,23 @@ void dsi_panel_ext_bridge_put(struct dsi_panel *panel);
 void dsi_panel_calc_dsi_transfer_time(struct dsi_host_common_cfg *config,
 		struct dsi_display_mode *mode, u32 frame_threshold_us);
 
-int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt);
+int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
+				enum dsi_cmd_set_type type);
+int dsi_panel_update_backlight(struct dsi_panel *panel,
+				u32 bl_lvl);
 
-int dsi_panel_alloc_cmd_packets(struct dsi_panel_cmd_set *cmd,
-		u32 packet_count);
+int dsi_panel_set_fod_hbm(struct dsi_panel *panel, bool status);
 
-int dsi_panel_create_cmd_packets(const char *data, u32 length, u32 count,
-					struct dsi_cmd_desc *cmd);
+u32 dsi_panel_get_fod_dim_alpha(struct dsi_panel *panel);
 
+int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt);
+int dsi_panel_alloc_cmd_packets(struct dsi_panel_cmd_set *cmd,
+				u32 packet_count);
+int dsi_panel_create_cmd_packets(const char *data,
+				u32 length,
+				u32 count,
+				struct dsi_cmd_desc *cmd);
 void dsi_panel_destroy_cmd_packets(struct dsi_panel_cmd_set *set);
-
 void dsi_panel_dealloc_cmd_packets(struct dsi_panel_cmd_set *set);
+
 #endif /* _DSI_PANEL_H_ */
diff --git a/techpack/display/msm/dsi/dsi_panel_mi.c b/techpack/display/msm/dsi/dsi_panel_mi.c
new file mode 100755
index 000000000000..46172a08e8f9
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_panel_mi.c
@@ -0,0 +1,3146 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"mi-dsi-panel:[%s:%d] " fmt, __func__, __LINE__
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/rtc.h>
+#include <video/mipi_display.h>
+
+#include "sde_kms.h"
+#include "dsi_panel.h"
+#include "dsi_display.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+#include "../../../../kernel/irq/internals.h"
+#include "xiaomi_frame_stat.h"
+
+#define to_dsi_display(x) container_of(x, struct dsi_display, host)
+
+extern struct frame_stat fm_stat;
+static struct dsi_read_config g_dsi_read_cfg;
+struct dsi_panel *g_panel;
+static struct dsi_panel_cmd_set gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_MAX];
+
+static struct calc_hw_vsync g_calc_hw_vsync[MAX_DSI_ACTIVE_DISPLAY];
+
+static void panelon_dimming_enable_delayed_work(struct work_struct *work)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = container_of(work,
+				struct dsi_panel_mi_cfg, dimming_enable_delayed_work.work);
+	struct dsi_panel *dsi_panel = mi_cfg->dsi_panel;
+
+	if (dsi_panel && !mi_cfg->hbm_enabled)
+		dsi_panel_set_disp_param(dsi_panel, DISPPARAM_DIMMING);
+        else {
+		DSI_INFO("hbm_enabled(%d), delay of dimming on\n", mi_cfg->hbm_enabled);
+		schedule_delayed_work(&mi_cfg->dimming_enable_delayed_work,
+			msecs_to_jiffies(mi_cfg->panel_on_dimming_delay));
+	}
+}
+
+static void enter_aod_delayed_work(struct work_struct *work)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = container_of(work,
+				struct dsi_panel_mi_cfg, enter_aod_delayed_work.work);
+	struct dsi_panel *panel = mi_cfg->dsi_panel;
+
+	if (!panel)
+		return;
+
+	mutex_lock(&panel->panel_lock);
+
+	if (!panel->panel_initialized)
+		goto exit;
+
+	if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+			panel->power_mode == SDE_MODE_DPMS_LP2) {
+		if (mi_cfg->layer_fod_unlock_success || mi_cfg->sysfs_fod_unlock_success) {
+			pr_info("[%d,%d]Fod fingerprint unlocked successfully, skip to enter aod mode\n",
+				mi_cfg->layer_fod_unlock_success, mi_cfg->sysfs_fod_unlock_success);
+			goto exit;
+		} else {
+			if (!mi_cfg->unset_doze_brightness) {
+				mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+			}
+			pr_info("delayed_work runing --- set doze brightness\n");
+			if (mi_cfg->layer_aod_flag)
+				dsi_panel_set_doze_brightness(panel, mi_cfg->unset_doze_brightness, false);
+			else
+				pr_info("delayed_work runing --- skip into doze\n");
+		}
+	}
+
+exit:
+	mutex_unlock(&panel->panel_lock);
+}
+
+
+static int dsi_panel_parse_gamma_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	if (mi_cfg->gamma_update_flag) {
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-flash-read-total-param",
+				&mi_cfg->gamma_cfg.flash_read_total_param);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-flash-read-total-param\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-flash-read-c1-index",
+				&mi_cfg->gamma_cfg.flash_read_c1_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-flash-read-c1-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-c8-index",
+				&mi_cfg->gamma_cfg.update_c8_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-c8-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-c9-index",
+				&mi_cfg->gamma_cfg.update_c9_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-c9-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-b3-index",
+				&mi_cfg->gamma_cfg.update_b3_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-b3-index\n");
+
+		mi_cfg->gamma_cfg.black_setting_flag = utils->read_bool(of_node,
+				"mi,mdss-dsi-panel-gamma-black-setting-flag");
+		if (!mi_cfg->gamma_cfg.black_setting_flag)
+			pr_info("can't get mi,mdss-dsi-panel-gamma-black-setting-flag\n");
+	}
+
+	return rc;
+}
+
+static int dsi_panel_parse_greenish_gamma_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	if (mi_cfg->greenish_gamma_update_flag) {
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-greenish-update-gamma-length",
+				&mi_cfg->greenish_gamma_read_len);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-greenish-update-gamma-length\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-greenish-update-gamma-offset",
+				&mi_cfg->greenish_gamma_cfg.greenish_gamma_update_offset);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-greenish-update-gamma-offset\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-param-count",
+				&mi_cfg->greenish_gamma_cfg.greenish_gamma_update_param_count);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-update-gamma-param-count\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-1st-index",
+				&mi_cfg->greenish_gamma_cfg.index_1st_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-1st-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-2nd-index",
+				&mi_cfg->greenish_gamma_cfg.index_2nd_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-2nd-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-3rd-index",
+				&mi_cfg->greenish_gamma_cfg.index_3rd_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-3rd-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-4th-index",
+				&mi_cfg->greenish_gamma_cfg.index_4th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-4th-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-5th-index",
+				&mi_cfg->greenish_gamma_cfg.index_5th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-5th-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-6th-index",
+				&mi_cfg->greenish_gamma_cfg.index_6th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-6th-index\n");
+	}
+
+	return rc;
+}
+
+static int dsi_panel_parse_white_point_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-register-read-length",
+			&mi_cfg->wp_reg_read_len);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-register-read-length\n");
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-info-index",
+			&mi_cfg->wp_info_index);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-info-index\n");
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-info-length",
+			&mi_cfg->wp_info_len);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-info-length\n");
+
+	return rc;
+}
+
+static int dsi_panel_parse_smart_fps_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	mi_cfg->smart_fps_support = utils->read_bool(of_node,
+			"mi,mdss-dsi-pan-enable-smart-fps");
+
+	if (mi_cfg->smart_fps_support) {
+		pr_info("smart fps is supported\n");
+
+		if (panel->dfps_caps.dfps_list_len > 1)
+			mi_cfg->smart_fps_max_framerate = panel->dfps_caps.max_refresh_rate;
+		else {
+			rc = utils->read_u32(of_node,
+					"mi,mdss-dsi-smart-fps-max_framerate", &mi_cfg->smart_fps_max_framerate);
+			if (rc) {
+				mi_cfg->smart_fps_max_framerate = 60;
+				pr_info("mi,mdss-dsi-smart-fps-max_framerate not defined\n");
+			} else
+				pr_info("smart fps max framerate is %d\n", mi_cfg->smart_fps_max_framerate);
+		}
+	}
+
+	return rc;
+}
+
+static int dsi_panel_parse_elvss_dimming_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-register-read-length",
+					&mi_cfg->elvss_dimming_read_len);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-register-read-length\n");
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-update-hbm-fod-on-index",
+					&mi_cfg->update_hbm_fod_on_index);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-update-hbm-fod-on-index\n");
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-update-hbm-fod-off-index",
+					&mi_cfg->update_hbm_fod_off_index);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-update-hbm-fod-off-index\n");
+
+	return rc;
+}
+
+int dsi_panel_parse_mi_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+	u32 length = 0;
+	const u32 *arr;
+
+	mi_cfg->dsi_panel = panel;
+	g_panel = panel;
+
+	INIT_DELAYED_WORK(&mi_cfg->enter_aod_delayed_work, enter_aod_delayed_work);
+	mi_cfg->aod_wakelock = wakeup_source_create("aod_wakelock");
+	wakeup_source_add(mi_cfg->aod_wakelock);
+
+	mi_cfg->bl_is_big_endian= utils->read_bool(utils->data,
+			"mi,mdss-dsi-bl-dcs-big-endian-type");
+
+	rc = utils->read_u64(utils->data, "mi,panel-id", &mi_cfg->panel_id);
+	if (rc) {
+		mi_cfg->panel_id = 0;
+		pr_info("mi,panel-id not specified\n");
+	} else {
+		pr_info("mi,panel-id is 0x%llx\n", mi_cfg->panel_id);
+	}
+
+	mi_cfg->mi_feature_enabled = utils->read_bool(of_node,
+			"mi,feature-enabled");
+	if (mi_cfg->mi_feature_enabled) {
+		pr_info("mi feature enabled\n");
+	} else {
+		pr_info("mi feature disabled\n");
+		return 0;
+	}
+
+	mi_cfg->hbm_51_ctrl_flag = utils->read_bool(utils->data,
+		"mi,mdss-dsi-panel-hbm-51-ctrl-flag");
+	if (mi_cfg->hbm_51_ctrl_flag) {
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-hbm-off-51-index", &mi_cfg->hbm_off_51_index);
+		if (rc) {
+			pr_err("mi,mdss-dsi-panel-hbm-off-51-index not defined,but need\n");
+		}
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-off-51-index", &mi_cfg->fod_off_51_index);
+		if (rc) {
+			pr_err("mi,mdss-dsi-panel-fod-off-51-index not defined,but need\n");
+		}
+		mi_cfg->vi_setting_enabled = utils->read_bool(of_node,
+			"mi,mdss-dsi-panel-vi-setting-enabled");
+		if (mi_cfg->vi_setting_enabled) {
+			pr_info("mi vi_setting_enabled = %d\n", mi_cfg->vi_setting_enabled);
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-vi-switch-threshold", &mi_cfg->vi_switch_threshold);
+			if (rc)
+				pr_err("mi,mdss-dsi-panel-vi-switch-threshold not defined,but need\n");
+		}
+		mi_cfg->dynamic_elvss_enabled = utils->read_bool(of_node,
+			"mi,mdss-dsi-panel-dynamic-elvss-enabled");
+		if (mi_cfg->dynamic_elvss_enabled) {
+			pr_info("mi dynamic_elvss_enabled = %d\n", mi_cfg->dynamic_elvss_enabled);
+		}
+	}
+
+	rc = utils->read_u32(of_node,
+		"mi,mdss-dsi-panel-fod-off-b5-index", &mi_cfg->fod_off_b5_index);
+	if (rc) {
+		pr_err("mi,mdss-dsi-panel-fod-off-b5-index not defined\n");
+	}
+
+	mi_cfg->fod_dimlayer_enabled = utils->read_bool(of_node,
+		"mi,mdss-dsi-panel-fod-dimlayer-enabled");
+	if (mi_cfg->fod_dimlayer_enabled) {
+		pr_info("fod dimlayer enabled.\n");
+	} else {
+		pr_info("fod dimlayer disabled.\n");
+	}
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		mi_cfg->prepare_before_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-prepare-before-fod-hbm-on");
+		if (mi_cfg->prepare_before_fod_hbm_on) {
+			pr_info("fod hbm on need prepare.\n");
+		} else {
+			pr_info("fod hbm on doesn't need prepare.\n");
+		}
+
+		mi_cfg->delay_before_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-before-fod-hbm-on");
+		if (mi_cfg->delay_before_fod_hbm_on) {
+			pr_info("delay before fod hbm on.\n");
+		}
+
+		mi_cfg->delay_after_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-after-fod-hbm-on");
+		if (mi_cfg->delay_after_fod_hbm_on) {
+			pr_info("delay after fod hbm on.\n");
+		}
+
+		mi_cfg->delay_before_fod_hbm_off = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-before-fod-hbm-off");
+		if (mi_cfg->delay_before_fod_hbm_off) {
+			pr_info("delay before fod hbm off.\n");
+		}
+
+		mi_cfg->delay_after_fod_hbm_off = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-after-fod-hbm-off");
+		if (mi_cfg->delay_after_fod_hbm_off) {
+			pr_info("delay after fod hbm off.\n");
+		}
+
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-dimlayer-brightness-alpha-lut-item-count",
+			&mi_cfg->brightnes_alpha_lut_item_count);
+		if (rc || mi_cfg->brightnes_alpha_lut_item_count <= 0) {
+			pr_err("can't get brightnes_alpha_lut_item_count\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		arr = utils->get_property(utils->data,
+				"mi,mdss-dsi-dimlayer-brightness-alpha-lut", &length);
+
+		length = length / sizeof(u32);
+
+		pr_info("length: %d\n", length);
+		if (!arr || length & 0x1 || length != mi_cfg->brightnes_alpha_lut_item_count * 2) {
+			pr_err("read mi,mdss-dsi-dimlayer-brightness-alpha-lut failed\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		mi_cfg->brightness_alpha_lut = (struct brightness_alpha *)kzalloc(length * sizeof(u32), GFP_KERNEL);
+		if (!mi_cfg->brightness_alpha_lut) {
+			pr_err("no memory for brightnes alpha lut\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		rc = utils->read_u32_array(utils->data, "mi,mdss-dsi-dimlayer-brightness-alpha-lut",
+			(u32 *)mi_cfg->brightness_alpha_lut, length);
+		if (rc) {
+			pr_err("cannot read mi,mdss-dsi-dimlayer-brightness-alpha-lut\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			kfree(mi_cfg->brightness_alpha_lut);
+			goto skip_dimlayer_parse;
+		}
+	}
+
+skip_dimlayer_parse:
+	mi_cfg->disp_rate_gpio = utils->get_named_gpio(utils->data,
+		"mi,mdss-dsi-panel-disp-rate-gpio",0);
+	if (gpio_is_valid(mi_cfg->disp_rate_gpio)) {
+		rc = gpio_request(mi_cfg->disp_rate_gpio, "disp_rate");
+		if (rc) {
+			pr_err("request for disp_rate gpio failed, rc=%d\n", rc);
+		}
+		rc = gpio_direction_output(mi_cfg->disp_rate_gpio, 1);
+		if (rc) {
+			pr_err("unable to set dir for disp_rate gpio rc=%d\n", rc);
+		}
+	} else {
+		pr_info("panel disp_rate gpio not specified\n");
+	}
+
+	rc = utils->read_u32(of_node,
+		"mi,mdss-panel-on-dimming-delay", &mi_cfg->panel_on_dimming_delay);
+	if (rc) {
+		mi_cfg->panel_on_dimming_delay = 0;
+		pr_info("panel on dimming delay disabled\n");
+	} else {
+		pr_info("panel on dimming delay %d ms\n", mi_cfg->panel_on_dimming_delay);
+	}
+
+	if (mi_cfg->panel_on_dimming_delay)
+		INIT_DELAYED_WORK(&mi_cfg->dimming_enable_delayed_work, panelon_dimming_enable_delayed_work);
+
+	rc = utils->read_u32(of_node,
+			"mi,disp-fod-off-dimming-delay", &mi_cfg->fod_off_dimming_delay);
+	if (rc) {
+		mi_cfg->fod_off_dimming_delay = DEFAULT_FOD_OFF_DIMMING_DELAY;
+		pr_info("default fod_off_dimming_delay %d\n", DEFAULT_FOD_OFF_DIMMING_DELAY);
+	} else {
+		pr_info("fod_off_dimming_delay %d\n", mi_cfg->fod_off_dimming_delay);
+	}
+
+	mi_cfg->gamma_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-gamma-update-flag");
+	if (mi_cfg->gamma_update_flag) {
+		pr_info("mi,mdss-dsi-panel-gamma-update-flag feature is defined\n");
+
+		rc = dsi_panel_parse_gamma_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse gamma config\n");
+	} else {
+		pr_info("mi,mdss-dsi-panel-gamma-update-flag feature not defined\n");
+	}
+
+	mi_cfg->greenish_gamma_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-greenish-update-gamma-flag");
+	if (mi_cfg->greenish_gamma_update_flag) {
+		pr_info("mi,mdss-dsi-greenish-update-gamma-flag feature is defined\n");
+
+		rc = dsi_panel_parse_greenish_gamma_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse greenish gamma config\n");
+	} else {
+		pr_info("mi,mdss-dsi-greenish-update-gamma-flag feature not defined\n");
+	}
+
+	mi_cfg->dc_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-dc-update-flag");
+	if (mi_cfg->dc_update_flag) {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag feature is defined\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-update-d2-index",
+				&mi_cfg->dc_cfg.update_d2_index);
+		if (rc)
+			pr_info("failed to parse dc config\n");
+	} else {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag feature not defined\n");
+	}
+
+	mi_cfg->wp_read_enabled= utils->read_bool(utils->data,
+				"mi,mdss-dsi-white-point-read-enabled");
+	if (mi_cfg->wp_read_enabled) {
+		rc = dsi_panel_parse_white_point_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse white point config\n");
+	} else {
+		pr_info("mi white point read not defined\n");
+	}
+
+	mi_cfg->elvss_dimming_check_enable = utils->read_bool(of_node,
+			"mi,elvss_dimming_check_enable");
+	if (mi_cfg->elvss_dimming_check_enable) {
+		pr_info("mi,elvss_dimming_check_enable is defined\n");
+
+		rc = dsi_panel_parse_elvss_dimming_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse elvss dimming config\n");
+	} else {
+		pr_info("mi,elvss_dimming_check_enable not defined\n");
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-dc-threshold", &mi_cfg->dc_threshold);
+	if (rc) {
+		mi_cfg->dc_threshold = 440;
+		pr_info("default dc backlight threshold is %d\n", mi_cfg->dc_threshold);
+	} else {
+		pr_info("dc backlight threshold %d \n", mi_cfg->dc_threshold);
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-dc-type", &mi_cfg->dc_type);
+	if (rc) {
+		mi_cfg->dc_type = 1;
+		pr_info("default dc backlight type is %d\n", mi_cfg->dc_type);
+	} else {
+		pr_info("dc backlight type %d \n", mi_cfg->dc_type);
+	}
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-hbm-brightness", &mi_cfg->hbm_brightness);
+	if (rc) {
+		mi_cfg->hbm_brightness = 0;
+		pr_info("default hbm brightness is %d\n", mi_cfg->hbm_brightness);
+	} else {
+		pr_info("hbm brightness %d \n", mi_cfg->hbm_brightness);
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-max-brightness-clone", &mi_cfg->max_brightness_clone);
+	if (rc) {
+		mi_cfg->max_brightness_clone = 4095;
+		pr_info("default max_brightness_clone is %d\n", mi_cfg->max_brightness_clone);
+	} else {
+		pr_info("max_brightness_clone is %d \n", mi_cfg->max_brightness_clone);
+	}
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->hbm_51_ctrl_flag) {
+		rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-on-b2-index", &mi_cfg->fod_on_b2_index);
+		if (rc) {
+			mi_cfg->fod_on_b2_index = 0;
+			pr_info("mi,mdss-dsi-panel-fod-on-b2-index not defined\n");
+		}
+	}
+
+	rc = dsi_panel_parse_smart_fps_config(panel, of_node);
+	if (rc)
+		DSI_INFO("failed to parse smart fps configuration, rc=%d\n", rc);
+
+	mi_cfg->is_tddi_flag = utils->read_bool(of_node,
+			"mi,is-tddi-flag");
+	if (mi_cfg->is_tddi_flag)
+		pr_info("panel is tddi\n");
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->thermal_hbm_disabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->unset_doze_brightness = DOZE_TO_NORMAL;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->fod_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->fod_hbm_off_time = ktime_get();
+	mi_cfg->fod_backlight_off_time = ktime_get();
+	mi_cfg->dc_enable = false;
+	mi_cfg->panel_dead_flag = false;
+	mi_cfg->tddi_doubleclick_flag = false;
+
+	mi_cfg->dither_enabled = false;
+
+	return rc;
+}
+
+void display_utc_time_marker(const char *format, ...)
+{
+	struct timespec ts;
+	struct rtc_time tm;
+	struct va_format vaf;
+	va_list args;
+
+	getnstimeofday(&ts);
+	rtc_time_to_tm(ts.tv_sec, &tm);
+
+	va_start(args, format);
+	vaf.fmt = format;
+	vaf.va = &args;
+
+	printk(KERN_INFO "%ps[%d-%02d-%02d %02d:%02d:%02d.%06lu] --- %pV",
+			__builtin_return_address(0),
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec/1000,
+			&vaf);
+
+	va_end(args);
+}
+
+int dsi_panel_update_elvss_dimming(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_read_config elvss_dimming_read;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	u32 count;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	if (!mi_cfg->elvss_dimming_check_enable) {
+		pr_debug("elvss_dimming_check_enable not defined, return\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_ELVSS_DIMMING_READ];
+	elvss_dimming_read.read_cmd = *cmd_set;
+	elvss_dimming_read.cmds_rlen = mi_cfg->elvss_dimming_read_len;
+	elvss_dimming_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &elvss_dimming_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read elvss_dimming, rc=%d\n", panel->name, rc);
+		retval = -EAGAIN;
+	} else {
+		pr_info("elvss dimming read result %x\n", elvss_dimming_read.rbuf[0]);
+		cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].cmds;
+		count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].count;
+		if (cmds && count >= mi_cfg->update_hbm_fod_on_index) {
+			tx_buf = (u8 *)cmds[mi_cfg->update_hbm_fod_on_index].msg.tx_buf;
+			tx_buf[1] = elvss_dimming_read.rbuf[0] & 0x7F;
+		}
+		cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+		count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+		if (cmds && count >= mi_cfg->update_hbm_fod_off_index) {
+			tx_buf = (u8 *)cmds[mi_cfg->update_hbm_fod_off_index].msg.tx_buf;
+			tx_buf[1] = elvss_dimming_read.rbuf[0] & 0x7F;
+		}
+		retval = 0;
+	}
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_read_greenish_gamma_setting(struct dsi_panel *panel)
+{
+	int rc =0;
+	int retval = 0;
+	int i = 0;
+	int param_count = 0;
+	u32 count = 0;
+	u32 offset = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct greenish_gamma_cfg *greenish_gamma_cfg;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_read_config greenish_gamma_read;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	greenish_gamma_cfg = &mi_cfg->greenish_gamma_cfg;
+
+	if (!mi_cfg->greenish_gamma_update_flag) {
+		pr_debug("greenish_gamma_update_flag not defined, return\n");
+		return 0;
+	}
+
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+
+	/* level2-key-enable */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	/* pre read command */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_PRE_READ);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_PRE_READ command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	/* read 1st~6th param */
+	offset = greenish_gamma_cfg->greenish_gamma_update_offset;
+	param_count = greenish_gamma_cfg->greenish_gamma_update_param_count;
+	for(i = 1; i <= param_count; i++) {
+		switch (i) {
+		case 1:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 1st greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 1st para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_1st_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_1st_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 1st para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 2:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 2nd greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 2nd para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_2nd_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_2nd_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 2nd para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 3:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 3rd greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 3rd para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_3rd_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_3rd_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 3rd para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 4:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 4th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 4th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_4th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_4th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 4th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 5:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 5th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 5th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_5th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_5th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 5th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 6:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 6th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 6th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_6th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_6th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 6th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* level2-key-disable */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		greenish_gamma_cfg->gamma_update_done = true;
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_update_greenish_gamma_setting(struct dsi_panel *panel)
+{
+	int rc =0;
+	int retval = 0;
+	int i = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+
+	if (!mi_cfg->greenish_gamma_update_flag || !mi_cfg->greenish_gamma_cfg.gamma_update_done) {
+		pr_debug("greenish_gamma_update_flag not defined or gamma update has not completed, return\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+	cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+
+	/* greenish gamma seeting cmd */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_B7);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_B7 command\n");
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		pr_info("greenish gamma DSI_CMD_SET_MI_GAMMA_B7 set is\n");
+		for (i = 0; i <= 15; i++) {
+			tx_buf = (u8 *)cmds[i].msg.tx_buf;
+			pr_info("DSI_CMD_SET_MI_GAMMA_B7 %d line tx_buf %x %x\n", i,
+				tx_buf[0], tx_buf[1]);
+		}
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+static int dsi_panel_read_gamma_opt_and_flash(struct dsi_panel *panel,
+				struct dsi_display_ctrl *ctrl)
+{
+	int rc = 0;
+	int retval = 0;
+	int i = 0;
+	int retry_cnt = 0;
+	u32 flags = 0;
+	struct dsi_display_mode *mode;
+	struct gamma_cfg *gamma_cfg;
+	struct dsi_cmd_desc *cmds;
+	enum dsi_cmd_set_state state;
+	u32 count = 0;
+	u32 param_index = 0;
+	u8 read_param_buf[200] = {0};
+	u8 read_fb_buf[16] = {0};
+	u8 *tx_buf;
+	bool checksum_pass = 0;
+
+	if (!panel || !ctrl || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mode = panel->cur_mode;
+	gamma_cfg = &panel->mi_cfg.gamma_cfg;
+
+	/* OTP Read 60hz gamma parameter */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	pr_debug("Gamma 0xC8 OPT Read 135 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C8].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C8].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_c8);
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_C8\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_c8, cmds->msg.rx_buf, sizeof(gamma_cfg->otp_read_c8));
+
+	pr_debug("Gamma 0xC9 OPT Read 180 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C9].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C9].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_c9);
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_C9\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_c9, cmds->msg.rx_buf, sizeof(gamma_cfg->otp_read_c9));
+
+#if 0
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE command\n");
+		goto error;
+	}
+#endif
+
+	pr_debug("Gamma 0xB3 OTP Read 45 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_B3].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_B3].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_b3) + 2;
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_B3\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_b3, &read_param_buf[2], sizeof(gamma_cfg->otp_read_b3));
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	pr_info("OTP Read 60hz gamma done\n");
+
+	/* Flash Read 90hz gamma parameter */
+	do {
+		gamma_cfg->gamma_checksum = 0;
+
+		if (retry_cnt > 0) {
+			pr_err("Failed to flash read 90hz gamma parameters, retry_cnt = %d\n",
+					retry_cnt);
+			mdelay(80);
+		}
+
+		for(i = 0; i < gamma_cfg->flash_read_total_param; i++)
+		{
+			cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE].cmds;
+			count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE].count;
+			tx_buf = (u8 *)cmds[gamma_cfg->flash_read_c1_index].msg.tx_buf;
+			if (cmds && count >= gamma_cfg->flash_read_c1_index) {
+				tx_buf[2] = i >> 8;
+				tx_buf[3] = i & 0xFF;
+			}
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			/* 0xFB Read 2 Parameter */
+			flags = 0;
+			cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB].cmds;
+			state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB].state;
+			if (state == DSI_CMD_SET_STATE_LP)
+				cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+			if (cmds->last_command) {
+				cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+				flags |= DSI_CTRL_CMD_LAST_COMMAND;
+			}
+			flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ |
+						DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+			cmds->msg.rx_buf = read_fb_buf;
+			cmds->msg.rx_len = 2;
+			rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+			if (rc <= 0) {
+				pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			if (i < sizeof(gamma_cfg->flash_read_c8)) {
+				gamma_cfg->flash_read_c8[i] = read_fb_buf[1];
+			}
+			else if (i < (sizeof(gamma_cfg->flash_read_c8) +
+						sizeof(gamma_cfg->flash_read_c9))) {
+				param_index = i - sizeof(gamma_cfg->flash_read_c8);
+				gamma_cfg->flash_read_c9[param_index] = read_fb_buf[1];
+			}
+			else if (i < (sizeof(gamma_cfg->flash_read_c8) +
+					sizeof(gamma_cfg->flash_read_c9) +
+					sizeof(gamma_cfg->flash_read_b3))) {
+				param_index = i - (sizeof(gamma_cfg->flash_read_c8) +
+								sizeof(gamma_cfg->flash_read_c9));
+				gamma_cfg->flash_read_b3[param_index] = read_fb_buf[1];
+			}
+
+			if (i < (gamma_cfg->flash_read_total_param - 2)) {
+				gamma_cfg->gamma_checksum = read_fb_buf[1] + gamma_cfg->gamma_checksum;
+			} else {
+				if (i == (gamma_cfg->flash_read_total_param - 2))
+					gamma_cfg->flash_read_checksum[0] = read_fb_buf[1];
+				if (i == (gamma_cfg->flash_read_total_param - 1))
+					gamma_cfg->flash_read_checksum[1] = read_fb_buf[1];
+			}
+		}
+		if (gamma_cfg->gamma_checksum == ((gamma_cfg->flash_read_checksum[0] << 8)
+				+ gamma_cfg->flash_read_checksum[1])) {
+			checksum_pass = 1;
+			pr_info("Flash Read 90hz gamma done\n");
+		} else {
+			checksum_pass = 0;
+		}
+		retry_cnt++;
+	}
+	while (!checksum_pass && (retry_cnt < 5));
+
+	if (checksum_pass) {
+		gamma_cfg->read_done = 1;
+		pr_info("Gamma read done\n");
+		retval = 0;
+	} else {
+		pr_err("Failed to flash read 90hz gamma\n");
+		retval = -EAGAIN;
+	}
+
+error:
+	return retval;
+
+}
+
+int dsi_panel_read_gamma_param(struct dsi_panel *panel)
+{
+	int rc = 0, ret = 0;
+	struct dsi_display *display;
+	struct dsi_display_ctrl *ctrl;
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_debug("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (display == NULL)
+		return -EINVAL;
+
+	if (!panel->panel_initialized) {
+		pr_err("Panel not initialized\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (panel->mi_cfg.gamma_cfg.read_done) {
+		pr_info("Gamma parameter have read and stored at POWER ON sequence\n");
+		goto unlock;
+	}
+
+	rc = dsi_display_clk_ctrl(display->dsi_clk_handle, DSI_ALL_CLKS, DSI_CLK_ON);
+	if (rc) {
+		pr_err("[%s] failed to enable DSI clocks, rc=%d\n", display->name, rc);
+		goto unlock;
+	}
+
+	ctrl = &display->ctrl[display->cmd_master_idx];
+
+	rc = dsi_display_cmd_engine_enable(display);
+	if (rc) {
+		pr_err("[%s] failed to enable cmd engine, rc=%d\n",
+		       display->name, rc);
+		goto error_disable_clks;
+	}
+
+	if (display->tx_cmd_buf == NULL) {
+		rc = dsi_host_alloc_cmd_tx_buffer(display);
+		if (rc) {
+			pr_err("failed to allocate cmd tx buffer memory\n");
+			goto error_disable_cmd_engine;
+		}
+	}
+
+	rc = dsi_panel_read_gamma_opt_and_flash(panel, ctrl);
+	if (rc) {
+		pr_err("[%s]failed to get gamma parameter, rc=%d\n",
+		       display->name, rc);
+		goto error_disable_cmd_engine;
+	}
+
+error_disable_cmd_engine:
+	ret = dsi_display_cmd_engine_disable(display);
+	if (ret) {
+		pr_err("[%s]failed to disable DSI cmd engine, rc=%d\n",
+				display->name, ret);
+	}
+error_disable_clks:
+	ret = dsi_display_clk_ctrl(display->dsi_clk_handle,
+			DSI_ALL_CLKS, DSI_CLK_OFF);
+	if (ret) {
+		pr_err("[%s] failed to disable all DSI clocks, rc=%d\n",
+		       display->name, ret);
+	}
+unlock:
+	mutex_unlock(&panel->panel_lock);
+
+	return rc;
+}
+
+ssize_t dsi_panel_print_gamma_param(struct dsi_panel *panel,
+				char *buf)
+{
+	int i = 0;
+	ssize_t count = 0;
+	struct gamma_cfg *gamma_cfg;
+	u8 *buffer = NULL;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_err("gamma_update_flag is not configed\n");
+		return -EINVAL;
+	}
+
+	gamma_cfg = &panel->mi_cfg.gamma_cfg;
+	if (!gamma_cfg->read_done) {
+		pr_info("Gamma parameter not read at POWER ON sequence\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma 0xC8 OPT Read %d Parameter (60Hz)\n",
+				sizeof(gamma_cfg->otp_read_c8));
+	buffer = gamma_cfg->otp_read_c8;
+	for (i = 1; i <= sizeof(gamma_cfg->otp_read_c8); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->otp_read_c8))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->otp_read_c8[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->otp_read_c8[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma 0xC9 OPT Read %d Parameter (60Hz)\n",
+				sizeof(gamma_cfg->otp_read_c9));
+	buffer = gamma_cfg->otp_read_c9;
+	for (i = 1; i <= sizeof(gamma_cfg->otp_read_c9); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->otp_read_c9))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->otp_read_c9[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->otp_read_c9[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma 0xB3 OPT Read %d Parameter (60Hz)\n",
+				sizeof(gamma_cfg->otp_read_b3));
+	buffer = gamma_cfg->otp_read_b3;
+	for (i = 1; i <= sizeof(gamma_cfg->otp_read_b3); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->otp_read_b3))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->otp_read_b3[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->otp_read_b3[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma Flash 0xC8 Read %d Parameter (90Hz)\n",
+				sizeof(gamma_cfg->flash_read_c8));
+	buffer = gamma_cfg->flash_read_c8;
+	for (i = 1; i <= sizeof(gamma_cfg->flash_read_c8); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->flash_read_c8))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->flash_read_c8[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->flash_read_c8[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma Flash 0xC9 Read %d Parameter (90Hz)\n",
+				sizeof(gamma_cfg->flash_read_c9));
+	buffer = gamma_cfg->flash_read_c9;
+	for (i = 1; i <= sizeof(gamma_cfg->flash_read_c9); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->flash_read_c9))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->flash_read_c9[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->flash_read_c9[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma Flash 0xB3 Read %d Parameter (90Hz)\n",
+				sizeof(gamma_cfg->flash_read_b3));
+	buffer = gamma_cfg->flash_read_b3;
+	for (i = 1; i <= sizeof(gamma_cfg->flash_read_b3); i++) {
+		if (i%8 && (i != sizeof(gamma_cfg->flash_read_b3))) {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				gamma_cfg->flash_read_b3[i - 1]);
+		} else {
+			count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				gamma_cfg->flash_read_b3[i - 1]);
+		}
+	}
+
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma Flash Read Checksum Decimal(%d) (90Hz)\n",
+				((gamma_cfg->flash_read_checksum[0] << 8) +
+				gamma_cfg->flash_read_checksum[1]));
+	count += snprintf(buf + count, PAGE_SIZE - count,
+				"Gamma Flash Read 450 Parameter SUM(%d) (90Hz)\n",
+				gamma_cfg->gamma_checksum);
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+int dsi_panel_update_gamma_param(struct dsi_panel *panel)
+{
+	struct dsi_display *display;
+	struct dsi_display_mode *mode;
+	struct gamma_cfg *gamma_cfg;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 i, count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+	int rc;
+
+	if (!panel || !panel->host)
+		return -EINVAL;
+
+	display = to_dsi_display(panel->host);
+	if (!display)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_debug("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	gamma_cfg = &panel->mi_cfg.gamma_cfg;
+	if (!gamma_cfg->read_done) {
+		pr_err("gamma parameter not ready\n");
+		pr_err("gamma parameter should be read and stored at POWER ON sequence\n");
+		return -EAGAIN;
+	}
+
+	if (!display->modes) {
+		rc = dsi_display_get_modes(display, &mode);
+		if (rc) {
+			pr_err("failed to get display mode for update gamma parameter\n");
+			return rc;
+		}
+	}
+
+	memset(gamma_cmd_set, 0, 2 * sizeof(struct dsi_panel_cmd_set));
+
+	mutex_lock(&panel->panel_lock);
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		if (mode && mode->priv_info) {
+			if (60 == mode->timing.refresh_rate && !gamma_cfg->update_done_60hz) {
+				pr_info("Update GAMMA Parameter (60Hz)\n");
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].count;
+				if (cmds && count >= gamma_cfg->update_c8_index &&
+					count >= gamma_cfg->update_c9_index &&
+					count >= gamma_cfg->update_b3_index) {
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c8_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c8_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_c8), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_c8, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c9_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c9_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_c9), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_c9, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_b3_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_b3_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_b3), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_b3, param_len);
+
+					memcpy(&gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ],
+							&mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH],
+							sizeof(struct dsi_panel_cmd_set));
+
+					gamma_cfg->update_done_60hz = true;
+				} else {
+					pr_err("please check gamma update parameter index configuration\n");
+				}
+			}
+			if (90 == mode->timing.refresh_rate && !gamma_cfg->update_done_90hz) {
+				pr_info("Update GAMMA Parameter (90Hz)\n");
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].count;
+				if (cmds && count >= gamma_cfg->update_c8_index &&
+					count >= gamma_cfg->update_c9_index &&
+					count >= gamma_cfg->update_b3_index) {
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c8_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c8_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_c8), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_c8, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c9_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c9_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_c9), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_c9, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_b3_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_b3_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_b3), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_b3, param_len);
+
+					memcpy(&gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ],
+							&mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH],
+							sizeof(struct dsi_panel_cmd_set));
+
+					gamma_cfg->update_done_90hz = true;
+				} else {
+					pr_err("please check gamma update parameter index configuration\n");
+				}
+			}
+		}
+	}
+	mutex_unlock(&panel->panel_lock);
+
+	return 0;
+}
+
+int dsi_panel_read_dc_param(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_read_config dc_read;
+	struct dc_cfg *dc_cfg;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	int i, j;
+	int retry_cnt = 0;
+	u32 checksum1 = 0, checksum2 = 0;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	dc_cfg = &panel->mi_cfg.dc_cfg;
+	if (!panel->mi_cfg.dc_update_flag) {
+		pr_debug("dc_update_flag is not configed\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	for (retry_cnt = 0; retry_cnt < 5; retry_cnt++) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SWITCH_PAGE4);
+		if (rc) {
+			pr_err("Failed to send DSI_CMD_SET_MI_SWITCH_PAGE4 command\n");
+			retval = -EAGAIN;
+			goto error;
+		}
+
+		priv_info = panel->cur_mode->priv_info;
+		cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_DC_READ];
+		dc_read.read_cmd = *cmd_set;
+		dc_read.cmds_rlen = sizeof(dc_cfg->exit_dc_lut);
+		dc_read.is_read = 1;
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			memcpy(dc_cfg->exit_dc_lut, dc_read.rbuf, sizeof(dc_cfg->exit_dc_lut));
+			for(i = 0; i < sizeof(dc_cfg->exit_dc_lut); i++)
+				checksum1 += dc_cfg->exit_dc_lut[i];
+		}
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			for(i = 0; i < sizeof(dc_cfg->exit_dc_lut); i++)
+				checksum2 += dc_read.rbuf[i];
+		}
+
+		if (checksum1 == checksum2) {
+			dc_cfg->read_done = true;
+			break;
+		}
+	}
+
+	if (dc_cfg->read_done && (panel->mi_cfg.panel_id) != 0x4A315300420202) {
+		for (i = 0; i < sizeof(dc_cfg->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5) ; j++) {
+				dc_cfg->enter_dc_lut[j] = dc_cfg->exit_dc_lut[(i + 1) * 5 -1];
+			}
+		}
+		pr_info("[%s]DC parameter read done\n", panel->name);
+		retval = 0;
+	} else if ((panel->mi_cfg.panel_id) == 0x4A315300420202) {
+		for (i = 0; i < sizeof(dc_cfg->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5 - 1) ; j++) {
+				dc_cfg->enter_dc_lut[j] = dc_cfg->exit_dc_lut[(i + 1) * 5 -1];
+			}
+		}
+		pr_info("[%s]DC parameter read done\n", panel->name);
+		retval = 0;
+	} else {
+		pr_err("Failed to read DC parameter\n");
+		retval = -EAGAIN;
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_update_dc_param(struct dsi_panel *panel)
+{
+	struct dsi_display *display;
+	struct dsi_display_mode *mode;
+	struct dc_cfg *dc_cfg;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 i, count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+	int rc;
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (!display)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.dc_update_flag) {
+		pr_debug("dc_update_flag is not configed\n");
+		return 0;
+	}
+
+	dc_cfg = &panel->mi_cfg.dc_cfg;
+	if (!dc_cfg->read_done) {
+		pr_err("DC parameter not ready\n");
+		return -EAGAIN;
+	}
+
+	if (!display->modes) {
+		rc = dsi_display_get_modes(display, &mode);
+		if (rc) {
+			pr_err("failed to get display mode for update gamma parameter\n");
+			return rc;
+		}
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		if (mode && mode->priv_info) {
+			// J1S only update 120Hz fps DC mode parameter
+			if ((panel->mi_cfg.panel_id >> 8) == 0x4A3153004202) {
+				if (120 == mode->timing.refresh_rate ) {
+					cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].cmds;
+					count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].count;
+					if (cmds && count >= dc_cfg->update_d2_index) {
+						tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+						tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+						param_len = min(sizeof(dc_cfg->exit_dc_lut), tx_len - 1);
+						memcpy(&tx_buf[1], dc_cfg->exit_dc_lut, param_len);
+					} else {
+						pr_err("please check dc update parameter index configuration\n");
+					}
+
+					cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].cmds;
+					count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].count;
+					if (cmds && count >= dc_cfg->update_d2_index) {
+						tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+						tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+						param_len = min(sizeof(dc_cfg->enter_dc_lut), tx_len - 1);
+						memcpy(&tx_buf[1], dc_cfg->enter_dc_lut, param_len);
+					} else {
+						pr_err("please check dc update parameter index configuration\n");
+					}
+				}
+			} else {
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].count;
+				if (cmds && count >= dc_cfg->update_d2_index) {
+					tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+					tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+					param_len = min(sizeof(dc_cfg->exit_dc_lut), tx_len - 1);
+					memcpy(&tx_buf[1], dc_cfg->exit_dc_lut, param_len);
+				} else {
+					pr_err("please check dc update parameter index configuration\n");
+				}
+
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].count;
+				if (cmds && count >= dc_cfg->update_d2_index) {
+					tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+					tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+					param_len = min(sizeof(dc_cfg->enter_dc_lut), tx_len - 1);
+					memcpy(&tx_buf[1], dc_cfg->enter_dc_lut, param_len);
+				} else {
+					pr_err("please check dc update parameter index configuration\n");
+				}
+			}
+		}
+	}
+	dc_cfg->update_done = true;
+
+	mutex_unlock(&panel->panel_lock);
+
+	return 0;
+}
+
+int dsi_panel_switch_disp_rate_gpio(struct dsi_panel *panel)
+{
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display_mode *mode;
+
+	if (!panel || !panel->cur_mode)
+		return -EINVAL;
+
+	mi_cfg = &panel->mi_cfg;
+	mode = panel->cur_mode;
+
+	if (gpio_is_valid(mi_cfg->disp_rate_gpio)) {
+		if (60 == mode->timing.refresh_rate) {
+			gpio_set_value(mi_cfg->disp_rate_gpio, 1);
+		} else if (90 == mode->timing.refresh_rate) {
+			gpio_set_value(mi_cfg->disp_rate_gpio, 1);
+		} else {
+			pr_info("disp_rate gpio not change\n");
+		}
+	}
+	return 0;
+}
+
+int dsi_panel_write_gamma_cmd_set(struct dsi_panel *panel,
+				enum dsi_gamma_cmd_set_type type)
+{
+	int rc = 0, i = 0;
+	ssize_t len;
+	struct dsi_cmd_desc *cmds;
+	u32 count;
+	enum dsi_cmd_set_state state;
+	const struct mipi_dsi_host_ops *ops = panel->host->ops;
+
+	if (!panel)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_err("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	if (!panel->mi_cfg.gamma_cfg.update_done_60hz ||
+		!panel->mi_cfg.gamma_cfg.update_done_90hz) {
+		pr_err("gamma parameter not update\n");
+		return 0;
+	}
+
+	cmds = gamma_cmd_set[type].cmds;
+	count = gamma_cmd_set[type].count;
+	state = gamma_cmd_set[type].state;
+
+	if (!cmds || count == 0) {
+		pr_debug("[%s] No commands to be sent for state\n", panel->name);
+		goto error;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (state == DSI_CMD_SET_STATE_LP)
+			cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+
+		if (cmds->last_command)
+			cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+
+		len = ops->transfer(panel->host, &cmds->msg);
+		if (len < 0) {
+			rc = len;
+			pr_err("failed to set cmds, rc=%d\n", rc);
+			goto error;
+		}
+		if (cmds->post_wait_ms)
+			usleep_range(cmds->post_wait_ms * 1000,
+					((cmds->post_wait_ms * 1000) + 10));
+		cmds++;
+	}
+error:
+	return rc;
+}
+
+int dsi_panel_write_cmd_set(struct dsi_panel *panel,
+				struct dsi_panel_cmd_set *cmd_sets)
+{
+	int rc = 0, i = 0;
+	ssize_t len;
+	struct dsi_cmd_desc *cmds;
+	u32 count;
+	enum dsi_cmd_set_state state;
+	struct dsi_display_mode *mode;
+	const struct mipi_dsi_host_ops *ops = panel->host->ops;
+
+	if (!panel || !panel->cur_mode)
+		return -EINVAL;
+
+	mode = panel->cur_mode;
+
+	cmds = cmd_sets->cmds;
+	count = cmd_sets->count;
+	state = cmd_sets->state;
+
+	if (count == 0) {
+		pr_debug("[%s] No commands to be sent for state\n", panel->name);
+		goto error;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (state == DSI_CMD_SET_STATE_LP)
+			cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+
+		if (cmds->last_command)
+			cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+
+		len = ops->transfer(panel->host, &cmds->msg);
+		if (len < 0) {
+			rc = len;
+			pr_err("failed to set cmds, rc=%d\n", rc);
+			goto error;
+		}
+		if (cmds->post_wait_ms)
+			usleep_range(cmds->post_wait_ms * 1000,
+					((cmds->post_wait_ms * 1000) + 10));
+		cmds++;
+	}
+error:
+	return rc;
+}
+
+int dsi_panel_read_cmd_set(struct dsi_panel *panel,
+				struct dsi_read_config *read_config)
+{
+	struct mipi_dsi_host *host;
+	struct dsi_display *display;
+	struct dsi_display_ctrl *ctrl;
+	struct dsi_cmd_desc *cmds;
+	enum dsi_cmd_set_state state;
+	int i, rc = 0, count = 0;
+	u32 flags = 0;
+
+	if (panel == NULL || read_config == NULL)
+		return -EINVAL;
+
+	host = panel->host;
+	if (host) {
+		display = to_dsi_display(host);
+		if (display == NULL)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	if (!panel->panel_initialized) {
+		pr_info("Panel not initialized\n");
+		return -EINVAL;
+	}
+
+	if (!read_config->is_read) {
+		pr_info("read operation was not permitted\n");
+		return -EPERM;
+	}
+
+	dsi_display_clk_ctrl(display->dsi_clk_handle,
+		DSI_ALL_CLKS, DSI_CLK_ON);
+
+	ctrl = &display->ctrl[display->cmd_master_idx];
+
+	rc = dsi_display_cmd_engine_enable(display);
+	if (rc) {
+		pr_err("cmd engine enable failed\n");
+		rc = -EPERM;
+		goto exit_ctrl;
+	}
+
+	if (display->tx_cmd_buf == NULL) {
+		rc = dsi_host_alloc_cmd_tx_buffer(display);
+		if (rc) {
+			pr_err("failed to allocate cmd tx buffer memory\n");
+			goto exit;
+		}
+	}
+
+	count = read_config->read_cmd.count;
+	cmds = read_config->read_cmd.cmds;
+	state = read_config->read_cmd.state;
+	if (count == 0) {
+		pr_err("No commands to be sent\n");
+		goto exit;
+	}
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ |
+		  DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+
+	memset(read_config->rbuf, 0x0, sizeof(read_config->rbuf));
+	cmds->msg.rx_buf = read_config->rbuf;
+	cmds->msg.rx_len = read_config->cmds_rlen;
+
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &(cmds->msg), &flags);
+	if (rc <= 0) {
+		pr_err("rx cmd transfer failed rc=%d\n", rc);
+		goto exit;
+	}
+
+	/* for debug log */
+	for (i = 0; i < read_config->cmds_rlen; i++)
+		pr_debug("[%d] = 0x%02X\n", i, read_config->rbuf[i]);
+
+exit:
+	dsi_display_cmd_engine_disable(display);
+exit_ctrl:
+	dsi_display_clk_ctrl(display->dsi_clk_handle,
+		DSI_ALL_CLKS, DSI_CLK_OFF);
+
+	return rc;
+}
+
+int dsi_panel_write_mipi_reg(struct dsi_panel *panel,
+				char *buf)
+{
+	struct dsi_panel_cmd_set cmd_sets = {0};
+	int retval = 0, dlen = 0;
+	u32 packet_count = 0;
+	char *token, *input_copy, *input_dup = NULL;
+	const char *delim = " ";
+	char *buffer = NULL;
+	u32 buf_size = 0;
+	u32 tmp_data = 0;
+
+	mutex_lock(&panel->panel_lock);
+
+	if (!panel || !panel->panel_initialized) {
+		pr_err("Panel not initialized!\n");
+		retval = -EAGAIN;
+		goto exit_unlock;
+	}
+
+	pr_debug("input buffer:{%s}\n", buf);
+
+	input_copy = kstrdup(buf, GFP_KERNEL);
+	if (!input_copy) {
+		retval = -ENOMEM;
+		goto exit_unlock;
+	}
+
+	input_dup = input_copy;
+	/* removes leading and trailing whitespace from input_copy */
+	input_copy = strim(input_copy);
+
+	/* Split a string into token */
+	token = strsep(&input_copy, delim);
+	if (token) {
+		retval = kstrtoint(token, 10, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free0;
+		}
+		g_dsi_read_cfg.is_read= !!tmp_data;
+	}
+
+	/* Removes leading whitespace from input_copy */
+	if (input_copy)
+		input_copy = skip_spaces(input_copy);
+	else
+		goto exit_free0;
+
+	token = strsep(&input_copy, delim);
+	if (token) {
+		retval = kstrtoint(token, 10, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free0;
+		}
+		if (tmp_data > sizeof(g_dsi_read_cfg.rbuf)) {
+			pr_err("read size exceeding the limit %d\n",
+					sizeof(g_dsi_read_cfg.rbuf));
+			goto exit_free0;
+		}
+		g_dsi_read_cfg.cmds_rlen = tmp_data;
+	}
+
+	/* Removes leading whitespace from input_copy */
+	if (input_copy)
+		input_copy = skip_spaces(input_copy);
+	else
+		goto exit_free0;
+
+	buffer = kzalloc(strlen(input_copy), GFP_KERNEL);
+	if (!buffer) {
+		retval = -ENOMEM;
+		goto exit_free0;
+	}
+
+	token = strsep(&input_copy, delim);
+	while (token) {
+		retval = kstrtoint(token, 16, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free1;
+		}
+		pr_debug("buffer[%d] = 0x%02x\n", buf_size, tmp_data);
+		buffer[buf_size++] = (tmp_data & 0xff);
+		/* Removes leading whitespace from input_copy */
+		if (input_copy) {
+			input_copy = skip_spaces(input_copy);
+			token = strsep(&input_copy, delim);
+		} else {
+			token = NULL;
+		}
+	}
+
+	retval = dsi_panel_get_cmd_pkt_count(buffer, buf_size, &packet_count);
+	if (!packet_count) {
+		pr_err("get pkt count failed!\n");
+		goto exit_free1;
+	}
+
+	retval = dsi_panel_alloc_cmd_packets(&cmd_sets, packet_count);
+	if (retval) {
+		pr_err("failed to allocate cmd packets, ret=%d\n", retval);
+		goto exit_free1;
+	}
+
+	retval = dsi_panel_create_cmd_packets(buffer, dlen, packet_count,
+						  cmd_sets.cmds);
+	if (retval) {
+		pr_err("failed to create cmd packets, ret=%d\n", retval);
+		goto exit_free2;
+	}
+
+	if (g_dsi_read_cfg.is_read) {
+		g_dsi_read_cfg.read_cmd = cmd_sets;
+		retval = dsi_panel_read_cmd_set(panel, &g_dsi_read_cfg);
+		if (retval <= 0) {
+			pr_err("[%s]failed to read cmds, rc=%d\n", panel->name, retval);
+			goto exit_free3;
+		}
+	} else {
+		g_dsi_read_cfg.read_cmd = cmd_sets;
+		retval = dsi_panel_write_cmd_set(panel, &cmd_sets);
+		if (retval) {
+			pr_err("[%s] failed to send cmds, rc=%d\n", panel->name, retval);
+			goto exit_free3;
+		}
+	}
+
+	pr_debug("[%s]: done!\n", panel->name);
+	retval = 0;
+
+exit_free3:
+	dsi_panel_destroy_cmd_packets(&cmd_sets);
+exit_free2:
+	dsi_panel_dealloc_cmd_packets(&cmd_sets);
+exit_free1:
+	kfree(buffer);
+exit_free0:
+	kfree(input_dup);
+exit_unlock:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+ssize_t dsi_panel_read_mipi_reg(struct dsi_panel *panel, char *buf)
+{
+	int i = 0;
+	ssize_t count = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (g_dsi_read_cfg.is_read) {
+		for (i = 0; i < g_dsi_read_cfg.cmds_rlen; i++) {
+			if (i == g_dsi_read_cfg.cmds_rlen - 1) {
+				count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				     g_dsi_read_cfg.rbuf[i]);
+			} else {
+				count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				     g_dsi_read_cfg.rbuf[i]);
+			}
+		}
+	}
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+ssize_t dsi_panel_read_wp_info(struct dsi_panel *panel, char *buf)
+{
+	int rc = 0;
+	int i = 0;
+	ssize_t count = 0;
+	struct dsi_read_config wp_read_config;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_WHITE_POINT_READ];
+	wp_read_config.read_cmd = *cmd_set;
+	wp_read_config.cmds_rlen = panel->mi_cfg.wp_reg_read_len;
+	wp_read_config.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &wp_read_config);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read wp_info, rc=%d\n", panel->name, rc);
+		count = -EAGAIN;
+	} else {
+		for (i = 0; i < panel->mi_cfg.wp_info_len; i++) {
+			if (i == panel->mi_cfg.wp_info_len - 1) {
+				count += snprintf(buf + count, PAGE_SIZE - count, "%02x\n",
+					 wp_read_config.rbuf[panel->mi_cfg.wp_info_index + i]);
+			} else {
+				count += snprintf(buf + count, PAGE_SIZE - count, "%02x",
+					wp_read_config.rbuf[panel->mi_cfg.wp_info_index + i]);
+			}
+		}
+	}
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+int dsi_panel_set_doze_brightness(struct dsi_panel *panel,
+			int doze_brightness, bool need_panel_lock)
+{
+	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display *display;
+	int cmd_type = DSI_CMD_SET_MAX;
+	const char *doze_brightness_str[] = {
+		[DOZE_TO_NORMAL] = "DOZE_TO_NORMAL",
+		[DOZE_BRIGHTNESS_HBM] = "DOZE_BRIGHTNESS_HBM",
+		[DOZE_BRIGHTNESS_LBM] = "DOZE_BRIGHTNESS_LBM",
+	};
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (!display || !display->drm_dev){
+		pr_err("invalid display or drm_dev ptr\n");
+		return -EINVAL;
+	}
+
+	if (need_panel_lock)
+		mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+
+	if (!panel->panel_initialized) {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		pr_info("Panel not initialized! save unset_doze_brightness = %s\n",
+				doze_brightness_str[mi_cfg->unset_doze_brightness]);
+		goto exit;
+	}
+
+	if (mi_cfg->fod_hbm_enabled) {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		if (mi_cfg->unset_doze_brightness == DOZE_TO_NORMAL) {
+			mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		pr_info("fod_hbm_enabled set, save unset_doze_brightness = %s\n",
+				doze_brightness_str[mi_cfg->unset_doze_brightness]);
+		goto exit;
+	}
+
+	if (mi_cfg->in_aod) {
+		if (mi_cfg->doze_brightness_state != doze_brightness ||
+			mi_cfg->unset_doze_brightness != DOZE_TO_NORMAL) {
+			if (mi_cfg->into_aod_pending &&
+				!mi_cfg->layer_aod_flag &&
+				doze_brightness != DOZE_TO_NORMAL) {
+				/* After unlocking the fingerprint, request to enter aod mode,
+				 *but there is no aod layer, skip to set doze brightness */
+				pr_info("aod layer is not ready, skip to set doze brightness\n");
+				rc = -EAGAIN;
+			} else {
+				if (doze_brightness == DOZE_BRIGHTNESS_HBM ||
+					mi_cfg->unset_doze_brightness == DOZE_BRIGHTNESS_HBM) {
+					cmd_type = DSI_CMD_SET_MI_DOZE_HBM;
+					mi_cfg->aod_backlight = 170;
+				} else if (doze_brightness == DOZE_BRIGHTNESS_LBM ||
+					mi_cfg->unset_doze_brightness == DOZE_BRIGHTNESS_LBM) {
+					cmd_type = DSI_CMD_SET_MI_DOZE_LBM;
+					mi_cfg->aod_backlight = 10;
+				}
+			}
+			if (cmd_type != DSI_CMD_SET_MAX) {
+				if (sde_kms_is_suspend_blocked(display->drm_dev)) {
+					pr_err("sde_kms is suspended, skip to set doze brightness\n");
+					mi_cfg->unset_doze_brightness = doze_brightness;
+					rc = -EBUSY;
+					goto exit;
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, cmd_type);
+					if (rc) {
+						pr_err("[%s] failed to send DSI_CMD_SET_MI_DOZE_%s cmd, rc=%d\n",
+							panel->name, cmd_type == DSI_CMD_SET_MI_DOZE_HBM ? "HBM" : "LBM", rc);
+					}
+				}
+			}
+
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+			mi_cfg->unset_doze_brightness = DOZE_TO_NORMAL;
+			mi_cfg->doze_brightness_state = doze_brightness;
+			if (display->drm_conn && display->drm_conn->kdev)
+				sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "doze_brightness");
+			pr_info("set doze brightness to %s\n", doze_brightness_str[doze_brightness]);
+		} else {
+			pr_info("%s has been set, skip\n", doze_brightness_str[doze_brightness]);
+		}
+	} else {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		if (mi_cfg->unset_doze_brightness != DOZE_TO_NORMAL)
+			pr_info("Not in Doze mode! save unset_doze_brightness = %s\n",
+					doze_brightness_str[mi_cfg->unset_doze_brightness]);
+	}
+
+exit:
+	if (need_panel_lock)
+		mutex_unlock(&panel->panel_lock);
+
+	return rc;
+}
+
+ssize_t dsi_panel_get_doze_brightness(struct dsi_panel *panel, char *buf)
+{
+	ssize_t count = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+	count = snprintf(buf, PAGE_SIZE, "%d\n", mi_cfg->doze_brightness_state);
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+ssize_t dsi_panel_lockdown_info_read(unsigned char *plockdowninfo)
+{
+	int rc = 0;
+	int i = 0;
+	struct dsi_read_config ld_read_config;
+	struct dsi_panel_cmd_set cmd_sets = {0};
+
+	if (!g_panel || !plockdowninfo) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	while(!g_panel->cur_mode || !g_panel->cur_mode->priv_info || !g_panel->panel_initialized) {
+		pr_debug("[%s][%s] waitting for panel priv_info initialized!\n", __func__, g_panel->name);
+		msleep_interruptible(1000);
+	}
+
+	mutex_lock(&g_panel->panel_lock);
+	if (g_panel->cur_mode->priv_info->cmd_sets[DSI_CMD_SET_MI_READ_LOCKDOWN_INFO].cmds) {
+		cmd_sets.cmds = g_panel->cur_mode->priv_info->cmd_sets[DSI_CMD_SET_MI_READ_LOCKDOWN_INFO].cmds;
+		cmd_sets.count = 1;
+		cmd_sets.state = g_panel->cur_mode->priv_info->cmd_sets[DSI_CMD_SET_MI_READ_LOCKDOWN_INFO].state;
+		rc = dsi_panel_write_cmd_set(g_panel, &cmd_sets);
+		if (rc) {
+			pr_err("[%s][%s] failed to send cmds, rc=%d\n", __func__, g_panel->name, rc);
+			rc = -EIO;
+			goto done;
+		}
+
+		ld_read_config.is_read = 1;
+		ld_read_config.cmds_rlen = 8;
+		ld_read_config.read_cmd = cmd_sets;
+		ld_read_config.read_cmd.cmds = &cmd_sets.cmds[1];
+		rc = dsi_panel_read_cmd_set(g_panel, &ld_read_config);
+		if (rc <= 0) {
+			pr_err("[%s][%s] failed to read cmds, rc=%d\n", __func__, g_panel->name, rc);
+			rc = -EIO;
+			goto done;
+		}
+
+		for(i = 0; i < 8; i++) {
+			pr_info("[%s][%d]0x%x", __func__, __LINE__, ld_read_config.rbuf[i]);
+			plockdowninfo[i] = ld_read_config.rbuf[i];
+		}
+
+		if (!strcmp(g_panel->name,"xiaomi 37 02 0b video mode dsc dsi panel")) {
+			plockdowninfo[7] = 0x01;
+			pr_info("[%s] plockdowninfo[7] = 0x%d \n", __func__, plockdowninfo[7]);
+		}
+	}
+
+done:
+	mutex_unlock(&g_panel->panel_lock);
+	return rc;
+}
+EXPORT_SYMBOL(dsi_panel_lockdown_info_read);
+
+int dsi_panel_set_thermal_hbm_disabled(struct dsi_panel *panel,
+			bool thermal_hbm_disabled)
+{
+	struct dsi_panel_mi_cfg *mi_cfg;
+	int ret = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+
+	display_utc_time_marker("thermal_hbm_disabled = %d, hbm_enabled = %d\n",
+			thermal_hbm_disabled, mi_cfg->hbm_enabled);
+
+	if (thermal_hbm_disabled) {
+		dsi_panel_set_disp_param(panel, DISPPARAM_SET_THERMAL_HBM_DISABLE);
+		if (mi_cfg->hbm_enabled && panel->panel_initialized) {
+			dsi_panel_set_disp_param(panel, DISPPARAM_HBM_OFF | DISPPARAM_THERMAL_SET);
+			if (mi_cfg->hbm_brightness)
+				ret = dsi_panel_update_backlight(panel, 2047);
+		}
+	} else {
+		dsi_panel_set_disp_param(panel, DISPPARAM_CLEAR_THERMAL_HBM_DISABLE);
+		if (mi_cfg->hbm_enabled && panel->panel_initialized) {
+			dsi_panel_set_disp_param(panel, DISPPARAM_HBM_ON | DISPPARAM_THERMAL_SET);
+			if (mi_cfg->hbm_brightness)
+				ret = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+		}
+	}
+
+	return ret;
+}
+
+
+int dsi_panel_get_thermal_hbm_disabled(struct dsi_panel *panel,
+			bool *thermal_hbm_disabled)
+{
+	ssize_t count = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+	*thermal_hbm_disabled = mi_cfg->thermal_hbm_disabled;
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+
+struct calc_hw_vsync *get_hw_calc_vsync_struct(int dsi_display_type)
+{
+	if (dsi_display_type == DSI_PRIMARY)
+		return &g_calc_hw_vsync[DSI_PRIMARY];
+	else if (dsi_display_type == DSI_SECONDARY)
+		return &g_calc_hw_vsync[DSI_SECONDARY];
+	else
+		return NULL;
+}
+
+ssize_t calc_hw_vsync_info(struct dsi_panel *panel, char *buf)
+{
+	struct calc_hw_vsync *calc_vsync;
+	ktime_t current_time;
+	u64 diff_us;
+	int i,index;
+	u32 fps;
+	u64 total_vsync_period_ns = 0;
+	u32 count = 0;
+	u64 valid_total_vsync_period_ns = 0;
+	u32 valid_count = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	if (!strcmp(panel->type, "primary"))
+		calc_vsync = &g_calc_hw_vsync[DSI_PRIMARY];
+	else
+		calc_vsync = &g_calc_hw_vsync[DSI_SECONDARY];
+
+	index = (calc_vsync->vsync_count == 0) ?
+			(MAX_VSYNC_COUNT - 1) : (calc_vsync->vsync_count -1);
+	fps = calc_vsync->vsyc_info[index].config_fps;
+
+	current_time = ktime_get();
+
+	for (i = 0; i < MAX_VSYNC_COUNT; i++) {
+		if (fps == calc_vsync->vsyc_info[index].config_fps) {
+			diff_us = (u64)ktime_us_delta(current_time,
+					calc_vsync->vsyc_info[index].timestamp);
+			if (diff_us <= USEC_PER_SEC) {
+				valid_total_vsync_period_ns +=
+					calc_vsync->vsyc_info[index].real_vsync_period_ns;
+				valid_count++;
+			}
+			total_vsync_period_ns +=
+					calc_vsync->vsyc_info[index].real_vsync_period_ns;
+			count++;
+		}
+		index = (index == 0) ? (MAX_VSYNC_COUNT - 1) : (index - 1);
+	}
+
+	if (valid_count && valid_count > fps / 4) {
+		calc_vsync->measured_vsync_period_ns =
+				valid_total_vsync_period_ns / valid_count;
+	} else {
+		calc_vsync->measured_vsync_period_ns =
+				total_vsync_period_ns / count;
+	}
+
+	/* Multiplying with 1000 to get fps in floating point */
+	calc_vsync->measured_fps_x1000 =
+			(u32)((NSEC_PER_SEC * 1000) / calc_vsync->measured_vsync_period_ns);
+	pr_info("[hw_vsync_info]fps: %d.%d, vsync_period_ns:%lld,"
+			" panel_mode:%s, panel_type:%s, average of %d statistics\n",
+			calc_vsync->measured_fps_x1000 / 1000,
+			calc_vsync->measured_fps_x1000 % 1000,
+			calc_vsync->measured_vsync_period_ns,
+			(panel->panel_mode == DSI_OP_VIDEO_MODE) ? "dsi_video" : "dsi_cmd",
+			panel->type, valid_count ? valid_count : count);
+
+	return scnprintf(buf, PAGE_SIZE, "fps: %d.%d vsync_period_ns:%lld"
+			" panel_mode:%s panel_type:%s\n",
+			calc_vsync->measured_fps_x1000 / 1000,
+			calc_vsync->measured_fps_x1000 % 1000,
+			calc_vsync->measured_vsync_period_ns,
+			(panel->panel_mode == DSI_OP_VIDEO_MODE) ? "dsi_video" : "dsi_cmd",
+			panel->type);
+}
+
+int dsi_panel_set_disp_param(struct dsi_panel *panel, u32 param)
+{
+	int rc = 0;
+	uint32_t temp = 0;
+	u32 fod_backlight = 0;
+	struct dsi_panel_mi_cfg *mi_cfg  = NULL;
+	struct dsi_cmd_desc *cmds = NULL;
+	struct dsi_display_mode_priv_info *priv_info;
+	static u8 backlight_delta = 0;
+	u32 resend_backlight;
+	u32 count;
+	u8 *tx_buf;
+	bool is_thermal_call = false;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+	if (!mi_cfg->mi_feature_enabled) {
+		pr_err("mi feature not enable, exit!\n");
+		goto exit;
+	}
+
+	display_utc_time_marker("param_type = 0x%X", param);
+
+	if (!panel->panel_initialized
+		&& (param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_ON
+		&& (param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_OFF
+		&& param != DISPPARAM_FOD_UNLOCK_SUCCESS
+		&& param != DISPPARAM_FOD_UNLOCK_FAIL
+		&& param != DISPPARAM_SET_THERMAL_HBM_DISABLE
+		&& param != DISPPARAM_CLEAR_THERMAL_HBM_DISABLE) {
+		pr_err("Panel not initialized!\n");
+		goto exit;
+	}
+
+	/* cur_mode ptr assignment in dsi_display_set_mode func after open drm node */
+	if (panel->cur_mode)
+		priv_info = panel->cur_mode->priv_info;
+	else
+		priv_info = NULL;
+
+	if ((param & 0x00F00000) == 0xD00000) {
+		fod_backlight = (param & 0x01FFF);
+		param = (param & 0x0FF00000);
+	}
+
+	/* set smart fps status */
+	if (param & 0xF0000000) {
+		fm_stat.enabled = param & 0x01;
+		pr_info("smart dfps enable = [%d]\n", fm_stat.enabled);
+	}
+
+	temp = param & 0x000000F0;
+	switch (temp) {
+	case DISPPARAM_CE_ON:
+		pr_info("ceon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CEON);
+		break;
+	case DISPPARAM_CE_OFF:
+		pr_info("ceoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CEOFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x00000F00;
+	switch (temp) {
+	case DISPPARAM_CABCUI_ON:
+		pr_info("cabcuion\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCUION);
+		break;
+	case DISPPARAM_CABCSTILL_ON:
+		pr_info("cabcstillon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCSTILLON);
+		break;
+	case DISPPARAM_CABCMOVIE_ON:
+		pr_info("cabcmovieon\n");
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCMOVIEON);
+		break;
+	case DISPPARAM_CABC_OFF:
+		pr_info("cabcoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCOFF);
+		break;
+	case DISPPARAM_SKIN_CE_CABCUI_ON:
+		pr_info("skince cabcuion\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCUION);
+		break;
+	case DISPPARAM_SKIN_CE_CABCSTILL_ON:
+		pr_info("skince cabcstillon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCSTILLON);
+		break;
+	case DISPPARAM_SKIN_CE_CABCMOVIE_ON:
+		pr_info("skince cabcmovieon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCMOVIEON);
+		break;
+	case DISPPARAM_SKIN_CE_CABC_OFF:
+		pr_info("skince cabcoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCOFF);
+		break;
+	case DISPPARAM_DIMMING_OFF:
+		if (mi_cfg->dimming_state != STATE_DIM_BLOCK) {
+			pr_info("dimming off\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+		} else {
+			pr_info("skip dimming off due to hbm on\n");
+		}
+		break;
+	case DISPPARAM_DIMMING:
+		if (mi_cfg->dimming_state != STATE_DIM_BLOCK) {
+			if (ktime_after(ktime_get(), mi_cfg->fod_hbm_off_time)
+				&& ktime_after(ktime_get(), mi_cfg->fod_backlight_off_time)) {
+				pr_info("dimming on\n");
+				dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGON);
+			} else {
+				pr_info("skip dimming on due to hbm off\n");
+			}
+		} else {
+			pr_info("skip dimming on due to hbm on\n");
+		}
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x0000F000;
+	switch (temp) {
+	case DISPPARAM_ACL_L1:
+		pr_info("acl level 1\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L1);
+		break;
+	case DISPPARAM_ACL_L2:
+		pr_info("acl level 2\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L2);
+		break;
+	case DISPPARAM_ACL_L3:
+		pr_info("acl level 3\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L3);
+		break;
+	case DISPPARAM_ACL_OFF:
+		pr_info("acl off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_OFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x000F0000;
+	switch (temp) {
+	case DISPPARAM_LCD_HBM_L1_ON:
+		pr_info("lcd hbm l1 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L1_ON);
+		break;
+	case DISPPARAM_LCD_HBM_L2_ON:
+		pr_info("lcd hbm  l2 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L2_ON);
+		break;
+	case DISPPARAM_LCD_HBM_L3_ON:
+		pr_info("lcd hbm  l3 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L3_ON);
+		break;
+	case DISPPARAM_LCD_HBM_OFF:
+		pr_info("lcd hbm off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_OFF);
+		break;
+	case DISPPARAM_HBM_ON:
+		if (param & DISPPARAM_THERMAL_SET)
+			is_thermal_call = true;
+		pr_info("hbm on, thermal_hbm_disabled = %d\n", mi_cfg->thermal_hbm_disabled);
+		if (!mi_cfg->fod_hbm_enabled && !mi_cfg->thermal_hbm_disabled)
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_ON);
+		if (is_thermal_call) {
+			pr_info("thermal clear hbm limit, restore previous hbm on\n");
+		} else {
+			mi_cfg->hbm_enabled = true;
+		}
+		mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		break;
+	case DISPPARAM_HBM_OFF:
+		if (param & DISPPARAM_THERMAL_SET)
+			is_thermal_call = true;
+		pr_info("hbm off\n");
+		if (!mi_cfg->fod_hbm_enabled) {
+			if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+				/* restore last backlight value when hbm off */
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_OFF].count;
+				if (cmds && count >= mi_cfg->hbm_off_51_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->hbm_off_51_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0x51) {
+						tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+						tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+					} else {
+						if (tx_buf)
+							pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+						else
+							pr_err("tx_buf is NULL pointer\n");
+					}
+				} else {
+					pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+				}
+			}
+			if (mi_cfg->vi_setting_enabled) {
+				/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+				if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+				}
+			}
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_OFF);
+			mi_cfg->dimming_state = STATE_DIM_RESTORE;
+		}
+		if (is_thermal_call) {
+			pr_info("thermal set hbm limit, hbm off\n");
+		} else {
+			mi_cfg->hbm_enabled = false;
+		}
+		break;
+	case DISPPARAM_HBM_HDR_ON:
+		pr_info("hbm hdr on\n");
+		if (!mi_cfg->fod_hbm_enabled && !mi_cfg->thermal_hbm_disabled)
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_HDR_ON);
+		mi_cfg->hbm_enabled = true;
+		mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		break;
+	case DISPPARAM_HBM_HDR_OFF:
+		pr_info("hbm hdr off\n");
+		if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+			/* restore last backlight value when hbm off */
+			cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_HDR_OFF].cmds;
+			count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_HDR_OFF].count;
+			if (cmds && count >= mi_cfg->hbm_off_51_index) {
+				tx_buf = (u8 *)cmds[mi_cfg->hbm_off_51_index].msg.tx_buf;
+				if (tx_buf && tx_buf[0] == 0x51) {
+					tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+					tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+					pr_info("DSI_CMD_SET_MI_HBM_HDR_OFF 0x%02X = 0x%02X 0x%02X\n",
+							tx_buf[0], tx_buf[1], tx_buf[2]);
+				} else {
+					if (tx_buf)
+						pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+					else
+						pr_err("tx_buf is NULL pointer\n");
+				}
+			} else {
+				pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+			}
+		}
+		if (mi_cfg->vi_setting_enabled) {
+			/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+			if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+			} else {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+			}
+		}
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_HDR_OFF);
+		mi_cfg->dimming_state = STATE_DIM_RESTORE;
+		mi_cfg->hbm_enabled = false;
+		break;
+	case DISPPARAM_HBM_FOD_ON:
+		pr_info("hbm fod on\n");
+		cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+		if (mi_cfg->fod_on_b2_index && priv_info &&
+			((mi_cfg->panel_id >> 8) == 0x4A32004202 ||
+			(mi_cfg->panel_id >> 8) == 0x4A3153004202)) {
+			pr_info("Fod on b2 index is enabled\n");
+			cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].cmds;
+			count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].count;
+			if (cmds && count >= mi_cfg->fod_on_b2_index + 2) {
+				tx_buf = (u8 *)cmds[mi_cfg->fod_on_b2_index].msg.tx_buf;
+				/* 0xB2(0) reg: if DC on (0xC8); if DC off (0x58) */
+				if (tx_buf && tx_buf[0] == 0xB2) {
+					if (mi_cfg->dc_enable) {
+						tx_buf[1] = 0xC8;
+					} else {
+						tx_buf[1] = 0x58;
+					}
+					pr_info("DSI_CMD_SET_MI_HBM_FOD_ON 0x%02X(9) = 0x%02X\n", tx_buf[0], tx_buf[1]);
+				} else {
+					if (tx_buf)
+						pr_err("tx_buf[0] = 0x%02X, check 0xB2 index\n", tx_buf[0]);
+					else
+						pr_err("tx_buf is NULL pointer\n");
+				}
+				tx_buf = (u8 *)cmds[mi_cfg->fod_on_b2_index + 2].msg.tx_buf;
+				/* 0xB2(9) reg: if DC on use 1 Pulse(0x00); if DC off use 4 Pulse(0x20) */
+				if (tx_buf && tx_buf[0] == 0xB2) {
+					if (mi_cfg->dc_enable) {
+						tx_buf[1] = 0x00;
+					} else {
+						tx_buf[1] = 0x20;
+					}
+					pr_info("DSI_CMD_SET_MI_HBM_FOD_ON 0x%02X(9) = 0x%02X\n", tx_buf[0], tx_buf[1]);
+				} else {
+					if (tx_buf)
+						pr_err("tx_buf[0] = 0x%02X, check 0xB2 index\n", tx_buf[0]);
+					else
+						pr_err("tx_buf is NULL pointer\n");
+				}
+			} else {
+				pr_err("0xB2 index(%d) error\n", mi_cfg->fod_on_b2_index);
+			}
+		}
+
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_ON);
+
+		if (mi_cfg->dc_type == 1)
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+		mi_cfg->fod_hbm_enabled = true;
+		mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		break;
+	case DISPPARAM_HBM_FOD2NORM:
+		pr_info("hbm fod to normal mode\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD2NORM);
+		break;
+	case DISPPARAM_HBM_FOD_OFF:
+		pr_info("hbm fod off\n");
+		if (!mi_cfg->hbm_enabled) {
+			if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+				/* restore last backlight value when fod off */
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+				if (cmds && count >= mi_cfg->fod_off_51_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->fod_off_51_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0x51) {
+						tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+						tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+						pr_info("DSI_CMD_SET_MI_HBM_FOD_OFF 0x%02X = 0x%02X 0x%02X\n",
+							tx_buf[0], tx_buf[1], tx_buf[2]);
+					} else {
+						if (tx_buf)
+							pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+						else
+							pr_err("tx_buf is NULL pointer\n");
+					}
+				} else {
+					pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+				}
+			}
+			if (mi_cfg->dc_type == 0 && mi_cfg->fod_off_b5_index && priv_info) {
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+				if (cmds && count >= mi_cfg->fod_off_b5_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->fod_off_b5_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0xb5) {
+						if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+							panel->power_mode == SDE_MODE_DPMS_LP2) {
+							pr_info("Fod off to aod set elvss swire to -3.0V\n");
+							tx_buf[1] = 0x19;
+						} else if (panel->power_mode == SDE_MODE_DPMS_ON) {
+							pr_info("Fod off to normal set elvss swire to -4.5V\n");
+							tx_buf[1] = 0x0A;
+						}
+					}
+				}
+			}
+			if (mi_cfg->vi_setting_enabled) {
+				/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+				if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+				}
+			}
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+			mi_cfg->dimming_state = STATE_DIM_RESTORE;
+		} else {
+			if (mi_cfg->thermal_hbm_disabled) {
+				pr_info("thermal set hbm limit, do not recovery hbm on\n");
+			} else {
+				pr_info("recovery hbm on mode\n");
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_ON);
+				if (mi_cfg->hbm_brightness)
+					rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+			}
+		}
+		if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_AOD_TO_DC_ON);
+			if (rc)
+				pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+					panel->name, rc);
+		}
+		mi_cfg->fod_hbm_enabled = false;
+		mi_cfg->fod_hbm_off_time = ktime_add_ms(ktime_get(),
+				mi_cfg->fod_off_dimming_delay);
+
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+				panel->power_mode == SDE_MODE_DPMS_LP2) {
+			if (mi_cfg->layer_fod_unlock_success || mi_cfg->sysfs_fod_unlock_success) {
+				pr_info("[%d,%d]Fod fingerprint unlock success, skip into aod mode\n",
+					mi_cfg->layer_fod_unlock_success, mi_cfg->sysfs_fod_unlock_success);
+			} else {
+				pr_info("delayed_work schedule --- delay enter aod mode\n");
+				mi_cfg->into_aod_pending = true;
+				__pm_wakeup_event(mi_cfg->aod_wakelock, DEFAULT_FOD_OFF_ENTER_AOD_DELAY + 100);
+				schedule_delayed_work(&mi_cfg->enter_aod_delayed_work,
+					msecs_to_jiffies(DEFAULT_FOD_OFF_ENTER_AOD_DELAY));
+			}
+		}
+		break;
+	case DISPPARAM_FOD_UNLOCK_SUCCESS:
+		pr_info("Fod fingerprint unlock success\n");
+		mi_cfg->sysfs_fod_unlock_success = true;
+		mi_cfg->into_aod_pending = false;
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+			panel->power_mode == SDE_MODE_DPMS_LP2) {
+			cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+		}
+		break;
+	case DISPPARAM_FOD_UNLOCK_FAIL:
+		pr_info("Fod fingerprint unlock fail\n");
+		mi_cfg->sysfs_fod_unlock_success = false;
+		mi_cfg->into_aod_pending = false;
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+				panel->power_mode == SDE_MODE_DPMS_LP2) {
+			cancel_delayed_work_sync(&mi_cfg->enter_aod_delayed_work);
+			if (mi_cfg->layer_fod_unlock_success) {
+				pr_info("layer_fod_unlock_success is true, skip into aod mode\n");
+			} else {
+				if (!mi_cfg->unset_doze_brightness)
+					mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+				dsi_panel_set_doze_brightness(panel, mi_cfg->unset_doze_brightness, false);
+			}
+		}
+		break;
+	case DISPPARAM_DC_ON:
+		pr_info("DC on\n");
+		if (mi_cfg->dc_type == 0) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+			if (rc)
+				pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+						panel->name, rc);
+			else
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+		}
+		mi_cfg->dc_enable = true;
+		break;
+	case DISPPARAM_DC_OFF:
+		pr_info("DC off\n");
+		if (mi_cfg->dc_type == 0) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_OFF);
+			if (rc)
+				pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_OFF cmd, rc=%d\n",
+						panel->name, rc);
+			else
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+		}
+		mi_cfg->dc_enable = false;
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x00F00000;
+	switch (temp) {
+	case DISPPARAM_NORMALMODE1:
+		pr_info("normal mode1\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_NORMAL1);
+		break;
+	case DISPPARAM_P3:
+		pr_info("dci p3 mode\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_DCIP3);
+		break;
+	case DISPPARAM_SRGB:
+		pr_info("sRGB\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SRGB);
+		break;
+	case DISPPARAM_DOZE_BRIGHTNESS_HBM:
+		if (mi_cfg->in_aod) {
+			pr_info("doze hbm On\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DOZE_HBM);
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		break;
+	case DISPPARAM_DOZE_BRIGHTNESS_LBM:
+		if (mi_cfg->in_aod) {
+			pr_info("doze lbm On\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DOZE_LBM);
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		break;
+	case DISPPARAM_DOZE_OFF:
+		pr_info("doze Off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_NOLP);
+		break;
+	case DISPPARAM_HBM_BACKLIGHT_RESEND:
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGON);
+		backlight_delta++;
+		if (mi_cfg->last_bl_level >= panel->bl_config.bl_max_level - 1)
+			resend_backlight = mi_cfg->last_bl_level -
+				((backlight_delta%2 == 0) ? 1 : 2);
+		else
+			resend_backlight = mi_cfg->last_bl_level +
+				((backlight_delta%2 == 0) ? 1 : 2);
+
+		pr_info("backlight resend: last_bl_level = %d; resend_backlight = %d\n",
+				mi_cfg->last_bl_level, resend_backlight);
+		rc = dsi_panel_update_backlight(panel, resend_backlight);
+		break;
+	case DISPPARAM_FOD_BACKLIGHT:
+		if (fod_backlight == 0x1000) {
+			pr_info("FOD backlight restore last_bl_level=%d\n",
+				mi_cfg->last_bl_level);
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+			if (mi_cfg->dc_enable && mi_cfg->dc_type) {
+				pr_info("FOD backlight restore dc_threshold=%d",
+				mi_cfg->dc_threshold);
+				rc = dsi_panel_update_backlight(panel, mi_cfg->dc_threshold);
+			} else {
+				pr_info("FOD backlight restore last_bl_level=%d",
+				mi_cfg->last_bl_level);
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+			}
+		} else if (fod_backlight >= 0) {
+			pr_info("FOD backlight set");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+			rc = dsi_panel_update_backlight(panel, fod_backlight);
+			mi_cfg->fod_target_backlight = fod_backlight;
+			mi_cfg->dimming_state = STATE_NONE;
+		}
+		break;
+	case DISPPARAM_CRC_OFF:
+		pr_info("crc off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x0F000000;
+	switch (temp) {
+	case DISPPARAM_FOD_BACKLIGHT_ON:
+		pr_info("fod_backlight_flag on\n");
+		mi_cfg->fod_backlight_flag = true;
+		break;
+	case DISPPARAM_FOD_BACKLIGHT_OFF:
+		pr_info("fod_backlight_flag off\n");
+		mi_cfg->fod_backlight_flag = false;
+		break;
+	case DISPPARAM_ELVSS_DIMMING_ON:
+		pr_info("elvss dimming on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFF);
+		break;
+	case DISPPARAM_ELVSS_DIMMING_OFF:
+		pr_info("elvss dimming off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFF);
+		break;
+	case DISPPARAM_FLAT_MODE_ON:
+		pr_info("flat mode on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FLAT_MODE_ON);
+		break;
+	case DISPPARAM_FLAT_MODE_OFF:
+		pr_info("flat mode off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FLAT_MODE_OFF);
+		break;
+	case DISPPARAM_DITHER_ON:
+		pr_info("dither on\n");
+		mi_cfg->dither_enabled = true;
+		break;
+	case DISPPARAM_DITHER_OFF:
+		pr_info("dither off\n");
+		mi_cfg->dither_enabled = false;
+		break;
+	case DISPPARAM_SET_THERMAL_HBM_DISABLE:
+		pr_info("set thermal hbm disable\n");
+		mi_cfg->thermal_hbm_disabled = true;
+		break;
+	case DISPPARAM_CLEAR_THERMAL_HBM_DISABLE:
+		pr_info("clear thermal hbm disable\n");
+		mi_cfg->thermal_hbm_disabled = false;
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0xF0000000;
+	switch (temp) {
+	case DISPPARAM_DFPS_LEVEL1:
+		DSI_INFO("DFPS:30fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL2:
+		DSI_INFO("DFPS:48fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL3:
+		DSI_INFO("DFPS:50fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL4:
+		DSI_INFO("DFPS:60fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL5:
+		DSI_INFO("DFPS:90fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL6:
+		DSI_INFO("DFPS:120fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	case DISPPARAM_DFPS_LEVEL7:
+		DSI_INFO("DFPS:144fps\n");
+		panel->mi_cfg.smart_fps_restore = true;
+		break;
+	default:
+		break;
+	}
+
+exit:
+	mutex_unlock(&panel->panel_lock);
+	return rc;
+}
+
diff --git a/techpack/display/msm/dsi/dsi_panel_mi.h b/techpack/display/msm/dsi/dsi_panel_mi.h
new file mode 100755
index 000000000000..9f36ac0d4290
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_panel_mi.h
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DSI_PANEL_MI_H_
+#define _DSI_PANEL_MI_H_
+
+#include <linux/of_device.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/backlight.h>
+#include <drm/drm_panel.h>
+#include <drm/msm_drm.h>
+
+#include "dsi_defs.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_clk.h"
+#include "dsi_pwr.h"
+#include "dsi_parser.h"
+#include "msm_drv.h"
+
+#define DEFAULT_FOD_OFF_DIMMING_DELAY     170
+#define DEFAULT_FOD_OFF_ENTER_AOD_DELAY   300
+#define DISPPARAM_THERMAL_SET             0x1
+
+#define MAX_VSYNC_COUNT                   200
+
+enum doze_bkl {
+	DOZE_TO_NORMAL = 0,
+	DOZE_BRIGHTNESS_HBM,
+	DOZE_BRIGHTNESS_LBM,
+};
+
+enum bkl_dimming_state {
+	STATE_NONE,
+	STATE_DIM_BLOCK,
+	STATE_DIM_RESTORE,
+	STATE_ALL
+};
+
+enum dsi_gamma_cmd_set_type {
+	DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ = 0,
+	DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ,
+	DSI_CMD_SET_MI_GAMMA_SWITCH_MAX
+};
+
+/* 60Hz gamma and 90Hz gamma info */
+struct gamma_cfg {
+	bool read_done;
+	u8 otp_read_c8[135];
+	u8 otp_read_c9[180];
+	u8 otp_read_b3[45];
+
+	u32 flash_read_total_param;
+	u32 flash_read_c1_index;
+	u32 gamma_checksum;
+	u8 flash_read_c8[135];
+	u8 flash_read_c9[180];
+	u8 flash_read_b3[45];
+	u8 flash_read_checksum[2];
+
+	u32 update_c8_index;
+	u32 update_c9_index;
+	u32 update_b3_index;
+	bool update_done_60hz;
+	bool update_done_90hz;
+
+	bool black_setting_flag;
+};
+
+/* Enter/Exit DC_LUT info */
+struct dc_cfg {
+	bool read_done;
+	bool update_done;
+	u32 update_d2_index;
+	u8 enter_dc_lut[75];
+	u8 exit_dc_lut[75];
+};
+
+struct greenish_gamma_cfg {
+	u32 index_1st_param;
+	u32 index_2nd_param;
+	u32 index_3rd_param;
+	u32 index_4th_param;
+	u32 index_5th_param;
+	u32 index_6th_param;
+
+	u32 greenish_gamma_update_offset;
+	u32 greenish_gamma_update_param_count;
+
+	bool gamma_update_done;
+};
+
+typedef struct brightness_alpha {
+	uint32_t brightness;
+	uint32_t alpha;
+} brightness_alpha;
+
+struct dsi_panel_mi_cfg {
+	struct dsi_panel *dsi_panel;
+
+	/* xiaomi panel id */
+	u64 panel_id;
+
+	/* xiaomi feature enable flag */
+	bool mi_feature_enabled;
+
+	/* bl_is_big_endian indicate brightness value
+	 * high byte to 1st parameter, low byte to 2nd parameter
+	 * eg: 0x51 { 0x03, 0xFF } ->
+	 * u8 payload[2] = { brightness >> 8, brightness & 0xff}
+	 */
+	bool bl_is_big_endian;
+	u32 last_bl_level;
+
+	/* indicate refresh frequency Fps gpio */
+	int disp_rate_gpio;
+
+	/* gamma read */
+	bool gamma_update_flag;
+	struct gamma_cfg gamma_cfg;
+
+	/* greenish gamma read */
+	bool greenish_gamma_update_flag;
+	u32 greenish_gamma_read_len;
+	struct greenish_gamma_cfg greenish_gamma_cfg;
+
+	/* dc read */
+	bool dc_update_flag;
+	struct dc_cfg dc_cfg;
+
+	/* white point coordinate info */
+	bool wp_read_enabled;
+	u32 wp_reg_read_len;
+	u32 wp_info_index;
+	u32 wp_info_len;
+
+	/* HBM and brightness use 51 reg ctrl */
+	bool hbm_51_ctrl_flag;
+	u32 hbm_off_51_index;
+	u32 fod_off_51_index;
+	u32 fod_off_b5_index;
+	u32 fod_on_b2_index;
+	bool vi_setting_enabled;
+	u32 vi_switch_threshold;
+
+	bool dynamic_elvss_enabled;
+
+	/* elvss dimming info */
+	bool elvss_dimming_check_enable;
+	u32 elvss_dimming_read_len;
+	u32 update_hbm_fod_on_index;
+	u32 update_hbm_fod_off_index;
+
+	u32 dimming_state;
+	u32 panel_on_dimming_delay;
+	struct delayed_work dimming_enable_delayed_work;
+
+	struct delayed_work enter_aod_delayed_work;
+
+	bool hbm_enabled;
+	bool thermal_hbm_disabled;
+	bool fod_hbm_enabled;
+	bool fod_hbm_layer_enabled;
+	u32 doze_brightness_state;
+	u32 unset_doze_brightness;
+	u32 fod_off_dimming_delay;
+	ktime_t fod_backlight_off_time;
+	ktime_t fod_hbm_off_time;
+	u32 fod_ui_ready;
+	bool layer_fod_unlock_success;
+	bool sysfs_fod_unlock_success;
+	bool into_aod_pending;
+	bool layer_aod_flag;
+	struct wakeup_source *aod_wakelock;
+
+	bool fod_backlight_flag;
+	u32 fod_target_backlight;
+	bool fod_flag;
+	/* set doze hbm/lbm only in AOD */
+	bool in_aod;
+	u32 dc_threshold;
+	bool dc_enable;
+	u32 dc_type;
+	u32 hbm_brightness;
+	u32 max_brightness_clone;
+	u32 aod_backlight;
+	uint32_t doze_brightness;
+	bool is_tddi_flag;
+	bool tddi_doubleclick_flag;
+	bool panel_dead_flag;
+
+	bool fod_dimlayer_enabled;
+	bool prepare_before_fod_hbm_on;
+	bool delay_before_fod_hbm_on;
+	bool delay_after_fod_hbm_on;
+	bool delay_before_fod_hbm_off;
+	bool delay_after_fod_hbm_off;
+	uint32_t brightnes_alpha_lut_item_count;
+	brightness_alpha *brightness_alpha_lut;
+
+	/* smart fps control */
+	bool smart_fps_support;
+	bool smart_fps_restore;
+	u32 smart_fps_max_framerate;
+	u32 smart_fps_value;
+
+	bool dither_enabled;
+};
+
+struct dsi_read_config {
+	bool is_read;
+	struct dsi_panel_cmd_set read_cmd;
+	u32 cmds_rlen;
+	u8 rbuf[256];
+};
+
+struct hw_vsync_info {
+	u32 config_fps;
+	ktime_t timestamp;
+	u64 real_vsync_period_ns;
+};
+
+struct calc_hw_vsync {
+	struct hw_vsync_info vsyc_info[MAX_VSYNC_COUNT];
+	int vsync_count;
+	ktime_t last_timestamp;
+	u64 measured_vsync_period_ns;
+	u64 measured_fps_x1000;
+};
+
+int dsi_panel_parse_mi_config(struct dsi_panel *panel,
+				struct device_node *of_node);
+
+void display_utc_time_marker(const char *format, ...);
+
+int dsi_panel_write_cmd_set(struct dsi_panel *panel,
+				struct dsi_panel_cmd_set *cmd_sets);
+
+int dsi_panel_read_cmd_set(struct dsi_panel *panel,
+				struct dsi_read_config *read_config);
+
+int dsi_panel_write_mipi_reg(struct dsi_panel *panel, char *buf);
+
+ssize_t dsi_panel_read_mipi_reg(struct dsi_panel *panel, char *buf);
+
+int dsi_panel_set_disp_param(struct dsi_panel *panel, u32 param);
+
+int dsi_panel_read_gamma_param(struct dsi_panel *panel);
+
+ssize_t dsi_panel_print_gamma_param(struct dsi_panel *panel,
+				char *buf);
+
+int dsi_panel_update_gamma_param(struct dsi_panel *panel);
+
+int dsi_panel_write_gamma_cmd_set(struct dsi_panel *panel,
+				enum dsi_gamma_cmd_set_type type);
+
+int dsi_panel_read_dc_param(struct dsi_panel *panel);
+
+int dsi_panel_update_dc_param(struct dsi_panel *panel);
+
+int dsi_panel_switch_disp_rate_gpio(struct dsi_panel *panel);
+
+ssize_t dsi_panel_read_wp_info(struct dsi_panel *panel, char *buf);
+
+int dsi_panel_set_doze_brightness(struct dsi_panel *panel,
+				int doze_brightness, bool need_panel_lock);
+
+ssize_t dsi_panel_get_doze_brightness(struct dsi_panel *panel, char *buf);
+
+int dsi_panel_update_elvss_dimming(struct dsi_panel *panel);
+
+int dsi_panel_read_greenish_gamma_setting(struct dsi_panel *panel);
+
+int dsi_panel_update_greenish_gamma_setting(struct dsi_panel *panel);
+
+int dsi_panel_set_thermal_hbm_disabled(struct dsi_panel *panel,
+				bool thermal_hbm_disabled);
+int dsi_panel_get_thermal_hbm_disabled(struct dsi_panel *panel,
+				bool *thermal_hbm_disabled);
+
+struct calc_hw_vsync *get_hw_calc_vsync_struct(int dsi_display_type);
+ssize_t calc_hw_vsync_info(struct dsi_panel *panel,
+				char *buf);
+
+#endif /* _DSI_PANEL_MI_H_ */
diff --git a/techpack/display/msm/dsi/dsi_phy.c b/techpack/display/msm/dsi/dsi_phy.c
index 1a826f7f9a3f..e797f7b51b3d 100644
--- a/techpack/display/msm/dsi/dsi_phy.c
+++ b/techpack/display/msm/dsi/dsi_phy.c
@@ -885,6 +885,7 @@ int dsi_phy_enable(struct msm_dsi_phy *phy,
 	phy->cfg.data_lanes = config->common_config.data_lanes;
 	phy->cfg.pll_source = pll_source;
 	phy->cfg.bit_clk_rate_hz = config->bit_clk_rate_hz;
+	phy->cfg.clk_strength = config->common_config.clk_strength;
 
 	/**
 	 * If PHY timing parameters are not present in panel dtsi file,
diff --git a/techpack/display/msm/dsi/dsi_phy_hw.h b/techpack/display/msm/dsi/dsi_phy_hw.h
index d124f2f42c85..4dafa5d3fb02 100644
--- a/techpack/display/msm/dsi/dsi_phy_hw.h
+++ b/techpack/display/msm/dsi/dsi_phy_hw.h
@@ -114,6 +114,7 @@ struct dsi_phy_cfg {
 	bool force_clk_lane_hs;
 	enum dsi_phy_type phy_type;
 	unsigned long bit_clk_rate_hz;
+	unsigned long clk_strength;
 	u32 data_lanes;
 };
 
diff --git a/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c b/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
index 764602f17388..5dfb81d61c7b 100644
--- a/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
+++ b/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
@@ -355,12 +355,21 @@ static void dsi_phy_hw_dphy_enable(struct dsi_phy_hw *phy,
 		vreg_ctrl_0 = less_than_1500_mhz ? 0x53 : 0x52;
 		glbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x00;
 		glbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x39 :  0x3c;
-		glbl_str_swi_cal_sel_ctrl = 0x00;
-		glbl_hstx_str_ctrl_0 = 0x88;
+		if (cfg->clk_strength == 0) {
+			glbl_str_swi_cal_sel_ctrl = 0x00;
+			glbl_hstx_str_ctrl_0 = 0x88;
+		} else {
+			glbl_str_swi_cal_sel_ctrl = 0x03;
+			glbl_hstx_str_ctrl_0 = cfg->clk_strength;
+		}
 	} else {
 		vreg_ctrl_0 = less_than_1500_mhz ? 0x5B : 0x59;
 		glbl_str_swi_cal_sel_ctrl = less_than_1500_mhz ? 0x03 : 0x00;
-		glbl_hstx_str_ctrl_0 = less_than_1500_mhz ? 0x66 : 0x88;
+		if (cfg->clk_strength == 0) {
+			glbl_hstx_str_ctrl_0 = less_than_1500_mhz ? 0x66 : 0x88;
+		} else {
+			glbl_hstx_str_ctrl_0 = cfg->clk_strength;
+		}
 		glbl_rescode_top_ctrl = 0x03;
 		glbl_rescode_bot_ctrl = 0x3c;
 	}
@@ -397,7 +406,11 @@ static void dsi_phy_hw_dphy_enable(struct dsi_phy_hw *phy,
 			glbl_rescode_top_ctrl);
 	DSI_W32(phy, DSIPHY_CMN_GLBL_RESCODE_OFFSET_BOT_CTRL,
 			glbl_rescode_bot_ctrl);
-	DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);
+	if (cfg->clk_strength == 0) {
+		DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);
+	} else {
+		DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, cfg->clk_strength);
+	}
 
 	/* Remove power down from all blocks */
 	DSI_W32(phy, DSIPHY_CMN_CTRL_0, 0x7f);
diff --git a/techpack/display/msm/msm_atomic.c b/techpack/display/msm/msm_atomic.c
index ddd966d7cd41..6c80d242e001 100644
--- a/techpack/display/msm/msm_atomic.c
+++ b/techpack/display/msm/msm_atomic.c
@@ -21,6 +21,7 @@
 #include "msm_gem.h"
 #include "msm_kms.h"
 #include "sde_trace.h"
+#include "xiaomi_frame_stat.h"
 
 #define MULTIPLE_CONN_DETECTED(x) (x > 1)
 
@@ -489,6 +490,12 @@ int msm_atomic_prepare_fb(struct drm_plane *plane,
 	return msm_framebuffer_prepare(new_state->fb, kms->aspace);
 }
 
+extern struct device *connector_kdev;
+void complete_time_generate_event(struct drm_device *dev)
+{
+	sysfs_notify(&connector_kdev->kobj, NULL, "complete_commit_time");
+}
+
 /* The (potentially) asynchronous part of the commit.  At this point
  * nothing can fail short of armageddon.
  */
@@ -531,12 +538,18 @@ static void complete_commit(struct msm_commit *c)
 
 	drm_atomic_state_put(state);
 
+	priv->complete_commit_time = ktime_get()/1000;
+
+	complete_time_generate_event(dev);
+
 	commit_destroy(c);
 }
 
 static void _msm_drm_commit_work_cb(struct kthread_work *work)
 {
 	struct msm_commit *commit = NULL;
+	ktime_t start, end;
+	s64 duration;
 
 	if (!work) {
 		DRM_ERROR("%s: Invalid commit work data!\n", __func__);
@@ -545,9 +558,16 @@ static void _msm_drm_commit_work_cb(struct kthread_work *work)
 
 	commit = container_of(work, struct msm_commit, commit_work);
 
+	start = ktime_get();
+	frame_stat_collector(0, COMMIT_START_TS);
+
 	SDE_ATRACE_BEGIN("complete_commit");
 	complete_commit(commit);
 	SDE_ATRACE_END("complete_commit");
+
+	end = ktime_get();
+	duration = ktime_to_ns(ktime_sub(end, start));
+	frame_stat_collector(duration, COMMIT_END_TS);
 }
 
 static struct msm_commit *commit_init(struct drm_atomic_state *state,
diff --git a/techpack/display/msm/msm_drv.c b/techpack/display/msm/msm_drv.c
index 30aec6dff29b..1267b736487d 100644
--- a/techpack/display/msm/msm_drv.c
+++ b/techpack/display/msm/msm_drv.c
@@ -69,6 +69,8 @@
 #define IDLE_TIMEOUT_MS_DEFAULT		100
 
 static DEFINE_MUTEX(msm_release_lock);
+atomic_t resume_pending;
+wait_queue_head_t resume_wait_q;
 
 static void msm_fb_output_poll_changed(struct drm_device *dev)
 {
@@ -1883,6 +1885,19 @@ static struct drm_driver msm_driver = {
 };
 
 #ifdef CONFIG_PM_SLEEP
+static int msm_pm_prepare(struct device *dev)
+{
+	atomic_inc(&resume_pending);
+	return 0;
+}
+
+static void msm_pm_complete(struct device *dev)
+{
+	atomic_set(&resume_pending, 0);
+	wake_up_all(&resume_wait_q);
+	return;
+}
+
 static int msm_pm_suspend(struct device *dev)
 {
 	struct drm_device *ddev;
@@ -1968,6 +1983,8 @@ static int msm_runtime_resume(struct device *dev)
 #endif
 
 static const struct dev_pm_ops msm_pm_ops = {
+	.prepare = msm_pm_prepare,
+	.complete = msm_pm_complete,
 	SET_SYSTEM_SLEEP_PM_OPS(msm_pm_suspend, msm_pm_resume)
 	SET_RUNTIME_PM_OPS(msm_runtime_suspend, msm_runtime_resume, NULL)
 };
@@ -1985,6 +2002,7 @@ static int compare_of(struct device *dev, void *data)
 	return dev->of_node == data;
 }
 
+
 /*
  * Identify what components need to be added by parsing what remote-endpoints
  * our MDP output ports are connected to. In the case of LVDS on MDP4, there
diff --git a/techpack/display/msm/msm_drv.h b/techpack/display/msm/msm_drv.h
index 084aaab34e3d..6a44666e5e5e 100644
--- a/techpack/display/msm/msm_drv.h
+++ b/techpack/display/msm/msm_drv.h
@@ -73,6 +73,9 @@ struct msm_gem_vma;
 
 #define TEARDOWN_DEADLOCK_RETRY_MAX 5
 
+extern atomic_t resume_pending;
+extern wait_queue_head_t resume_wait_q;
+
 struct msm_file_private {
 	rwlock_t queuelock;
 	struct list_head submitqueues;
@@ -107,6 +110,7 @@ enum msm_mdp_plane_property {
 
 	/* range properties */
 	PLANE_PROP_ZPOS = PLANE_PROP_BLOBCOUNT,
+	PLANE_PROP_FOD,
 	PLANE_PROP_ALPHA,
 	PLANE_PROP_COLOR_FILL,
 	PLANE_PROP_H_DECIMATE,
@@ -128,6 +132,7 @@ enum msm_mdp_plane_property {
 	PLANE_PROP_SRC_CONFIG,
 	PLANE_PROP_FB_TRANSLATION_MODE,
 	PLANE_PROP_MULTIRECT_MODE,
+	PLANE_PROP_MI_LAYER_INFO,
 
 	/* total # of properties */
 	PLANE_PROP_COUNT
@@ -164,7 +169,11 @@ enum msm_mdp_crtc_property {
 	CRTC_PROP_CAPTURE_OUTPUT,
 
 	CRTC_PROP_IDLE_PC_STATE,
+	CRCT_PROP_MI_FOD_SYNC_INFO,
 
+#ifdef CONFIG_DRM_SDE_EXPO
+	CRTC_PROP_DIM_LAYER_EXPO,
+#endif
 	/* total # of properties */
 	CRTC_PROP_COUNT
 };
@@ -710,6 +719,7 @@ struct msm_drm_private {
 
 	/* update the flag when msm driver receives shutdown notification */
 	bool shutdown_in_progress;
+	ktime_t  complete_commit_time;
 
 	struct msm_idle idle;
 };
diff --git a/techpack/display/msm/msm_notifier.c b/techpack/display/msm/msm_notifier.c
index 20be9ba81de5..5a64bdb70759 100644
--- a/techpack/display/msm/msm_notifier.c
+++ b/techpack/display/msm/msm_notifier.c
@@ -130,6 +130,7 @@ static int msm_notifier_probe(struct platform_device *pdev)
 
 	active_displays = devm_kzalloc(&pdev->dev,
 				sizeof(*active_displays), GFP_KERNEL);
+
 	if (!active_displays) {
 		ret = -ENOMEM;
 		goto end;
@@ -180,6 +181,7 @@ static int msm_notifier_probe(struct platform_device *pdev)
 	devm_kfree(&pdev->dev, active_displays);
 end:
 	devm_kfree(&pdev->dev, info);
+
 	return ret;
 }
 
diff --git a/techpack/display/msm/sde/clone_cooling_device.c b/techpack/display/msm/sde/clone_cooling_device.c
new file mode 100644
index 000000000000..6ee443b072e7
--- /dev/null
+++ b/techpack/display/msm/sde/clone_cooling_device.c
@@ -0,0 +1,162 @@
+#include <linux/err.h>
+#include <linux/slab.h>
+#include "sde_dbg.h"
+
+#include "clone_cooling_device.h"
+#include "../dsi/dsi_display.h"
+#include "../dsi/dsi_panel_mi.h"
+
+#define BL_NODE_NAME_SIZE 32
+
+static int bd_cdev_get_max_brightness_clone(struct thermal_cooling_device *cdev,
+					unsigned long *state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	struct backlight_device *bd;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	if (!cdev_clone->panel)
+		return -ENODEV;
+
+	*state = cdev_clone->panel->mi_cfg.max_brightness_clone;
+	return 0;
+}
+
+static int bd_cdev_get_cur_brightness_clone(struct thermal_cooling_device *cdev,
+                                        unsigned long *state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	struct backlight_device *bd;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	*state = bd->thermal_brightness_clone_limit;
+	return 0;
+}
+
+static int bd_cdev_set_cur_brightness_clone(struct thermal_cooling_device *cdev,
+					unsigned long state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	unsigned long brightness_lvl;
+	struct backlight_device *bd;
+	int rc = 0;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	if (state > cdev_clone->panel->mi_cfg.max_brightness_clone)
+		return -EINVAL;
+
+	brightness_lvl = cdev_clone->panel->mi_cfg.max_brightness_clone - state;
+	if (brightness_lvl == bd->thermal_brightness_limit)
+		return 0;
+	bd->thermal_brightness_clone_limit = brightness_lvl;
+	brightness_lvl = (bd->props.brightness_clone_backup
+				<= bd->thermal_brightness_clone_limit) ?
+				bd->props.brightness_clone_backup :
+				bd->thermal_brightness_clone_limit;
+
+	SDE_INFO("backup_brightness_clone[%d], thermal limit[%d]\n", bd->props.brightness_clone_backup, bd->thermal_brightness_clone_limit);
+	bd->props.brightness_clone = brightness_lvl;
+	sysfs_notify(&bd->dev.kobj, NULL, "brightness_clone");
+
+	return rc;
+}
+
+static struct thermal_cooling_device_ops bd_cdev_clone_ops = {
+	.get_max_state = bd_cdev_get_max_brightness_clone,
+	.get_cur_state = bd_cdev_get_cur_brightness_clone,
+	.set_cur_state = bd_cdev_set_cur_brightness_clone,
+};
+
+int backlight_clone_cdev_register(struct sde_clone_cdev *cdev_clone,
+					struct device *parent,
+					struct backlight_device *bd)
+{
+	static int display_clone_count;
+	char bl_node_name[BL_NODE_NAME_SIZE];
+
+	if (!bd || !parent || !cdev_clone)
+		return -EINVAL;
+	if (!of_find_property(parent->of_node, "#cooling-cells", NULL))
+		return -ENODEV;
+	snprintf(bl_node_name, BL_NODE_NAME_SIZE, "brightness%u-clone", display_clone_count++);
+
+	cdev_clone->bd = bd;
+	cdev_clone->cdev = thermal_of_cooling_device_register(parent->of_node,
+				bl_node_name, cdev_clone, &bd_cdev_clone_ops);
+
+	if (!&(cdev_clone->cdev)) {
+		pr_err("Cooling device register failed\n");
+		return -EINVAL;
+	}
+	else
+		display_clone_count++;
+
+	return 0;
+}
+
+void backlight_clone_cdev_unregister(struct sde_clone_cdev *cdev_clone)
+{
+	if (!cdev_clone)
+		return;
+
+	thermal_cooling_device_unregister(cdev_clone->cdev);
+}
+
+int sde_backlight_clone_setup(struct sde_connector *c_conn, struct device *parent, struct backlight_device *bd)
+{
+	struct dsi_display *display;
+	struct sde_clone_cdev *cdev_clone = NULL;
+	int rc = 0;
+
+	if (!c_conn || !parent || !bd)
+		return -ENOMEM;
+
+	display = (struct dsi_display *) c_conn->display;
+	if (!display || !display->panel)
+		return -ENOMEM;
+
+	cdev_clone = devm_kzalloc(parent, sizeof(*cdev_clone), GFP_KERNEL);
+	if (!cdev_clone)
+		return -ENOMEM;
+
+	cdev_clone->panel = display->panel;
+	bd->thermal_brightness_clone_limit = cdev_clone->panel->mi_cfg.max_brightness_clone;
+	rc = backlight_clone_cdev_register(cdev_clone, parent, bd);
+	if (rc) {
+		pr_err("Failed to register backlight_clone_cdev\n");
+		return -ENODEV;
+	}
+	c_conn->cdev_clone = cdev_clone;
+
+	return 0;
+}
diff --git a/techpack/display/msm/sde/clone_cooling_device.h b/techpack/display/msm/sde/clone_cooling_device.h
new file mode 100644
index 000000000000..e10dd28151d8
--- /dev/null
+++ b/techpack/display/msm/sde/clone_cooling_device.h
@@ -0,0 +1,19 @@
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/thermal.h>
+#include <linux/notifier.h>
+
+#include "sde_connector.h"
+#include "dsi_panel.h"
+
+struct sde_connector;
+struct sde_clone_cdev {
+	struct thermal_cooling_device *cdev;
+	struct backlight_device *bd;
+	struct dsi_panel *panel;
+};
+
+int sde_backlight_clone_setup(struct sde_connector *c_conn,
+			struct device *dev,
+			struct backlight_device *bd);
+void backlight_clone_cdev_unregister(struct sde_clone_cdev *cdev_clone);
diff --git a/techpack/display/msm/sde/sde_color_processing.c b/techpack/display/msm/sde/sde_color_processing.c
index 7f0d68b2457a..f140244eb31d 100644
--- a/techpack/display/msm/sde/sde_color_processing.c
+++ b/techpack/display/msm/sde/sde_color_processing.c
@@ -2396,9 +2396,20 @@ static void dspp_ltm_install_property(struct drm_crtc *crtc)
 	char feature_name[256];
 	struct sde_kms *kms = NULL;
 	struct sde_mdss_cfg *catalog = NULL;
-	u32 version;
+	u32 version = 0, ltm_sw_fuse = 0;
 
 	kms = get_kms(crtc);
+	if (!kms || !kms->hw_sw_fuse) {
+		DRM_ERROR("!kms = %d\n", !kms);
+		return;
+	}
+
+	ltm_sw_fuse = sde_hw_get_ltm_sw_fuse_value(kms->hw_sw_fuse);
+	DRM_DEBUG_DRIVER("ltm_sw_fuse value: 0x%x\n", ltm_sw_fuse);
+	if (ltm_sw_fuse != SW_FUSE_ENABLE) {
+		pr_info("ltm_sw_fuse is not enabled: 0x%x\n", ltm_sw_fuse);
+	}
+
 	catalog = kms->catalog;
 	version = catalog->dspp[0].sblk->ltm.version >> 16;
 	snprintf(feature_name, ARRAY_SIZE(feature_name), "%s%d",
diff --git a/techpack/display/msm/sde/sde_connector.c b/techpack/display/msm/sde/sde_connector.c
index 6f20aa6f0abf..ee220965c01c 100644
--- a/techpack/display/msm/sde/sde_connector.c
+++ b/techpack/display/msm/sde/sde_connector.c
@@ -14,9 +14,15 @@
 #include <linux/backlight.h>
 #include <linux/string.h>
 #include "dsi_drm.h"
+#include "dsi_defs.h"
 #include "dsi_display.h"
 #include "sde_crtc.h"
 #include "sde_rm.h"
+#include "sde_trace.h"
+#include "dsi_mi_feature.h"
+#include "dsi_display.h"
+#include "dsi_panel_mi.h"
+#include "clone_cooling_device.h"
 
 #define BL_NODE_NAME_SIZE 32
 #define HDR10_PLUS_VSIF_TYPE_CODE      0x81
@@ -85,15 +91,19 @@ static int sde_backlight_device_update_status(struct backlight_device *bd)
 
 	c_conn = bl_get_data(bd);
 	display = (struct dsi_display *) c_conn->display;
-	if (brightness > display->panel->bl_config.bl_max_level)
-		brightness = display->panel->bl_config.bl_max_level;
+	if (brightness > display->panel->bl_config.brightness_max_level)
+		brightness = display->panel->bl_config.brightness_max_level;
 
-	/* map UI brightness into driver backlight level with rounding */
-	bl_lvl = mult_frac(brightness, display->panel->bl_config.bl_max_level,
-			display->panel->bl_config.brightness_max_level);
+	if (brightness) {
+		int bl_min = display->panel->bl_config.bl_min_level ? : 1;
+		int bl_range = display->panel->bl_config.bl_max_level - bl_min;
 
-	if (!bl_lvl && brightness)
-		bl_lvl = 1;
+		/* map UI brightness into driver backlight level rounding it */
+		bl_lvl = bl_min + DIV_ROUND_CLOSEST((brightness - 1) * bl_range,
+			display->panel->bl_config.brightness_max_level - 1);
+	} else {
+		bl_lvl = 0;
+	}
 
 	if (!c_conn->allow_bl_update) {
 		c_conn->unset_bl_level = bl_lvl;
@@ -111,6 +121,7 @@ static int sde_backlight_device_update_status(struct backlight_device *bd)
 		rc = c_conn->ops.set_backlight(&c_conn->base,
 				c_conn->display, bl_lvl);
 		c_conn->unset_bl_level = 0;
+		c_conn->mi_dimlayer_state.current_backlight = bl_lvl;
 	}
 
 	return rc;
@@ -134,6 +145,7 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 	struct dsi_backlight_config *bl_config;
 	static int display_count;
 	char bl_node_name[BL_NODE_NAME_SIZE];
+	int rc = 0;
 
 	if (!c_conn || !dev || !dev->dev) {
 		SDE_ERROR("invalid param\n");
@@ -149,7 +161,7 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 	display = (struct dsi_display *) c_conn->display;
 	bl_config = &display->panel->bl_config;
 	props.max_brightness = bl_config->brightness_max_level;
-	props.brightness = bl_config->brightness_max_level;
+	props.brightness = bl_config->brightness_init_level;
 	snprintf(bl_node_name, BL_NODE_NAME_SIZE, "panel%u-backlight",
 							display_count);
 	c_conn->bl_device = backlight_device_register(bl_node_name, dev->dev,
@@ -161,7 +173,15 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 		return -ENODEV;
 	}
 	display_count++;
-
+	rc = sde_backlight_clone_setup(c_conn, dev->dev, c_conn->bl_device);
+	if (rc) {
+		SDE_ERROR("Failed to register backlight_clone_cdev: %ld\n",
+				    PTR_ERR(c_conn->cdev_clone));
+		backlight_clone_cdev_unregister(c_conn->cdev_clone);
+		backlight_device_unregister(c_conn->bl_device);
+		c_conn->bl_device = NULL;
+		return -ENODEV;
+	}
 	return 0;
 }
 
@@ -547,6 +567,9 @@ static int _sde_connector_update_power_locked(struct sde_connector *c_conn)
 	SDE_DEBUG("conn %d - dpms %d, lp %d, panel %d\n", connector->base.id,
 			c_conn->dpms_mode, c_conn->lp_mode, mode);
 
+	if (SDE_MODE_DPMS_OFF == mode)
+		c_conn->fod_frame_count = 0;
+
 	if (mode != c_conn->last_panel_power_mode && c_conn->ops.set_power) {
 		display = c_conn->display;
 		set_power = c_conn->ops.set_power;
@@ -748,6 +771,50 @@ static int _sde_connector_update_dirty_properties(
 	return 0;
 }
 
+void sde_connector_update_fod_hbm(struct drm_connector *connector)
+{
+	static atomic_t effective_status = ATOMIC_INIT(false);
+	struct sde_crtc_state *cstate;
+	struct sde_connector *c_conn;
+	struct dsi_display *display;
+	bool status;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	if (!connector) {
+		SDE_ERROR("invalid connector\n");
+		return;
+	}
+
+	c_conn = to_sde_connector(connector);
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI)
+		return;
+
+	display = (struct dsi_display *) c_conn->display;
+
+	if (!c_conn->encoder || !c_conn->encoder->crtc ||
+			!c_conn->encoder->crtc->state)
+		return;
+
+	cstate = to_sde_crtc_state(c_conn->encoder->crtc->state);
+	status = cstate->fod_dim_layer != NULL;
+	if (atomic_xchg(&effective_status, status) == status)
+		return;
+
+	mi_cfg = &display->panel->mi_cfg;
+
+	if ((status && mi_cfg && mi_cfg->delay_before_fod_hbm_on) ||
+			(!status && mi_cfg && mi_cfg->delay_before_fod_hbm_off))
+		sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+	dsi_panel_set_fod_hbm(display->panel, status);
+
+	if ((status && mi_cfg && mi_cfg->delay_after_fod_hbm_on) ||
+			(!status && mi_cfg && mi_cfg->delay_after_fod_hbm_off))
+		sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+	dsi_display_set_fod_ui(display, status);
+}
+
 struct sde_connector_dyn_hdr_metadata *sde_connector_get_dyn_hdr_meta(
 		struct drm_connector *connector)
 {
@@ -760,6 +827,249 @@ struct sde_connector_dyn_hdr_metadata *sde_connector_get_dyn_hdr_meta(
 	return &c_state->dyn_hdr_meta;
 }
 
+void sde_crtc_fod_ui_ready(struct dsi_display *display, int type, int value)
+{
+	if (!display)
+		return;
+
+	if (type == 1) /* HBM */
+	{
+		if (value == 0)
+			display->panel->mi_cfg.fod_ui_ready &= ~0x01;
+		else if (value == 1)
+			display->panel->mi_cfg.fod_ui_ready |= 0x01;
+	}
+
+	if (type == 2) /* ICON */
+	{
+		if (value == 0)
+			display->panel->mi_cfg.fod_ui_ready &= ~0x02;
+		else if (value == 1)
+			display->panel->mi_cfg.fod_ui_ready |= 0x02;
+
+	}
+
+	SDE_INFO("fod_ui_ready notify=%d", display->panel->mi_cfg.fod_ui_ready);
+	sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "fod_ui_ready");
+}
+
+static int _sde_connector_mi_dimlayer_hbm_fence(struct drm_connector *connector)
+{
+	int rc = 0;
+	struct sde_connector *c_conn;
+	struct dsi_display *dsi_display;
+	bool skip = false;
+	static int skip_frame_count = 0;
+	bool hbm_overlay;
+	static bool last_fod_unlock_success;
+	static bool last_layer_aod_flag;
+	bool crc_off_after_delay_of_hbm_on = false;
+	struct dsi_panel_mi_cfg *mi_cfg;
+#if 0
+	bool icon;
+	static bool last_icon = false;
+#endif
+	if (!connector) {
+		SDE_ERROR("invalid argument\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI)
+		return 0;
+
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &dsi_display->panel->mi_cfg;
+	if (!mi_cfg) {
+		SDE_ERROR("invalid mi_cfg\n");
+		return -EINVAL;
+	}
+
+	if (!c_conn->allow_bl_update) {
+		/*Skip 2 frames after panel on to avoid hbm flicker*/
+		if (mi_cfg->dc_type == 1 && dsi_display->panel->power_mode == SDE_MODE_DPMS_ON)
+			skip_frame_count = 2;
+		return 0;
+	}
+
+	if (skip_frame_count) {
+		SDE_INFO("skip_frame_count=%d\n", skip_frame_count);
+		skip_frame_count--;
+		return 0;
+	}
+
+	mi_cfg->layer_fod_unlock_success =
+			c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_FOD_UNLOCK_SUCCESS;
+	if (last_fod_unlock_success != mi_cfg->layer_fod_unlock_success)
+		SDE_INFO("layer_fod_unlock_success = %d\n",
+					mi_cfg->layer_fod_unlock_success);
+
+	last_fod_unlock_success = mi_cfg->layer_fod_unlock_success;
+
+	mi_cfg->layer_aod_flag = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_AOD;
+	if (last_layer_aod_flag != mi_cfg->layer_aod_flag)
+		SDE_INFO("layer_aod_flag = %d\n", mi_cfg->layer_aod_flag);
+
+	last_layer_aod_flag = mi_cfg->layer_aod_flag;
+
+	hbm_overlay = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_HBM_OVERLAY;
+	if (hbm_overlay) {
+		/* TODO: mutex_lock(&panel->panel_lock); */
+		if (mi_cfg->fod_hbm_layer_enabled == false) {
+			/* in AOD, first frame should be skipped for hardware limitation */
+			if (mi_cfg->dc_type != 2 &&
+					(dsi_display->panel->power_mode == SDE_MODE_DPMS_LP1 ||
+					 dsi_display->panel->power_mode == SDE_MODE_DPMS_LP2)) {
+				SDE_INFO("fod_frame_count=%d\n", c_conn->fod_frame_count);
+				if (c_conn->fod_frame_count == 0)
+					skip = true;
+
+				c_conn->fod_frame_count++;
+			} else {
+				c_conn->fod_frame_count = 0;
+			}
+			if (skip == false) {
+				/* dimming off before hbm ctl */
+				if (mi_cfg->prepare_before_fod_hbm_on && ((mi_cfg->panel_id >> 8) == 0x4A3232003808)) {
+					/* Set flags to disable dimming and backlight */
+					mi_cfg->dimming_state = STATE_DIM_BLOCK;
+					mi_cfg->fod_hbm_enabled = true;
+
+					sde_connector_pre_hbm_ctl(connector);
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+				}
+
+				if (mi_cfg->delay_before_fod_hbm_on)
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+				sde_connector_hbm_ctl(connector, DISPPARAM_HBM_FOD_ON);
+
+				/* Send crc off cmd before delay only if DC off(MIUI-1755728) */
+				if (mi_cfg->dc_type == 2) {
+					if (!mi_cfg->dc_enable || (mi_cfg->dc_enable &&
+						mi_cfg->last_bl_level > mi_cfg->dc_threshold)) {
+						dsi_panel_acquire_panel_lock(dsi_display->panel);
+						rc = dsi_panel_tx_cmd_set(dsi_display->panel,
+								DSI_CMD_SET_MI_CRC_OFF);
+						dsi_panel_release_panel_lock(dsi_display->panel);
+					} else {
+						crc_off_after_delay_of_hbm_on = true;
+					}
+				}
+
+				if (mi_cfg->delay_after_fod_hbm_on) {
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+				}
+
+				/* Turn off crc after delay of hbm on can avoid flash high
+				 * brightness if DC on (MIUI-1755728) */
+				if (mi_cfg->dc_type == 2 && crc_off_after_delay_of_hbm_on) {
+					dsi_panel_acquire_panel_lock(dsi_display->panel);
+					rc = dsi_panel_tx_cmd_set(dsi_display->panel,
+							DSI_CMD_SET_MI_CRC_OFF);
+					dsi_panel_release_panel_lock(dsi_display->panel);
+				}
+
+				mi_cfg->fod_hbm_layer_enabled = true;
+				/*sde_crtc_fod_ui_ready(dsi_display, 1, 1);*/
+			}
+		}
+	} else {
+		if (mi_cfg->fod_hbm_layer_enabled == true) {
+			SDE_INFO("layer_fod_unlock_success = %d, sysfs_fod_unlock_success = %d\n",
+					mi_cfg->layer_fod_unlock_success,
+					mi_cfg->sysfs_fod_unlock_success);
+			if (mi_cfg->delay_before_fod_hbm_off)
+				sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+			sde_connector_hbm_ctl(connector, DISPPARAM_HBM_FOD_OFF);
+			if (mi_cfg->dc_type)
+				sysfs_notify(&c_conn->bl_device->dev.kobj, NULL, "brightness_clone");
+			if (mi_cfg->delay_after_fod_hbm_off)
+				sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+			mi_cfg->fod_hbm_layer_enabled = false;
+			/*sde_crtc_fod_ui_ready(dsi_display, 1, 0);*/
+		}
+	}
+#if 0
+	icon = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_ICON;
+	if (last_icon != icon) {
+		if (icon) {
+			sde_crtc_fod_ui_ready(dsi_display, 2, 1);
+		} else {
+			if (last_icon)
+				sde_crtc_fod_ui_ready(dsi_display, 2, 0);
+		}
+	}
+	last_icon = icon;
+#endif
+	return rc;
+}
+
+void sde_connector_fod_notify(struct drm_connector *conn)
+{
+	struct sde_connector *c_conn;
+	bool icon, hbm_state;
+	static bool last_icon = false;
+	static bool last_hbm_state = false;
+	struct dsi_display *dsi_display;
+
+	if (!conn) {
+		SDE_ERROR("invalid params\n");
+		return;
+	}
+
+	c_conn = to_sde_connector(conn);
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		SDE_ERROR("not DRM_MODE_CONNECTOR_DSIl\n");
+		return;
+	}
+
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return;
+	}
+
+	icon = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_ICON;
+	if (last_icon != icon) {
+		if (icon) {
+			/* Make sure icon was displayed on panel before notifying
+			 * fingerprint to capture image */
+			if (dsi_display->panel->mi_cfg.fod_hbm_layer_enabled) {
+				sde_encoder_wait_for_event(c_conn->encoder,
+						MSM_ENC_TX_COMPLETE);
+			}
+
+			sde_crtc_fod_ui_ready(dsi_display, 2, 1);
+		} else {
+			sde_crtc_fod_ui_ready(dsi_display, 2, 0);
+		}
+	}
+	last_icon = icon;
+
+	hbm_state = dsi_display->panel->mi_cfg.fod_hbm_layer_enabled;
+	if (last_hbm_state != hbm_state) {
+		if (hbm_state) {
+		   /* The black screen fingerprint unlocks, waits for HBM effect */
+			if (icon) {
+				sde_encoder_wait_for_event(c_conn->encoder,
+						MSM_ENC_TX_COMPLETE);
+			}
+			sde_crtc_fod_ui_ready(dsi_display, 1, 1);
+		} else {
+			sde_crtc_fod_ui_ready(dsi_display, 1, 0);
+		}
+	}
+	last_hbm_state = hbm_state;
+}
+
 int sde_connector_pre_kickoff(struct drm_connector *connector)
 {
 	struct sde_connector *c_conn;
@@ -805,6 +1115,11 @@ int sde_connector_pre_kickoff(struct drm_connector *connector)
 
 	SDE_EVT32_VERBOSE(connector->base.id);
 
+	/* fingerprint hbm fence */
+	_sde_connector_mi_dimlayer_hbm_fence(connector);
+
+	sde_connector_update_fod_hbm(connector);
+
 	rc = c_conn->ops.pre_kickoff(connector, c_conn->display, &params);
 
 	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI)
@@ -912,6 +1227,8 @@ void sde_connector_helper_bridge_enable(struct drm_connector *connector)
 	if (c_conn->bl_device) {
 		c_conn->bl_device->props.power = FB_BLANK_UNBLANK;
 		c_conn->bl_device->props.state &= ~BL_CORE_FBBLANK;
+	if (!(display->panel->cur_mode->dsi_mode_flags & DSI_MODE_FLAG_DMS)
+		&& !(display->panel->cur_mode->dsi_mode_flags & DSI_MODE_FLAG_DMS_FPS))
 		backlight_update_status(c_conn->bl_device);
 	}
 	c_conn->panel_dead = false;
@@ -966,7 +1283,8 @@ void sde_connector_destroy(struct drm_connector *connector)
 		drm_property_blob_put(c_conn->blob_mode_info);
 	if (c_conn->blob_ext_hdr)
 		drm_property_blob_put(c_conn->blob_ext_hdr);
-
+	if (c_conn->cdev_clone)
+		backlight_clone_cdev_unregister(c_conn->cdev_clone);
 	if (c_conn->bl_device)
 		backlight_device_unregister(c_conn->bl_device);
 	drm_connector_unregister(connector);
@@ -1452,11 +1770,13 @@ static int sde_connector_atomic_set_property(struct drm_connector *connector,
 	 * atomic set property framework.
 	 */
 	case CONNECTOR_PROP_BL_SCALE:
-		c_conn->bl_scale = val;
+		//c_conn->bl_scale = val;
+		c_conn->bl_scale = MAX_BL_SCALE_LEVEL;
 		c_conn->bl_scale_dirty = true;
 		break;
 	case CONNECTOR_PROP_SV_BL_SCALE:
-		c_conn->bl_scale_sv = val;
+		//c_conn->bl_scale_sv = val;
+		c_conn->bl_scale_sv = MAX_SV_BL_SCALE_LEVEL;
 		c_conn->bl_scale_dirty = true;
 		break;
 	case CONNECTOR_PROP_HDR_METADATA:
@@ -1924,13 +2244,97 @@ static const struct file_operations conn_cmd_tx_fops = {
 	.write =	_sde_debugfs_conn_cmd_tx_write,
 };
 
-static int _sde_debugfs_conn_cmd_rx_open(struct inode *inode, struct file *file)
+static void _sde_connector_report_panel_dead(struct sde_connector *conn, bool skip_pre_kickoff);
+static int _sde_debugfs_conn_esd_test_open(struct inode *inode, struct file *file)
 {
 	/* non-seekable */
 	file->private_data = inode->i_private;
 	return nonseekable_open(inode, file);
 }
 
+static ssize_t _sde_debugfs_conn_esd_test_write(struct file *file,
+			const char __user *p, size_t count, loff_t *ppos)
+{
+	struct drm_connector *connector = file->private_data;
+	struct sde_connector *c_conn = to_sde_connector(connector);
+	struct dsi_display *display = c_conn->display;
+	struct drm_event event;
+	int power_mode;
+	char *input;
+	int rc = 0;
+	const char *sde_power_mode_str[] = {
+		[SDE_MODE_DPMS_ON] = "SDE_MODE_DPMS_ON",
+		[SDE_MODE_DPMS_LP1] = "SDE_MODE_DPMS_LP1",
+		[SDE_MODE_DPMS_LP2] = "SDE_MODE_DPMS_LP2",
+		[SDE_MODE_DPMS_STANDBY] = "SDE_MODE_DPMS_STANDBY",
+		[SDE_MODE_DPMS_SUSPEND] = "SDE_MODE_DPMS_SUSPEND",
+		[SDE_MODE_DPMS_OFF] = "SDE_MODE_DPMS_OFF",
+	};
+
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return -EINVAL;
+	}
+
+	input = kmalloc(count + 1, GFP_KERNEL);
+	if (!input)
+		return -ENOMEM;
+
+	if (copy_from_user(input, p, count)) {
+		SDE_ERROR("copy from user failed\n");
+		rc = -EFAULT;
+		goto end;
+	}
+	input[count] = '\0';
+	DSI_INFO("[esd-test]intput esd test: %s\n", input);
+
+	if (!strncmp(input, "1", 1) || !strncmp(input, "on", 2) ||
+		!strncmp(input, "true", 4)) {
+		DSI_INFO("[esd-test]panel esd irq trigging \n");
+	} else {
+		goto end;
+	}
+	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI) {
+		if (dsi_panel_initialized(display->panel)) {
+			if (atomic_read(&(display->panel->esd_recovery_pending))) {
+				SDE_ERROR("[esd-test]ESD recovery already pending\n");
+				rc = count;
+				goto end;
+			}
+			power_mode = display->panel->power_mode;
+			DSI_INFO("[esd-test]power_mode = %s\n", sde_power_mode_str[power_mode]);
+			if (power_mode == SDE_MODE_DPMS_ON ||
+				power_mode == SDE_MODE_DPMS_LP1) {
+				atomic_set(&display->panel->esd_recovery_pending, 1);
+				_sde_connector_report_panel_dead(c_conn, false);
+			} else {
+				if (!c_conn->panel_dead) {
+					atomic_set(&display->panel->esd_recovery_pending, 1);
+					c_conn->panel_dead = true;
+					event.type = DRM_EVENT_PANEL_DEAD;
+					event.length = sizeof(bool);
+					msm_mode_object_event_notify(&c_conn->base.base,
+						c_conn->base.dev, &event, (u8 *)&c_conn->panel_dead);
+					SDE_EVT32(SDE_EVTLOG_ERROR);
+					SDE_ERROR("[esd-test]esd irq check failed report PANEL_DEAD"
+						" conn_id: %d enc_id: %d\n",
+						c_conn->base.base.id, c_conn->encoder->base.id);
+				}
+			}
+			rc = count;
+		}
+	}
+
+end:
+	kfree(input);
+	return rc;
+}
+
+static const struct file_operations conn_esd_test_fops = {
+	.open  = _sde_debugfs_conn_esd_test_open,
+	.write = _sde_debugfs_conn_esd_test_write,
+};
+
 static ssize_t _sde_debugfs_conn_cmd_rx_read(struct file *file,
 		char __user *buf, size_t count, loff_t *ppos)
 {
@@ -2090,7 +2494,7 @@ static ssize_t _sde_debugfs_conn_cmd_rx_write(struct file *file,
 }
 
 static const struct file_operations conn_cmd_rx_fops = {
-	.open =         _sde_debugfs_conn_cmd_rx_open,
+	.open =         _sde_debugfs_conn_esd_test_open,
 	.read =         _sde_debugfs_conn_cmd_rx_read,
 	.write =        _sde_debugfs_conn_cmd_rx_write,
 };
@@ -2135,6 +2539,13 @@ static int sde_connector_init_debugfs(struct drm_connector *connector)
 		}
 	}
 
+	if (!debugfs_create_file("esd_test", 0600,
+		connector->debugfs_entry,
+		connector, &conn_esd_test_fops)) {
+		SDE_ERROR("[esd-test]failed to create connector esd_test\n");
+		return -ENOMEM;
+	}
+
 	if (sde_connector->ops.cmd_receive) {
 		if (!debugfs_create_file("rx_cmd", 0600,
 			connector->debugfs_entry,
@@ -2333,6 +2744,7 @@ static void _sde_connector_report_panel_dead(struct sde_connector *conn,
 	bool skip_pre_kickoff)
 {
 	struct drm_event event;
+	struct dsi_display *display = (struct dsi_display *)(conn->display);
 
 	if (!conn)
 		return;
@@ -2342,10 +2754,13 @@ static void _sde_connector_report_panel_dead(struct sde_connector *conn,
 	 * 2) Commit thread (if TE stops coming)
 	 * So such case, avoid failure notification twice.
 	 */
-	if (conn->panel_dead)
+	if (conn->panel_dead) {
+		SDE_INFO("panel_dead is true, return!\n");
 		return;
+	}
 
 	conn->panel_dead = true;
+	display->panel->mi_cfg.panel_dead_flag = true;
 	event.type = DRM_EVENT_PANEL_DEAD;
 	event.length = sizeof(bool);
 	msm_mode_object_event_notify(&conn->base.base,
@@ -2991,3 +3406,119 @@ int sde_connector_event_notify(struct drm_connector *connector, uint32_t type,
 
 	return ret;
 }
+
+int sde_connector_hbm_ctl(struct drm_connector *connector, uint32_t op_code)
+{
+	int ret = 0;
+
+	SDE_ATRACE_BEGIN("sde_connector_hbm_ctl");
+	ret = dsi_display_hbm_set_disp_param(connector, op_code);
+	SDE_ATRACE_END("sde_connector_hbm_ctl");
+	return ret;
+}
+
+int sde_connector_pre_hbm_ctl(struct drm_connector *connector)
+{
+	int ret;
+	/* close dimming */
+	ret = dsi_display_hbm_set_disp_param(connector, DISPPARAM_HBM_BACKLIGHT_RESEND);
+	return ret;
+}
+
+#define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
+
+static uint32_t interpolate(uint32_t x, uint32_t xa, uint32_t xb, uint32_t ya, uint32_t yb)
+{
+	uint32_t bf;
+
+	bf = ya - (ya - yb) * (x - xa) / (xb - xa);
+
+	SDE_DEBUG("backlight brightness:%d, [i-1]bl:%d, [i]bl:%d, [i-1]alpha:%d, [i]alpha:%d, bf:%d",
+			x, xa, xb, ya, yb, bf);
+
+	return bf;
+}
+
+static uint32_t brightness_to_alpha(struct dsi_panel_mi_cfg *mi_cfg, uint32_t brightness)
+{
+	int i;
+	int level = mi_cfg->brightnes_alpha_lut_item_count;
+
+	if (!mi_cfg->brightness_alpha_lut)
+		return 0;
+
+	if (brightness == 0x0)
+		return mi_cfg->brightness_alpha_lut[0].alpha;
+
+	for (i = 0; i < level; i++){
+		if (mi_cfg->brightness_alpha_lut[i].brightness >= brightness)
+			break;
+	}
+
+	if (i == 0)
+		return mi_cfg->brightness_alpha_lut[i].alpha;
+
+	if (i == level)
+		return mi_cfg->brightness_alpha_lut[i - 1].alpha;
+	else
+		return interpolate(brightness,
+							mi_cfg->brightness_alpha_lut[i-1].brightness, mi_cfg->brightness_alpha_lut[i].brightness,
+							mi_cfg->brightness_alpha_lut[i-1].alpha, mi_cfg->brightness_alpha_lut[i].alpha);
+}
+
+void sde_connector_mi_get_current_alpha(struct drm_connector *connector, uint32_t brightness, uint32_t *alpha)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		SDE_ERROR("Invalid connector/encoder/bridge ptr\n");
+		return;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel ptr\n");
+		return;
+	}
+
+	mi_cfg = &display->panel->mi_cfg;
+
+	*alpha = brightness_to_alpha(mi_cfg, brightness);
+	return;
+}
+
+void sde_connector_mi_get_current_backlight(struct drm_connector *connector, uint32_t *brightness)
+{
+	struct sde_connector *c_conn = to_sde_connector(connector);
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		SDE_ERROR("Invalid connector/encoder/bridge ptr\n");
+		return;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel ptr\n");
+		return;
+	}
+
+	if (display->panel->mi_cfg.in_aod) {
+		*brightness = display->panel->mi_cfg.aod_backlight;
+		return;
+	}
+
+	*brightness = c_conn->mi_dimlayer_state.current_backlight;
+}
+
+void sde_connector_mi_update_dimlayer_state(struct drm_connector *connector,
+	enum mi_dimlayer_type mi_dimlayer_type)
+{
+	struct sde_connector *c_conn = to_sde_connector(connector);
+	c_conn->mi_dimlayer_state.mi_dimlayer_type = mi_dimlayer_type;
+}
diff --git a/techpack/display/msm/sde/sde_connector.h b/techpack/display/msm/sde/sde_connector.h
index 1771a36d74ed..ec07849a1a89 100644
--- a/techpack/display/msm/sde/sde_connector.h
+++ b/techpack/display/msm/sde/sde_connector.h
@@ -402,6 +402,21 @@ struct sde_connector_dyn_hdr_metadata {
 	bool dynamic_hdr_update;
 };
 
+enum mi_dimlayer_type {
+	MI_DIMLAYER_NULL = 0x0,
+	MI_DIMLAYER_FOD_HBM_OVERLAY = 0x1,
+	MI_DIMLAYER_FOD_ICON = 0x2,
+	MI_DIMLAYER_AOD = 0x4,
+	MI_FOD_UNLOCK_SUCCESS = 0x8,
+	MI_DIMLAYER_MAX,
+};
+
+struct mi_dimlayer_state
+{
+	enum mi_dimlayer_type mi_dimlayer_type;
+	uint32_t current_backlight;
+};
+
 /**
  * struct sde_connector - local sde connector structure
  * @base: Base drm connector structure
@@ -446,6 +461,7 @@ struct sde_connector_dyn_hdr_metadata {
  * last_cmd_tx_sts: status of the last command transfer
  * @hdr_capable: external hdr support present
  * @core_clk_rate: MDP core clk rate used for dynamic HDR packet calculation
+ * @mi_dimlayer_state: mi dimlayer state
  * @cmd_rx_buf: the return buffer of response of command transfer
  * @rx_len: the length of dcs command received buffer
  */
@@ -483,6 +499,7 @@ struct sde_connector {
 	spinlock_t event_lock;
 
 	struct backlight_device *bl_device;
+	struct sde_clone_cdev *cdev_clone;
 	struct delayed_work status_work;
 	u32 esd_status_interval;
 	bool panel_dead;
@@ -502,6 +519,8 @@ struct sde_connector {
 	bool last_cmd_tx_sts;
 	bool hdr_capable;
 
+	struct mi_dimlayer_state mi_dimlayer_state;
+	u32 fod_frame_count;
 	u8 cmd_rx_buf[MAX_CMD_RECEIVE_SIZE];
 	int rx_len;
 };
@@ -988,5 +1007,22 @@ int sde_connector_get_panel_vfp(struct drm_connector *connector,
  * @connector: Pointer to DRM connector object
  */
 int sde_connector_esd_status(struct drm_connector *connector);
+/**
+ * sde_connector_hbm_ctl - mi function to control hbm
+ * @connector: Pointer to DRM connector object
+ * @op_code: hbm operation code
+ */
+int sde_connector_hbm_ctl(struct drm_connector *connector, uint32_t op_code);
+
+int sde_connector_pre_hbm_ctl(struct drm_connector *connector);
+
+void sde_connector_mi_update_dimlayer_state(struct drm_connector *connector,
+	enum mi_dimlayer_type mi_dimlayer_type);
+
+void sde_connector_mi_get_current_backlight(struct drm_connector *connector, uint32_t *brightness);
+
+void sde_connector_mi_get_current_alpha(struct drm_connector *connector, uint32_t brightness, uint32_t *alpha);
+
+void sde_connector_fod_notify(struct drm_connector *connector);
 
 #endif /* _SDE_CONNECTOR_H_ */
diff --git a/techpack/display/msm/sde/sde_crtc.c b/techpack/display/msm/sde/sde_crtc.c
index cb02fc59ec12..ec84177bda20 100644
--- a/techpack/display/msm/sde/sde_crtc.c
+++ b/techpack/display/msm/sde/sde_crtc.c
@@ -42,9 +42,17 @@
 #include "sde_power_handle.h"
 #include "sde_core_perf.h"
 #include "sde_trace.h"
+#include "xiaomi_frame_stat.h"
+#include "dsi_display.h"
+
+#ifdef CONFIG_DRM_SDE_EXPO
+#include "dsi_display.h"
+#include "dsi_panel.h"
+#endif
 
 #define SDE_PSTATES_MAX (SDE_STAGE_MAX * 4)
 #define SDE_MULTIRECT_PLANE_MAX (SDE_STAGE_MAX * 2)
+#define IDLE_TIMEOUT_DEFAULT (1100)
 
 struct sde_crtc_custom_events {
 	u32 event;
@@ -52,6 +60,8 @@ struct sde_crtc_custom_events {
 			struct sde_irq_callback *irq);
 };
 
+extern struct frame_stat fm_stat;
+
 static int sde_crtc_power_interrupt_handler(struct drm_crtc *crtc_drm,
 	bool en, struct sde_irq_callback *ad_irq);
 static int sde_crtc_idle_interrupt_handler(struct drm_crtc *crtc_drm,
@@ -1474,6 +1484,16 @@ static void _sde_crtc_blend_setup_mixer(struct drm_crtc *crtc,
 		for (i = 0; i < cstate->num_dim_layers; i++)
 			_sde_crtc_setup_dim_layer_cfg(crtc, sde_crtc,
 					mixer, &cstate->dim_layer[i]);
+
+		if (cstate->fod_dim_layer)
+			_sde_crtc_setup_dim_layer_cfg(crtc, sde_crtc,
+					mixer, cstate->fod_dim_layer);
+#ifdef CONFIG_DRM_SDE_EXPO
+		if (cstate->exposure_dim_layer) {
+			_sde_crtc_setup_dim_layer_cfg(crtc, sde_crtc,
+					mixer, cstate->exposure_dim_layer);
+		}
+#endif
 	}
 
 	_sde_crtc_program_lm_output_roi(crtc);
@@ -2206,6 +2226,14 @@ static void sde_crtc_frame_event_cb(void *data, u32 event)
 	kthread_queue_work(&priv->event_thread[crtc_id].worker, &fevent->work);
 }
 
+static void _sde_crtc_mi_update_state(struct sde_crtc_state *cstate, enum mi_dimlayer_type dimlayer_state)
+{
+	int i = 0;
+
+	for (i = 0; i < cstate->num_connectors; i++)
+		sde_connector_mi_update_dimlayer_state(cstate->connectors[i], dimlayer_state);
+}
+
 void sde_crtc_prepare_commit(struct drm_crtc *crtc,
 		struct drm_crtc_state *old_state)
 {
@@ -2437,11 +2465,13 @@ static void sde_crtc_frame_event_work(struct kthread_work *work)
 		SDE_ATRACE_END("signal_release_fence");
 	}
 
-	if (fevent->event & SDE_ENCODER_FRAME_EVENT_SIGNAL_RETIRE_FENCE)
+	if (fevent->event & SDE_ENCODER_FRAME_EVENT_SIGNAL_RETIRE_FENCE) {
 		/* this api should be called without spin_lock */
 		_sde_crtc_retire_event(fevent->connector, fevent->ts,
 				(fevent->event & SDE_ENCODER_FRAME_EVENT_ERROR)
 				? SDE_FENCE_SIGNAL_ERROR : SDE_FENCE_SIGNAL);
+		frame_stat_collector(0, RETIRE_FENCE_TS);
+	}
 
 	if (fevent->event & SDE_ENCODER_FRAME_EVENT_PANEL_DEAD)
 		SDE_ERROR("crtc%d ts:%lld received panel dead event\n",
@@ -2498,6 +2528,7 @@ void _sde_crtc_clear_dim_layers_v1(struct drm_crtc_state *state)
 		memset(&cstate->dim_layer[i], 0, sizeof(cstate->dim_layer[i]));
 
 	cstate->num_dim_layers = 0;
+	cstate->num_dim_layers_bank = 0;
 }
 
 /**
@@ -2546,6 +2577,7 @@ static void _sde_crtc_set_dim_layer_v1(struct drm_crtc *crtc,
 
 	/* populate from user space */
 	cstate->num_dim_layers = count;
+	cstate->num_dim_layers_bank = count;
 	for (i = 0; i < count; i++) {
 		user_cfg = &dim_layer_v1.layer_cfg[i];
 
@@ -2578,6 +2610,51 @@ static void _sde_crtc_set_dim_layer_v1(struct drm_crtc *crtc,
 	}
 }
 
+#ifdef CONFIG_DRM_SDE_EXPO
+static int sde_crtc_config_exposure_dim_layer(struct drm_crtc_state *crtc_state, int stage)
+{
+	struct sde_kms *kms;
+	struct sde_hw_dim_layer *dim_layer;
+	struct sde_crtc_state *cstate = to_sde_crtc_state(crtc_state);
+	struct drm_display_mode *mode = &crtc_state->adjusted_mode;
+	int alpha = sde_crtc_get_property(cstate, CRTC_PROP_DIM_LAYER_EXPO);
+
+	kms = _sde_crtc_get_kms(crtc_state->crtc);
+	if (!kms || !kms->catalog) {
+		return -EINVAL;
+	}
+
+	if (cstate->num_dim_layers == SDE_MAX_DIM_LAYERS - 1) {
+		pr_err("failed to get available dim layer for exposure\n");
+		return -EINVAL;
+	}
+
+	if (!alpha) {
+		cstate->exposure_dim_layer = NULL;
+		return 0;
+	}
+
+	if ((stage + SDE_STAGE_0) >= kms->catalog->mixer[0].sblk->maxblendstages) {
+		return -EINVAL;
+	}
+
+	dim_layer = &cstate->dim_layer[cstate->num_dim_layers];
+	dim_layer->flags = SDE_DRM_DIM_LAYER_INCLUSIVE;
+	dim_layer->stage = stage + SDE_STAGE_0;
+
+	dim_layer->rect.x = 0;
+	dim_layer->rect.y = 0;
+	dim_layer->rect.w = mode->hdisplay;
+	dim_layer->rect.h = mode->vdisplay;
+	dim_layer->color_fill = (struct sde_mdss_color) {0, 0, 0, alpha};
+	cstate->exposure_dim_layer = dim_layer;
+
+	dim_layer->flags = SDE_CRTC_DIRTY_DIM_LAYER_EXPO;
+
+	return 0;
+}
+#endif
+
 /**
  * _sde_crtc_set_dest_scaler - copy dest scaler settings from userspace
  * @sde_crtc   :  Pointer to sde crtc
@@ -3214,11 +3291,21 @@ static void sde_crtc_atomic_begin(struct drm_crtc *crtc,
 	_sde_crtc_blend_setup(crtc, old_state, true);
 	_sde_crtc_dest_scaler_setup(crtc);
 
+	if (g_panel->mi_cfg.smart_fps_support
+		&& sde_encoder_check_curr_mode(sde_crtc->mixers[0].encoder,
+					MSM_DISPLAY_CMD_MODE) &&
+		kthread_cancel_delayed_work_sync(&sde_crtc->idle_notify_work_cmd_mode)) {
+		pr_debug("idle notify work cancelled");
+	}
+
 	/* cancel the idle notify delayed work */
 	if (sde_encoder_check_curr_mode(sde_crtc->mixers[0].encoder,
 					MSM_DISPLAY_VIDEO_MODE) &&
-		kthread_cancel_delayed_work_sync(&sde_crtc->idle_notify_work))
+		kthread_cancel_delayed_work_sync(&sde_crtc->idle_notify_work)) {
 		SDE_DEBUG("idle notify work cancelled\n");
+	}
+
+	fm_stat.idle_status = false;
 
 	/*
 	 * Since CP properties use AXI buffer to program the
@@ -3262,6 +3349,10 @@ static void sde_crtc_atomic_flush(struct drm_crtc *crtc,
 	struct sde_crtc_state *cstate;
 	struct sde_kms *sde_kms;
 	int idle_time = 0;
+	static bool idle_time_enable = false;
+	ktime_t get_input_fence_ts;
+	ktime_t now;
+	s64 duration;
 
 	if (!crtc || !crtc->dev || !crtc->dev->dev_private) {
 		SDE_ERROR("invalid crtc\n");
@@ -3299,6 +3390,11 @@ static void sde_crtc_atomic_flush(struct drm_crtc *crtc,
 
 	event_thread = &priv->event_thread[crtc->index];
 	idle_time = sde_crtc_get_property(cstate, CRTC_PROP_IDLE_TIMEOUT);
+	if (!idle_time && idle_time_enable) {
+		idle_time = IDLE_TIMEOUT_DEFAULT;
+		idle_time_enable = false;
+	} else
+		idle_time_enable = true;
 
 	/*
 	 * If no mixers has been allocated in sde_crtc_atomic_check(),
@@ -3329,7 +3425,20 @@ static void sde_crtc_atomic_flush(struct drm_crtc *crtc,
 	}
 
 	/* wait for acquire fences before anything else is done */
+	now = ktime_get();
 	_sde_crtc_wait_for_fences(crtc);
+	get_input_fence_ts = ktime_get();
+	duration = ktime_to_ns(ktime_sub(get_input_fence_ts, now));
+	frame_stat_collector(duration, GET_INPUT_FENCE_TS);
+
+	if(g_panel->mi_cfg.smart_fps_support
+		&& sde_encoder_check_curr_mode(sde_crtc->mixers[0].encoder,
+							MSM_DISPLAY_CMD_MODE)) {
+		kthread_queue_delayed_work(&event_thread->worker,
+					&sde_crtc->idle_notify_work_cmd_mode,
+					msecs_to_jiffies(IDLE_TIMEOUT_DEFAULT));
+		pr_debug("schedule idle notify work\n");
+	}
 
 	/* schedule the idle notify delayed work */
 	if (idle_time && sde_encoder_check_curr_mode(
@@ -3588,6 +3697,7 @@ void sde_crtc_commit_kickoff(struct drm_crtc *crtc,
 	unsigned long flags;
 	enum sde_crtc_idle_pc_state idle_pc_state;
 	struct sde_encoder_kickoff_params params = { 0 };
+	uint32_t fod_sync_info;
 
 	if (!crtc) {
 		SDE_ERROR("invalid argument\n");
@@ -3617,6 +3727,9 @@ void sde_crtc_commit_kickoff(struct drm_crtc *crtc,
 
 	idle_pc_state = sde_crtc_get_property(cstate, CRTC_PROP_IDLE_PC_STATE);
 
+	fod_sync_info = sde_crtc_get_mi_fod_sync_info(cstate);
+	_sde_crtc_mi_update_state(cstate, fod_sync_info);
+
 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 		if (encoder->crtc != crtc)
 			continue;
@@ -4456,6 +4569,86 @@ static int _sde_crtc_check_secure_state_smmu_translation(struct drm_crtc *crtc,
 	return -EINVAL;
 }
 
+static struct sde_hw_dim_layer* sde_crtc_setup_fod_dim_layer(
+		struct sde_crtc_state *cstate,
+		uint32_t stage)
+{
+	struct drm_crtc_state *crtc_state = &cstate->base;
+	struct drm_display_mode *mode = &crtc_state->adjusted_mode;
+	struct sde_hw_dim_layer *dim_layer = NULL;
+	struct dsi_display *display;
+	struct sde_kms *kms;
+	uint32_t layer_stage;
+	uint32_t alpha;
+
+	kms = _sde_crtc_get_kms(crtc_state->crtc);
+	if (!kms || !kms->catalog) {
+		SDE_ERROR("Invalid kms\n");
+		goto error;
+	}
+
+	layer_stage = SDE_STAGE_0 + stage;
+	if (layer_stage >= kms->catalog->mixer[0].sblk->maxblendstages) {
+		SDE_ERROR("Stage too large %u vs max %u\n", layer_stage,
+			kms->catalog->mixer[0].sblk->maxblendstages);
+		goto error;
+	}
+
+	if (cstate->num_dim_layers == SDE_MAX_DIM_LAYERS) {
+		SDE_ERROR("Max dim layers reached\n");
+		goto error;
+	}
+
+	display = get_main_display();
+	if (!display || !display->panel) {
+		SDE_ERROR("Invalid primary display\n");
+		goto error;
+	}
+
+	mutex_lock(&display->panel->panel_lock);
+	alpha = dsi_panel_get_fod_dim_alpha(display->panel);
+	mutex_unlock(&display->panel->panel_lock);
+
+	dim_layer = &cstate->dim_layer[cstate->num_dim_layers];
+	dim_layer->flags = SDE_DRM_DIM_LAYER_INCLUSIVE;
+	dim_layer->stage = layer_stage;
+	dim_layer->rect.x = 0;
+	dim_layer->rect.y = 0;
+	dim_layer->rect.w = mode->hdisplay;
+	dim_layer->rect.h = mode->vdisplay;
+	dim_layer->color_fill =
+			(struct sde_mdss_color) {0, 0, 0, alpha};
+
+error:
+	return dim_layer;
+}
+
+static void sde_crtc_fod_atomic_check(struct sde_crtc_state *cstate,
+		struct plane_state *pstates, int cnt)
+{
+	uint32_t dim_layer_stage;
+	int plane_idx;
+
+	for (plane_idx = 0; plane_idx < cnt; plane_idx++)
+		if (sde_plane_is_fod_layer(pstates[plane_idx].drm_pstate))
+			break;
+
+	if (plane_idx == cnt) {
+		cstate->fod_dim_layer = NULL;
+	} else {
+		dim_layer_stage = pstates[plane_idx].stage;
+		cstate->fod_dim_layer = sde_crtc_setup_fod_dim_layer(cstate,
+				dim_layer_stage);
+	}
+
+	if (!cstate->fod_dim_layer)
+		return;
+
+	for (plane_idx = 0; plane_idx < cnt; plane_idx++)
+		if (pstates[plane_idx].stage >= dim_layer_stage)
+			pstates[plane_idx].stage++;
+}
+
 static int _sde_crtc_check_secure_conn(struct drm_crtc *crtc,
 		struct drm_crtc_state *state, uint32_t fb_sec)
 {
@@ -4702,6 +4895,34 @@ static int _sde_crtc_check_get_pstates(struct drm_crtc *crtc,
 	return rc;
 }
 
+#ifdef CONFIG_DRM_SDE_EXPO
+static int sde_crtc_exposure_atomic_check(struct sde_crtc_state *cstate,
+		struct plane_state *pstates, int cnt)
+{
+	int i, zpos = 0;
+	struct dsi_display *dsi_display = get_main_display();
+	struct dsi_panel *panel = dsi_display->panel;
+
+	if (!panel->dimlayer_exposure) {
+		cstate->exposure_dim_layer = NULL;
+		return 0;
+	}
+
+	for (i = 0; i < cnt; i++) {
+		if (pstates[i].stage > zpos)
+			zpos = pstates[i].stage;
+	}
+	zpos++;
+
+	if (sde_crtc_config_exposure_dim_layer(&cstate->base, zpos)) {
+		SDE_ERROR("Failed to config dim layer\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
 static int _sde_crtc_check_zpos(struct drm_crtc_state *state,
 		struct sde_crtc *sde_crtc,
 		struct plane_state *pstates,
@@ -4798,6 +5019,23 @@ static int _sde_crtc_atomic_check_pstates(struct drm_crtc *crtc,
 			plane, multirect_plane, &cnt);
 	if (rc)
 		return rc;
+#if 0
+	/*
+	 * mi layer check
+	 *   need execute only sde_enc->disp_info.is_primary is true
+	*/
+	rc = sde_crtc_mi_atomic_check(sde_crtc, cstate, (void *)pstates, cnt);
+	if (rc)
+		return rc;
+#endif
+
+	sde_crtc_fod_atomic_check(cstate, pstates, cnt);
+
+#ifdef CONFIG_DRM_SDE_EXPO
+	rc = sde_crtc_exposure_atomic_check(cstate, pstates, cnt);
+	if (rc)
+		return rc;
+#endif
 
 	/* assign mixer stages based on sorted zpos property */
 	rc = _sde_crtc_check_zpos(state, sde_crtc, pstates, cstate, mode, cnt);
@@ -4921,6 +5159,157 @@ static int sde_crtc_atomic_check(struct drm_crtc *crtc,
 	return rc;
 }
 
+static uint32_t get_current_brightness(struct sde_crtc_state *cstate)
+{
+	int i;
+	uint32_t brightness;
+	for (i = 0; i < cstate->num_connectors; i++) {
+		sde_connector_mi_get_current_backlight(cstate->connectors[i], &brightness);
+	}
+	return brightness;
+}
+
+static uint32_t get_current_alpha(struct sde_crtc_state *cstate, uint32_t brightness)
+{
+	int i;
+	uint32_t alpha;
+	for (i = 0; i < cstate->num_connectors; i++) {
+		sde_connector_mi_get_current_alpha(cstate->connectors[i], brightness, &alpha);
+	}
+	return alpha;
+}
+
+static uint32_t _sde_crtc_config_mi_dim_layer_lapha(struct sde_crtc_state *cstate)
+{
+	uint32_t alpha, current_brightness;
+
+	current_brightness = get_current_brightness(cstate);
+	if(cstate->mi_state.dimlayer_backlight_stash == current_brightness)
+		return cstate->mi_state.dimlayer_alpha_stash;
+
+	alpha = get_current_alpha(cstate, current_brightness) & 0x000000FF;
+	cstate->mi_state.dimlayer_backlight_stash = current_brightness;
+	cstate->mi_state.dimlayer_alpha_stash = alpha;
+
+	return alpha;
+}
+
+void _sde_crtc_config_mi_dim_layer(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+				struct drm_crtc_state *drm_state, uint32_t dim_layer_stage)
+{
+	uint32_t alpha;
+	struct sde_hw_mixer *lm;
+	struct sde_crtc_mixer *mixer;
+	struct drm_display_mode *display_mode = &drm_state->adjusted_mode;
+	alpha = _sde_crtc_config_mi_dim_layer_lapha(cstate);
+	mixer = sde_crtc->mixers;
+	lm = mixer->hw_lm;
+
+	cstate->mi_state.mi_dim_layer = cstate->dim_layer;
+	if (lm && lm->ops.setup_dim_layer) {
+		if (cstate->num_dim_layers_bank <= SDE_MAX_DIM_LAYERS) {
+			cstate->dim_layer[cstate->num_dim_layers_bank].flags = SDE_DRM_DIM_LAYER_INCLUSIVE;
+			cstate->dim_layer[cstate->num_dim_layers_bank].stage = dim_layer_stage + SDE_STAGE_0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.x = 0x0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.y = 0x0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.w = display_mode->hdisplay;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.h = display_mode->vdisplay;
+			cstate->dim_layer[cstate->num_dim_layers_bank].color_fill = (struct sde_mdss_color) {0x0, 0x0, 0x0, alpha};
+			cstate->num_dim_layers = cstate->num_dim_layers_bank + 1;
+			_sde_crtc_mi_update_state(cstate, MI_DIMLAYER_FOD_ICON);
+		} else {
+			SDE_ERROR("invalid number of dim_layers:%d", cstate->num_dim_layers);
+		}
+	}
+}
+
+int sde_crtc_mi_atomic_check(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+		void *pstates, int cnt)
+{
+	uint32_t i;
+	uint32_t mi_plane;
+
+	uint32_t dim_layer_stage = 0x0;
+	uint32_t mi_aodlayer_index = 0x0;
+	uint32_t mi_iconlayer_index = 0x0;
+	uint32_t mi_pressed_Iconlayer_index = 0x0;
+	bool mi_dimlayer_switch_enable = true;
+	int max_stage = 0;
+	struct plane_state *pstates_ = (struct plane_state *)pstates;
+
+	/* dimlayer switch for FOD and DC function */
+	if (!mi_dimlayer_switch_enable)
+		return 0;
+
+	for (i = 0; i < cnt; i++) {
+		mi_plane = sde_plane_get_mi_layer_info(pstates_[i].drm_pstate);
+
+		switch (mi_plane) {
+		case MI_LAYER_FOD_HBM_OVERLAY:
+			mi_pressed_Iconlayer_index = i;
+			break;
+		case MI_LAYER_FOD_ICON:
+			mi_iconlayer_index = i;
+			break;
+		case MI_LAYER_AOD:
+			mi_aodlayer_index = i;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* Create mi dim layer under index layer */
+	if (mi_pressed_Iconlayer_index > 0) {
+		dim_layer_stage = pstates_[mi_pressed_Iconlayer_index].stage;
+		for (i = 0; i < cnt; i++) {
+			if (pstates_[i].stage >= dim_layer_stage) {
+				pstates_[i].stage++;
+				pstates_[i].sde_pstate->stage++;
+				if (pstates_[i].stage > max_stage)
+					max_stage = pstates_[i].stage;
+			}
+		}
+
+		/* do not use same stage */
+		for (i = 0; i < cstate->num_dim_layers; i++) {
+			if (cstate->dim_layer[i].stage >= dim_layer_stage &&
+				cstate->dim_layer[i].stage <= max_stage)
+				cstate->dim_layer[i].stage++;
+		}
+	} else if ((mi_iconlayer_index > 0)) {
+		for (i = 0; i < cnt; i++) {
+			if (pstates_[i].stage > dim_layer_stage)
+				dim_layer_stage = pstates_[i].stage;
+		}
+
+		/* do not use same stage */
+		for (i = 0; i < cstate->num_dim_layers; i++) {
+			if (cstate->dim_layer[i].stage > dim_layer_stage )
+				cstate->dim_layer[i].stage = dim_layer_stage++;
+		}
+
+		dim_layer_stage++;
+	}
+
+	if (dim_layer_stage > SDE_STAGE_MAX - SDE_STAGE_0) {
+		SDE_ERROR(" > %d plane stages assigned\n", SDE_STAGE_MAX - SDE_STAGE_0);
+		return 0;
+	 }
+
+	if (dim_layer_stage > 0x0 && cstate->mi_state.mi_dim_layer == NULL) {
+		SDE_ATRACE_BEGIN("dimlayer_show");
+		_sde_crtc_config_mi_dim_layer(sde_crtc, cstate, &cstate->base, dim_layer_stage);
+		SDE_ATRACE_END("dimlayer_show");
+	} else {
+		cstate->mi_state.mi_dim_layer = NULL;
+		_sde_crtc_mi_update_state(cstate, MI_DIMLAYER_NULL);
+	}
+
+	return 0;
+}
+
 /**
  * sde_crtc_get_num_datapath - get the number of datapath active
  *				of primary connector
@@ -5072,6 +5461,10 @@ static void sde_crtc_install_properties(struct drm_crtc *crtc,
 		return;
 	}
 
+	/* mi properties */
+	msm_property_install_range(&sde_crtc->property_info, "mi_fod_sync_info",
+		0x0, 0, U32_MAX, 0, CRCT_PROP_MI_FOD_SYNC_INFO);
+
 	/* range properties */
 	msm_property_install_range(&sde_crtc->property_info,
 		"input_fence_timeout", 0x0, 0, SDE_CRTC_MAX_INPUT_FENCE_TIMEOUT,
@@ -5080,6 +5473,11 @@ static void sde_crtc_install_properties(struct drm_crtc *crtc,
 	msm_property_install_volatile_range(&sde_crtc->property_info,
 		"output_fence", 0x0, 0, ~0, 0, CRTC_PROP_OUTPUT_FENCE);
 
+#ifdef CONFIG_DRM_SDE_EXPO
+	msm_property_install_volatile_range(&sde_crtc->property_info,
+			"dim_layer_exposure", 0x0, 0, ~0, 0, CRTC_PROP_DIM_LAYER_EXPO);
+#endif
+
 	msm_property_install_range(&sde_crtc->property_info,
 			"output_fence_offset", 0x0, 0, 1, 0,
 			CRTC_PROP_OUTPUT_FENCE_OFFSET);
@@ -6257,11 +6655,25 @@ static void __sde_crtc_idle_notify_work(struct kthread_work *work)
 		event.length = sizeof(u32);
 		msm_mode_object_event_notify(&crtc->base, crtc->dev,
 				&event, (u8 *)&ret);
-
+		fm_stat.idle_status = true;
 		SDE_DEBUG("crtc[%d]: idle timeout notified\n", crtc->base.id);
 	}
 }
 
+static void __sde_crtc_idle_notify_work_cmd_mode(struct kthread_work *work)
+{
+	struct sde_crtc *sde_crtc = container_of(work, struct sde_crtc,
+				idle_notify_work_cmd_mode.work);
+
+	if (!sde_crtc) {
+		SDE_ERROR("invalid sde crtc\n");
+	} else {
+		fm_stat.idle_status = true;
+		calc_fps(0,0);
+		pr_debug("idle timeout notified cmd mode\n");
+	}
+}
+
 /* initialize crtc */
 struct drm_crtc *sde_crtc_init(struct drm_device *dev, struct drm_plane *plane)
 {
@@ -6354,6 +6766,8 @@ struct drm_crtc *sde_crtc_init(struct drm_device *dev, struct drm_plane *plane)
 
 	kthread_init_delayed_work(&sde_crtc->idle_notify_work,
 					__sde_crtc_idle_notify_work);
+	kthread_init_delayed_work(&sde_crtc->idle_notify_work_cmd_mode,
+					__sde_crtc_idle_notify_work_cmd_mode);
 
 	SDE_DEBUG("crtc=%d new_llcc=%d, old_llcc=%d\n",
 		crtc->base.id,
@@ -6585,6 +6999,14 @@ static int sde_crtc_idle_interrupt_handler(struct drm_crtc *crtc_drm,
 	return 0;
 }
 
+uint32_t sde_crtc_get_mi_fod_sync_info(struct sde_crtc_state *cstate)
+{
+	if (!cstate)
+		return 0;
+
+	return sde_crtc_get_property(cstate, CRCT_PROP_MI_FOD_SYNC_INFO);;
+}
+
 /**
  * sde_crtc_update_cont_splash_settings - update mixer settings
  *	and initial clk during device bootup for cont_splash use case
diff --git a/techpack/display/msm/sde/sde_crtc.h b/techpack/display/msm/sde/sde_crtc.h
index c18421708447..85e4ab8e0f32 100644
--- a/techpack/display/msm/sde/sde_crtc.h
+++ b/techpack/display/msm/sde/sde_crtc.h
@@ -352,6 +352,7 @@ struct sde_crtc {
 	bool misr_enable_debugfs;
 	u32 misr_frame_count;
 	struct kthread_delayed_work idle_notify_work;
+	struct kthread_delayed_work idle_notify_work_cmd_mode;
 
 	struct sde_power_event *power_event;
 
@@ -383,8 +384,58 @@ struct sde_crtc {
 	struct drm_property_blob *dspp_blob_info;
 };
 
+#ifdef CONFIG_DRM_SDE_EXPO
+enum sde_crtc_dirty_flags {
+	SDE_CRTC_DIRTY_DIM_LAYER_EXPO,
+};
+#endif
+
 #define to_sde_crtc(x) container_of(x, struct sde_crtc, base)
 
+/**
+ * enum sde_crtc_mi_layer_type: type of mi layer
+ * @MI_LAYER_FOD_PRESSED_ICON: FOD touched icon layer
+ * @MI_LAYER_FOD_ICON: FOD untouch icon layer
+ * @MI_LAYER_AOD: AOD layer
+ */
+enum sde_crtc_mi_layer_type {
+	MI_LAYER_NULL = 0x0,
+	MI_LAYER_FOD_HBM_OVERLAY = 0x1,
+	MI_LAYER_FOD_ICON = 0x2,
+	MI_LAYER_AOD = 0x4,
+	MI_LAYER_MAX,
+};
+
+/**
+ * sde_crtc_mi_dc_backlight - mi dc backlight
+ * @mi_dc_bl_state: dc backlihgt state
+ * @mi_dc_backlight_level: last backlight stash
+ * @mi_dc_layer_alpha: dc dim layer alpha
+ */
+typedef struct sde_crtc_mi_dc_backlight
+{
+	uint8_t mi_dc_bl_state;
+	int32_t mi_dc_bl_level;
+	int32_t mi_dc_bl_layer_alpha;
+} sde_crtc_mi_dc_backlight;
+
+typedef struct sde_crtc_mi_layer
+{
+	int32_t layer_index;
+	enum sde_crtc_mi_layer_type last_state;
+} sde_crtc_mi_layer;
+
+/**
+ * sde_crtc_mi_state - mi crtc state
+ * @mi_dim_layer: dim layer added by Mi
+ */
+struct sde_crtc_mi_state {
+	struct sde_hw_dim_layer *mi_dim_layer;
+	struct sde_crtc_mi_layer mi_layer;
+	uint32_t dimlayer_backlight_stash;
+	uint8_t  dimlayer_alpha_stash;
+};
+
 /**
  * struct sde_crtc_state - sde container for atomic crtc state
  * @base: Base drm crtc state structure
@@ -413,6 +464,7 @@ struct sde_crtc {
  * @scl3_lut_cfg: QSEED3 lut config
  * @new_perf: new performance state being requested
  * @secure_session: Indicates the type of secure session
+ * @mi_state: Mi part of crtc state
  */
 struct sde_crtc_state {
 	struct drm_crtc_state base;
@@ -435,6 +487,7 @@ struct sde_crtc_state {
 	uint64_t input_fence_timeout_ns;
 	uint32_t num_dim_layers;
 	struct sde_hw_dim_layer dim_layer[SDE_MAX_DIM_LAYERS];
+	struct sde_hw_dim_layer *fod_dim_layer;
 	uint32_t num_ds;
 	uint32_t num_ds_enabled;
 	bool ds_dirty;
@@ -443,6 +496,13 @@ struct sde_crtc_state {
 
 	struct sde_core_perf_params new_perf;
 	int secure_session;
+	/* Mi crtc state */
+	struct sde_crtc_mi_state mi_state;
+	uint32_t num_dim_layers_bank;
+
+#ifdef CONFIG_DRM_SDE_EXPO
+	struct sde_hw_dim_layer *exposure_dim_layer;
+#endif
 };
 
 enum sde_crtc_irq_state {
@@ -864,6 +924,25 @@ void sde_crtc_misr_setup(struct drm_crtc *crtc, bool enable, u32 frame_count);
 void sde_crtc_get_misr_info(struct drm_crtc *crtc,
 		struct sde_crtc_misr_info *crtc_misr_info);
 
+/**
+ * sde_crtc_mi_atomic_check - to do crtc mi atomic check
+ * @crtc: Pointer to sde crtc state structure
+ * @cstate: Pointer to sde crtc state structure
+ * @pstates: Pointer to sde plane state structure
+ * @cnt: plane refence count
+ */
+int sde_crtc_mi_atomic_check(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+		void *pstates, int cnt);
+
+/**
+ * sde_crtc_mi_atomic_check - to do crtc mi atomic check
+ * @crtc: Pointer to sde crtc state structure
+ * @cstate: Pointer to sde crtc state structure
+ * @pstates: Pointer to sde plane state structure
+ * @cnt: plane refence count
+ */
+uint32_t sde_crtc_get_mi_fod_sync_info(struct sde_crtc_state *cstate);
+
 /**
  * sde_crtc_get_num_datapath - get the number of datapath active
  *				of primary connector
diff --git a/techpack/display/msm/sde/sde_encoder.c b/techpack/display/msm/sde/sde_encoder.c
index cbb8b5b87bbc..7f99f8f384b2 100644
--- a/techpack/display/msm/sde/sde_encoder.c
+++ b/techpack/display/msm/sde/sde_encoder.c
@@ -40,6 +40,10 @@
 #include "sde_core_irq.h"
 #include "sde_hw_top.h"
 #include "sde_hw_qdss.h"
+#include "dsi_display.h"
+#include "dsi_panel_mi.h"
+#include "dsi_drm.h"
+#include "xiaomi_frame_stat.h"
 
 #define SDE_DEBUG_ENC(e, fmt, ...) SDE_DEBUG("enc%d " fmt,\
 		(e) ? (e)->base.base.id : -1, ##__VA_ARGS__)
@@ -87,6 +91,7 @@
 		(msm_is_mode_seamless_dms(adj_mode) || \
 		(msm_is_mode_seamless_dyn_clk(adj_mode) && \
 		is_cmd_mode) || msm_is_mode_seamless_poms(adj_mode))
+extern struct frame_stat fm_stat;
 
 /**
  * enum sde_enc_rc_events - events for resource control state machine
@@ -283,6 +288,7 @@ struct sde_encoder_virt {
 	struct kthread_delayed_work delayed_off_work;
 	struct kthread_work vsync_event_work;
 	struct kthread_work input_event_work;
+	struct kthread_work touch_notify_work;
 	struct kthread_work esd_trigger_work;
 	struct input_handler *input_handler;
 	bool input_handler_registered;
@@ -2318,6 +2324,8 @@ static void sde_encoder_input_event_handler(struct input_handle *handle,
 		return;
 	}
 
+	SDE_DEBUG("%s: type[%d] code[%d] value[%d]\n", __func__, type, code, value);
+
 	drm_enc = (struct drm_encoder *)handle->handler->private;
 	if (!drm_enc->dev || !drm_enc->dev->dev_private) {
 		SDE_ERROR("invalid parameters\n");
@@ -2338,9 +2346,13 @@ static void sde_encoder_input_event_handler(struct input_handle *handle,
 	SDE_EVT32_VERBOSE(DRMID(drm_enc));
 
 	disp_thread = &priv->disp_thread[sde_enc->crtc->index];
-
 	kthread_queue_work(&disp_thread->worker,
-				&sde_enc->input_event_work);
+				&sde_enc->touch_notify_work);
+
+	/* Only consider EV_ABS (touch) events in QC original design */
+	if (type == EV_ABS && sde_encoder_check_curr_mode(drm_enc, MSM_DISPLAY_CMD_MODE))
+		kthread_queue_work(&disp_thread->worker,
+					&sde_enc->input_event_work);
 }
 
 void sde_encoder_control_idle_pc(struct drm_encoder *drm_enc, bool enable)
@@ -3150,6 +3162,8 @@ static int _sde_encoder_input_connect(struct input_handler *handler,
 		goto error_unregister;
 	}
 
+	SDE_EVT32(handle, SDE_EVTLOG_FUNC_ENTRY);
+
 	return 0;
 
 error_unregister:
@@ -3163,9 +3177,10 @@ static int _sde_encoder_input_connect(struct input_handler *handler,
 
 static void _sde_encoder_input_disconnect(struct input_handle *handle)
 {
-	 input_close_device(handle);
-	 input_unregister_handle(handle);
-	 kfree(handle);
+	SDE_EVT32(handle, SDE_EVTLOG_FUNC_EXIT);
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
 }
 
 /**
@@ -3181,6 +3196,10 @@ static const struct input_device_id sde_input_ids[] = {
 					BIT_MASK(ABS_MT_POSITION_X) |
 					BIT_MASK(ABS_MT_POSITION_Y) },
 	},
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
 	{ },
 };
 
@@ -3190,8 +3209,10 @@ static void _sde_encoder_input_handler_register(
 	struct sde_encoder_virt *sde_enc = to_sde_encoder_virt(drm_enc);
 	int rc;
 
+#if 0
 	if (!sde_encoder_check_curr_mode(drm_enc, MSM_DISPLAY_CMD_MODE))
 		return;
+#endif
 
 	if (sde_enc->input_handler && !sde_enc->input_handler->private) {
 		sde_enc->input_handler->private = sde_enc;
@@ -3757,6 +3778,7 @@ static void sde_encoder_underrun_callback(struct drm_encoder *drm_enc,
 		atomic_read(&phy_enc->underrun_cnt));
 
 	SDE_DBG_CTRL("stop_ftrace");
+	SDE_ERROR("underrun: %d\n", atomic_read(&phy_enc->underrun_cnt));
 	SDE_DBG_CTRL("panic_underrun");
 
 	SDE_ATRACE_END("encoder_underrun_callback");
@@ -4484,11 +4506,34 @@ static void _sde_encoder_setup_dither(struct sde_encoder_phys *phys)
 	struct msm_display_dsc_info *dsc = NULL;
 	struct sde_encoder_virt *sde_enc;
 	struct sde_hw_pingpong *hw_pp;
+	struct dsi_display *dsi_display;
+	struct sde_connector *c_conn;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
 	if (!phys || !phys->connector || !phys->hw_pp ||
 			!phys->hw_pp->ops.setup_dither || !phys->parent)
 		return;
 
+	c_conn = to_sde_connector(phys->connector);
+	if(c_conn->connector_type != DRM_MODE_CONNECTOR_DSI){
+		SDE_DEBUG("connector type is not  dsi, return\n");
+		return;
+	}
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return;
+	}
+
+	mi_cfg = &dsi_display->panel->mi_cfg;
+	if (!mi_cfg) {
+		SDE_ERROR("invalid mi_cfg\n");
+		return;
+	}
+
+	if (!mi_cfg->dither_enabled)
+		return;
+
 	topology = sde_connector_get_topology_name(phys->connector);
 	if ((topology == SDE_RM_TOPOLOGY_PPSPLIT) &&
 			(phys->split_role == ENC_ROLE_SLAVE))
@@ -4646,6 +4691,34 @@ static void sde_encoder_input_event_work_handler(struct kthread_work *work)
 			SDE_ENC_RC_EVENT_EARLY_WAKEUP);
 }
 
+static void sde_encoder_touch_notify_work_handler(struct kthread_work *work)
+{
+	struct dsi_bridge *c_bridge = NULL;
+	struct dsi_display *dsi_display = NULL;
+	struct drm_encoder *drm_enc = NULL;
+	struct sde_encoder_virt *sde_enc = container_of(work,
+				struct sde_encoder_virt, touch_notify_work);
+
+	if (!sde_enc) {
+		SDE_ERROR("invalid encoder for the touch notify\n");
+		return;
+	}
+
+	drm_enc = &sde_enc->base;
+
+	c_bridge = container_of(drm_enc->bridge, struct dsi_bridge, base);
+	if (c_bridge)
+		dsi_display = c_bridge->display;
+
+	if (dsi_display && dsi_display->is_prim_display && dsi_display->panel
+		&& dsi_display->panel->mi_cfg.smart_fps_restore) {
+		if (dsi_display->panel->mi_cfg.smart_fps_support && fm_stat.enabled) {
+			calc_fps(0, (int)true);
+			dsi_display->panel->mi_cfg.smart_fps_restore = false;
+		}
+	}
+}
+
 static void sde_encoder_vsync_event_work_handler(struct kthread_work *work)
 {
 	struct sde_encoder_virt *sde_enc = container_of(work,
@@ -5066,32 +5139,6 @@ void sde_encoder_kickoff(struct drm_encoder *drm_enc, bool is_error)
 	SDE_ATRACE_END("encoder_kickoff");
 }
 
-void sde_encoder_helper_get_pp_line_count(struct drm_encoder *drm_enc,
-			struct sde_hw_pp_vsync_info *info)
-{
-	struct sde_encoder_virt *sde_enc;
-	struct sde_encoder_phys *phys;
-	int i, ret;
-
-	if (!drm_enc || !info)
-		return;
-
-	sde_enc = to_sde_encoder_virt(drm_enc);
-
-	for (i = 0; i < sde_enc->num_phys_encs; i++) {
-		phys = sde_enc->phys_encs[i];
-		if (phys && phys->hw_intf && phys->hw_pp
-				&& phys->hw_intf->ops.get_vsync_info) {
-			ret = phys->hw_intf->ops.get_vsync_info(
-						phys->hw_intf, &info[i]);
-			if (!ret) {
-				info[i].pp_idx = phys->hw_pp->idx - PINGPONG_0;
-				info[i].intf_idx = phys->hw_intf->idx - INTF_0;
-			}
-		}
-	}
-}
-
 int sde_encoder_helper_reset_mixers(struct sde_encoder_phys *phys_enc,
 		struct drm_framebuffer *fb)
 {
@@ -5822,7 +5869,7 @@ struct drm_encoder *sde_encoder_init_with_ops(
 		sde_enc->rsc_client = NULL;
 	}
 
-	if (disp_info->capabilities & MSM_DISPLAY_CAP_CMD_MODE) {
+	if (disp_info->capabilities & (MSM_DISPLAY_CAP_CMD_MODE | MSM_DISPLAY_CAP_VID_MODE)) {
 		ret = _sde_encoder_input_handler(sde_enc);
 		if (ret)
 			SDE_ERROR(
@@ -5841,6 +5888,9 @@ struct drm_encoder *sde_encoder_init_with_ops(
 	kthread_init_work(&sde_enc->input_event_work,
 			sde_encoder_input_event_work_handler);
 
+	kthread_init_work(&sde_enc->touch_notify_work,
+			sde_encoder_touch_notify_work_handler);
+
 	kthread_init_work(&sde_enc->esd_trigger_work,
 			sde_encoder_esd_trigger_work_handler);
 
@@ -6320,3 +6370,48 @@ void sde_encoder_recovery_events_handler(struct drm_encoder *encoder,
 	sde_enc = to_sde_encoder_virt(encoder);
 	sde_enc->recovery_events_enabled = enabled;
 }
+
+void sde_encoder_save_vsync_info(struct sde_encoder_phys *phys_enc)
+{
+	struct sde_encoder_virt *sde_enc;
+	struct msm_mode_info *info;
+	struct calc_hw_vsync *calc_vsync;
+	ktime_t current_ktime;
+	u32 diff_us = 0;
+	u32 config_vsync_period_us = 0;
+
+	if (!phys_enc || !phys_enc->parent)
+		return;
+
+	sde_enc = to_sde_encoder_virt(phys_enc->parent);
+	if (sde_enc->disp_info.display_type == SDE_CONNECTOR_PRIMARY)
+		calc_vsync = get_hw_calc_vsync_struct(DSI_PRIMARY);
+	else if (sde_enc->disp_info.display_type == SDE_CONNECTOR_SECONDARY)
+		calc_vsync = get_hw_calc_vsync_struct(DSI_SECONDARY);
+	else
+		return;
+
+	if (!calc_vsync)
+		return;
+
+	info = &sde_enc->mode_info;
+	config_vsync_period_us = USEC_PER_SEC / info->frame_rate;
+
+	current_ktime = ktime_get();
+	diff_us = (u64)ktime_us_delta(current_ktime, calc_vsync->last_timestamp);
+	if ((diff_us * 10) <= (config_vsync_period_us * 9) ||
+		(diff_us * 10) >= (config_vsync_period_us * 11)) {
+		calc_vsync->last_timestamp = current_ktime;
+		return;
+	}
+
+	calc_vsync->vsyc_info[calc_vsync->vsync_count].config_fps = info->frame_rate;
+	calc_vsync->vsyc_info[calc_vsync->vsync_count].timestamp = current_ktime;
+	calc_vsync->vsyc_info[calc_vsync->vsync_count].real_vsync_period_ns =
+			ktime_to_ns(ktime_sub(current_ktime, calc_vsync->last_timestamp));
+
+	calc_vsync->last_timestamp = current_ktime;
+
+	calc_vsync->vsync_count++;
+	calc_vsync->vsync_count %= MAX_VSYNC_COUNT;
+}
diff --git a/techpack/display/msm/sde/sde_encoder_phys.h b/techpack/display/msm/sde/sde_encoder_phys.h
index 22355dc99f9e..c679d8bca67d 100644
--- a/techpack/display/msm/sde/sde_encoder_phys.h
+++ b/techpack/display/msm/sde/sde_encoder_phys.h
@@ -522,14 +522,6 @@ void sde_encoder_phys_setup_cdm(struct sde_encoder_phys *phys_enc,
 		struct drm_framebuffer *fb, const struct sde_format *format,
 		struct sde_rect *wb_roi);
 
-/**
- * sde_encoder_helper_get_pp_line_count - pingpong linecount helper function
- * @drm_enc:    Pointer to drm encoder structure
- * @info:       structure used to populate the pp line count information
- */
-void sde_encoder_helper_get_pp_line_count(struct drm_encoder *drm_enc,
-		struct sde_hw_pp_vsync_info *info);
-
 /**
  * sde_encoder_helper_trigger_flush - control flush helper function
  *	This helper function may be optionally specified by physical
@@ -576,6 +568,8 @@ int sde_encoder_helper_wait_event_timeout(
 void sde_encoder_helper_get_jitter_bounds_ns(struct drm_encoder *encoder,
 			u64 *l_bound, u64 *u_bound);
 
+void sde_encoder_save_vsync_info(struct sde_encoder_phys *phys_enc);
+
 /**
  * sde_encoder_helper_switch_vsync - switch vsync source to WD or default
  * @drm_enc:     Pointer to drm encoder structure
diff --git a/techpack/display/msm/sde/sde_encoder_phys_cmd.c b/techpack/display/msm/sde/sde_encoder_phys_cmd.c
index 454e83694db4..644fe6bded94 100644
--- a/techpack/display/msm/sde/sde_encoder_phys_cmd.c
+++ b/techpack/display/msm/sde/sde_encoder_phys_cmd.c
@@ -232,13 +232,14 @@ static void sde_encoder_phys_cmd_te_rd_ptr_irq(void *arg, int irq_idx)
 	struct sde_encoder_phys_cmd *cmd_enc;
 	u32 scheduler_status = INVALID_CTL_STATUS;
 	struct sde_hw_ctl *ctl;
-	struct sde_hw_pp_vsync_info info[MAX_CHANNELS_PER_ENC] = {{0}};
 	struct sde_encoder_phys_cmd_te_timestamp *te_timestamp;
 	unsigned long lock_flags;
 
 	if (!phys_enc || !phys_enc->hw_pp || !phys_enc->hw_intf)
 		return;
 
+	sde_encoder_save_vsync_info(phys_enc);
+
 	SDE_ATRACE_BEGIN("rd_ptr_irq");
 	cmd_enc = to_sde_encoder_phys_cmd(phys_enc);
 	ctl = phys_enc->hw_ctl;
@@ -256,14 +257,6 @@ static void sde_encoder_phys_cmd_te_rd_ptr_irq(void *arg, int irq_idx)
 	}
 	spin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);
 
-	sde_encoder_helper_get_pp_line_count(phys_enc->parent, info);
-	SDE_EVT32_IRQ(DRMID(phys_enc->parent),
-		info[0].pp_idx, info[0].intf_idx,
-		info[0].wr_ptr_line_count, info[0].intf_frame_count,
-		info[1].pp_idx, info[1].intf_idx,
-		info[1].wr_ptr_line_count, info[1].intf_frame_count,
-		scheduler_status);
-
 	if (phys_enc->parent_ops.handle_vblank_virt)
 		phys_enc->parent_ops.handle_vblank_virt(phys_enc->parent,
 			phys_enc);
@@ -278,7 +271,6 @@ static void sde_encoder_phys_cmd_wr_ptr_irq(void *arg, int irq_idx)
 	struct sde_encoder_phys *phys_enc = arg;
 	struct sde_hw_ctl *ctl;
 	u32 event = 0;
-	struct sde_hw_pp_vsync_info info[MAX_CHANNELS_PER_ENC] = {{0}};
 
 	if (!phys_enc || !phys_enc->hw_ctl)
 		return;
@@ -296,12 +288,6 @@ static void sde_encoder_phys_cmd_wr_ptr_irq(void *arg, int irq_idx)
 		}
 	}
 
-	sde_encoder_helper_get_pp_line_count(phys_enc->parent, info);
-	SDE_EVT32_IRQ(DRMID(phys_enc->parent),
-		ctl->idx - CTL_0, event,
-		info[0].pp_idx, info[0].intf_idx, info[0].wr_ptr_line_count,
-		info[1].pp_idx, info[1].intf_idx, info[1].wr_ptr_line_count);
-
 	/* Signal any waiting wr_ptr start interrupt */
 	wake_up_all(&phys_enc->pending_kickoff_wq);
 	SDE_ATRACE_END("wr_ptr_irq");
diff --git a/techpack/display/msm/sde/sde_encoder_phys_vid.c b/techpack/display/msm/sde/sde_encoder_phys_vid.c
index 67e6b068b8cf..2f6bc0e6b0bf 100644
--- a/techpack/display/msm/sde/sde_encoder_phys_vid.c
+++ b/techpack/display/msm/sde/sde_encoder_phys_vid.c
@@ -11,6 +11,7 @@
 #include "sde_formats.h"
 #include "dsi_display.h"
 #include "sde_trace.h"
+#include "xiaomi_frame_stat.h"
 
 #define SDE_DEBUG_VIDENC(e, fmt, ...) SDE_DEBUG("enc%d intf%d " fmt, \
 		(e) && (e)->base.parent ? \
@@ -490,6 +491,8 @@ static void sde_encoder_phys_vid_vblank_irq(void *arg, int irq_idx)
 	if (!hw_ctl)
 		return;
 
+	sde_encoder_save_vsync_info(phys_enc);
+
 	SDE_ATRACE_BEGIN("vblank_irq");
 
 	/*
@@ -516,6 +519,7 @@ static void sde_encoder_phys_vid_vblank_irq(void *arg, int irq_idx)
 		event = SDE_ENCODER_FRAME_EVENT_DONE |
 			SDE_ENCODER_FRAME_EVENT_SIGNAL_RETIRE_FENCE |
 			SDE_ENCODER_FRAME_EVENT_SIGNAL_RELEASE_FENCE;
+		frame_stat_collector(0, VBLANK_TS);
 	}
 
 not_flushed:
diff --git a/techpack/display/msm/sde/sde_expo_dim_layer.c b/techpack/display/msm/sde/sde_expo_dim_layer.c
new file mode 100644
index 000000000000..425c0ae54309
--- /dev/null
+++ b/techpack/display/msm/sde/sde_expo_dim_layer.c
@@ -0,0 +1,102 @@
+/*
+ * A new exposure driver based on SDE dim layer for OLED devices
+ *
+ * Copyright (C) 2012-2014, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019, Devries <therkduan@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "dsi_display.h"
+#include "sde_crtc.h"
+#include "sde_expo_dim_layer.h"
+
+static int interpolate(int x, int xa, int xb, int ya, int yb)
+{
+	int bf, factor, plus;
+	int sub = 0;
+
+	bf = 2 * (yb - ya) * (x - xa) / (xb - xa);
+	factor = bf / 2;
+	plus = bf % 2;
+	if ((xa - xb) && (yb - ya))
+		sub = 2 * (x - xa) * (x - xb) / (yb - ya) / (xa - xb);
+
+	return ya + factor + plus + sub;
+}
+
+static int brightness_to_alpha(uint16_t brightness)
+{
+	int level = ARRAY_SIZE(brightness_alpha_lut);
+	int index, alpha;
+
+	for (index = 0; index < ARRAY_SIZE(brightness_alpha_lut); index++) {
+		if (brightness_alpha_lut[index][BRIGHTNESS] >= brightness)
+			break;
+	}
+
+	if (index == 0)
+		alpha = brightness_alpha_lut[0][ALPHA];
+	else if (index == level)
+		alpha = brightness_alpha_lut[level - 1][ALPHA];
+	else
+		alpha = interpolate(brightness,
+			brightness_alpha_lut[index - 1][BRIGHTNESS],
+			brightness_alpha_lut[index][BRIGHTNESS],
+			brightness_alpha_lut[index - 1][ALPHA],
+			brightness_alpha_lut[index][ALPHA]);
+
+	return alpha;
+}
+
+static void set_dim_layer_exposure(uint16_t brightness, struct dsi_display *display)
+{
+	struct drm_crtc *crtc;
+	struct drm_crtc_state *state;
+	struct msm_drm_private *priv;
+	struct drm_property *prop;
+
+	if (!display->drm_conn) {
+		pr_err("The display is not connected!!\n");
+		return;
+	};
+
+	if (!display->drm_conn->state->crtc) {
+		pr_err("No CRTC on display connector!!\n");
+		return;
+	}
+
+	crtc = display->drm_conn->state->crtc;
+	state = crtc->state;
+	priv = crtc->dev->dev_private;
+	prop = priv->crtc_property[CRTC_PROP_DIM_LAYER_EXPO];
+
+	crtc->funcs->atomic_set_property(crtc, state, prop, (uint64_t)brightness_to_alpha(brightness));
+}
+
+uint32_t expo_map_dim_level(uint32_t level, struct dsi_display *display)
+{
+	uint32_t override_level, brightness;
+	uint16_t dim_brightness;
+
+	if (level < DIM_THRES_LEVEL) {
+		override_level = DIM_THRES_LEVEL;
+	} else {
+		override_level = level;
+	}
+
+	brightness = level / BACKLIGHT_DIM_SCALE;
+	dim_brightness = brightness > U16_MAX ? U16_MAX : brightness;
+
+	set_dim_layer_exposure(dim_brightness, display);
+
+	return override_level;
+}
diff --git a/techpack/display/msm/sde/sde_expo_dim_layer.h b/techpack/display/msm/sde/sde_expo_dim_layer.h
new file mode 100644
index 000000000000..919a168865ea
--- /dev/null
+++ b/techpack/display/msm/sde/sde_expo_dim_layer.h
@@ -0,0 +1,54 @@
+/*
+ * A new exposure driver based on SDE dim layer for OLED devices
+ *
+ * Copyright (C) 2012-2014, The Linux Foundation. All rights reserved.
+ * Copyright (C) 2019, Devries <therkduan@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef SDE_EXPO_DIM_LAYER_H
+#define SDE_EXPO_DIM_LAYER_H
+
+#define DIM_THRES_LEVEL 440
+#define BACKLIGHT_DIM_SCALE 1
+
+enum {
+	BRIGHTNESS = 0,
+	ALPHA = 1,
+	LUT_MAX,
+};
+
+static const uint16_t brightness_alpha_lut[][LUT_MAX] = {
+/* {brightness, alpha} */
+	{0, 0xFF},
+	{2, 0xD7},
+	{20, 0xB9},
+	{35, 0xAA},
+	{50, 0x9B},
+	{65, 0x8C},
+	{80, 0x7D},
+	{90, 0x78},
+	{100, 0x73},
+	{120, 0x6C},
+	{140, 0x64},
+	{160, 0x5A},
+	{180, 0x50},
+	{200, 0x46},
+	{240, 0x32},
+	{270, 0x28},
+	{360, 0x1E},
+	{440, 0x00}
+};
+
+uint32_t expo_map_dim_level(uint32_t level, struct dsi_display *display);
+
+#endif /* SDE_EXPO_DIM_LAYER_H */
diff --git a/techpack/display/msm/sde/sde_hw_intf.c b/techpack/display/msm/sde/sde_hw_intf.c
index f6ac49701657..ba5a4da47808 100644
--- a/techpack/display/msm/sde/sde_hw_intf.c
+++ b/techpack/display/msm/sde/sde_hw_intf.c
@@ -630,9 +630,6 @@ static int sde_hw_intf_get_vsync_info(struct sde_hw_intf *intf,
 	val = SDE_REG_READ(c, INTF_TEAR_LINE_COUNT);
 	info->wr_ptr_line_count = val & 0xffff;
 
-	val = SDE_REG_READ(c, INTF_FRAME_COUNT);
-	info->intf_frame_count = val;
-
 	return 0;
 }
 
diff --git a/techpack/display/msm/sde/sde_hw_mdss.h b/techpack/display/msm/sde/sde_hw_mdss.h
index 15f0b91d3c2a..e9ac1603f235 100644
--- a/techpack/display/msm/sde/sde_hw_mdss.h
+++ b/techpack/display/msm/sde/sde_hw_mdss.h
@@ -85,11 +85,11 @@ enum sde_format_flags {
 #define SDE_VSYNC_SOURCE_INTF_1		4
 #define SDE_VSYNC_SOURCE_INTF_2		5
 #define SDE_VSYNC_SOURCE_INTF_3		6
-#define SDE_VSYNC_SOURCE_WD_TIMER_4	11
-#define SDE_VSYNC_SOURCE_WD_TIMER_3	12
-#define SDE_VSYNC_SOURCE_WD_TIMER_2	13
-#define SDE_VSYNC_SOURCE_WD_TIMER_1	14
-#define SDE_VSYNC_SOURCE_WD_TIMER_0	15
+#define SDE_VSYNC_SOURCE_WD_TIMER_4	0x11
+#define SDE_VSYNC_SOURCE_WD_TIMER_3	0x12
+#define SDE_VSYNC_SOURCE_WD_TIMER_2	0x13
+#define SDE_VSYNC_SOURCE_WD_TIMER_1	0x14
+#define SDE_VSYNC_SOURCE_WD_TIMER_0	0x15
 
 enum sde_hw_blk_type {
 	SDE_HW_BLK_TOP = 0,
@@ -169,6 +169,7 @@ enum sde_stage {
 	SDE_STAGE_8,
 	SDE_STAGE_9,
 	SDE_STAGE_10,
+	SDE_STAGE_11,
 	SDE_STAGE_MAX
 };
 
@@ -687,7 +688,6 @@ struct sde_hw_autorefresh {
  * @rd_ptr_frame_count:	num frames sent since enabling interface
  * @rd_ptr_line_count:	current line on panel (rd ptr)
  * @wr_ptr_line_count:	current line within pp fifo (wr ptr)
- * @intf_frame_count:	num frames read from intf
  */
 struct sde_hw_pp_vsync_info {
 	u32 pp_idx;
@@ -696,7 +696,6 @@ struct sde_hw_pp_vsync_info {
 	u32 rd_ptr_frame_count;
 	u32 rd_ptr_line_count;
 	u32 wr_ptr_line_count;
-	u32 intf_frame_count;
 };
 
 #endif  /* _SDE_HW_MDSS_H */
diff --git a/techpack/display/msm/sde/sde_hw_top.c b/techpack/display/msm/sde/sde_hw_top.c
index d275224e61a2..e2127c0f8b1d 100644
--- a/techpack/display/msm/sde/sde_hw_top.c
+++ b/techpack/display/msm/sde/sde_hw_top.c
@@ -50,6 +50,8 @@
 #define MDP_WD_TIMER_4_CTL2               0x444
 #define MDP_WD_TIMER_4_LOAD_VALUE         0x448
 
+#define LTM_SW_FUSE_OFFSET 0x10
+
 #define MDP_TICK_COUNT                    16
 #define XO_CLK_RATE                       19200
 #define MS_TICKS_IN_SEC                   1000
@@ -654,3 +656,33 @@ void sde_hw_mdp_destroy(struct sde_hw_mdp *mdp)
 	kfree(mdp);
 }
 
+struct sde_hw_sw_fuse *sde_hw_sw_fuse_init(void __iomem *addr,
+	u32 sw_fuse_len, const struct sde_mdss_cfg *m)
+{
+	struct sde_hw_sw_fuse *c;
+
+	c = kzalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return ERR_PTR(-ENOMEM);
+
+	c->hw.base_off = addr;
+	c->hw.blk_off = 0;
+	c->hw.length = sw_fuse_len;
+	c->hw.hwversion = m->hwversion;
+
+	return c;
+}
+
+void sde_hw_sw_fuse_destroy(struct sde_hw_sw_fuse *sw_fuse)
+{
+	kfree(sw_fuse);
+}
+
+u32 sde_hw_get_ltm_sw_fuse_value(struct sde_hw_sw_fuse *sw_fuse)
+{
+	u32 ltm_sw_fuse = 0;
+
+	if (sw_fuse)
+		ltm_sw_fuse = SDE_REG_READ(&sw_fuse->hw, LTM_SW_FUSE_OFFSET);
+	return ltm_sw_fuse;
+}
diff --git a/techpack/display/msm/sde/sde_hw_top.h b/techpack/display/msm/sde/sde_hw_top.h
index 21f1daf1098f..7f188abfb359 100644
--- a/techpack/display/msm/sde/sde_hw_top.h
+++ b/techpack/display/msm/sde/sde_hw_top.h
@@ -242,6 +242,12 @@ struct sde_hw_sid {
 	struct sde_hw_blk_reg_map hw;
 };
 
+#define SW_FUSE_ENABLE 0x1
+struct sde_hw_sw_fuse {
+	/* sw fuse base */
+	struct sde_hw_blk_reg_map hw;
+};
+
 /**
  * sde_hw_sid_rotator_set - initialize the sid blk reg map
  * @addr: Mapped register io address
@@ -279,4 +285,23 @@ struct sde_hw_mdp *sde_hw_mdptop_init(enum sde_mdp idx,
 
 void sde_hw_mdp_destroy(struct sde_hw_mdp *mdp);
 
+/**
+ * sde_hw_sw_fuse_init - initialize the sw fuse blk reg map
+ * @addr: Mapped register io address
+ * @sw_fuse_len: Length of block
+ * @m: Pointer to mdss catalog data
+ */
+struct sde_hw_sw_fuse *sde_hw_sw_fuse_init(void __iomem *addr,
+		u32 sw_fuse_len, const struct sde_mdss_cfg *m);
+/**
+ * sde_hw_sw_fuse_destroy - free memory for sw fuse
+ * @sw_fuse: sde_hw_sw_fuse
+ */
+void sde_hw_sw_fuse_destroy(struct sde_hw_sw_fuse *sw_fuse);
+
+/**
+ * sde_hw_get_ltm_sw_fuse_value - read LTM sw fuse register value
+ * @sw_fuse: sde_hw_sw_fuse
+ */
+u32 sde_hw_get_ltm_sw_fuse_value(struct sde_hw_sw_fuse *sw_fuse);
 #endif /*_SDE_HW_TOP_H */
diff --git a/techpack/display/msm/sde/sde_kms.c b/techpack/display/msm/sde/sde_kms.c
index 0e98cf561f07..df6abdae721c 100644
--- a/techpack/display/msm/sde/sde_kms.c
+++ b/techpack/display/msm/sde/sde_kms.c
@@ -1045,7 +1045,11 @@ static void sde_kms_commit(struct msm_kms *kms,
 			sde_crtc_commit_kickoff(crtc, old_crtc_state);
 		}
 	}
-
+/*
+	for_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i) {
+		sde_crtc_fod_ui_ready(crtc, old_crtc_state);
+	}
+*/
 	SDE_ATRACE_END("sde_kms_commit");
 }
 
@@ -1199,6 +1203,8 @@ static void sde_kms_complete_commit(struct msm_kms *kms,
 			pr_err("Connector Post kickoff failed rc=%d\n",
 					 rc);
 		}
+
+		sde_connector_fod_notify(connector);
 	}
 
 	_sde_kms_drm_check_dpms(old_state, DRM_PANEL_EVENT_BLANK);
@@ -1273,7 +1279,7 @@ static void sde_kms_wait_for_commit_done(struct msm_kms *kms,
 			sde_encoder_virt_reset(encoder);
 	}
 
-	SDE_ATRACE_END("sde_ksm_wait_for_commit_done");
+	SDE_ATRACE_END("sde_kms_wait_for_commit_done");
 }
 
 static void sde_kms_prepare_fence(struct msm_kms *kms,
@@ -1933,6 +1939,14 @@ static void _sde_kms_hw_destroy(struct sde_kms *sde_kms,
 		msm_iounmap(pdev, sde_kms->sid);
 	sde_kms->sid = NULL;
 
+	if (sde_kms->hw_sw_fuse)
+		sde_hw_sw_fuse_destroy(sde_kms->hw_sw_fuse);
+	sde_kms->hw_sw_fuse = NULL;
+
+	if (sde_kms->sw_fuse)
+		msm_iounmap(pdev, sde_kms->sw_fuse);
+	sde_kms->sw_fuse = NULL;
+
 	if (sde_kms->reg_dma)
 		msm_iounmap(pdev, sde_kms->reg_dma);
 	sde_kms->reg_dma = NULL;
@@ -3555,6 +3569,20 @@ static int _sde_kms_hw_init_ioremap(struct sde_kms *sde_kms,
 			SDE_ERROR("dbg base register sid failed: %d\n", rc);
 	}
 
+	sde_kms->sw_fuse = msm_ioremap(platformdev, "swfuse_phys",
+					"swfuse_phys");
+	if (IS_ERR(sde_kms->sw_fuse)) {
+		sde_kms->sw_fuse = NULL;
+		SDE_DEBUG("sw_fuse is not defined");
+	} else {
+		sde_kms->sw_fuse_len = msm_iomap_size(platformdev,
+							"swfuse_phys");
+		rc =  sde_dbg_reg_register_base("sw_fuse", sde_kms->sw_fuse,
+						sde_kms->sw_fuse_len);
+		if (rc)
+			SDE_ERROR("dbg base register sw_fuse failed: %d\n", rc);
+	}
+
 error:
 	return rc;
 }
@@ -3759,6 +3787,17 @@ static int _sde_kms_hw_init_blocks(struct sde_kms *sde_kms,
 		goto perf_err;
 	}
 
+	if (sde_kms->sw_fuse) {
+		sde_kms->hw_sw_fuse = sde_hw_sw_fuse_init(sde_kms->sw_fuse,
+				sde_kms->sw_fuse_len, sde_kms->catalog);
+		if (IS_ERR(sde_kms->hw_sw_fuse)) {
+			SDE_ERROR("failed to init sw_fuse %ld\n",
+					PTR_ERR(sde_kms->hw_sw_fuse));
+			sde_kms->hw_sw_fuse = NULL;
+		}
+	} else {
+		sde_kms->hw_sw_fuse = NULL;
+	}
 	/*
 	 * _sde_kms_drm_obj_init should create the DRM related objects
 	 * i.e. CRTCs, planes, encoders, connectors and so forth
diff --git a/techpack/display/msm/sde/sde_kms.h b/techpack/display/msm/sde/sde_kms.h
index 6882cdfdb00f..8da016d93efe 100644
--- a/techpack/display/msm/sde/sde_kms.h
+++ b/techpack/display/msm/sde/sde_kms.h
@@ -249,9 +249,10 @@ struct sde_kms {
 
 	/* io/register spaces: */
 	void __iomem *mmio, *vbif[VBIF_MAX], *reg_dma, *sid,
-		*imem;
+		*imem, *sw_fuse;
 	unsigned long mmio_len, vbif_len[VBIF_MAX],
 		reg_dma_len, sid_len, imem_len;
+	unsigned long sw_fuse_len;
 
 	struct regulator *vdd;
 	struct regulator *mmagic;
@@ -277,6 +278,7 @@ struct sde_kms {
 	struct sde_hw_mdp *hw_mdp;
 	struct sde_hw_uidle *hw_uidle;
 	struct sde_hw_sid *hw_sid;
+	struct sde_hw_sw_fuse *hw_sw_fuse;
 	int dsi_display_count;
 	void **dsi_displays;
 	int wb_display_count;
diff --git a/techpack/display/msm/sde/sde_plane.c b/techpack/display/msm/sde/sde_plane.c
index 0264cefe1ddd..e223473378e6 100644
--- a/techpack/display/msm/sde/sde_plane.c
+++ b/techpack/display/msm/sde/sde_plane.c
@@ -3357,6 +3357,18 @@ static void _sde_plane_atomic_disable(struct drm_plane *plane,
 				SDE_SSPP_RECT_SOLO, SDE_SSPP_MULTIRECT_NONE);
 }
 
+int sde_plane_is_fod_layer(const struct drm_plane_state *drm_state)
+{
+	struct sde_plane_state *pstate;
+
+	if (!drm_state)
+		return 0;
+
+	pstate = to_sde_plane_state(drm_state);
+
+	return sde_plane_get_property(pstate, PLANE_PROP_FOD);
+}
+
 static void sde_plane_atomic_update(struct drm_plane *plane,
 				struct drm_plane_state *old_state)
 {
@@ -3418,6 +3430,18 @@ void sde_plane_restore(struct drm_plane *plane)
 	sde_plane_atomic_update(plane, plane->state);
 }
 
+uint32_t sde_plane_get_mi_layer_info(const struct drm_plane_state *drm_state)
+{
+	struct sde_plane_state *pstate;
+
+	if (!drm_state)
+		return 0;
+
+	pstate = to_sde_plane_state(drm_state);
+
+	return sde_plane_get_property(pstate, PLANE_PROP_MI_LAYER_INFO);
+}
+
 bool sde_plane_is_cache_required(struct drm_plane *plane)
 {
 	struct sde_plane_state *pstate;
@@ -3541,8 +3565,6 @@ static void _sde_plane_install_properties(struct drm_plane *plane,
 	const struct sde_format_extended *format_list;
 	struct sde_kms_info *info;
 	struct sde_plane *psde = to_sde_plane(plane);
-	int zpos_max = 255;
-	int zpos_def = 0;
 	char feature_name[256];
 
 	if (!plane || !psde) {
@@ -3559,23 +3581,14 @@ static void _sde_plane_install_properties(struct drm_plane *plane,
 
 	psde->catalog = catalog;
 
-	if (sde_is_custom_client()) {
-		if (catalog->mixer_count &&
-				catalog->mixer[0].sblk->maxblendstages) {
-			zpos_max = catalog->mixer[0].sblk->maxblendstages - 1;
-			if (catalog->has_base_layer &&
-					(zpos_max > SDE_STAGE_MAX - 1))
-				zpos_max = SDE_STAGE_MAX - 1;
-			else if (zpos_max > SDE_STAGE_MAX - SDE_STAGE_0 - 1)
-				zpos_max = SDE_STAGE_MAX - SDE_STAGE_0 - 1;
-		}
-	} else if (plane->type != DRM_PLANE_TYPE_PRIMARY) {
-		/* reserve zpos == 0 for primary planes */
-		zpos_def = drm_plane_index(plane) + 1;
-	}
+	msm_property_install_range(&psde->property_info, "mi_layer_info",
+		0x0, 0, U32_MAX, 0, PLANE_PROP_MI_LAYER_INFO);
 
 	msm_property_install_range(&psde->property_info, "zpos",
-		0x0, 0, zpos_max, zpos_def, PLANE_PROP_ZPOS);
+		0x0, 0, INT_MAX, 0, PLANE_PROP_ZPOS);
+
+	msm_property_install_range(&psde->property_info, "fod",
+		0x0, 0, INT_MAX, 0, PLANE_PROP_FOD);
 
 	msm_property_install_range(&psde->property_info, "alpha",
 		0x0, 0, 255, 255, PLANE_PROP_ALPHA);
@@ -3998,6 +4011,8 @@ static int sde_plane_atomic_set_property(struct drm_plane *plane,
 {
 	struct sde_plane *psde = plane ? to_sde_plane(plane) : NULL;
 	struct sde_plane_state *pstate;
+	struct drm_property *fod_property;
+	uint64_t fod_val = 0;
 	int idx, ret = -EINVAL;
 
 	SDE_DEBUG_PLANE(psde, "\n");
@@ -4008,11 +4023,25 @@ static int sde_plane_atomic_set_property(struct drm_plane *plane,
 		SDE_ERROR_PLANE(psde, "invalid state\n");
 	} else {
 		pstate = to_sde_plane_state(state);
+		idx = msm_property_index(&psde->property_info,
+				property);
+		if (idx == PLANE_PROP_ZPOS) {
+			if (val & FOD_PRESSED_LAYER_ZORDER) {
+				val &= ~FOD_PRESSED_LAYER_ZORDER;
+				fod_val = 1;
+			}
+
+			fod_property = psde->property_info.
+					property_array[PLANE_PROP_FOD];
+			ret = msm_property_atomic_set(&psde->property_info,
+					&pstate->property_state,
+					fod_property, fod_val);
+			if (ret)
+				SDE_ERROR("failed to set fod prop");
+		}
 		ret = msm_property_atomic_set(&psde->property_info,
 				&pstate->property_state, property, val);
 		if (!ret) {
-			idx = msm_property_index(&psde->property_info,
-					property);
 			switch (idx) {
 			case PLANE_PROP_INPUT_FENCE:
 				_sde_plane_set_input_fence(psde, pstate, val);
diff --git a/techpack/display/msm/sde/sde_plane.h b/techpack/display/msm/sde/sde_plane.h
index 316bd75f47d9..cbdb8696039b 100644
--- a/techpack/display/msm/sde/sde_plane.h
+++ b/techpack/display/msm/sde/sde_plane.h
@@ -308,4 +308,12 @@ void sde_plane_setup_src_split_order(struct drm_plane *plane,
  */
 bool sde_plane_is_cache_required(struct drm_plane *plane);
 
+/*
+ * sde_plane_get_mi_layer_info - get mi layer info
+ * @plane: Pointer to DRM plane object
+ */
+uint32_t sde_plane_get_mi_layer_info(const struct drm_plane_state *drm_state);
+
+int sde_plane_is_fod_layer(const struct drm_plane_state *drm_state);
+
 #endif /* _SDE_PLANE_H_ */
diff --git a/techpack/display/msm/sde/sde_rm.c b/techpack/display/msm/sde/sde_rm.c
index 9e8a02f9eee9..4953da9e8c6c 100644
--- a/techpack/display/msm/sde/sde_rm.c
+++ b/techpack/display/msm/sde/sde_rm.c
@@ -2068,6 +2068,7 @@ void sde_rm_release(struct sde_rm *rm, struct drm_encoder *enc, bool nxt)
 	} else {
 		SDE_DEBUG("release rsvp[s%de%d]\n", rsvp->seq,
 				rsvp->enc_id);
+		SDE_EVT32(rsvp, rsvp->seq, rsvp->enc_id, nxt, DRMID(enc), DRMID(conn));
 		_sde_rm_release_rsvp(rm, rsvp, conn);
 	}
 
@@ -2075,6 +2076,41 @@ void sde_rm_release(struct sde_rm *rm, struct drm_encoder *enc, bool nxt)
 	mutex_unlock(&rm->rm_lock);
 }
 
+static void _sde_rm_check_and_modify_commit_rsvps(
+		struct sde_rm *rm,
+		struct sde_rm_rsvp *rsvp)
+{
+
+	struct sde_rm_hw_blk *blk;
+	enum sde_hw_blk_type type;
+	bool modify = false;
+
+	if (!rsvp)
+		return;
+	for (type = 0; type < SDE_HW_BLK_MAX; type++) {
+		list_for_each_entry(blk, &rm->hw_blks[type], list) {
+			if (blk->rsvp_nxt &&  blk->rsvp_nxt->enc_id == rsvp->enc_id
+					 && blk->rsvp_nxt != rsvp) {
+				pr_err("rsvp :%x blk->rsvp_nxt :%x, enc_id: %x type :%x\n",
+					rsvp, blk->rsvp_nxt, blk->rsvp_nxt->enc_id , type);
+				SDE_EVT32(rsvp, blk->rsvp_nxt, blk->rsvp_nxt->enc_id , type);
+				modify = true;
+			}
+		}
+	}
+
+	if (modify) {
+		for (type = 0; type < SDE_HW_BLK_MAX; type++) {
+			list_for_each_entry(blk, &rm->hw_blks[type], list) {
+				if (blk->rsvp_nxt && blk->rsvp_nxt->enc_id
+						 == rsvp->enc_id) {
+					blk->rsvp_nxt = rsvp;
+				}
+			}
+		}
+	}
+}
+
 static int _sde_rm_commit_rsvp(
 		struct sde_rm *rm,
 		struct sde_rm_rsvp *rsvp,
@@ -2084,6 +2120,8 @@ static int _sde_rm_commit_rsvp(
 	enum sde_hw_blk_type type;
 	int ret = 0;
 
+	_sde_rm_check_and_modify_commit_rsvps(rm, rsvp);
+
 	/* Swap next rsvp to be the active */
 	for (type = 0; type < SDE_HW_BLK_MAX; type++) {
 		list_for_each_entry(blk, &rm->hw_blks[type], list) {
diff --git a/techpack/display/msm/xiaomi_frame_stat.c b/techpack/display/msm/xiaomi_frame_stat.c
new file mode 100644
index 000000000000..e1505b0d20bc
--- /dev/null
+++ b/techpack/display/msm/xiaomi_frame_stat.c
@@ -0,0 +1,171 @@
+#include "xiaomi_frame_stat.h"
+
+struct frame_stat fm_stat = {.enabled = true};
+
+ssize_t smart_fps_value_show(struct device *device,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", g_panel->mi_cfg.smart_fps_value);
+}
+
+void frame_stat_notify(int data)
+{
+	struct dsi_display *display = NULL;
+	struct mipi_dsi_host *host = NULL;
+
+	if (g_panel)
+		host = g_panel->host;
+
+	if (host)
+		display = container_of(host, struct dsi_display, host);
+
+	if (!display) {
+		pr_err("%s: invalid param.\n");
+		return;
+	}
+
+	g_panel->mi_cfg.smart_fps_value = data;
+
+	sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "smart_fps_value");
+	pr_debug("%s: fps = %d\n", __func__, g_panel->mi_cfg.smart_fps_value);
+
+	fm_stat.skip_count = 0;
+	fm_stat.last_fps = data;
+	return;
+}
+
+void calc_fps(u64 duration, int input_event)
+{
+	ktime_t current_time_us;
+	u64 fps, diff_us, diff, curr_fps;
+
+	if (!g_panel->mi_cfg.smart_fps_support || !fm_stat.enabled)
+		return;
+
+	if (input_event) {
+		frame_stat_notify(0xFF); //0xFF used as a symbol of input event.
+		fm_stat.last_fps = g_panel->mi_cfg.smart_fps_max_framerate;
+		fm_stat.skip_once = true;
+		pr_debug("%s: input event restore fps.\n", __func__);
+		goto exit;
+	}
+
+	current_time_us = ktime_get();
+	if (fm_stat.idle_status) {
+		if (fm_stat.last_fps != IDLE_FPS) {
+			if (g_panel->panel_mode == DSI_OP_CMD_MODE)
+				/* video panel will directly notify SDM */
+				frame_stat_notify(IDLE_FPS);
+
+			fm_stat.last_fps = IDLE_FPS;
+			pr_debug("%s: exit fps calc due to idle mode\n", __func__);
+		}
+		goto exit;
+	}
+
+	if(!fm_stat.start) {
+		fm_stat.last_sampled_time_us = current_time_us;
+		fm_stat.start = true;
+	}
+	diff_us = (u64)ktime_us_delta(current_time_us, fm_stat.last_sampled_time_us);
+
+	fm_stat.frame_count++;
+
+	if (fm_stat.last_frame_commit_time_us > 0) {
+		diff = (u64)ktime_us_delta(current_time_us, fm_stat.last_frame_commit_time_us);
+		fm_stat.last_frame_commit_time_us = current_time_us;
+		if (diff > LONG_FRAME_INTERVAL) {
+			fm_stat.skip_count++;
+			pr_debug("%s: Long frame interval, frame interval[%lld ms], count[%d]\n", __func__, diff/NANO_TO_MICRO, fm_stat.skip_count);
+			if (fm_stat.skip_count > LONG_INTERVAL_FRAME_COUNT) {
+				/* Sometime  app refresh in low fps, here set 50hz */
+				frame_stat_notify(IDLE_FPS);
+				fm_stat.last_fps = IDLE_FPS;
+			}
+			goto exit;
+		} else
+			fm_stat.skip_count = 0;
+	}
+
+	if (diff_us >= FPS_PERIOD_1_SEC) {
+		/* skip once after input events */
+		if (fm_stat.skip_once) {
+			fm_stat.skip_once = false;
+			goto exit;
+		}
+
+		 /* Multiplying with 10 to get fps in floating point */
+		fps = fm_stat.frame_count * FPS_PERIOD_1_SEC * 10;
+		do_div(fps, diff_us);
+		curr_fps = (unsigned int)fps/10;
+		if (curr_fps != fm_stat.last_fps)
+			frame_stat_notify(curr_fps);
+
+		pr_debug("%s: FPS:%d.%d max_frame_duration = %lld(us) max_input_fence_duration = %lld(us)\n",
+				__func__,
+				(unsigned int)fps/10,
+				(unsigned int)fps%10,
+				fm_stat.max_frame_duration/NANO_TO_MICRO,
+				fm_stat.max_input_fence_duration/NANO_TO_MICRO);
+		goto exit;
+	} else {
+		fm_stat.delta_commit_duration = duration;
+		if (fm_stat.max_frame_duration < fm_stat.delta_commit_duration)
+			fm_stat.max_frame_duration = fm_stat.delta_commit_duration;
+
+		fm_stat.delta_input_duration = fm_stat.input_fence_duration;
+		if (fm_stat.max_input_fence_duration < fm_stat.delta_input_duration)
+			fm_stat.max_input_fence_duration = fm_stat.delta_input_duration;
+
+		fm_stat.last_frame_commit_time_us = current_time_us;
+		goto final;
+	}
+
+exit:
+	fm_stat.last_sampled_time_us = current_time_us;
+	fm_stat.frame_count = 0;
+	fm_stat.start = false;
+	fm_stat.max_frame_duration = 0;
+	fm_stat.max_input_fence_duration = 0;
+	fm_stat.last_frame_commit_time_us = current_time_us;
+final:
+	return;
+}
+
+void frame_stat_collector(u64 duration, enum stat_item item)
+{
+	ktime_t now = ktime_get();
+
+	switch (item) {
+	case COMMIT_START_TS:
+		fm_stat.commit_start_ts = now;
+		pr_debug("%s: commit start ts = %lld\n", __func__, fm_stat.commit_start_ts);
+		break;
+	case GET_INPUT_FENCE_TS:
+		fm_stat.get_input_fence_ts = now;
+		pr_debug("%s: get_input_fence_ts = %lld, duration = %lld \n", __func__, fm_stat.get_input_fence_ts, duration);
+		fm_stat.input_fence_duration = duration;
+		break;
+	case VBLANK_TS:
+		fm_stat.commit_start_ts = now;
+		pr_debug("vblank ts = %lld\n", fm_stat.get_input_fence_ts);
+		break;
+	case RETIRE_FENCE_TS:
+		fm_stat.retire_fence_ts = now;
+		pr_debug("%s: retire fence ts = %lld\n", __func__, fm_stat.retire_fence_ts);
+		break;
+	case COMMIT_END_TS:
+		fm_stat.commit_end_ts = now;
+		if (fm_stat.input_fence_duration > duration/10)
+			pr_debug("%s: long wait for input fence might cause frame miss!\n", __func__);
+		calc_fps(duration, 0);
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+
+
diff --git a/techpack/display/msm/xiaomi_frame_stat.h b/techpack/display/msm/xiaomi_frame_stat.h
new file mode 100644
index 000000000000..f7a4208a0dbc
--- /dev/null
+++ b/techpack/display/msm/xiaomi_frame_stat.h
@@ -0,0 +1,69 @@
+
+#ifndef XIAOMI_FRAME_STAT_H_
+#define XIAOMI_FRAME_STAT_H_
+
+#include <linux/ktime.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/kernel.h>
+#include <linux/timekeeping.h>
+#include "msm_drv.h"
+#include "sde_crtc.h"
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/msm_drm.h>
+#include "dsi_panel.h"
+#include "dsi_display.h"
+
+#ifndef FPS_PERIOD_1_SEC
+#define FPS_PERIOD_1_SEC	(1000000)
+#endif
+#define NANO_TO_MICRO				(1000)
+#define MAX_STAT_FRAME_COUNT 		(60)
+#define STAT_ITEM_NUM 				(5)
+#define IDLE_FPS					(50)
+#define DEFAULT_FPS					(60)
+#define LONG_INTERVAL_FRAME_COUNT	(3)
+#define LONG_FRAME_INTERVAL			(70000)
+
+extern struct drm_crtc *gcrtc;
+extern struct dsi_panel *g_panel;
+
+enum stat_item {
+	COMMIT_START_TS = 1,
+	GET_INPUT_FENCE_TS,
+	VBLANK_TS,
+	RETIRE_FENCE_TS,
+	COMMIT_END_TS,
+	RESERVED = 0xF,
+};
+
+struct frame_stat {
+	ktime_t commit_start_ts;
+	ktime_t get_input_fence_ts;
+	ktime_t retire_fence_ts;
+	ktime_t commit_end_ts;
+	ktime_t last_sampled_time_us;
+	ktime_t max_frame_duration;
+	ktime_t delta_commit_duration;
+	ktime_t last_frame_commit_time_us;
+	ktime_t max_input_fence_duration;
+	ktime_t delta_input_duration;
+	u64 input_fence_duration;
+	u64 frame_count;
+	bool start;
+	/* enabled will be changed by user application, the false indicates smart dfps disabled */
+	bool enabled;
+	bool idle_status;
+	bool skip_once;
+	u64 last_fps;
+	u64 skip_count;
+};
+
+void frame_stat_collector(u64 duration, enum stat_item item);
+void calc_fps(u64 duration, int input_event);
+void frame_stat_notify(int data);
+ssize_t smart_fps_value_show(struct device *device,
+			struct device_attribute *attr,
+			char *buf);
+#endif
-- 
2.48.1

