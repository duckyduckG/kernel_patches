From ab2c13308c01e75172390fa95895d9d4830478e8 Mon Sep 17 00:00:00 2001
From: Sebastiano Barezzi <barezzisebastiano@gmail.com>
Date: Mon, 21 Nov 2022 23:22:53 +0100
Subject: [PATCH 082/157] techpack: display: Import Xiaomi changes

* From dagu-s-oss

Change-Id: Ifa6dad25e33b9b27a1ae59ee98da415ae0ed07e6
---
 techpack/display/msm/Makefile                 |    4 +
 techpack/display/msm/dsi/dsi_catalog.c        |    8 +
 techpack/display/msm/dsi/dsi_catalog.h        |    7 +
 techpack/display/msm/dsi/dsi_ctrl.c           |   89 +-
 techpack/display/msm/dsi/dsi_ctrl_hw.h        |   21 +
 techpack/display/msm/dsi/dsi_ctrl_hw_2_2.c    |   90 +-
 techpack/display/msm/dsi/dsi_defs.h           |  106 +
 techpack/display/msm/dsi/dsi_display.c        |  173 +-
 techpack/display/msm/dsi/dsi_display.h        |   11 +
 techpack/display/msm/dsi/dsi_display_mi.c     |  117 +
 techpack/display/msm/dsi/dsi_drm.c            |  127 +-
 techpack/display/msm/dsi/dsi_drm.h            |    1 +
 techpack/display/msm/dsi/dsi_mi_feature.h     |   98 +
 techpack/display/msm/dsi/dsi_panel.c          |  831 +++-
 techpack/display/msm/dsi/dsi_panel.h          |   25 +
 techpack/display/msm/dsi/dsi_panel_mi.c       | 4158 +++++++++++++++++
 techpack/display/msm/dsi/dsi_panel_mi.h       |  415 ++
 techpack/display/msm/dsi/dsi_phy.c            |    2 +
 techpack/display/msm/dsi/dsi_phy_hw.h         |    2 +
 techpack/display/msm/dsi/dsi_phy_hw_v4_0.c    |   29 +-
 techpack/display/msm/dsi/mi_disp_lhbm.c       |  340 ++
 techpack/display/msm/dsi/mi_disp_lhbm.h       |   78 +
 .../display/msm/dsi/mi_disp_nvt_alpha_data.h  |  420 ++
 techpack/display/msm/msm_drv.c                |    3 +
 techpack/display/msm/msm_drv.h                |    2 +
 .../display/msm/sde/clone_cooling_device.c    |  165 +
 .../display/msm/sde/clone_cooling_device.h    |   19 +
 .../display/msm/sde/sde_color_processing.c    |  239 +-
 techpack/display/msm/sde/sde_connector.c      |  606 ++-
 techpack/display/msm/sde/sde_connector.h      |   38 +
 techpack/display/msm/sde/sde_crtc.c           |  196 +-
 techpack/display/msm/sde/sde_crtc.h           |   70 +
 techpack/display/msm/sde/sde_encoder.c        |  164 +-
 techpack/display/msm/sde/sde_encoder.h        |   15 +
 .../display/msm/sde/sde_hw_color_proc_v4.c    |    6 +-
 .../msm/sde/sde_hw_color_processing_v1_7.c    |   14 +-
 techpack/display/msm/sde/sde_hw_mdss.h        |    2 +
 .../msm/sde/sde_hw_reg_dma_v1_color_proc.c    |    7 +-
 techpack/display/msm/sde/sde_hw_top.c         |   32 +
 techpack/display/msm/sde/sde_hw_top.h         |   25 +
 techpack/display/msm/sde/sde_kms.c            |   48 +
 techpack/display/msm/sde/sde_kms.h            |    6 +-
 techpack/display/msm/sde/sde_plane.c          |   15 +
 techpack/display/msm/sde/sde_plane.h          |    6 +
 techpack/display/msm/sde/sde_rm.c             |   34 +
 techpack/display/pll/dsi_pll_7nm.c            |    4 +
 techpack/display/pll/pll_drv.c                |    8 +
 47 files changed, 8738 insertions(+), 138 deletions(-)
 create mode 100644 techpack/display/msm/dsi/dsi_display_mi.c
 create mode 100644 techpack/display/msm/dsi/dsi_mi_feature.h
 create mode 100755 techpack/display/msm/dsi/dsi_panel_mi.c
 create mode 100755 techpack/display/msm/dsi/dsi_panel_mi.h
 create mode 100644 techpack/display/msm/dsi/mi_disp_lhbm.c
 create mode 100644 techpack/display/msm/dsi/mi_disp_lhbm.h
 create mode 100644 techpack/display/msm/dsi/mi_disp_nvt_alpha_data.h
 create mode 100644 techpack/display/msm/sde/clone_cooling_device.c
 create mode 100644 techpack/display/msm/sde/clone_cooling_device.h

diff --git a/techpack/display/msm/Makefile b/techpack/display/msm/Makefile
index 18eb12c35530..773dbd09a16e 100644
--- a/techpack/display/msm/Makefile
+++ b/techpack/display/msm/Makefile
@@ -35,6 +35,7 @@ msm_drm-$(CONFIG_DRM_MSM_SDE) += sde/sde_crtc.o \
 	sde/sde_kms.o \
 	sde/sde_plane.o \
 	sde/sde_connector.o \
+	sde/clone_cooling_device.o \
 	sde/sde_color_processing.o \
 	sde/sde_vbif.o \
 	sde_io_util.o \
@@ -100,6 +101,9 @@ msm_drm-$(CONFIG_DRM_MSM_DSI) += dsi/dsi_phy.o \
 	dsi/dsi_panel.o \
 	dsi/dsi_clk_manager.o \
 	dsi/dsi_display_test.o \
+	dsi/dsi_display_mi.o \
+	dsi/dsi_panel_mi.o \
+	dsi/mi_disp_lhbm.o \
 
 msm_drm-$(CONFIG_DSI_PARSER) += dsi/dsi_parser.o \
 
diff --git a/techpack/display/msm/dsi/dsi_catalog.c b/techpack/display/msm/dsi/dsi_catalog.c
index 19fb900c1475..619574c23f5b 100644
--- a/techpack/display/msm/dsi/dsi_catalog.c
+++ b/techpack/display/msm/dsi/dsi_catalog.c
@@ -83,6 +83,8 @@ static void dsi_catalog_cmn_init(struct dsi_ctrl_hw *ctrl,
 		ctrl->ops.config_clk_gating = NULL;
 		ctrl->ops.map_mdp_regs = NULL;
 		ctrl->ops.log_line_count = NULL;
+		ctrl->ops.configure_cmddma_window = NULL;
+		ctrl->ops.reset_trig_ctrl = NULL;
 		break;
 	case DSI_CTRL_VERSION_2_0:
 		ctrl->ops.setup_lane_map = dsi_ctrl_hw_20_setup_lane_map;
@@ -100,6 +102,8 @@ static void dsi_catalog_cmn_init(struct dsi_ctrl_hw *ctrl,
 		ctrl->ops.config_clk_gating = NULL;
 		ctrl->ops.map_mdp_regs = NULL;
 		ctrl->ops.log_line_count = NULL;
+		ctrl->ops.configure_cmddma_window = NULL;
+		ctrl->ops.reset_trig_ctrl = NULL;
 		break;
 	case DSI_CTRL_VERSION_2_2:
 	case DSI_CTRL_VERSION_2_3:
@@ -122,6 +126,10 @@ static void dsi_catalog_cmn_init(struct dsi_ctrl_hw *ctrl,
 			dsi_ctrl_hw_kickoff_non_embedded_mode;
 		ctrl->ops.map_mdp_regs = dsi_ctrl_hw_22_map_mdp_regs;
 		ctrl->ops.log_line_count = dsi_ctrl_hw_22_log_line_count;
+		ctrl->ops.configure_cmddma_window =
+			dsi_ctrl_hw_22_configure_cmddma_window;
+		ctrl->ops.reset_trig_ctrl =
+			dsi_ctrl_hw_22_reset_trigger_controls;
 		break;
 	default:
 		break;
diff --git a/techpack/display/msm/dsi/dsi_catalog.h b/techpack/display/msm/dsi/dsi_catalog.h
index 3118cb573301..b49fd50f9331 100644
--- a/techpack/display/msm/dsi/dsi_catalog.h
+++ b/techpack/display/msm/dsi/dsi_catalog.h
@@ -274,5 +274,12 @@ int dsi_phy_hw_v4_0_cache_phy_timings(struct dsi_phy_per_lane_cfgs *timings,
 int dsi_ctrl_hw_22_map_mdp_regs(struct platform_device *pdev,
 		struct dsi_ctrl_hw *ctrl);
 
+void dsi_ctrl_hw_22_configure_cmddma_window(struct dsi_ctrl_hw *ctrl,
+		struct dsi_ctrl_cmd_dma_info *cmd,
+		u32 line_no, u32 window);
+
+void dsi_ctrl_hw_22_reset_trigger_controls(struct dsi_ctrl_hw *ctrl,
+		struct dsi_host_common_cfg *cfg);
+
 u32 dsi_ctrl_hw_22_log_line_count(struct dsi_ctrl_hw *ctrl, bool cmd_mode);
 #endif /* _DSI_CATALOG_H_ */
diff --git a/techpack/display/msm/dsi/dsi_ctrl.c b/techpack/display/msm/dsi/dsi_ctrl.c
index c92bfbcef14d..12f3307f3650 100644
--- a/techpack/display/msm/dsi/dsi_ctrl.c
+++ b/techpack/display/msm/dsi/dsi_ctrl.c
@@ -552,6 +552,7 @@ static int dsi_ctrl_init_regmap(struct platform_device *pdev,
 		}
 		ctrl->hw.mmss_misc_base = ptr;
 		ctrl->hw.disp_cc_base = NULL;
+		ctrl->hw.mdp_intf_base = NULL;
 		break;
 	case DSI_CTRL_VERSION_2_2:
 	case DSI_CTRL_VERSION_2_3:
@@ -564,6 +565,10 @@ static int dsi_ctrl_init_regmap(struct platform_device *pdev,
 		}
 		ctrl->hw.disp_cc_base = ptr;
 		ctrl->hw.mmss_misc_base = NULL;
+
+		ptr = msm_ioremap(pdev, "mdp_intf_base", ctrl->name);
+		if (!IS_ERR(ptr))
+			ctrl->hw.mdp_intf_base = ptr;
 		break;
 	default:
 		break;
@@ -1226,6 +1231,61 @@ int dsi_message_validate_tx_mode(struct dsi_ctrl *dsi_ctrl,
 
 	return rc;
 }
+
+static void dsi_configure_command_scheduling(struct dsi_ctrl *dsi_ctrl,
+		struct dsi_ctrl_cmd_dma_info *cmd_mem)
+{
+	u32 line_no = 0, window = 0, sched_line_no = 0;
+	struct dsi_ctrl_hw_ops dsi_hw_ops = dsi_ctrl->hw.ops;
+	struct dsi_mode_info *timing = &(dsi_ctrl->host_config.video_timing);
+
+	line_no = dsi_ctrl->host_config.common_config.dma_sched_line;
+	window = dsi_ctrl->host_config.common_config.dma_sched_window;
+
+	SDE_EVT32(dsi_ctrl->cell_index, SDE_EVTLOG_FUNC_ENTRY, line_no, window);
+	/*
+	 * In case of command scheduling in video mode, the line at which
+	 * the command is scheduled can revert to the default value i.e. 1
+	 * for the following cases:
+	 *      1) No schedule line defined by the panel.
+	 *      2) schedule line defined is greater than VFP.
+	 */
+	if ((dsi_ctrl->host_config.panel_mode == DSI_OP_VIDEO_MODE) &&
+		dsi_hw_ops.schedule_dma_cmd &&
+		(dsi_ctrl->current_state.vid_engine_state ==
+					DSI_CTRL_ENGINE_ON)) {
+		sched_line_no = (line_no == 0) ? 1 : line_no;
+
+		if (timing) {
+			if (sched_line_no >= timing->v_front_porch)
+				sched_line_no = 1;
+			sched_line_no += timing->v_back_porch +
+				timing->v_sync_width + timing->v_active;
+		}
+		dsi_hw_ops.schedule_dma_cmd(&dsi_ctrl->hw, sched_line_no);
+	}
+
+	/*
+	 * In case of command scheduling in command mode, the window size
+	 * is reset to zero, if the total scheduling window is greater
+	 * than the panel height.
+	 */
+	if ((dsi_ctrl->host_config.panel_mode == DSI_OP_CMD_MODE) &&
+			dsi_hw_ops.configure_cmddma_window) {
+		sched_line_no = line_no;
+
+		if ((sched_line_no + window) > timing->v_active)
+			window = 0;
+
+		sched_line_no += timing->v_active;
+
+		dsi_hw_ops.configure_cmddma_window(&dsi_ctrl->hw, cmd_mem,
+				sched_line_no, window);
+	}
+	SDE_EVT32(dsi_ctrl->cell_index, SDE_EVTLOG_FUNC_EXIT,
+			sched_line_no, window);
+}
+
 static u32 calculate_schedule_line(struct dsi_ctrl *dsi_ctrl, u32 flags)
 {
 	u32 line_no = 0x1;
@@ -1234,7 +1294,7 @@ static u32 calculate_schedule_line(struct dsi_ctrl *dsi_ctrl, u32 flags)
 	/* check if custom dma scheduling line needed */
 	if ((dsi_ctrl->host_config.panel_mode == DSI_OP_VIDEO_MODE) &&
 		(flags & DSI_CTRL_CMD_CUSTOM_DMA_SCHED))
-		line_no = dsi_ctrl->host_config.u.video_engine.dma_sched_line;
+		line_no = dsi_ctrl->host_config.common_config.dma_sched_line;
 
 	timing = &(dsi_ctrl->host_config.video_timing);
 
@@ -1252,20 +1312,31 @@ static void dsi_kickoff_msg_tx(struct dsi_ctrl *dsi_ctrl,
 				u32 flags)
 {
 	u32 hw_flags = 0;
-	u32 line_no = 0x1;
 	struct dsi_ctrl_hw_ops dsi_hw_ops = dsi_ctrl->hw.ops;
 
 	SDE_EVT32(dsi_ctrl->cell_index, SDE_EVTLOG_FUNC_ENTRY, flags,
 		msg->flags);
 
-	line_no = calculate_schedule_line(dsi_ctrl, flags);
+	if (dsi_ctrl->hw.reset_trig_ctrl)
+		dsi_hw_ops.reset_trig_ctrl(&dsi_ctrl->hw,
+			&dsi_ctrl->host_config.common_config);
 
-	if ((dsi_ctrl->host_config.panel_mode == DSI_OP_VIDEO_MODE) &&
-		dsi_hw_ops.schedule_dma_cmd &&
-		(dsi_ctrl->current_state.vid_engine_state ==
-					DSI_CTRL_ENGINE_ON))
-		dsi_hw_ops.schedule_dma_cmd(&dsi_ctrl->hw,
-				line_no);
+	/*
+	 * Always enable DMA scheduling for video mode panel.
+	 *
+	 * In video mode panel, if the DMA is triggered very close to
+	 * the beginning of the active window and the DMA transfer
+	 * happens in the last line of VBP, then the HW state will
+	 * stay in âwaitâ and return to âidleâ in the first line of VFP.
+	 * But somewhere in the middle of the active window, if SW
+	 * disables DSI command mode engine while the HW is still
+	 * waiting and re-enable after timing engine is OFF. So the
+	 * HW never âseesâ another vblank line and hence it gets
+	 * stuck in the âwaitâ state.
+	 */
+	if ((flags & DSI_CTRL_CMD_CUSTOM_DMA_SCHED) ||
+		(dsi_ctrl->host_config.panel_mode == DSI_OP_VIDEO_MODE))
+		dsi_configure_command_scheduling(dsi_ctrl, cmd_mem);
 
 	dsi_ctrl->cmd_mode = (dsi_ctrl->host_config.panel_mode ==
 				DSI_OP_CMD_MODE);
diff --git a/techpack/display/msm/dsi/dsi_ctrl_hw.h b/techpack/display/msm/dsi/dsi_ctrl_hw.h
index a6c7f2fdfef3..e764fb3dcb2b 100644
--- a/techpack/display/msm/dsi/dsi_ctrl_hw.h
+++ b/techpack/display/msm/dsi/dsi_ctrl_hw.h
@@ -854,6 +854,25 @@ struct dsi_ctrl_hw_ops {
 	 * @cmd_mode:»       Boolean to indicate command mode operation.
 	 */
 	u32 (*log_line_count)(struct dsi_ctrl_hw *ctrl, bool cmd_mode);
+
+	/**
+	 * hw.ops.configure_cmddma_window() - configure DMA window for CMD TX
+	 * @ctrl:	Pointer to the controller host hardware.
+	 * @cmd:	Pointer to the DSI DMA command info.
+	 * @line_no:	Line number at which the CMD needs to be triggered.
+	 * @window:	Width of the DMA CMD window.
+	 */
+	void (*configure_cmddma_window)(struct dsi_ctrl_hw *ctrl,
+			struct dsi_ctrl_cmd_dma_info *cmd,
+			u32 line_no, u32 window);
+
+	/**
+	 * hw.ops.reset_trig_ctrl() - resets trigger control of DSI controller
+	 * @ctrl:	Pointer to the controller host hardware.
+	 * @cfg:	Common configuration parameters.
+	 */
+	void (*reset_trig_ctrl)(struct dsi_ctrl_hw *ctrl,
+			struct dsi_host_common_cfg *cfg);
 };
 
 /*
@@ -891,6 +910,7 @@ struct dsi_ctrl_hw {
 	void __iomem *te_rd_ptr_reg;
 	void __iomem *line_count_reg;
 	u32 disp_cc_length;
+	void __iomem *mdp_intf_base;
 	u32 index;
 
 	/* features */
@@ -903,6 +923,7 @@ struct dsi_ctrl_hw {
 
 	bool phy_isolation_enabled;
 	bool null_insertion_enabled;
+	bool reset_trig_ctrl;
 };
 
 #endif /* _DSI_CTRL_HW_H_ */
diff --git a/techpack/display/msm/dsi/dsi_ctrl_hw_2_2.c b/techpack/display/msm/dsi/dsi_ctrl_hw_2_2.c
index 56821e857a91..14fd2e388936 100644
--- a/techpack/display/msm/dsi/dsi_ctrl_hw_2_2.c
+++ b/techpack/display/msm/dsi/dsi_ctrl_hw_2_2.c
@@ -12,6 +12,12 @@
 
 /* register to configure DMA scheduling */
 #define DSI_DMA_SCHEDULE_CTRL 0x100
+#define DSI_DMA_SCHEDULE_CTRL2 0x0104
+
+/* offset addresses of MDP INTF base register, to be mapped for debug feature */
+#define MDP_INTF_TEAR_OFFSET 0x280
+#define MDP_INTF_TEAR_LINE_COUNT_OFFSET 0x30
+#define MDP_INTF_LINE_COUNT_OFFSET 0xB0
 
 /* MDP INTF registers to be mapped*/
 #define MDP_INTF1_TEAR_LINE_COUNT 0xAE6BAB0
@@ -51,6 +57,7 @@ void dsi_ctrl_hw_22_schedule_dma_cmd(struct dsi_ctrl_hw *ctrl, int line_no)
 	reg |= (line_no & 0xffff);
 
 	DSI_W32(ctrl, DSI_DMA_SCHEDULE_CTRL, reg);
+	ctrl->reset_trig_ctrl = true;
 }
 
 /*
@@ -181,10 +188,85 @@ u32 dsi_ctrl_hw_22_log_line_count(struct dsi_ctrl_hw *ctrl, bool cmd_mode)
 
 	u32 reg = 0;
 
-	if (cmd_mode && ctrl->te_rd_ptr_reg)
-		reg = readl_relaxed(ctrl->te_rd_ptr_reg);
-	else if (ctrl->line_count_reg)
-		reg = readl_relaxed(ctrl->line_count_reg);
+	if (IS_ERR_OR_NULL(ctrl->mdp_intf_base))
+		return reg;
+
+	if (cmd_mode)
+		reg = readl_relaxed(ctrl->mdp_intf_base + MDP_INTF_TEAR_OFFSET
+					+ MDP_INTF_TEAR_LINE_COUNT_OFFSET);
+	else
+		reg = readl_relaxed(ctrl->mdp_intf_base
+					+ MDP_INTF_LINE_COUNT_OFFSET);
 
 	return reg;
 }
+
+/**
+ * dsi_ctrl_hw_22_configure_cmddma_window() - configure DMA window for CMD TX
+ * @ctrl:       Pointer to the controller host hardware.
+ * @cmd:        Pointer to the DSI DMA command info.
+ * @line_no:    Line number at which the CMD needs to be triggered.
+ * @window:     Width of the DMA CMD window.
+ */
+void dsi_ctrl_hw_22_configure_cmddma_window(struct dsi_ctrl_hw *ctrl,
+		struct dsi_ctrl_cmd_dma_info *cmd,
+		u32 line_no, u32 window)
+{
+	u32 reg = 0;
+
+	if (!window)
+		return;
+
+	if (cmd->en_broadcast) {
+		reg = DSI_R32(ctrl, DSI_TRIG_CTRL);
+		if (cmd->is_master) {
+			reg &= ~0xF;
+			reg |= 0xc;
+		} else {
+			reg &= ~0xF;
+			reg |= BIT(16);
+		}
+
+		DSI_W32(ctrl, DSI_TRIG_CTRL, reg);
+
+		if (cmd->is_master) {
+			reg = 0;
+			reg |= line_no;
+			reg |= window << 16;
+			DSI_W32(ctrl, DSI_DMA_SCHEDULE_CTRL2, reg);
+		}
+	} else {
+		reg = DSI_R32(ctrl, DSI_TRIG_CTRL);
+		reg &= ~0xF;
+		reg |= 0xc;
+		DSI_W32(ctrl, DSI_TRIG_CTRL, reg);
+
+		reg = 0;
+		reg |= line_no;
+		reg |= window << 16;
+		DSI_W32(ctrl, DSI_DMA_SCHEDULE_CTRL2, reg);
+	}
+	ctrl->reset_trig_ctrl = true;
+}
+
+/**
+ * dsi_ctrl_hw_22_reset_trigger_controls() - reset dsi trigger configurations
+ * @ctrl:		Pointer to the controller host hardware.
+ * @cfg:		DSI host configuration that is common to both video and
+ *			command modes.
+ */
+void dsi_ctrl_hw_22_reset_trigger_controls(struct dsi_ctrl_hw *ctrl,
+					struct dsi_host_common_cfg *cfg)
+{
+	u32 reg = 0;
+	const u8 trigger_map[DSI_TRIGGER_MAX] = {
+		0x0, 0x2, 0x1, 0x4, 0x5, 0x6 };
+
+	reg |= (cfg->te_mode == DSI_TE_ON_EXT_PIN) ? BIT(31) : 0;
+	reg |= (trigger_map[cfg->dma_cmd_trigger] & 0x7);
+	reg |= (trigger_map[cfg->mdp_cmd_trigger] & 0x7) << 4;
+	DSI_W32(ctrl, DSI_TRIG_CTRL, reg);
+	DSI_W32(ctrl, DSI_DMA_SCHEDULE_CTRL2, 0x0);
+	DSI_W32(ctrl, DSI_DMA_SCHEDULE_CTRL, 0x0);
+	ctrl->reset_trig_ctrl = false;
+}
diff --git a/techpack/display/msm/dsi/dsi_defs.h b/techpack/display/msm/dsi/dsi_defs.h
index 5179edfebd02..ecf649ba646f 100644
--- a/techpack/display/msm/dsi/dsi_defs.h
+++ b/techpack/display/msm/dsi/dsi_defs.h
@@ -297,6 +297,7 @@ enum dsi_cmd_set_type {
 	DSI_CMD_SET_POST_CMD_TO_VID_SWITCH,
 	DSI_CMD_SET_VID_TO_CMD_SWITCH,
 	DSI_CMD_SET_POST_VID_TO_CMD_SWITCH,
+	DSI_CMD_SET_PANEL_STATUS_OFFSET,
 	DSI_CMD_SET_PANEL_STATUS,
 	DSI_CMD_SET_LP1,
 	DSI_CMD_SET_LP2,
@@ -307,6 +308,107 @@ enum dsi_cmd_set_type {
 	DSI_CMD_SET_POST_TIMING_SWITCH,
 	DSI_CMD_SET_QSYNC_ON,
 	DSI_CMD_SET_QSYNC_OFF,
+	/* xiaomi add start */
+	DSI_CMD_SET_MI_CEON,
+	DSI_CMD_SET_MI_CEOFF,
+	DSI_CMD_SET_MI_CABCUION,
+	DSI_CMD_SET_MI_CABCSTILLON,
+	DSI_CMD_SET_MI_CABCMOVIEON,
+	DSI_CMD_SET_MI_CABCOFF,
+	DSI_CMD_SET_MI_SKINCE_CABCUION,
+	DSI_CMD_SET_MI_SKINCE_CABCSTILLON,
+	DSI_CMD_SET_MI_SKINCE_CABCMOVIEON,
+	DSI_CMD_SET_MI_SKINCE_CABCOFF,
+	DSI_CMD_SET_MI_DIMMINGON,
+	DSI_CMD_SET_MI_DIMMINGOFF,
+	DSI_CMD_SET_MI_ACL_OFF,
+	DSI_CMD_SET_MI_ACL_L1,
+	DSI_CMD_SET_MI_ACL_L2,
+	DSI_CMD_SET_MI_ACL_L3,
+	DSI_CMD_SET_DISP_LCD_HBM_L1_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_L2_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_L3_ON,
+	DSI_CMD_SET_DISP_LCD_HBM_OFF,
+	DSI_CMD_SET_MI_HBM_ON,
+	DSI_CMD_SET_MI_HBM_OFF,
+	DSI_CMD_SET_MI_HBM_FOD_ON,
+	DSI_CMD_SET_MI_HBM_FOD_OFF,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT,
+	DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT,
+	DSI_CMD_SET_MI_FOD_LHBM_OFF,
+	DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT_READ_REG_PRE,
+	DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT_READ_REG,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_GIR_OFF_READ_REG_PRE,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_GIR_ON_READ_REG_PRE,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_GIR_OFF_READ_REG_PRE,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_GIR_ON_READ_REG_PRE,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_READ_OFFSET_REG,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_READ_OFFSET_REG,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B2_REG,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B5_REG,
+	DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B8_REG,
+	DSI_CMD_SET_MI_HBM_HDR_ON,
+	DSI_CMD_SET_MI_HBM_HDR_OFF,
+	DSI_CMD_SET_MI_HBM_FOD2NORM,
+	DSI_CMD_SET_MI_NORMAL1,
+	DSI_CMD_SET_MI_CRC_DCIP3,
+	DSI_CMD_SET_MI_SRGB,
+	DSI_CMD_SET_MI_DOZE_HBM,
+	DSI_CMD_SET_MI_DOZE_LBM,
+	DSI_CMD_SET_MI_CRC_OFF,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_OFF,
+	DSI_CMD_SET_MI_FLAT_MODE_ON,
+	DSI_CMD_SET_MI_FLAT_MODE_OFF,
+	DSI_CMD_SET_MI_GIR_ON,
+	DSI_CMD_SET_MI_GIR_OFF,
+	DSI_CMD_SET_MI_GIR_READ_REG_PRE,
+	DSI_CMD_SET_MI_GIR_OFF_READ_REG_PRE,
+	DSI_CMD_SET_MI_GIR_READ_REG,
+	DSI_CMD_SET_TIMING_SWITCH_GIR_ON,
+	DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_C8,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_C9,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE,
+	DSI_CMD_SET_MI_GAMMA_OTP_READ_B3,
+	DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE,
+	DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE,
+	DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB,
+	DSI_CMD_SET_MI_WHITE_POINT_READ,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET,
+	DSI_CMD_SET_MI_ELVSS_DIMMING_READ,
+	DSI_CMD_SET_MI_DC_ON,
+	DSI_CMD_SET_MI_DC_OFF,
+	DSI_CMD_SET_MI_VI_SETTING_LOW,
+	DSI_CMD_SET_MI_VI_SETTING_HIGH,
+	DSI_CMD_SET_MI_SWITCH_PAGE4,
+	DSI_CMD_SET_MI_DC_READ,
+	DSI_CMD_SET_MI_DC_READ_D2,
+	DSI_CMD_SET_MI_DC_READ_D4,
+	DSI_CMD_SET_MI_AOD_TO_DC_ON,
+	DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON,
+	DSI_CMD_SET_MI_DYNAMIC_ELVSS_OFF,
+	DSI_CMD_SET_MI_GAMMA_PRE_READ,
+	DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE,
+	DSI_CMD_SET_MI_GAMMA_READ_B7,
+	DSI_CMD_SET_MI_GAMMA_B7,
+	DSI_CMD_SET_MI_BLACK_SETTING,
+	DSI_CMD_SET_MI_READ_LOCKDOWN_INFO,
+	DSI_CMD_SET_DISP_PEN_120HZ,
+	DSI_CMD_SET_DISP_PEN_60HZ,
+	DSI_CMD_SET_DISP_PEN_30HZ,
+	DSI_CMD_SET_DISABLE_INSERT_BLACK,
+	DSI_CMD_SET_INSERT_BLACK,
+	DSI_CMD_SET_MI_ROUND_ON,
+	DSI_CMD_SET_MI_ROUND_OFF,
+	DSI_CMD_SET_MI_DIM_FP_DBV_MAX_IN_HBM,
+	DSI_CMD_SET_MI_DIM_FP_DBV_MAX_IN_NORMAL,
+	/* xiaomi add end */
 	DSI_CMD_SET_MAX
 };
 
@@ -515,6 +617,10 @@ struct dsi_host_common_cfg {
 	enum dsi_phy_type phy_type;
 	struct dsi_split_link_config split_link;
 	u32 byte_intf_clk_div;
+	u32 clk_strength;
+	bool cphy_strength;
+	u32 dma_sched_line;
+	u32 dma_sched_window;
 };
 
 /**
diff --git a/techpack/display/msm/dsi/dsi_display.c b/techpack/display/msm/dsi/dsi_display.c
index acb1f7db43e1..bfa9a5a1b468 100644
--- a/techpack/display/msm/dsi/dsi_display.c
+++ b/techpack/display/msm/dsi/dsi_display.c
@@ -7,12 +7,14 @@
 #include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <linux/err.h>
+#include <drm/drm_notifier_mi.h>
 
 #include "msm_drv.h"
 #include "sde_connector.h"
 #include "msm_mmu.h"
 #include "dsi_display.h"
 #include "dsi_panel.h"
+#include "dsi_panel_mi.h"
 #include "dsi_ctrl.h"
 #include "dsi_ctrl_hw.h"
 #include "dsi_drm.h"
@@ -33,6 +35,10 @@
 #define DSI_CLOCK_BITRATE_RADIX 10
 #define MAX_TE_SOURCE_ID  2
 
+DEFINE_MUTEX(dsi_display_clk_mutex);
+
+extern int mi_disp_lhbm_attach_primary_dsi_display(struct dsi_display *display);
+
 static char dsi_display_primary[MAX_CMDLINE_PARAM_LEN];
 static char dsi_display_secondary[MAX_CMDLINE_PARAM_LEN];
 static struct dsi_display_boot_param boot_displays[MAX_DSI_ACTIVE_DISPLAY] = {
@@ -246,7 +252,7 @@ int dsi_display_set_backlight(struct drm_connector *connector,
 	return rc;
 }
 
-static int dsi_display_cmd_engine_enable(struct dsi_display *display)
+int dsi_display_cmd_engine_enable(struct dsi_display *display)
 {
 	int rc = 0;
 	int i;
@@ -290,7 +296,7 @@ static int dsi_display_cmd_engine_enable(struct dsi_display *display)
 	return rc;
 }
 
-static int dsi_display_cmd_engine_disable(struct dsi_display *display)
+int dsi_display_cmd_engine_disable(struct dsi_display *display)
 {
 	int rc = 0;
 	int i;
@@ -476,7 +482,7 @@ static void dsi_display_register_te_irq(struct dsi_display *display)
 }
 
 /* Allocate memory for cmd dma tx buffer */
-static int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display)
+int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display)
 {
 	int rc = 0, cnt = 0;
 	struct dsi_display_ctrl *display_ctrl;
@@ -646,8 +652,10 @@ static int dsi_display_read_status(struct dsi_display_ctrl *ctrl,
 	lenp = config->status_valid_params ?: config->status_cmds_rlen;
 	count = config->status_cmd.count;
 	cmds = config->status_cmd.cmds;
-	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ |
-		  DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ);
+
+	if (ctrl->ctrl->host_config.panel_mode == DSI_OP_VIDEO_MODE)
+		flags |= DSI_CTRL_CMD_CUSTOM_DMA_SCHED;
 
 	for (i = 0; i < count; ++i) {
 		memset(config->status_buf, 0x0, SZ_4K);
@@ -655,6 +663,10 @@ static int dsi_display_read_status(struct dsi_display_ctrl *ctrl,
 			cmds[i].msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
 			flags |= DSI_CTRL_CMD_LAST_COMMAND;
 		}
+		if ((cmds[i].msg.flags & MIPI_DSI_MSG_CMD_DMA_SCHED) &&
+			(panel->panel_initialized))
+			flags |= DSI_CTRL_CMD_CUSTOM_DMA_SCHED;
+
 		if (config->status_cmd.state == DSI_CMD_SET_STATE_LP)
 			cmds[i].msg.flags |= MIPI_DSI_MSG_USE_LPM;
 		cmds[i].msg.rx_buf = config->status_buf;
@@ -781,6 +793,7 @@ int dsi_display_check_status(struct drm_connector *connector, void *display,
 					bool te_check_override)
 {
 	struct dsi_display *dsi_display = display;
+	struct drm_panel_esd_config *config;
 	struct dsi_panel *panel;
 	u32 status_mode;
 	int rc = 0x1, ret;
@@ -832,6 +845,11 @@ int dsi_display_check_status(struct drm_connector *connector, void *display,
 	dsi_display_mask_ctrl_error_interrupts(dsi_display, mask, true);
 
 	if (status_mode == ESD_MODE_REG_READ) {
+		config = &(panel->esd_config);
+		if (config->offset_cmd.count != 0) {
+			rc = dsi_panel_write_cmd_set(panel, &config->offset_cmd);
+		}
+
 		rc = dsi_display_status_reg_read(dsi_display);
 	} else if (status_mode == ESD_MODE_SW_BTA) {
 		rc = dsi_display_status_bta_request(dsi_display);
@@ -1045,24 +1063,46 @@ int dsi_display_set_power(struct drm_connector *connector,
 		int power_mode, void *disp)
 {
 	struct dsi_display *display = disp;
+	struct dsi_panel_mi_cfg *mi_cfg;
 	int rc = 0;
+	struct mi_drm_notifier notify_data;
 
 	if (!display || !display->panel) {
 		DSI_ERR("invalid display/panel\n");
 		return -EINVAL;
 	}
 
+	mi_cfg = &display->panel->mi_cfg;
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+
 	switch (power_mode) {
 	case SDE_MODE_DPMS_LP1:
+		mi_cfg->in_aod = true;
+		mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 		rc = dsi_panel_set_lp1(display->panel);
+		if (mi_cfg->unset_doze_brightness)
+			dsi_panel_set_doze_brightness(display->panel,
+				mi_cfg->unset_doze_brightness, true);
+		mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 		break;
 	case SDE_MODE_DPMS_LP2:
+		mi_cfg->in_aod = true;
+		mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 		rc = dsi_panel_set_lp2(display->panel);
+		if (mi_cfg->unset_doze_brightness)
+			dsi_panel_set_doze_brightness(display->panel,
+				mi_cfg->unset_doze_brightness, true);
+		mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 		break;
 	case SDE_MODE_DPMS_ON:
 		if ((display->panel->power_mode == SDE_MODE_DPMS_LP1) ||
-			(display->panel->power_mode == SDE_MODE_DPMS_LP2))
+			(display->panel->power_mode == SDE_MODE_DPMS_LP2)) {
+			mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
 			rc = dsi_panel_set_nolp(display->panel);
+			mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
+		}
 		break;
 	case SDE_MODE_DPMS_OFF:
 	default:
@@ -2760,6 +2800,12 @@ static int dsi_display_broadcast_cmd(struct dsi_display *display,
 		m_flags |= DSI_CTRL_CMD_LAST_COMMAND;
 	}
 
+	if ((msg->flags & MIPI_DSI_MSG_CMD_DMA_SCHED) &&
+			(display->panel->panel_initialized)) {
+		flags |= DSI_CTRL_CMD_CUSTOM_DMA_SCHED;
+		m_flags |= DSI_CTRL_CMD_CUSTOM_DMA_SCHED;
+	}
+
 	if (display->queue_cmd_waits ||
 			msg->flags & MIPI_DSI_MSG_ASYNC_OVERRIDE) {
 		flags |= DSI_CTRL_CMD_ASYNC_WAIT;
@@ -2940,6 +2986,10 @@ static ssize_t dsi_host_transfer(struct mipi_dsi_host *host,
 				msg->flags & MIPI_DSI_MSG_ASYNC_OVERRIDE)
 			cmd_flags |= DSI_CTRL_CMD_ASYNC_WAIT;
 
+		if ((msg->flags & MIPI_DSI_MSG_CMD_DMA_SCHED) &&
+				(display->panel->panel_initialized))
+			cmd_flags |= DSI_CTRL_CMD_CUSTOM_DMA_SCHED;
+
 		rc = dsi_ctrl_cmd_transfer(display->ctrl[ctrl_idx].ctrl, msg,
 				&cmd_flags);
 		if (rc) {
@@ -4951,7 +5001,23 @@ int dsi_display_splash_res_cleanup(struct  dsi_display *display)
 
 static int dsi_display_force_update_dsi_clk(struct dsi_display *display)
 {
-	int rc = 0;
+	int rc = 0, i = 0;
+	struct dsi_display_ctrl *ctrl;
+
+
+	/*
+	 * The force update dsi clock, is the only clock update function that toggles the state of
+	 * DSI clocks without any ref count protection. With the addition of ASYNC command wait,
+	 * there is a need for adding a check for any queued waits before updating these clocks.
+	 */
+	display_for_each_ctrl(i, display) {
+		ctrl = &display->ctrl[i];
+		if (!ctrl->ctrl || !ctrl->ctrl->dma_wait_queued)
+			continue;
+		flush_workqueue(display->dma_cmd_workq);
+		cancel_work_sync(&ctrl->ctrl->dma_cmd_wait);
+		ctrl->ctrl->dma_wait_queued = false;
+	}
 
 	rc = dsi_display_link_clk_force_update_ctrl(display->dsi_clk_handle);
 
@@ -5210,6 +5276,10 @@ static int dsi_display_bind(struct device *dev,
 	/* register te irq handler */
 	dsi_display_register_te_irq(display);
 
+	rc = mi_disp_lhbm_attach_primary_dsi_display(display);
+	if (rc)
+		DSI_ERR("lhbm attach primary_dsi_display fail\n");
+
 	goto error;
 
 error_host_deinit:
@@ -5416,6 +5486,7 @@ int dsi_display_dev_probe(struct platform_device *pdev)
 	display->panel_node = panel_node;
 	display->pdev = pdev;
 	display->boot_disp = boot_disp;
+	display->is_prim_display = true;
 
 	dsi_display_parse_cmdline_topology(display, index);
 
@@ -6782,6 +6853,11 @@ int dsi_display_set_mode(struct dsi_display *display,
 			timing.h_active, timing.v_active,
 			timing.refresh_rate);
 
+	if (display->panel->cur_mode->timing.refresh_rate != timing.refresh_rate) {
+		if (display->drm_conn && display->drm_conn->kdev)
+			sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "dynamic_fps");
+	}
+
 	memcpy(display->panel->cur_mode, &adj_mode, sizeof(adj_mode));
 error:
 	mutex_unlock(&display->display_lock);
@@ -7598,6 +7674,69 @@ int dsi_display_enable(struct dsi_display *display)
 
 		display->panel->panel_initialized = true;
 		DSI_DEBUG("cont splash enabled, display enable not required\n");
+
+		rc = dsi_panel_update_elvss_dimming(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to update elvss dimming parameter, rc=%d\n",
+			       display->name, rc);
+		}
+
+		rc = dsi_panel_read_gamma_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read gamma para, rc=%d\n",
+				display->name, rc);
+		} else {
+			rc = dsi_panel_update_gamma_param(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update gamma para, rc=%d\n",
+					display->name, rc);
+			}
+		}
+
+		rc = dsi_panel_read_dc_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read DC para, rc=%d\n",
+				display->name, rc);
+		} else {
+			rc = dsi_panel_update_dc_param(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update DC para, rc=%d\n",
+					display->name, rc);
+			}
+		}
+
+		rc = mi_dsi_panel_read_and_update_dc_param_v2(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read DC para, rc=%d\n",
+				display->name, rc);
+		}
+
+		rc = mi_dsi_panel_read_and_update_gir_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read and update gir  para, rc=%d\n",
+				display->name, rc);
+		}
+
+		rc = mi_dsi_panel_read_and_update_lhbm_green_500nit_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read and update fod lhbm green 500nit  para, rc=%d\n",
+				display->name, rc);
+		}
+
+		rc = mi_dsi_panel_read_lhbm_white_param(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read fod lhbm white para, rc=%d\n",
+				display->name, rc);
+		}
+
+		if (display->panel->mi_cfg.is_tddi_flag) {
+			rc = dsi_panel_lockdowninfo_param_read(display->panel);
+			if (!rc) {
+				DSI_ERR("[%s] failed to read lockdowninfo para, rc=%d\n",
+					display->name, rc);
+			}
+		}
+
 		return 0;
 	}
 
@@ -7636,10 +7775,28 @@ int dsi_display_enable(struct dsi_display *display)
 
 	if (mode->dsi_mode_flags & DSI_MODE_FLAG_DMS) {
 		rc = dsi_panel_switch(display->panel);
-		if (rc)
+		if (rc) {
 			DSI_ERR("[%s] failed to switch DSI panel mode, rc=%d\n",
 				   display->name, rc);
+			goto error;
+		}
 
+		if ((display->panel->mi_cfg.panel_id >> 8) == 0x4A3153004202) {
+
+			rc = dsi_panel_dc_switch(display->panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to set dc command, rc=%d\n",
+					display->name, rc);
+				goto error;
+			}
+		}
+
+		rc = dsi_panel_switch_disp_rate_gpio(display->panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to set disp_rate gpio, rc=%d\n",
+				   display->name, rc);
+			goto error;
+		}
 		goto error;
 	}
 
diff --git a/techpack/display/msm/dsi/dsi_display.h b/techpack/display/msm/dsi/dsi_display.h
index d254dfe739bd..ec0dbab2ddec 100644
--- a/techpack/display/msm/dsi/dsi_display.h
+++ b/techpack/display/msm/dsi/dsi_display.h
@@ -199,6 +199,7 @@ struct dsi_display {
 	const char *display_type;
 	struct list_head list;
 	bool is_cont_splash_enabled;
+	bool is_prim_display;
 	bool sw_te_using_wd;
 	struct mutex display_lock;
 	int disp_te_gpio;
@@ -735,4 +736,14 @@ int dsi_display_cont_splash_config(void *display);
 int dsi_display_get_panel_vfp(void *display,
 	int h_active, int v_active);
 
+int dsi_display_cmd_engine_enable(struct dsi_display *display);
+int dsi_display_cmd_engine_disable(struct dsi_display *display);
+int dsi_host_alloc_cmd_tx_buffer(struct dsi_display *display);
+
+int dsi_display_hbm_set_disp_param(struct drm_connector *connector,
+				u32 param_type);
+
+int dsi_display_esd_irq_ctrl(struct dsi_display *display,
+		bool enable);
+
 #endif /* _DSI_DISPLAY_H_ */
diff --git a/techpack/display/msm/dsi/dsi_display_mi.c b/techpack/display/msm/dsi/dsi_display_mi.c
new file mode 100644
index 000000000000..85f8ee6e6406
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_display_mi.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"mi-dsi-display:[%s] " fmt, __func__
+
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/err.h>
+
+#include "msm_drv.h"
+#include "sde_connector.h"
+#include "msm_mmu.h"
+#include "dsi_display.h"
+#include "dsi_panel.h"
+#include "dsi_panel_mi.h"
+#include "dsi_ctrl.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_drm.h"
+#include "dsi_clk.h"
+#include "dsi_pwr.h"
+#include "sde_dbg.h"
+#include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+#include "../msm_drv.h"
+
+#define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
+
+static atomic64_t g_param = ATOMIC64_INIT(0);
+
+int dsi_display_set_disp_param(struct drm_connector *connector,
+			u32 param_type)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	int ret = 0;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		pr_err("Invalid connector/encoder/bridge ptr\n");
+		return -EINVAL;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		pr_err("Invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	atomic64_set(&g_param, param_type);
+	if (sde_kms_is_suspend_blocked(display->drm_dev) &&
+		dsi_panel_is_need_tx_cmd(param_type)) {
+		pr_err("sde_kms is suspended, skip to set_disp_param\n");
+		return -EBUSY;
+	}
+
+	ret = dsi_panel_set_disp_param(display->panel, param_type);
+
+	return ret;
+}
+
+int dsi_display_hbm_set_disp_param(struct drm_connector *connector,
+				u32 op_code)
+{
+	int rc;
+	struct sde_connector *c_conn;
+
+	c_conn = to_sde_connector(connector);
+
+	pr_debug("%s fod hbm command:0x%x \n", __func__, op_code);
+
+	if (op_code == DISPPARAM_HBM_FOD_ON) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_FOD_ON);
+	} else if (op_code == DISPPARAM_HBM_FOD_OFF) {
+		/* close HBM and restore DC */
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_FOD_OFF);
+	} else if(op_code == DISPPARAM_DIMMING_OFF) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_DIMMING_OFF);
+	} else if (op_code == DISPPARAM_HBM_BACKLIGHT_RESEND) {
+		rc = dsi_display_set_disp_param(connector, DISPPARAM_HBM_BACKLIGHT_RESEND);
+	}
+
+	return rc;
+}
+
+int dsi_display_esd_irq_ctrl(struct dsi_display *display,
+		bool enable)
+{
+	int rc = 0;
+
+	if (!display) {
+		DSI_ERR("Invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&display->display_lock);
+
+	rc = dsi_panel_esd_irq_ctrl(display->panel, enable);
+	if (rc)
+		pr_err("[%s] failed to set esd irq, rc=%d\n",
+				display->name, rc);
+
+	mutex_unlock(&display->display_lock);
+
+	return rc;
+}
diff --git a/techpack/display/msm/dsi/dsi_drm.c b/techpack/display/msm/dsi/dsi_drm.c
index 0457c57b6d6e..db00c16a7c8e 100644
--- a/techpack/display/msm/dsi/dsi_drm.c
+++ b/techpack/display/msm/dsi/dsi_drm.c
@@ -6,12 +6,19 @@
 
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_atomic.h>
+#include <drm/drm_notifier_mi.h>
 
 #include "msm_kms.h"
 #include "sde_connector.h"
 #include "dsi_drm.h"
 #include "sde_trace.h"
+#include <drm/drm_bridge.h>
+#include <linux/pm_wakeup.h>
+#include "msm_drv.h"
 #include "sde_dbg.h"
+#include "dsi_defs.h"
+#include "sde_encoder.h"
+#include "dsi_mi_feature.h"
 
 #define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
 #define to_dsi_state(x)      container_of((x), struct dsi_connector_state, base)
@@ -28,6 +35,13 @@ static struct dsi_display_mode_priv_info default_priv_info = {
 	.dsc_enabled = false,
 };
 
+#define WAIT_RESUME_TIMEOUT 200
+
+struct dsi_bridge *gbridge;
+static struct delayed_work prim_panel_work;
+static atomic_t prim_panel_is_on;
+static struct wakeup_source *prim_panel_wakelock;
+
 static void convert_to_dsi_mode(const struct drm_display_mode *drm_mode,
 				struct dsi_display_mode *dsi_mode)
 {
@@ -165,6 +179,9 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	int rc = 0;
 	struct dsi_bridge *c_bridge = to_dsi_bridge(bridge);
+	struct mi_drm_notifier notify_data;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	int power_mode = 0;
 
 	if (!bridge) {
 		DSI_ERR("Invalid params\n");
@@ -179,6 +196,8 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 	if (bridge->encoder->crtc->state->active_changed)
 		atomic_set(&c_bridge->display->panel->esd_recovery_pending, 0);
 
+	mi_cfg = &c_bridge->display->panel->mi_cfg;
+
 	/* By this point mode should have been validated through mode_fixup */
 	rc = dsi_display_set_mode(c_bridge->display,
 			&(c_bridge->dsi_mode), 0x0);
@@ -188,6 +207,29 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 		return;
 	}
 
+	if (c_bridge->display->is_prim_display && atomic_read(&prim_panel_is_on) && !mi_cfg->fod_dimlayer_enabled) {
+		cancel_delayed_work_sync(&prim_panel_work);
+		__pm_relax(prim_panel_wakelock);
+		if (c_bridge->display->panel->panel_mode == DSI_OP_VIDEO_MODE) {
+			DSI_INFO("skip set display config for video panel in fpc\n");
+			return;
+		} else if (c_bridge->display->panel->panel_mode == DSI_OP_CMD_MODE &&
+		    c_bridge->dsi_mode.dsi_mode_flags != DSI_MODE_FLAG_DMS) {
+			DSI_INFO("skip set display config because timming not switch for command panel\n");
+			return;
+		}
+	}
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		power_mode = sde_connector_get_lp(c_bridge->display->drm_conn);
+	} else {
+		power_mode = MI_DRM_BLANK_UNBLANK;
+	}
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+	mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
+
 	if (c_bridge->dsi_mode.dsi_mode_flags &
 		(DSI_MODE_FLAG_SEAMLESS | DSI_MODE_FLAG_VRR |
 		 DSI_MODE_FLAG_DYN_CLK)) {
@@ -212,12 +254,16 @@ static void dsi_bridge_pre_enable(struct drm_bridge *bridge)
 				c_bridge->id, rc);
 		(void)dsi_display_unprepare(c_bridge->display);
 	}
+
+	mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 	SDE_ATRACE_END("dsi_display_enable");
 
 	rc = dsi_display_splash_res_cleanup(c_bridge->display);
 	if (rc)
 		DSI_ERR("Continuous splash pipeline cleanup failed, rc=%d\n",
 									rc);
+	if (c_bridge->display->is_prim_display)
+		atomic_set(&prim_panel_is_on, true);
 }
 
 static void dsi_bridge_enable(struct drm_bridge *bridge)
@@ -250,6 +296,12 @@ static void dsi_bridge_enable(struct drm_bridge *bridge)
 			sde_connector_schedule_status_work(display->drm_conn,
 				true);
 	}
+
+	rc = dsi_display_esd_irq_ctrl(c_bridge->display, true);
+	if (rc) {
+		DSI_ERR("[%d] DSI display enable esd irq failed, rc=%d\n",
+				c_bridge->id, rc);
+	}
 }
 
 static void dsi_bridge_disable(struct drm_bridge *bridge)
@@ -257,16 +309,38 @@ static void dsi_bridge_disable(struct drm_bridge *bridge)
 	int rc = 0;
 	int private_flags;
 	struct dsi_display *display;
+	struct mi_drm_notifier notify_data;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	int power_mode = 0;
 	struct dsi_bridge *c_bridge = to_dsi_bridge(bridge);
 
 	if (!bridge) {
 		DSI_ERR("Invalid params\n");
 		return;
 	}
+
+	mi_cfg = &c_bridge->display->panel->mi_cfg;
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		power_mode = sde_connector_get_lp(c_bridge->display->drm_conn);
+	} else {
+		power_mode = MI_DRM_BLANK_POWERDOWN;
+	}
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+	mi_drm_notifier_call_chain(MI_DRM_PRE_EVENT_BLANK, &notify_data);
+
 	display = c_bridge->display;
 	private_flags =
 		bridge->encoder->crtc->state->adjusted_mode.private_flags;
 
+	rc = dsi_display_esd_irq_ctrl(c_bridge->display, false);
+	if (rc) {
+		DSI_ERR("[%d] DSI display disable esd irq failed, rc=%d\n",
+				c_bridge->id, rc);
+	}
+
 	if (display && display->drm_conn) {
 		display->poms_pending =
 			private_flags & MSM_MODE_FLAG_SEAMLESS_POMS;
@@ -285,12 +359,27 @@ static void dsi_bridge_post_disable(struct drm_bridge *bridge)
 {
 	int rc = 0;
 	struct dsi_bridge *c_bridge = to_dsi_bridge(bridge);
+	struct mi_drm_notifier notify_data;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	int power_mode = 0;
 
 	if (!bridge) {
 		DSI_ERR("Invalid params\n");
 		return;
 	}
 
+	mi_cfg = &c_bridge->display->panel->mi_cfg;
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		power_mode = sde_connector_get_lp(c_bridge->display->drm_conn);
+	} else {
+		power_mode = MI_DRM_BLANK_POWERDOWN;
+	}
+
+	notify_data.data = &power_mode;
+	notify_data.id = MSM_DRM_PRIMARY_DISPLAY;
+	mi_drm_notifier_call_chain(MI_DRM_EARLY_EVENT_BLANK, &notify_data);
+
 	SDE_ATRACE_BEGIN("dsi_bridge_post_disable");
 	SDE_ATRACE_BEGIN("dsi_display_disable");
 	rc = dsi_display_disable(c_bridge->display);
@@ -309,9 +398,25 @@ static void dsi_bridge_post_disable(struct drm_bridge *bridge)
 		SDE_ATRACE_END("dsi_bridge_post_disable");
 		return;
 	}
+
+	mi_drm_notifier_call_chain(MI_DRM_EVENT_BLANK, &notify_data);
 	SDE_ATRACE_END("dsi_bridge_post_disable");
+	if (c_bridge->display->is_prim_display)
+		atomic_set(&prim_panel_is_on, false);
 }
 
+static void prim_panel_off_delayed_work(struct work_struct *work)
+{
+	mutex_lock(&gbridge->base.lock);
+	if (atomic_read(&prim_panel_is_on)) {
+		dsi_bridge_post_disable(&gbridge->base);
+		__pm_relax(prim_panel_wakelock);
+		mutex_unlock(&gbridge->base.lock);
+		return;
+	}
+	mutex_unlock(&gbridge->base.lock);
+} // git
+
 static void dsi_bridge_mode_set(struct drm_bridge *bridge,
 				struct drm_display_mode *mode,
 				struct drm_display_mode *adjusted_mode)
@@ -426,7 +531,8 @@ static bool dsi_bridge_mode_fixup(struct drm_bridge *bridge,
 			(!(dsi_mode.dsi_mode_flags & DSI_MODE_FLAG_POMS)) &&
 			(!(dsi_mode.dsi_mode_flags & DSI_MODE_FLAG_DYN_CLK)) &&
 			(!crtc_state->active_changed ||
-			 display->is_cont_splash_enabled)) {
+			 display->is_cont_splash_enabled) &&
+			 display->config.panel_mode == DSI_OP_CMD_MODE) {
 			dsi_mode.dsi_mode_flags |= DSI_MODE_FLAG_DMS;
 
 			SDE_EVT32(SDE_EVTLOG_FUNC_CASE2,
@@ -1057,6 +1163,18 @@ struct dsi_bridge *dsi_drm_bridge_init(struct dsi_display *display,
 	}
 
 	encoder->bridge = &bridge->base;
+
+	encoder->bridge->is_dsi_drm_bridge = true;
+	mutex_init(&encoder->bridge->lock);
+
+	if (display->is_prim_display) {
+		gbridge = bridge;
+		prim_panel_wakelock = wakeup_source_create("prim_panel_wakelock");
+		wakeup_source_add(prim_panel_wakelock);
+		atomic_set(&prim_panel_is_on, false);
+		INIT_DELAYED_WORK(&prim_panel_work, prim_panel_off_delayed_work);
+	}
+
 	return bridge;
 error_free_bridge:
 	kfree(bridge);
@@ -1069,5 +1187,12 @@ void dsi_drm_bridge_cleanup(struct dsi_bridge *bridge)
 	if (bridge && bridge->base.encoder)
 		bridge->base.encoder->bridge = NULL;
 
+	if (bridge == gbridge) {
+		atomic_set(&prim_panel_is_on, false);
+		cancel_delayed_work_sync(&prim_panel_work);
+		wakeup_source_remove(prim_panel_wakelock);
+		wakeup_source_destroy(prim_panel_wakelock);
+	}
+
 	kfree(bridge);
 }
diff --git a/techpack/display/msm/dsi/dsi_drm.h b/techpack/display/msm/dsi/dsi_drm.h
index ec012c2cb529..051dd6d97bf0 100644
--- a/techpack/display/msm/dsi/dsi_drm.h
+++ b/techpack/display/msm/dsi/dsi_drm.h
@@ -23,6 +23,7 @@ struct dsi_bridge {
 
 	struct dsi_display *display;
 	struct dsi_display_mode dsi_mode;
+	struct mutex lock;
 };
 
 /**
diff --git a/techpack/display/msm/dsi/dsi_mi_feature.h b/techpack/display/msm/dsi/dsi_mi_feature.h
new file mode 100644
index 000000000000..827a4594ae1d
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_mi_feature.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DSI_MI_FEATURE_H_
+#define _DSI_MI_FEATURE_H_
+
+enum DISPPARAM_MODE  {
+	DISPPARAM_WARM                 = 0x1,
+	DISPPARAM_DEFAULT              = 0x2,
+	DISPPARAM_COLD                 = 0x3,
+	DISPPARAM_PAPERMODE8           = 0x5,
+	DISPPARAM_PAPERMODE1           = 0x6,
+	DISPPARAM_PAPERMODE2           = 0x7,
+	DISPPARAM_PAPERMODE3           = 0x8,
+	DISPPARAM_PAPERMODE4           = 0x9,
+	DISPPARAM_PAPERMODE5           = 0xA,
+	DISPPARAM_PAPERMODE6           = 0xB,
+	DISPPARAM_PAPERMODE7           = 0xC,
+	DISPPARAM_WHITEPOINT_XY        = 0xE,
+
+	DISPPARAM_CE_ON                = 0x10,
+	DISPPARAM_CE_OFF               = 0xF0,
+
+	DISPPARAM_CABCUI_ON            = 0x100,
+	DISPPARAM_CABCSTILL_ON         = 0x200,
+	DISPPARAM_CABCMOVIE_ON         = 0x300,
+	DISPPARAM_CABC_OFF             = 0x400,
+	DISPPARAM_SKIN_CE_CABCUI_ON    = 0x500,
+	DISPPARAM_SKIN_CE_CABCSTILL_ON = 0x600,
+	DISPPARAM_SKIN_CE_CABCMOVIE_ON = 0x700,
+	DISPPARAM_SKIN_CE_CABC_OFF     = 0x800,
+	DISPPARAM_DIMMING_OFF          = 0xE00,
+	DISPPARAM_DIMMING              = 0xF00,
+
+	DISPPARAM_ACL_L1               = 0x1000,
+	DISPPARAM_ACL_L2               = 0x2000,
+	DISPPARAM_ACL_L3               = 0x3000,
+	DISPPARAM_LOW_BRIGHTNESS_FOD   = 0xD000,
+	DISPPARAM_FP_STATUS            = 0xE000,
+	DISPPARAM_ACL_OFF              = 0xF000,
+	DISPPARAM_ROUND_ON             = 0xB000,
+	DISPPARAM_ROUND_OFF            = 0xC000,
+
+	DISPPARAM_HBM_ON               = 0x10000,
+	DISPPARAM_HBM_FOD_ON           = 0x20000,
+	DISPPARAM_HBM_FOD2NORM         = 0x30000,
+	DISPPARAM_DC_ON                = 0x40000,
+	DISPPARAM_DC_OFF               = 0x50000,
+	DISPPARAM_HBM_HDR_ON           = 0x60000,
+	DISPPARAM_FOD_UNLOCK_SUCCESS   = 0x70000,
+	DISPPARAM_FOD_UNLOCK_FAIL      = 0x80000,
+	DISPPARAM_HBM_HDR_OFF          = 0x90000,
+	DISPPARAM_HBM_FOD_OFF          = 0xE0000,
+	DISPPARAM_HBM_OFF              = 0xF0000,
+	DISPPARAM_LCD_HBM_OFF          = 0xA0000,
+	DISPPARAM_LCD_HBM_L1_ON        = 0xB0000,
+	DISPPARAM_LCD_HBM_L2_ON        = 0xC0000,
+	DISPPARAM_LCD_HBM_L3_ON        = 0xD0000,
+
+	DISPPARAM_NORMALMODE1          = 0x100000,
+	DISPPARAM_P3                   = 0x200000,
+	DISPPARAM_SRGB                 = 0x300000,
+	DISPPARAM_SKIN_CE              = 0x400000,
+	DISPPARAM_SKIN_CE_OFF          = 0x500000,
+	DISPPARAM_DOZE_BRIGHTNESS_HBM  = 0x600000,
+	DISPPARAM_DOZE_BRIGHTNESS_LBM  = 0x700000,
+	DISPPARAM_DOZE_OFF             = 0x800000,
+	DISPPARAM_HBM_BACKLIGHT_RESEND = 0xA00000,
+	DISPPARAM_FOD_BACKLIGHT        = 0xD00000,
+	DISPPARAM_CRC_OFF              = 0xF00000,
+
+	DISPPARAM_FOD_BACKLIGHT_ON     = 0x1000000,
+	DISPPARAM_FOD_BACKLIGHT_OFF    = 0x2000000,
+	DISPPARAM_ELVSS_DIMMING_ON     = 0x3000000,
+	DISPPARAM_ELVSS_DIMMING_OFF    = 0x4000000,
+	DISPPARAM_FLAT_MODE_ON         = 0x5000000,
+	DISPPARAM_FLAT_MODE_OFF        = 0x6000000,
+	DISPPARAM_DITHER_ON            = 0x7000000,
+	DISPPARAM_DITHER_OFF           = 0x8000000,
+	DISPPARAM_SET_THERMAL_HBM_DISABLE     = 0xC000000,
+	DISPPARAM_CLEAR_THERMAL_HBM_DISABLE   = 0xD000000,
+
+	DISPPARAM_GIR_ON               = 0xE0000000,
+	DISPPARAM_GIR_OFF              = 0xF0000000,
+};
+
+#endif /* _DSI_MI_FEATURE_H_ */
diff --git a/techpack/display/msm/dsi/dsi_panel.c b/techpack/display/msm/dsi/dsi_panel.c
index e1f231f13c00..190352654a06 100644
--- a/techpack/display/msm/dsi/dsi_panel.c
+++ b/techpack/display/msm/dsi/dsi_panel.c
@@ -14,7 +14,11 @@
 #include "dsi_panel.h"
 #include "dsi_ctrl_hw.h"
 #include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+
+#include "dsi_display.h"
 #include "sde_dbg.h"
+#include "dsi_mi_feature.h"
 
 /**
  * topology is currently defined by a set of following 3 values:
@@ -34,6 +38,8 @@
 #define DEFAULT_PANEL_PREFILL_LINES	25
 #define MIN_PREFILL_LINES      35
 
+extern void sde_crtc_fod_ui_ready(struct dsi_display *display, int type, int value);
+
 enum dsi_dsc_ratio_type {
 	DSC_8BPC_8BPP,
 	DSC_10BPC_8BPP,
@@ -73,7 +79,7 @@ static char dsi_dsc_rc_range_min_qp_1_1_scr1[][15] = {
  */
 static char dsi_dsc_rc_range_max_qp_1_1[][15] = {
 	{4, 4, 5, 6, 7, 7, 7, 8, 9, 10, 11, 12, 13, 13, 15},
-	{4, 8, 9, 10, 11, 11, 11, 12, 13, 14, 15, 16, 17, 17, 19},
+	{8, 8, 9, 10, 11, 11, 11, 12, 13, 14, 15, 16, 17, 17, 19},
 	{12, 12, 13, 14, 15, 15, 15, 16, 17, 18, 19, 20, 21, 21, 23},
 	{7, 8, 9, 10, 11, 11, 11, 12, 13, 13, 14, 14, 15, 15, 16},
 	};
@@ -452,7 +458,26 @@ static int dsi_panel_power_on(struct dsi_panel *panel)
 {
 	int rc = 0;
 
-	rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+	if (panel->mi_cfg.is_tddi_flag) {
+		if (!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag) {
+			rc = dsi_pwr_enable_regulator(&panel->power_info, true); // git
+
+			if (gpio_is_valid(panel->reset_config.tp_reset_gpio)
+					&& !panel->reset_gpio_always_on
+					&& panel->mi_cfg.panel_id == 0x4C38314100420400) {
+				rc = gpio_direction_output(panel->reset_config.tp_reset_gpio, 1);
+				if (rc) {
+					DSI_ERR("unable to set direction for gpio [%d]\n",
+							panel->reset_config.tp_reset_gpio);
+				}
+			}
+			if (panel->mi_cfg.panel_dead_flag) {
+				panel->mi_cfg.panel_dead_flag = false;
+			}
+		}
+	} else {
+		rc = dsi_pwr_enable_regulator(&panel->power_info, true);
+	}
 	if (rc) {
 		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
 				panel->name, rc);
@@ -465,6 +490,10 @@ static int dsi_panel_power_on(struct dsi_panel *panel)
 		goto error_disable_vregs;
 	}
 
+	/* If LP11_INIT is set, skip panel reset here*/
+	if (panel->lp11_init)
+		goto exit;
+
 	rc = dsi_panel_reset(panel);
 	if (rc) {
 		DSI_ERR("[%s] failed to reset panel, rc=%d\n", panel->name, rc);
@@ -496,9 +525,35 @@ static int dsi_panel_power_off(struct dsi_panel *panel)
 	if (gpio_is_valid(panel->reset_config.disp_en_gpio))
 		gpio_set_value(panel->reset_config.disp_en_gpio, 0);
 
-	if (gpio_is_valid(panel->reset_config.reset_gpio) &&
-					!panel->reset_gpio_always_on)
-		gpio_set_value(panel->reset_config.reset_gpio, 0);
+	if (panel->mi_cfg.panel_id == 0x4C334100420200) {
+		mdelay(2);
+	}
+
+	if (panel->mi_cfg.is_tddi_flag) {
+		if (!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag) {
+			if (gpio_is_valid(panel->reset_config.reset_gpio))
+				gpio_set_value(panel->reset_config.reset_gpio, 0);
+
+				if (gpio_is_valid(panel->reset_config.tp_reset_gpio) && !panel->reset_gpio_always_on
+					&& panel->mi_cfg.panel_id == 0x4C38314100420400){
+					rc=gpio_direction_output(panel->reset_config.tp_reset_gpio, 0);
+					if (rc){
+							DSI_ERR("unable to set direction for gpio [%d]\n",
+							panel->reset_config.tp_reset_gpio);
+					}
+				}
+		}
+	} else {
+		if (gpio_is_valid(panel->reset_config.reset_gpio) &&
+						!panel->reset_gpio_always_on)
+			gpio_set_value(panel->reset_config.reset_gpio, 0);
+	}
+
+	if (panel->reset_config.reset_powerdown_delay) {
+		usleep_range(panel->reset_config.reset_powerdown_delay * 1000,
+			(panel->reset_config.reset_powerdown_delay * 1000) + 100);
+		DSI_WARN("reset_powerdown_delay = %d\n", panel->reset_config.reset_powerdown_delay);
+	}
 
 	if (gpio_is_valid(panel->reset_config.lcd_mode_sel_gpio))
 		gpio_set_value(panel->reset_config.lcd_mode_sel_gpio, 0);
@@ -516,14 +571,17 @@ static int dsi_panel_power_off(struct dsi_panel *panel)
 		       rc);
 	}
 
-	rc = dsi_pwr_enable_regulator(&panel->power_info, false);
-	if (rc)
-		DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
-				panel->name, rc);
+	if (!panel->mi_cfg.is_tddi_flag
+			|| (!panel->mi_cfg.tddi_doubleclick_flag || panel->mi_cfg.panel_dead_flag)) {
+		rc = dsi_pwr_enable_regulator(&panel->power_info, false);
+		if (rc)
+			DSI_ERR("[%s] failed to enable vregs, rc=%d\n",
+					panel->name, rc);
+	}
 
 	return rc;
 }
-static int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
+int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
 				enum dsi_cmd_set_type type)
 {
 	int rc = 0, i = 0;
@@ -560,6 +618,9 @@ static int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
 		if (type == DSI_CMD_SET_VID_TO_CMD_SWITCH)
 			cmds->msg.flags |= MIPI_DSI_MSG_ASYNC_OVERRIDE;
 
+		if (type == DSI_CMD_SET_MI_GIR_ON || type == DSI_CMD_SET_MI_GIR_OFF)
+			cmds->msg.flags |= MIPI_DSI_MSG_CMD_DMA_SCHED;
+
 		len = ops->transfer(panel->host, &cmds->msg);
 		if (len < 0) {
 			rc = len;
@@ -638,6 +699,36 @@ static int dsi_panel_wled_register(struct dsi_panel *panel,
 	return 0;
 }
 
+static int dsi_panel_wled_register_a(struct dsi_panel *panel,
+		struct dsi_backlight_config *bl)
+{
+	struct backlight_device *bd;
+
+	bd = backlight_device_get_by_type_a(BACKLIGHT_RAW);
+	if (!bd) {
+		DSI_ERR("[%s] fail raw backlight register\n", panel->name);
+		return -EPROBE_DEFER;
+	}
+
+	bl->raw_bd = bd;
+	return 0;
+}
+
+static int dsi_panel_wled_register_b(struct dsi_panel *panel,
+		struct dsi_backlight_config *bl)
+{
+	struct backlight_device *bd;
+
+	bd = backlight_device_get_by_type_b(BACKLIGHT_RAW);
+	if (!bd) {
+		DSI_ERR("[%s] fail raw backlight register\n", panel->name);
+		return -EPROBE_DEFER;
+	}
+
+	bl->raw_bd = bd;
+	return 0;
+}
+
 static int dsi_panel_dcs_set_display_brightness_c2(struct mipi_dsi_device *dsi,
 			u32 bl_lvl)
 {
@@ -654,11 +745,13 @@ static int dsi_panel_dcs_set_display_brightness_c2(struct mipi_dsi_device *dsi,
 
 
 
-static int dsi_panel_update_backlight(struct dsi_panel *panel,
+int dsi_panel_update_backlight(struct dsi_panel *panel,
 	u32 bl_lvl)
 {
 	int rc = 0;
 	struct mipi_dsi_device *dsi;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+	static int use_count = 10;
 	struct dsi_backlight_config *bl;
 
 	if (!panel || (bl_lvl > 0xffff)) {
@@ -674,12 +767,43 @@ static int dsi_panel_update_backlight(struct dsi_panel *panel,
 
 	if (panel->bl_config.bl_dcs_subtype == 0xc2)
 		rc = dsi_panel_dcs_set_display_brightness_c2(dsi, bl_lvl);
-	else
+	else if (panel->mi_cfg.bl_is_big_endian) {
+		if ((!mi_cfg->last_bl_level && bl_lvl) ||
+			(mi_cfg->last_bl_level && !bl_lvl))
+			use_count = 10;
+
+		if (use_count-- > 0 && mi_cfg->last_bl_level != bl_lvl)
+			DSI_INFO("set backlight from %d to %d\n",
+				mi_cfg->last_bl_level, bl_lvl);
+
+		if (!mi_cfg->in_aod &&mi_cfg->vi_setting_enabled) {
+			if (bl_lvl >= mi_cfg->vi_switch_threshold) {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+			} else {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+			}
+		}
+		rc = mipi_dsi_dcs_set_display_brightness_big_endian(dsi, bl_lvl);
+	} else
 		rc = mipi_dsi_dcs_set_display_brightness(dsi, bl_lvl);
 
 	if (rc < 0)
 		DSI_ERR("failed to update dcs backlight:%d\n", bl_lvl);
 
+	if (mi_cfg->local_hbm_enabled) {
+		if (bl_lvl > 2047 && mi_cfg->dim_fp_dbv_max_in_hbm_flag == false) {
+			dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIM_FP_DBV_MAX_IN_HBM);
+			mi_cfg->dim_fp_dbv_max_in_hbm_flag = true;
+			DSI_INFO("set DSI_CMD_SET_MI_DIM_FP_DBV_MAX to hbm\n");
+		} else if (bl_lvl <= 2047 && mi_cfg->dim_fp_dbv_max_in_hbm_flag == true) {
+			dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIM_FP_DBV_MAX_IN_NORMAL);
+			mi_cfg->dim_fp_dbv_max_in_hbm_flag = false;
+			DSI_INFO("set DSI_CMD_SET_MI_DIM_FP_DBV_MAX to normal\n");
+		}
+		if(panel->mi_cfg.local_hbm_cur_status) {
+			mi_dsi_panel_set_fod_brightness(dsi, bl_lvl);
+		}
+	}
 	return rc;
 }
 
@@ -734,21 +858,85 @@ static int dsi_panel_update_pwm_backlight(struct dsi_panel *panel,
 	return rc;
 }
 
+bool dc_skip_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+/* 1. dc enable is 1;
+ * 2. bl lvl should less than dc theshold;
+ * 3. bl lvl not 0, we should not skip set 0;
+ * 4. dc type is 1 means need backlight control here, 0 means IC can switch automatically.
+ * When meet all the 4 conditions at the same time, skip set this bl.
+ */
+	if (mi_cfg->dc_enable && bl_lvl < mi_cfg->dc_threshold && bl_lvl != 0 && mi_cfg->dc_type) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
 int dsi_panel_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
 {
 	int rc = 0;
 	struct dsi_backlight_config *bl = &panel->bl_config;
+	struct dsi_backlight_config *bl_slaver = &panel->bl_slaver_config;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
 
 	if (panel->host_config.ext_bridge_mode)
 		return 0;
 
 	DSI_DEBUG("backlight type:%d lvl:%d\n", bl->type, bl_lvl);
+
+	/* lmi panel must restore to last_bl_level to avoid flash high
+	 * brightness white exiting app lock with DC on (MIUI-1755728),
+	 * must make sure last_bl_level is correct. */
+	if (mi_cfg->dc_type == 2 && mi_cfg->last_bl_level != bl_lvl) {
+		mi_cfg->last_bl_level = bl_lvl;
+		if (bl_lvl)
+			mi_cfg->last_nonzero_bl_level = bl_lvl;
+	}
+
+	if (dc_skip_set_backlight(panel, bl_lvl)) {
+		DSI_INFO("skip set backlight bacase dc enable %d, bl %d\n",
+			panel->mi_cfg.dc_enable, bl_lvl);
+		return rc;
+	}else if (!panel->mi_cfg.bl_enable) {
+		mi_cfg->last_bl_level = bl_lvl;
+		if (bl_lvl)
+			mi_cfg->last_nonzero_bl_level = bl_lvl;
+		return rc;
+	}
+
+	if (0 == bl_lvl && (panel->host_config.cphy_strength || panel->mi_cfg.panel_id == 0x4C38314100420400)){
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_INSERT_BLACK);
+		usleep_range((6 * 1000),(6 * 1000) + 10);
+	}
+
 	switch (bl->type) {
 	case DSI_BACKLIGHT_WLED:
-		rc = backlight_device_set_brightness(bl->raw_bd, bl_lvl);
+		if (panel->mi_cfg.panel_id == 0x4C38314100420400){
+			rc = backlight_device_set_brightness(bl->raw_bd, bl_lvl);
+			rc = backlight_device_set_brightness(bl_slaver->raw_bd,bl_lvl);
+		}else{
+			rc = backlight_device_set_brightness(bl->raw_bd, bl_lvl);
+		}
 		break;
 	case DSI_BACKLIGHT_DCS:
-		rc = dsi_panel_update_backlight(panel, bl_lvl);
+		if (mi_cfg->fod_backlight_flag) {
+			DSI_INFO("fod_backlight_flag set, skip set backlight %d\n", bl_lvl);
+		} else {
+			if (mi_cfg->hbm_51_ctrl_flag &&
+				(mi_cfg->fod_hbm_enabled || 
+				 (mi_cfg->thermal_hbm_disabled && bl_lvl > 2047 && mi_cfg->last_bl_level > 0) || 
+				 (mi_cfg->hbm_enabled && !mi_cfg->hbm_brightness && !mi_cfg->thermal_hbm_disabled))) {
+				DSI_INFO("fod_hbm_enabled(%d), hbm_enabled(%d), thermal_hbm_disabled(%d), skip set backlight %d\n", 
+						mi_cfg->fod_hbm_enabled, mi_cfg->hbm_enabled, mi_cfg->thermal_hbm_disabled, bl_lvl);
+			} else if (mi_cfg->thermal_hbm_disabled && bl_lvl > 2047 && mi_cfg->last_bl_level == 0) {
+				bl_lvl = 2047;
+				rc = dsi_panel_update_backlight(panel, bl_lvl);
+			} else {
+				rc = dsi_panel_update_backlight(panel, bl_lvl);
+			}
+		}
 		break;
 	case DSI_BACKLIGHT_EXTERNAL:
 		break;
@@ -760,6 +948,31 @@ int dsi_panel_set_backlight(struct dsi_panel *panel, u32 bl_lvl)
 		rc = -ENOTSUPP;
 	}
 
+	if ((mi_cfg->last_bl_level == 0 || (mi_cfg->dimming_state == STATE_DIM_RESTORE)) && bl_lvl) {
+		if (mi_cfg->panel_on_dimming_delay)
+			schedule_delayed_work(&mi_cfg->dimming_enable_delayed_work,
+				msecs_to_jiffies(mi_cfg->panel_on_dimming_delay));
+
+		if (mi_cfg->dimming_state == STATE_DIM_RESTORE)
+			mi_cfg->dimming_state = STATE_NONE;
+	}
+
+	if (mi_cfg->last_bl_level == 0 && bl_lvl && (panel->host_config.cphy_strength || panel->mi_cfg.panel_id == 0x4C38314100420400)){
+		DSI_INFO("disable insert black \n");
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISABLE_INSERT_BLACK);
+	}
+
+	if (bl_lvl > 0 && mi_cfg->last_bl_level == 0 && mi_cfg->dc_type) {
+		DSI_INFO("crc off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+	}
+	if (bl_lvl == 0 && mi_cfg->dc_type) {
+		DSI_INFO("DC off\n");
+		mi_cfg->dc_enable = false;
+	}
+	mi_cfg->last_bl_level = bl_lvl;
+	if (bl_lvl)
+		mi_cfg->last_nonzero_bl_level = bl_lvl;
 	return rc;
 }
 
@@ -819,13 +1032,20 @@ static int dsi_panel_bl_register(struct dsi_panel *panel)
 {
 	int rc = 0;
 	struct dsi_backlight_config *bl = &panel->bl_config;
+	struct dsi_backlight_config *bl_slaver = &panel->bl_slaver_config;
 
 	if (panel->host_config.ext_bridge_mode)
 		return 0;
 
 	switch (bl->type) {
 	case DSI_BACKLIGHT_WLED:
-		rc = dsi_panel_wled_register(panel, bl);
+		if (panel->mi_cfg.panel_id == 0x4C38314100420400){
+			// L81A dual backlight
+			rc = dsi_panel_wled_register_a(panel, bl);
+			rc = dsi_panel_wled_register_b(panel, bl_slaver);
+		}else{
+			rc = dsi_panel_wled_register(panel, bl);
+		}
 		break;
 	case DSI_BACKLIGHT_DCS:
 		break;
@@ -1204,7 +1424,7 @@ static int dsi_panel_parse_misc_host_config(struct dsi_host_common_cfg *host,
 					    struct dsi_parser_utils *utils,
 					    const char *name)
 {
-	u32 val = 0;
+	u32 val = 0, line_no = 0, window = 0;
 	int rc = 0;
 	bool panel_cphy_mode = false;
 
@@ -1235,11 +1455,41 @@ static int dsi_panel_parse_misc_host_config(struct dsi_host_common_cfg *host,
 
 	host->force_hs_clk_lane = utils->read_bool(utils->data,
 					"qcom,mdss-dsi-force-clock-lane-hs");
+
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-clk-strength", &val);
+	if (!rc) {
+		host->clk_strength = val;
+		DSI_INFO("[%s] clk_strength = %d\n", name, val);
+	} else {
+		host->clk_strength = 0;
+		DSI_INFO("[%s] clk_strength default value = %d\n", name, val);
+	}
+
 	panel_cphy_mode = utils->read_bool(utils->data,
 					"qcom,panel-cphy-mode");
 	host->phy_type = panel_cphy_mode ? DSI_PHY_TYPE_CPHY
 						: DSI_PHY_TYPE_DPHY;
 
+	host->cphy_strength = utils->read_bool(utils->data,
+					"qcom,mdss-dsi-cphy-strength");
+
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-dma-schedule-line",
+			&line_no);
+	if (rc)
+		host->dma_sched_line = 0;
+	else
+		host->dma_sched_line = line_no;
+
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-dma-schedule-window",
+				&window);
+	if (rc)
+		host->dma_sched_window = 0;
+	else
+		host->dma_sched_window = window;
+ 
+	DSI_DEBUG("[%s] DMA scheduling parameters Line: %d Window: %d\n", name,
+		host->dma_sched_line, host->dma_sched_window);
+
 	return 0;
 }
 
@@ -1574,7 +1824,6 @@ static int dsi_panel_parse_video_host_config(struct dsi_video_engine_cfg *cfg,
 	const char *traffic_mode;
 	u32 vc_id = 0;
 	u32 val = 0;
-	u32 line_no = 0;
 
 	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-h-sync-pulse", &val);
 	if (rc) {
@@ -1637,17 +1886,6 @@ static int dsi_panel_parse_video_host_config(struct dsi_video_engine_cfg *cfg,
 		cfg->vc_id = vc_id;
 	}
 
-	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-dma-schedule-line",
-				  &line_no);
-	if (rc) {
-		DSI_DEBUG("[%s] set default dma scheduling line no\n", name);
-		cfg->dma_sched_line = 0x1;
-		/* do not fail since we have default value */
-		rc = 0;
-	} else {
-		cfg->dma_sched_line = line_no;
-	}
-
 error:
 	return rc;
 }
@@ -1820,6 +2058,7 @@ const char *cmd_set_prop_map[DSI_CMD_SET_MAX] = {
 	"qcom,cmd-to-video-mode-post-switch-commands",
 	"qcom,video-to-cmd-mode-switch-commands",
 	"qcom,video-to-cmd-mode-post-switch-commands",
+	"qcom,mdss-dsi-panel-status-offset-command",
 	"qcom,mdss-dsi-panel-status-command",
 	"qcom,mdss-dsi-lp1-command",
 	"qcom,mdss-dsi-lp2-command",
@@ -1830,6 +2069,107 @@ const char *cmd_set_prop_map[DSI_CMD_SET_MAX] = {
 	"qcom,mdss-dsi-post-mode-switch-on-command",
 	"qcom,mdss-dsi-qsync-on-commands",
 	"qcom,mdss-dsi-qsync-off-commands",
+	/* xiaomi add start */
+	"mi,mdss-dsi-ceon-command",
+	"mi,mdss-dsi-ceoff-command",
+	"mi,mdss-dsi-cabcuion-command",
+	"mi,mdss-dsi-cabcstillon-command",
+	"mi,mdss-dsi-cabcmovieon-command",
+	"mi,mdss-dsi-cabcoff-command",
+	"mi,mdss-dsi-skince-cabcuion-command",
+	"mi,mdss-dsi-skince-cabcstillon-command",
+	"mi,mdss-dsi-skince-cabcmovieon-command",
+	"mi,mdss-dsi-skince-cabcoff-command",
+	"mi,mdss-dsi-dimmingon-command",
+	"mi,mdss-dsi-dimmingoff-command",
+	"mi,mdss-dsi-acl-off-command",
+	"mi,mdss-dsi-acl-l1-command",
+	"mi,mdss-dsi-acl-l2-command",
+	"mi,mdss-dsi-acl-l3-command",
+	"mi,mdss-dsi-lcd-hbm-l1-on-command",
+	"mi,mdss-dsi-lcd-hbm-l2-on-command",
+	"mi,mdss-dsi-lcd-hbm-l3-on-command",
+	"mi,mdss-dsi-lcd-hbm-off-command",
+	"mi,mdss-dsi-hbm-on-command",
+	"mi,mdss-dsi-hbm-off-command",
+	"mi,mdss-dsi-hbm-fod-on-command",
+	"mi,mdss-dsi-hbm-fod-off-command",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-command",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-command",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-command",
+	"mi,mdss-dsi-fod-lhbm-off-command",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-read-pre-command",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-read-command",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-giroff-read-pre-command",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-giron-read-pre-command",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-giroff-read-pre-command",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-giron-read-pre-command",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-read-offest-command",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-read-offest-command",
+	"mi,mdss-dsi-fod-lhbm-white-read-B2-command",
+	"mi,mdss-dsi-fod-lhbm-white-read-B5-command",
+	"mi,mdss-dsi-fod-lhbm-white-read-B8-command",
+	"mi,mdss-dsi-hbm-hdr-on-command",
+	"mi,mdss-dsi-hbm-hdr-off-command",
+	"mi,mdss-dsi-hbm-fod2norm-command",
+	"mi,mdss-dsi-normal1-command",
+	"mi,mdss-dsi-crc-dcip3-command",
+	"mi,mdss-dsi-srgb-command",
+	"mi,mdss-dsi-doze-hbm-command",
+	"mi,mdss-dsi-doze-lbm-command",
+	"mi,mdss-dsi-crc-off-command",
+	"mi,mdss-dsi-elvss-dimming-off-command",
+	"mi,mdss-dsi-flat-on-command",
+	"mi,mdss-dsi-flat-off-command",
+	"mi,mdss-dsi-gir-on-command",
+	"mi,mdss-dsi-gir-off-command",
+	"mi,mdss-dsi-gir-read-reg-pre-command",
+	"mi,mdss-dsi-gir-off-read-reg-pre-command",
+	"mi,mdss-dsi-gir-read-reg-command",
+	"mi,mdss-dsi-timing-switch-gir-on-command",
+	"mi,mdss-dsi-level2-key-enable-command",
+	"mi,mdss-dsi-gamma-otp-read-c8-command",
+	"mi,mdss-dsi-gamma-otp-read-c9-command",
+	"mi,mdss-dsi-gamma-otp-read-b3-pre-command",
+	"mi,mdss-dsi-gamma-otp-read-b3-command",
+	"mi,mdss-dsi-level2-key-disable-command",
+	"mi,mdss-dsi-gamma-flash-read-pre-command",
+	"mi,mdss-dsi-gamma-read-fb-command",
+	"mi,mdss-dsi-white-point-read-command",
+	"mi,mdss-dsi-elvss-dimming-offset-command",
+	"mi,mdss-dsi-elvss-dimming-read-command",
+	"mi,mdss-dsi-dc-on-command",
+	"mi,mdss-dsi-dc-off-command",
+	"mi,mdss-dsi-vi-setting-low-command",
+	"mi,mdss-dsi-vi-setting-high-command",
+	"mi,mdss-dsi-switch-page4-command",
+	"mi,mdss-dsi-dc-read-command",
+	"mi,mdss-dsi-dc-read-d2-command",
+	"mi,mdss-dsi-dc-read-d4-command",
+	"mi,mdss-dsi-aod-to-dc-on-command",
+	"mi,mdss-dsi-dynamic-elvss-on-command",
+	"mi,mdss-dsi-dynamic-elvss-off-command",
+	"mi,mdss-dsi-update-gamma-pre-read-command",
+	"mi,mdss-dsi-update-gamma-read-1st-pre-command",
+	"mi,mdss-dsi-update-gamma-read-2nd-pre-command",
+	"mi,mdss-dsi-update-gamma-read-3rd-pre-command",
+	"mi,mdss-dsi-update-gamma-read-4th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-5th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-6th-pre-command",
+	"mi,mdss-dsi-update-gamma-read-b7-command",
+	"mi,mdss-dsi-greenish-gamma-set-command",
+	"mi,mdss-dsi-black-setting-command",
+	"mi,mdss-dsi-read-lockdown-info-command",
+	"qcom,mdss-dsi-dispparam-pen-120hz-command",
+	"qcom,mdss-dsi-dispparam-pen-60hz-command",
+	"qcom,mdss-dsi-dispparam-pen-30hz-command",
+	"mi,mdss-dsi-disable-insert-black-command",
+	"mi,mdss-dsi-insert-black-screen-command",
+	"mi,mdss-dsi-round-on-command",
+	"mi,mdss-dsi-round-off-command",
+	"mi,mdss-dsi-dim-fp-dbv-max-in-hbm-command",
+	"mi,mdss-dsi-dim-fp-dbv-max-in-normal-command",
+	/* xiaomi add end */
 };
 
 const char *cmd_set_state_map[DSI_CMD_SET_MAX] = {
@@ -1846,6 +2186,7 @@ const char *cmd_set_state_map[DSI_CMD_SET_MAX] = {
 	"qcom,cmd-to-video-mode-post-switch-commands-state",
 	"qcom,video-to-cmd-mode-switch-commands-state",
 	"qcom,video-to-cmd-mode-post-switch-commands-state",
+	"qcom,mdss-dsi-panel-status-offset-command-state",
 	"qcom,mdss-dsi-panel-status-command-state",
 	"qcom,mdss-dsi-lp1-command-state",
 	"qcom,mdss-dsi-lp2-command-state",
@@ -1856,9 +2197,110 @@ const char *cmd_set_state_map[DSI_CMD_SET_MAX] = {
 	"qcom,mdss-dsi-post-mode-switch-on-command-state",
 	"qcom,mdss-dsi-qsync-on-commands-state",
 	"qcom,mdss-dsi-qsync-off-commands-state",
+	/* xiaomi add start */
+	"mi,mdss-dsi-ceon-command-state",
+	"mi,mdss-dsi-ceoff-command-state",
+	"mi,mdss-dsi-cabcuion-command-state",
+	"mi,mdss-dsi-cabcstillon-command-state",
+	"mi,mdss-dsi-cabcmovieon-command-state",
+	"mi,mdss-dsi-cabcoff-command-state",
+	"mi,mdss-dsi-skince-cabcuion-command-state",
+	"mi,mdss-dsi-skince-cabcstillon-command-state",
+	"mi,mdss-dsi-skince-cabcmovieon-command-state",
+	"mi,mdss-dsi-skince-cabcoff-command-state",
+	"mi,mdss-dsi-dimmingon-command-state",
+	"mi,mdss-dsi-dimmingoff-command-state",
+	"mi,mdss-dsi-acl-off-command-state",
+	"mi,mdss-dsi-acl-l1-command-state",
+	"mi,mdss-dsi-acl-l2-command-state",
+	"mi,mdss-dsi-acl-l3-command-state",
+	"mi,mdss-dsi-lcd-hbm-l1-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-l2-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-l3-on-command-state",
+	"mi,mdss-dsi-lcd-hbm-off-command-state",
+	"mi,mdss-dsi-hbm-on-command-state",
+	"mi,mdss-dsi-hbm-off-command-state",
+	"mi,mdss-dsi-hbm-fod-on-command-state",
+	"mi,mdss-dsi-hbm-fod-off-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-command-state",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-command-state",
+	"mi,mdss-dsi-fod-lhbm-off-command-state",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-green-500nit-read-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-giroff-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-1000nit-giron-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-giroff-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-giron-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-giron-read-pre-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-110nit-read-offest-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-read-B2-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-read-B5-command-state",
+	"mi,mdss-dsi-fod-lhbm-white-read-B8-command-state",
+	"mi,mdss-dsi-hbm-hdr-on-command-state",
+	"mi,mdss-dsi-hbm-hdr-off-command-state",
+	"mi,mdss-dsi-hbm-fod2norm-command-state",
+	"mi,mdss-dsi-normal1-command-state",
+	"mi,mdss-dsi-crc-dcip3-command-state",
+	"mi,mdss-dsi-srgb-command-state",
+	"mi,mdss-dsi-doze-hbm-command-state",
+	"mi,mdss-dsi-doze-lbm-command-state",
+	"mi,mdss-dsi-crc-off-command-state",
+	"mi,mdss-dsi-elvss-dimming-off-command-state",
+	"mi,mdss-dsi-flat-on-command-state",
+	"mi,mdss-dsi-flat-off-command-state",
+	"mi,mdss-dsi-gir-on-command-state",
+	"mi,mdss-dsi-gir-off-command-state",
+	"mi,mdss-dsi-gir-read-reg-pre-command-state",
+	"mi,mdss-dsi-gir-off-read-reg-pre-command-state",
+	"mi,mdss-dsi-gir-read-reg-command-state",
+	"mi,mdss-dsi-timing-switch-gir-on-command-state",
+	"mi,mdss-dsi-level2-key-enable-command-state",
+	"mi,mdss-dsi-gamma-otp-read-c8-command-state",
+	"mi,mdss-dsi-gamma-otp-read-c9-command-state",
+	"mi,mdss-dsi-gamma-otp-read-b3-pre-command-state",
+	"mi,mdss-dsi-gamma-otp-read-b3-command-state",
+	"mi,mdss-dsi-level2-key-disable-command-state",
+	"mi,mdss-dsi-gamma-flash-read-pre-command-state",
+	"mi,mdss-dsi-gamma-read-fb-command-state",
+	"mi,mdss-dsi-white-point-read-command-state",
+	"mi,mdss-dsi-elvss-dimming-offset-command-state",
+	"mi,mdss-dsi-elvss-dimming-read-command-state",
+	"mi,mdss-dsi-dc-on-command-state",
+	"mi,mdss-dsi-dc-off-command-state",
+	"mi,mdss-dsi-vi-setting-low-command-state",
+	"mi,mdss-dsi-vi-setting-high-command-state",
+	"mi,mdss-dsi-switch-page4-command-state",
+	"mi,mdss-dsi-dc-read-command-state",
+	"mi,mdss-dsi-dc-read-d2-command-state",
+	"mi,mdss-dsi-dc-read-d4-command-state",
+	"mi,mdss-dsi-aod-to-dc-on-command-state",
+	"mi,mdss-dsi-dynamic-elvss-on-command-state",
+	"mi,mdss-dsi-dynamic-elvss-off-command-state",
+	"mi,mdss-dsi-update-gamma-pre-read-command-state",
+	"mi,mdss-dsi-update-gamma-read-1st-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-2nd-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-3rd-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-4th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-5th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-6th-pre-command-state",
+	"mi,mdss-dsi-update-gamma-read-b7-command-state",
+	"mi,mdss-dsi-greenish-gamma-set-command-state",
+	"mi,mdss-dsi-black-setting-command-state",
+	"mi,mdss-dsi-read-lockdown-info-command-state",
+	"qcom,mdss-dsi-dispparam-pen-120hz-command-state",
+	"qcom,mdss-dsi-dispparam-pen-60hz-command-state",
+	"qcom,mdss-dsi-dispparam-pen-30hz-command-state",
+	"mi,mdss-dsi-disable-insert-black-command-state",
+	"mi,mdss-dsi-insert-black-screen-command-state",
+	"mi,mdss-dsi-round-on-command-state",
+	"mi,mdss-dsi-round-off-command-state",
+	"mi,mdss-dsi-dim-fp-dbv-max-in-hbm-command-state",
+	"mi,mdss-dsi-dim-fp-dbv-max-in-normal-command-state",
+	/* xiaomi add end */
 };
 
-static int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt)
+int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt)
 {
 	const u32 cmd_set_min_size = 7;
 	u32 count = 0;
@@ -1882,7 +2324,7 @@ static int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt)
 	return 0;
 }
 
-static int dsi_panel_create_cmd_packets(const char *data,
+int dsi_panel_create_cmd_packets(const char *data,
 					u32 length,
 					u32 count,
 					struct dsi_cmd_desc *cmd)
@@ -1927,7 +2369,7 @@ static int dsi_panel_create_cmd_packets(const char *data,
 	return rc;
 }
 
-static void dsi_panel_destroy_cmd_packets(struct dsi_panel_cmd_set *set)
+void dsi_panel_destroy_cmd_packets(struct dsi_panel_cmd_set *set)
 {
 	u32 i = 0;
 	struct dsi_cmd_desc *cmd;
@@ -1938,12 +2380,12 @@ static void dsi_panel_destroy_cmd_packets(struct dsi_panel_cmd_set *set)
 	}
 }
 
-static void dsi_panel_dealloc_cmd_packets(struct dsi_panel_cmd_set *set)
+void dsi_panel_dealloc_cmd_packets(struct dsi_panel_cmd_set *set)
 {
 	kfree(set->cmds);
 }
 
-static int dsi_panel_alloc_cmd_packets(struct dsi_panel_cmd_set *cmd,
+int dsi_panel_alloc_cmd_packets(struct dsi_panel_cmd_set *cmd,
 					u32 packet_count)
 {
 	u32 size;
@@ -2065,6 +2507,7 @@ static int dsi_panel_parse_reset_sequence(struct dsi_panel *panel)
 	u32 count = 0;
 	u32 size = 0;
 	u32 *arr_32 = NULL;
+	u32 powerdown_delay = 0;
 	const u32 *arr;
 	struct dsi_parser_utils *utils = &panel->utils;
 	struct dsi_reset_seq *seq;
@@ -2072,6 +2515,13 @@ static int dsi_panel_parse_reset_sequence(struct dsi_panel *panel)
 	if (panel->host_config.ext_bridge_mode)
 		return 0;
 
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-reset-powerdown-delay",
+							&powerdown_delay);
+	if (rc)
+		DSI_DEBUG("[%s] cannot read reset-powerdown-delay\n", panel->name);
+
+	panel->reset_config.reset_powerdown_delay = powerdown_delay;
+
 	arr = utils->get_property(utils->data,
 			"qcom,mdss-dsi-reset-sequence", &length);
 	if (!arr) {
@@ -2253,6 +2703,10 @@ static int dsi_panel_parse_gpios(struct dsi_panel *panel)
 		goto error;
 	}
 
+	panel->reset_config.tp_reset_gpio = utils->get_named_gpio(utils->data,
+						"qcom,platform-tp-reset-gpio",
+						0);
+
 	panel->reset_config.disp_en_gpio = utils->get_named_gpio(utils->data,
 						"qcom,5v-boost-gpio",
 						0);
@@ -2406,6 +2860,7 @@ static int dsi_panel_parse_bl_config(struct dsi_panel *panel)
 		panel->bl_config.brightness_max_level = val;
 	}
 
+	/*
 	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-bl-ctrl-dcs-subtype",
 		&val);
 	if (rc) {
@@ -2415,6 +2870,17 @@ static int dsi_panel_parse_bl_config(struct dsi_panel *panel)
 	} else {
 		panel->bl_config.bl_dcs_subtype = val;
 	}
+	*/
+
+	rc = utils->read_u32(utils->data, "qcom,mdss-brightness-init-level",
+		&val);
+	if (rc) {
+		DSI_DEBUG("[%s] brigheness-init-level unspecified, defaulting to max level\n",
+			 panel->name);
+		panel->bl_config.brightness_init_level = panel->bl_config.brightness_max_level;
+	} else {
+		panel->bl_config.brightness_init_level = val;
+	}
 
 	panel->bl_config.bl_inverted_dbv = utils->read_bool(utils->data,
 		"qcom,mdss-dsi-bl-inverted-dbv");
@@ -3176,6 +3642,12 @@ int dsi_panel_parse_esd_reg_read_configs(struct dsi_panel *panel)
 	if (!esd_config)
 		return -EINVAL;
 
+	dsi_panel_parse_cmd_sets_sub(&esd_config->offset_cmd,
+				DSI_CMD_SET_PANEL_STATUS_OFFSET, utils);
+	if (!esd_config->offset_cmd.count) {
+		pr_err("no panel status offset command\n");
+	}
+
 	dsi_panel_parse_cmd_sets_sub(&esd_config->status_cmd,
 				DSI_CMD_SET_PANEL_STATUS, utils);
 	if (!esd_config->status_cmd.count) {
@@ -3288,6 +3760,12 @@ static int dsi_panel_parse_esd_config(struct dsi_panel *panel)
 
 	esd_config = &panel->esd_config;
 	esd_config->status_mode = ESD_MODE_MAX;
+
+	/* esd check using gpio irq method has high priority */
+	rc = dsi_panel_parse_esd_gpio_config(panel);
+	if (rc)
+		DSI_DEBUG("Failed to get mi,esd-err-irq-gpio config\n");
+
 	esd_config->esd_enabled = utils->read_bool(utils->data,
 		"qcom,esd-check-enabled");
 
@@ -3470,6 +3948,10 @@ struct dsi_panel *dsi_panel_get(struct device *parent,
 	if (rc)
 		DSI_DEBUG("failed to parse esd config, rc=%d\n", rc);
 
+	rc = dsi_panel_parse_mi_config(panel, of_node);
+	if (rc)
+		DSI_DEBUG("failed to parse mi config, rc=%d\n", rc);
+
 	panel->power_mode = SDE_MODE_DPMS_OFF;
 	drm_panel_init(&panel->drm_panel);
 	panel->drm_panel.dev = &panel->mipi_device.dev;
@@ -3494,6 +3976,9 @@ void dsi_panel_put(struct dsi_panel *panel)
 	/* free resources allocated for ESD check */
 	dsi_panel_esd_config_deinit(&panel->esd_config);
 
+	wakeup_source_remove(panel->mi_cfg.aod_wakelock);
+	wakeup_source_destroy(panel->mi_cfg.aod_wakelock);
+
 	kfree(panel);
 }
 
@@ -4003,10 +4488,6 @@ int dsi_panel_pre_prepare(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
-	/* If LP11_INIT is set, panel will be powered up during prepare() */
-	if (panel->lp11_init)
-		goto error;
-
 	rc = dsi_panel_power_on(panel);
 	if (rc) {
 		DSI_ERR("[%s] panel power on failed, rc=%d\n", panel->name, rc);
@@ -4023,6 +4504,8 @@ int dsi_panel_update_pps(struct dsi_panel *panel)
 	int rc = 0;
 	struct dsi_panel_cmd_set *set = NULL;
 	struct dsi_display_mode_priv_info *priv_info = NULL;
+	struct dsi_parser_utils *utils = &panel->utils;
+	int panel_cnt = 0;
 
 	if (!panel || !panel->cur_mode) {
 		DSI_ERR("invalid params\n");
@@ -4034,6 +4517,10 @@ int dsi_panel_update_pps(struct dsi_panel *panel)
 	priv_info = panel->cur_mode->priv_info;
 
 	set = &priv_info->cmd_sets[DSI_CMD_SET_PPS];
+	rc = utils->read_u32(utils->data, "qcom,mdss-dsi-panel-count",
+							&panel_cnt);
+	if (!rc && panel_cnt == 2)
+		priv_info->dsc.pic_width >>= 1;
 
 	dsi_dsc_create_pps_buf_cmd(&priv_info->dsc, panel->dsc_pps_cmd, 0);
 	rc = dsi_panel_create_cmd_packets(panel->dsc_pps_cmd,
@@ -4058,6 +4545,10 @@ int dsi_panel_update_pps(struct dsi_panel *panel)
 int dsi_panel_set_lp1(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	mi_cfg = &panel->mi_cfg;
+	mi_cfg->hbm_enabled = false;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4084,6 +4575,12 @@ int dsi_panel_set_lp1(struct dsi_panel *panel)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_LP1 cmd, rc=%d\n",
 		       panel->name, rc);
 exit:
+	//for l3a && j11
+	if (panel->mi_cfg.panel_id == 0x4C334100420200 || panel->mi_cfg.panel_id == 0x4A323200380801)
+		panel->mi_cfg.bl_enable = false;
+	else
+		panel->mi_cfg.bl_enable = true;
+	panel->mi_cfg.bl_wait_frame = false;
 	mutex_unlock(&panel->panel_lock);
 	return rc;
 }
@@ -4091,7 +4588,10 @@ int dsi_panel_set_lp1(struct dsi_panel *panel)
 int dsi_panel_set_lp2(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
+	mi_cfg = &panel->mi_cfg;
+	mi_cfg->hbm_enabled = false;
 	if (!panel) {
 		DSI_ERR("invalid params\n");
 		return -EINVAL;
@@ -4113,6 +4613,7 @@ int dsi_panel_set_lp2(struct dsi_panel *panel)
 int dsi_panel_set_nolp(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4120,9 +4621,19 @@ int dsi_panel_set_nolp(struct dsi_panel *panel)
 	}
 
 	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+
 	if (!panel->panel_initialized)
 		goto exit;
 
+	cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+
+	if (mi_cfg->fod_hbm_enabled || (mi_cfg->fod_skip_nolp && mi_cfg->sysfs_fod_unlock_success && !mi_cfg->fod_to_nolp)) {
+		DSI_INFO("fod_hbm_enabled = %d || (mi_cfg->sysfs_fod_unlock_success = %d && mi_cfg->fod_skip_nolp = %d mi_cfg->layer_fod_unlock_success = %d), skip\n", mi_cfg->fod_hbm_enabled, mi_cfg->sysfs_fod_unlock_success, mi_cfg->fod_skip_nolp, mi_cfg->layer_fod_unlock_success);
+		goto exit_skip;
+	}
+
 	/*
 	 * Consider about LP1->LP2->NOLP.
 	 */
@@ -4135,6 +4646,31 @@ int dsi_panel_set_nolp(struct dsi_panel *panel)
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_NOLP cmd, rc=%d\n",
 		       panel->name, rc);
+
+	mi_cfg->dimming_state = STATE_DIM_RESTORE;
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_AOD_TO_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_AOD_TO_DC_ON cmd, rc=%d\n",
+				panel->name, rc);
+	}
+
+exit_skip:
+	if (mi_cfg->fod_hbm_enabled && mi_cfg->dynamic_elvss_enabled) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON);
+		if (rc)
+			DSI_ERR("Failed to send DSI_CMD_SET_MI_DYNAMIC_ELVSS_ON command\n");
+		else
+			DSI_INFO("dynamic elvss on\n");
+	}
+
+	mi_cfg->in_aod = false;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	mi_cfg->layer_fod_unlock_success = false;
+	mi_cfg->sysfs_fod_unlock_success = false;
+	mi_cfg->fod_to_nolp = false;
 exit:
 	mutex_unlock(&panel->panel_lock);
 	return rc;
@@ -4152,7 +4688,7 @@ int dsi_panel_prepare(struct dsi_panel *panel)
 	mutex_lock(&panel->panel_lock);
 
 	if (panel->lp11_init) {
-		rc = dsi_panel_power_on(panel);
+		rc = dsi_panel_reset(panel);
 		if (rc) {
 			DSI_ERR("[%s] panel power on failed, rc=%d\n",
 			       panel->name, rc);
@@ -4422,9 +4958,18 @@ int dsi_panel_switch(struct dsi_panel *panel)
 		return -EINVAL;
 	}
 
+	if (panel->mi_cfg.panel_id == 0x4C334100420200 && panel->mi_cfg.in_aod) {
+		DSI_INFO("In AOD, skip set fps \n");
+		return rc;
+	}
+
 	mutex_lock(&panel->panel_lock);
 
-	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_TIMING_SWITCH);
+	if (panel->mi_cfg.gir_enabled) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_TIMING_SWITCH_GIR_ON);
+	} else {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_TIMING_SWITCH);
+	}
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_TIMING_SWITCH cmds, rc=%d\n",
 		       panel->name, rc);
@@ -4453,9 +4998,41 @@ int dsi_panel_post_switch(struct dsi_panel *panel)
 	return rc;
 }
 
+int dsi_panel_dc_switch(struct dsi_panel *panel)
+{
+	int rc = 0;
+
+	if (!panel) {
+		DSI_ERR("Invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (panel->mi_cfg.dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+					panel->name, rc);
+	} else {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_OFF);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_OFF cmd, rc=%d\n",
+				panel->name, rc);
+	}
+	pr_debug("[%s] tx dc success, dc status %d",
+		panel->name, panel->mi_cfg.dc_enable);
+
+	mutex_unlock(&panel->panel_lock);
+	return rc;
+}
+
 int dsi_panel_enable(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display *display = NULL;
+	struct mipi_dsi_host *host = NULL;
 
 	if (!panel) {
 		DSI_ERR("Invalid params\n");
@@ -4464,12 +5041,57 @@ int dsi_panel_enable(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
+	mi_cfg = &panel->mi_cfg;
+
 	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_ON);
 	if (rc)
 		DSI_ERR("[%s] failed to send DSI_CMD_SET_ON cmds, rc=%d\n",
 		       panel->name, rc);
 	else
 		panel->panel_initialized = true;
+
+	if (mi_cfg->gamma_update_flag) {
+		if (mi_cfg->gamma_cfg.update_done_60hz &&
+			(60 == panel->cur_mode->timing.refresh_rate)) {
+			rc = dsi_panel_write_gamma_cmd_set(panel,
+					DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ);
+			if (rc)
+				DSI_ERR("[%s] failed to send 60HZ GAMMA, rc=%d\n",
+						panel->name, rc);
+		}
+		if (mi_cfg->gamma_cfg.update_done_90hz &&
+			(90 == panel->cur_mode->timing.refresh_rate)) {
+			rc = dsi_panel_write_gamma_cmd_set(panel,
+					DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ);
+			if (rc)
+				DSI_ERR("[%s] failed to send 90HZ GAMMA, rc=%d\n",
+						panel->name, rc);
+		}
+	}
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+		if (rc)
+			DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+				panel->name, rc);
+	}
+
+	host = panel->host;
+	if (host && mi_cfg->fod_hbm_enabled) {
+		display = container_of(host, struct dsi_display, host);
+		sde_crtc_fod_ui_ready(display, 1, 0);
+	}
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	mi_cfg->cabc_current_status = 0;
+
 	mutex_unlock(&panel->panel_lock);
 	return rc;
 }
@@ -4492,7 +5114,72 @@ int dsi_panel_post_enable(struct dsi_panel *panel)
 		goto error;
 	}
 error:
+	if (panel->host_config.phy_type == DSI_PHY_TYPE_CPHY || panel->mi_cfg.panel_id == 0x4C38314100420400) {
+		rc = dsi_panel_match_fps_pen_setting(panel, panel->cur_mode);
+		if (rc) {
+			DSI_ERR("[%s] failed to update TP fps code setting, rc=%d\n",
+				panel->name, rc);
+		}
+	}
+
 	mutex_unlock(&panel->panel_lock);
+
+	if (panel->mi_cfg.gamma_update_flag) {
+		if (!panel->mi_cfg.gamma_cfg.read_done) {
+			rc = dsi_panel_read_gamma_param(panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to read gamma para, rc=%d\n",
+					panel->name, rc);
+			} else {
+				rc = dsi_panel_update_gamma_param(panel);
+				if (rc) {
+					DSI_ERR("[%s] failed to update gamma para, rc=%d\n",
+						panel->name, rc);
+				}
+			}
+		}
+
+		if (panel->mi_cfg.gamma_cfg.black_setting_flag) {
+			mutex_lock(&panel->panel_lock);
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_BLACK_SETTING);
+			if (rc) {
+				DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_BLACK_SETTING cmds, rc=%d\n",
+					panel->name, rc);
+			}
+			mutex_unlock(&panel->panel_lock);
+		}
+	}
+
+	if (panel->mi_cfg.dc_update_flag && !panel->mi_cfg.dc_cfg.read_done) {
+		rc = dsi_panel_read_dc_param(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read DC para, rc=%d\n",
+				panel->name, rc);
+		} else {
+			rc = dsi_panel_update_dc_param(panel);
+			if (rc) {
+				DSI_ERR("[%s] failed to update DC para, rc=%d\n",
+					panel->name, rc);
+			}
+		}
+	}
+
+	if (panel->mi_cfg.greenish_gamma_update_flag && !panel->mi_cfg.greenish_gamma_cfg.gamma_update_done) {
+		rc = dsi_panel_read_greenish_gamma_setting(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to read greenish gamma setting, rc=%d\n",
+				panel->name, rc);
+		}
+	}
+
+	if (panel->mi_cfg.greenish_gamma_update_flag && panel->mi_cfg.greenish_gamma_cfg.gamma_update_done) {
+		rc = dsi_panel_update_greenish_gamma_setting(panel);
+		if (rc) {
+			DSI_ERR("[%s] failed to update greenish gamma setting, rc=%d\n",
+				panel->name, rc);
+		}
+	}
+
 	return rc;
 }
 
@@ -4522,6 +5209,13 @@ int dsi_panel_pre_disable(struct dsi_panel *panel)
 int dsi_panel_disable(struct dsi_panel *panel)
 {
 	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+	struct dsi_display *display = NULL;
+	struct mipi_dsi_host *host = NULL;
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_cmd_desc *cmds = NULL;
+	u32 count;
+	u8 *tx_buf = NULL;
 
 	if (!panel) {
 		DSI_ERR("invalid params\n");
@@ -4530,6 +5224,8 @@ int dsi_panel_disable(struct dsi_panel *panel)
 
 	mutex_lock(&panel->panel_lock);
 
+	mi_cfg = &panel->mi_cfg;
+
 	/* Avoid sending panel off commands when ESD recovery is underway */
 	if (!atomic_read(&panel->esd_recovery_pending)) {
 		/*
@@ -4541,6 +5237,37 @@ int dsi_panel_disable(struct dsi_panel *panel)
 			panel->power_mode == SDE_MODE_DPMS_LP2))
 			dsi_pwr_panel_regulator_mode_set(&panel->power_info,
 				"ibb", REGULATOR_MODE_STANDBY);
+
+		priv_info = panel->cur_mode ? panel->cur_mode->priv_info : NULL;
+		if (mi_cfg->fod_hbm_enabled && priv_info) {
+			DSI_INFO("hbm fod off\n");
+			if (mi_cfg->hbm_51_ctrl_flag) {
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+				if (cmds && count >= mi_cfg->fod_off_51_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->fod_off_51_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0x51) {
+						tx_buf[1] = 0x00;
+						tx_buf[2] = 0x00;
+					}
+					DSI_INFO("DSI_CMD_SET_MI_HBM_FOD_OFF 0x%02X = 0x%02X 0x%02X\n",
+							tx_buf[0], tx_buf[1], tx_buf[2]);
+				} else {
+					if (tx_buf)
+						DSI_ERR("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+					else
+						DSI_ERR("tx_buf is NULL pointer\n");
+				}
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+			} else {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+			}
+			if (rc) {
+				DSI_ERR("[%s] failed to send DSI_CMD_SET_MI_HBM_FOD_OFF cmds, rc=%d\n",
+					panel->name, rc);
+			}
+		}
+
 		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_OFF);
 		if (rc) {
 			/*
@@ -4553,10 +5280,36 @@ int dsi_panel_disable(struct dsi_panel *panel)
 					panel->name, rc);
 			rc = 0;
 		}
+	} else {
+		mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+		DSI_INFO("save doze brightness state [%d] when ESD recovery is underway\n",
+				mi_cfg->unset_doze_brightness);
 	}
 	panel->panel_initialized = false;
 	panel->power_mode = SDE_MODE_DPMS_OFF;
 
+	host = panel->host;
+	if (host && mi_cfg->fod_hbm_enabled) {
+		display = container_of(host, struct dsi_display, host);
+		sde_crtc_fod_ui_ready(display, 1, 0);
+	}
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->into_aod_pending = false;
+	mi_cfg->layer_fod_unlock_success = false;
+	mi_cfg->sysfs_fod_unlock_success = false;
+	mi_cfg->gir_enabled = false;
+	mi_cfg->request_gir_status = false;
+	mi_cfg->local_hbm_cur_status = false;
+	mi_cfg->bl_enable = true;
+	if (mi_cfg->dc_type)
+		mi_cfg->dc_enable = false;
 	mutex_unlock(&panel->panel_lock);
 	return rc;
 }
diff --git a/techpack/display/msm/dsi/dsi_panel.h b/techpack/display/msm/dsi/dsi_panel.h
index ee30cd5375b4..47abc3b2dcd5 100644
--- a/techpack/display/msm/dsi/dsi_panel.h
+++ b/techpack/display/msm/dsi/dsi_panel.h
@@ -20,6 +20,7 @@
 #include "dsi_pwr.h"
 #include "dsi_parser.h"
 #include "msm_drv.h"
+#include "dsi_panel_mi.h"
 
 #define MAX_BL_LEVEL 4096
 #define MAX_BL_SCALE_LEVEL 1024
@@ -34,6 +35,7 @@
  * Override to use async transfer
  */
 #define MIPI_DSI_MSG_ASYNC_OVERRIDE BIT(4)
+#define MIPI_DSI_MSG_CMD_DMA_SCHED BIT(5)
 
 enum dsi_panel_rotation {
 	DSI_PANEL_ROTATE_NONE = 0,
@@ -118,6 +120,7 @@ struct dsi_backlight_config {
 	u32 bl_min_level;
 	u32 bl_max_level;
 	u32 brightness_max_level;
+	u32 brightness_init_level;
 	u32 bl_level;
 	u32 bl_scale;
 	u32 bl_scale_sv;
@@ -145,8 +148,10 @@ struct dsi_panel_reset_config {
 	u32 count;
 
 	int reset_gpio;
+	int tp_reset_gpio;
 	int disp_en_gpio;
 	int lcd_mode_sel_gpio;
+	u32 reset_powerdown_delay;
 	u32 mode_sel_state;
 };
 
@@ -163,6 +168,7 @@ struct drm_panel_esd_config {
 	bool esd_enabled;
 
 	enum esd_check_status_mode status_mode;
+	struct dsi_panel_cmd_set offset_cmd;
 	struct dsi_panel_cmd_set status_cmd;
 	u32 *status_cmds_rlen;
 	u32 *status_valid_params;
@@ -199,6 +205,7 @@ struct dsi_panel {
 
 	struct dsi_regulator_info power_info;
 	struct dsi_backlight_config bl_config;
+	struct dsi_backlight_config bl_slaver_config;
 	struct dsi_panel_reset_config reset_config;
 	struct dsi_pinctrl_info pinctrl;
 	struct drm_panel_hdr_properties hdr_props;
@@ -222,6 +229,8 @@ struct dsi_panel {
 
 	bool sync_broadcast_en;
 
+	struct dsi_panel_mi_cfg mi_cfg;
+
 	int panel_test_gpio;
 	int power_mode;
 	enum dsi_panel_physical_type panel_type;
@@ -330,6 +339,8 @@ int dsi_panel_switch(struct dsi_panel *panel);
 
 int dsi_panel_post_switch(struct dsi_panel *panel);
 
+int dsi_panel_dc_switch(struct dsi_panel *panel);
+
 void dsi_dsc_pclk_param_calc(struct msm_display_dsc_info *dsc, int intf_width);
 
 void dsi_panel_bl_handoff(struct dsi_panel *panel);
@@ -345,4 +356,18 @@ void dsi_panel_ext_bridge_put(struct dsi_panel *panel);
 void dsi_panel_calc_dsi_transfer_time(struct dsi_host_common_cfg *config,
 		struct dsi_display_mode *mode, u32 frame_threshold_us);
 
+int dsi_panel_tx_cmd_set(struct dsi_panel *panel,
+				enum dsi_cmd_set_type type);
+int dsi_panel_update_backlight(struct dsi_panel *panel,
+				u32 bl_lvl);
+int dsi_panel_get_cmd_pkt_count(const char *data, u32 length, u32 *cnt);
+int dsi_panel_alloc_cmd_packets(struct dsi_panel_cmd_set *cmd,
+				u32 packet_count);
+int dsi_panel_create_cmd_packets(const char *data,
+				u32 length,
+				u32 count,
+				struct dsi_cmd_desc *cmd);
+void dsi_panel_destroy_cmd_packets(struct dsi_panel_cmd_set *set);
+void dsi_panel_dealloc_cmd_packets(struct dsi_panel_cmd_set *set);
+
 #endif /* _DSI_PANEL_H_ */
diff --git a/techpack/display/msm/dsi/dsi_panel_mi.c b/techpack/display/msm/dsi/dsi_panel_mi.c
new file mode 100755
index 000000000000..07e146d6d169
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_panel_mi.c
@@ -0,0 +1,4158 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"mi-dsi-panel:[%s:%d] " fmt, __func__, __LINE__
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <video/mipi_display.h>
+
+#include "sde_kms.h"
+#include "dsi_panel.h"
+#include "dsi_display.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_parser.h"
+#include "dsi_mi_feature.h"
+#include "drm_mipi_dsi.h"
+#include "../../../../kernel/irq/internals.h"
+
+#include "mi_disp_nvt_alpha_data.h"
+#include "mi_disp_lhbm.h"
+
+#define to_dsi_display(x) container_of(x, struct dsi_display, host)
+
+static struct dsi_read_config g_dsi_read_cfg;
+struct dsi_panel *g_panel;
+static struct dsi_panel_cmd_set gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_MAX];
+
+static void panelon_dimming_enable_delayed_work(struct work_struct *work)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = container_of(work,
+				struct dsi_panel_mi_cfg, dimming_enable_delayed_work.work);
+	struct dsi_panel *dsi_panel = mi_cfg->dsi_panel;
+
+	if (dsi_panel && !mi_cfg->hbm_enabled)
+		dsi_panel_set_disp_param(dsi_panel, DISPPARAM_DIMMING);
+        else {
+		DSI_INFO("hbm_enabled(%d), delay of dimming on\n", mi_cfg->hbm_enabled);
+		schedule_delayed_work(&mi_cfg->dimming_enable_delayed_work,
+			msecs_to_jiffies(mi_cfg->panel_on_dimming_delay));
+	}
+}
+
+static void panelon_cabc_delayed_work(struct work_struct *work)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = container_of(work,
+				struct dsi_panel_mi_cfg, cabc_delayed_work.work);
+	struct dsi_panel *dsi_panel = mi_cfg->dsi_panel;
+	int rc = 0;
+
+	if (!dsi_panel) {
+		pr_err("invalid params\n");
+		return;
+	}
+
+	mutex_lock(&dsi_panel->panel_lock);
+
+	if (!dsi_panel->panel_initialized || !mi_cfg->last_bl_level) {
+		DSI_INFO("Panel not initialized! \n");
+		goto exit;
+	}
+
+	if (dsi_panel->host_config.phy_type == DSI_PHY_TYPE_CPHY) {
+		if (dsi_panel->mi_cfg.cabc_current_status != dsi_panel->mi_cfg.cabc_temp_status){
+			switch (dsi_panel->mi_cfg.cabc_temp_status) {
+			case DISPPARAM_CABCUI_ON:
+				DSI_INFO("cabcuion\n");
+				rc = dsi_panel_tx_cmd_set(dsi_panel, DSI_CMD_SET_MI_CABCUION);
+				break;
+			case DISPPARAM_CABCSTILL_ON:
+				DSI_INFO("cabcstillon\n");
+				rc = dsi_panel_tx_cmd_set(dsi_panel, DSI_CMD_SET_MI_CABCSTILLON);
+				break;
+			case DISPPARAM_CABCMOVIE_ON:
+				DSI_INFO("cabcmovieon\n");
+				dsi_panel_tx_cmd_set(dsi_panel, DSI_CMD_SET_MI_CABCMOVIEON);
+				break;
+			case DISPPARAM_CABC_OFF:
+				DSI_INFO("cabcoff\n");
+				rc = dsi_panel_tx_cmd_set(dsi_panel, DSI_CMD_SET_MI_CABCOFF);
+				break;
+			default:
+				DSI_INFO("cabc = 0x%X \n", dsi_panel->mi_cfg.cabc_temp_status);
+				break;
+			}
+			dsi_panel->mi_cfg.cabc_current_status = dsi_panel->mi_cfg.cabc_temp_status;
+			if (rc) {
+				DSI_ERR("cabc failed rc=%d\n", rc);
+			}
+		}
+	}
+
+exit:
+	mutex_unlock(&dsi_panel->panel_lock);
+}
+
+static void enter_aod_delayed_work(struct work_struct *work)
+{
+	struct dsi_panel_mi_cfg *mi_cfg = container_of(work,
+				struct dsi_panel_mi_cfg, enter_aod_delayed_work.work);
+	struct dsi_panel *panel = mi_cfg->dsi_panel;
+
+	if (!panel)
+		return;
+
+	mutex_lock(&panel->panel_lock);
+
+	if (!panel->panel_initialized)
+		goto exit;
+
+	if (mi_cfg->local_hbm_enabled) {
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+				panel->power_mode == SDE_MODE_DPMS_LP2) {
+			if (mi_cfg->fp_status == AUTH_START) {
+				if (!mi_cfg->unset_doze_brightness) {
+					mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+				}
+				pr_info("delayed_work runing --- set doze brightness\n");
+				dsi_panel_set_doze_brightness(panel, mi_cfg->unset_doze_brightness, false);
+			}
+		}
+	}else {
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+				panel->power_mode == SDE_MODE_DPMS_LP2) {
+			if (mi_cfg->layer_fod_unlock_success || mi_cfg->sysfs_fod_unlock_success) {
+				pr_info("[%d,%d]Fod fingerprint unlocked successfully, skip to enter aod mode\n",
+					mi_cfg->layer_fod_unlock_success, mi_cfg->sysfs_fod_unlock_success);
+				goto exit;
+			} else {
+				if (!mi_cfg->unset_doze_brightness) {
+					mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+				}
+				pr_info("delayed_work runing --- set doze brightness, unset_doze_brightness:%d\n", mi_cfg->unset_doze_brightness);
+				if (mi_cfg->layer_aod_flag) {
+					dsi_panel_set_doze_brightness(panel, mi_cfg->unset_doze_brightness, false);
+					mi_cfg->fod_to_nolp = true;
+				}
+				else
+					pr_info("delayed_work runing --- skip into doze\n");
+			}
+		}
+	}
+
+exit:
+	mutex_unlock(&panel->panel_lock);
+}
+
+
+static int dsi_panel_parse_gamma_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	if (mi_cfg->gamma_update_flag) {
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-flash-read-total-param",
+				&mi_cfg->gamma_cfg.flash_read_total_param);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-flash-read-total-param\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-flash-read-c1-index",
+				&mi_cfg->gamma_cfg.flash_read_c1_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-flash-read-c1-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-c8-index",
+				&mi_cfg->gamma_cfg.update_c8_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-c8-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-c9-index",
+				&mi_cfg->gamma_cfg.update_c9_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-c9-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-gamma-update-b3-index",
+				&mi_cfg->gamma_cfg.update_b3_index);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-panel-gamma-update-b3-index\n");
+
+		mi_cfg->gamma_cfg.black_setting_flag = utils->read_bool(of_node,
+				"mi,mdss-dsi-panel-gamma-black-setting-flag");
+		if (!mi_cfg->gamma_cfg.black_setting_flag)
+			pr_info("can't get mi,mdss-dsi-panel-gamma-black-setting-flag\n");
+	}
+
+	return rc;
+}
+
+static int dsi_panel_parse_greenish_gamma_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	if (mi_cfg->greenish_gamma_update_flag) {
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-greenish-update-gamma-length",
+				&mi_cfg->greenish_gamma_read_len);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-greenish-update-gamma-length\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-greenish-update-gamma-offset",
+				&mi_cfg->greenish_gamma_cfg.greenish_gamma_update_offset);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-greenish-update-gamma-offset\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-param-count",
+				&mi_cfg->greenish_gamma_cfg.greenish_gamma_update_param_count);
+		if (rc)
+			pr_info("failed to get mi,mdss-dsi-update-gamma-param-count\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-1st-index",
+				&mi_cfg->greenish_gamma_cfg.index_1st_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-1st-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-2nd-index",
+				&mi_cfg->greenish_gamma_cfg.index_2nd_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-2nd-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-3rd-index",
+				&mi_cfg->greenish_gamma_cfg.index_3rd_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-3rd-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-4th-index",
+				&mi_cfg->greenish_gamma_cfg.index_4th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-4th-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-5th-index",
+				&mi_cfg->greenish_gamma_cfg.index_5th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-5th-index\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-update-gamma-6th-index",
+				&mi_cfg->greenish_gamma_cfg.index_6th_param);
+		if (rc)
+			pr_info("failed to get mdss-dsi-update-gamma-6th-index\n");
+	}
+
+	return rc;
+}
+
+static int dsi_panel_parse_white_point_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-register-read-length",
+			&mi_cfg->wp_reg_read_len);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-register-read-length\n");
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-info-index",
+			&mi_cfg->wp_info_index);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-info-index\n");
+
+	rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-white-point-info-length",
+			&mi_cfg->wp_info_len);
+	if (rc)
+		pr_info("failed to get mi,mdss-dsi-white-point-info-length\n");
+
+	return rc;
+}
+
+static int dsi_panel_parse_elvss_dimming_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-register-read-length",
+					&mi_cfg->elvss_dimming_read_len);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-register-read-length\n");
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-update-hbm-fod-on-index",
+					&mi_cfg->update_hbm_fod_on_index);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-update-hbm-fod-on-index\n");
+
+	rc = utils->read_u32(of_node, "mi,mdss-dsi-elvss-dimming-update-hbm-fod-off-index",
+					&mi_cfg->update_hbm_fod_off_index);
+	if (rc)
+		pr_err("failed to get mi,mdss-dsi-elvss-dimming-update-hbm-fod-off-index\n");
+
+	return rc;
+}
+
+int dsi_panel_parse_esd_gpio_config(struct dsi_panel *panel)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+
+	mi_cfg->esd_err_irq_gpio = of_get_named_gpio_flags(
+			utils->data, "mi,esd-err-irq-gpio",
+			0, (enum of_gpio_flags *)&(mi_cfg->esd_err_irq_flags));
+	if (gpio_is_valid(mi_cfg->esd_err_irq_gpio)) {
+		mi_cfg->esd_err_irq = gpio_to_irq(mi_cfg->esd_err_irq_gpio);
+		rc = gpio_request(mi_cfg->esd_err_irq_gpio, "esd_err_irq_gpio");
+		if (rc)
+			pr_err("Failed to request esd irq gpio %d, rc=%d\n",
+				mi_cfg->esd_err_irq_gpio, rc);
+		else
+			gpio_direction_input(mi_cfg->esd_err_irq_gpio);
+	} else {
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+int dsi_panel_parse_mi_config(struct dsi_panel *panel,
+				struct device_node *of_node)
+{
+	int rc = 0;
+	struct dsi_parser_utils *utils = &panel->utils;
+	struct dsi_panel_mi_cfg *mi_cfg = &panel->mi_cfg;
+	u32 length = 0;
+	const u32 *arr;
+
+	mi_cfg->dsi_panel = panel;
+	g_panel = panel;
+
+	INIT_DELAYED_WORK(&mi_cfg->enter_aod_delayed_work, enter_aod_delayed_work);
+	mi_cfg->aod_wakelock = wakeup_source_create("aod_wakelock");
+	wakeup_source_add(mi_cfg->aod_wakelock);
+
+	mi_cfg->bl_is_big_endian= utils->read_bool(utils->data,
+			"mi,mdss-dsi-bl-dcs-big-endian-type");
+
+	rc = utils->read_u64(utils->data, "mi,panel-id", &mi_cfg->panel_id);
+	if (rc) {
+		mi_cfg->panel_id = 0;
+		pr_info("mi,panel-id not specified\n");
+	} else {
+		pr_info("mi,panel-id is 0x%llx\n", mi_cfg->panel_id);
+	}
+
+	mi_cfg->mi_feature_enabled = utils->read_bool(of_node,
+			"mi,feature-enabled");
+	if (mi_cfg->mi_feature_enabled) {
+		pr_info("mi feature enabled\n");
+	} else {
+		pr_info("mi feature disabled\n");
+		return 0;
+	}
+
+	mi_cfg->hbm_51_ctrl_flag = utils->read_bool(utils->data,
+		"mi,mdss-dsi-panel-hbm-51-ctrl-flag");
+	if (mi_cfg->hbm_51_ctrl_flag) {
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-hbm-off-51-index", &mi_cfg->hbm_off_51_index);
+		if (rc) {
+			pr_err("mi,mdss-dsi-panel-hbm-off-51-index not defined,but need\n");
+		}
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-off-51-index", &mi_cfg->fod_off_51_index);
+		if (rc) {
+			pr_err("mi,mdss-dsi-panel-fod-off-51-index not defined,but need\n");
+		}
+		mi_cfg->vi_setting_enabled = utils->read_bool(of_node,
+			"mi,mdss-dsi-panel-vi-setting-enabled");
+		if (mi_cfg->vi_setting_enabled) {
+			pr_info("mi vi_setting_enabled = %d\n", mi_cfg->vi_setting_enabled);
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-vi-switch-threshold", &mi_cfg->vi_switch_threshold);
+			if (rc)
+				pr_err("mi,mdss-dsi-panel-vi-switch-threshold not defined,but need\n");
+		}
+		mi_cfg->dynamic_elvss_enabled = utils->read_bool(of_node,
+			"mi,mdss-dsi-panel-dynamic-elvss-enabled");
+		if (mi_cfg->dynamic_elvss_enabled) {
+			pr_info("mi dynamic_elvss_enabled = %d\n", mi_cfg->dynamic_elvss_enabled);
+		}
+	}
+
+	rc = utils->read_u32(of_node,
+		"mi,mdss-dsi-panel-fod-off-b5-index", &mi_cfg->fod_off_b5_index);
+	if (rc) {
+		pr_err("mi,mdss-dsi-panel-fod-off-b5-index not defined\n");
+	}
+
+	mi_cfg->fod_dimlayer_enabled = utils->read_bool(of_node,
+		"mi,mdss-dsi-panel-fod-dimlayer-enabled");
+	if (mi_cfg->fod_dimlayer_enabled) {
+		pr_info("fod dimlayer enabled.\n");
+	} else {
+		pr_info("fod dimlayer disabled.\n");
+	}
+
+	if (mi_cfg->fod_dimlayer_enabled) {
+		mi_cfg->prepare_before_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-prepare-before-fod-hbm-on");
+		if (mi_cfg->prepare_before_fod_hbm_on) {
+			pr_info("fod hbm on need prepare.\n");
+		} else {
+			pr_info("fod hbm on doesn't need prepare.\n");
+		}
+
+		mi_cfg->delay_before_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-before-fod-hbm-on");
+		if (mi_cfg->delay_before_fod_hbm_on) {
+			pr_info("delay before fod hbm on.\n");
+		}
+
+		mi_cfg->delay_after_fod_hbm_on = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-after-fod-hbm-on");
+		if (mi_cfg->delay_after_fod_hbm_on) {
+			pr_info("delay after fod hbm on.\n");
+		}
+
+		mi_cfg->delay_before_fod_hbm_off = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-before-fod-hbm-off");
+		if (mi_cfg->delay_before_fod_hbm_off) {
+			pr_info("delay before fod hbm off.\n");
+		}
+
+		mi_cfg->delay_after_fod_hbm_off = utils->read_bool(of_node,
+			"mi,mdss-panel-delay-after-fod-hbm-off");
+		if (mi_cfg->delay_after_fod_hbm_off) {
+			pr_info("delay after fod hbm off.\n");
+		}
+
+		mi_cfg->fod_skip_nolp = utils->read_bool(of_node,
+			"mi,mdss-panel-fod-skip-nolp");
+		if (mi_cfg->fod_skip_nolp) {
+			pr_info("j1 fod skip nolp\n");
+		}
+
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-dimlayer-brightness-alpha-lut-item-count",
+			&mi_cfg->brightnes_alpha_lut_item_count);
+		if (rc || mi_cfg->brightnes_alpha_lut_item_count <= 0) {
+			pr_err("can't get brightnes_alpha_lut_item_count\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		arr = utils->get_property(utils->data,
+				"mi,mdss-dsi-dimlayer-brightness-alpha-lut", &length);
+
+		length = length / sizeof(u32);
+
+		pr_info("length: %d\n", length);
+		if (!arr || length & 0x1 || length != mi_cfg->brightnes_alpha_lut_item_count * 2) {
+			pr_err("read mi,mdss-dsi-dimlayer-brightness-alpha-lut failed\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		mi_cfg->brightness_alpha_lut = (struct brightness_alpha *)kzalloc(length * sizeof(u32), GFP_KERNEL);
+		if (!mi_cfg->brightness_alpha_lut) {
+			pr_err("no memory for brightnes alpha lut\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			goto skip_dimlayer_parse;
+		}
+
+		rc = utils->read_u32_array(utils->data, "mi,mdss-dsi-dimlayer-brightness-alpha-lut",
+			(u32 *)mi_cfg->brightness_alpha_lut, length);
+		if (rc) {
+			pr_err("cannot read mi,mdss-dsi-dimlayer-brightness-alpha-lut\n");
+			mi_cfg->fod_dimlayer_enabled = false;
+			kfree(mi_cfg->brightness_alpha_lut);
+			goto skip_dimlayer_parse;
+		}
+	}
+
+skip_dimlayer_parse:
+
+	mi_cfg->local_hbm_enabled = utils->read_bool(utils->data, "mi,local-hbm-enabled");
+	if (mi_cfg->local_hbm_enabled) {
+		pr_info("local_hbm_enabled\n");
+		mi_cfg->fod_lhbm_87reg_ctrl_flag = utils->read_bool(utils->data,
+		"mi,mdss-dsi-panel-fod-lhbm-87reg-ctrl-flag");
+		if (mi_cfg->fod_lhbm_87reg_ctrl_flag) {
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-white-1000nit-87reg-index", &mi_cfg->fod_lhbm_white_1000nit_87reg_index);
+			if (rc) {
+				pr_err("mi,mdss-dsi-panel-fod-lhbm-white-1000nit-87reg-index not defined,but need\n");
+			}
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-white-110nit-87reg-index", &mi_cfg->fod_lhbm_white_110nit_87reg_index);
+			if (rc) {
+				pr_err("mi,mdss-dsi-panel-fod-lhbm-white-110nit-87reg-index not defined,but need\n");
+			}
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-green-500nit-87reg-index", &mi_cfg->fod_lhbm_green_500nit_87reg_index);
+			if (rc) {
+				pr_err("mi,mdss-dsi-panel-fod-lhbm-green-500nit-87reg-index not defined,but need\n");
+			}
+		}
+		mi_cfg->fod_lhbm_b2reg_ctrl_flag = utils->read_bool(utils->data,
+		"mi,mdss-dsi-panel-fod-lhbm-87reg-ctrl-flag");
+		if (mi_cfg->fod_lhbm_87reg_ctrl_flag) {
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-white-1000nit-b2reg-index", &mi_cfg->fod_lhbm_white_1000nit_b2reg_index);
+			if (rc) {
+				pr_err("mi,mdss-dsi-panel-fod-lhbm-white-1000nit-b2reg-index not defined,but need\n");
+			}
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-white-110nit-b2reg-index", &mi_cfg->fod_lhbm_white_110nit_b2reg_index);
+			if (rc) {
+				pr_err("mi,mdss-dsi-panel-fod-lhbm-white-110nit-b2reg-index not defined,but need\n");
+			}
+		}
+
+		rc = utils->read_u32(utils->data, "mi,doze-hbm-dbv-level", &mi_cfg->doze_hbm_dbv_level);
+		rc |= utils->read_u32(utils->data, "mi,doze-lbm-dbv-level", &mi_cfg->doze_lbm_dbv_level);
+		if (rc) {
+			mi_cfg->doze_hbm_dbv_level = 0;
+			mi_cfg->doze_lbm_dbv_level = 0;
+			pr_info("mi,doze-hbm-dbv-level/mi,doze-lbm-dbv-level not specified\n");
+		} else {
+			pr_info("mi,doze-hbm-dbv-level = %d mi,doze-lbm-dbv-level = %d\n", mi_cfg->doze_hbm_dbv_level, mi_cfg->doze_lbm_dbv_level);
+		}
+
+		mi_cfg->fod_lhbm_green_500nit_update_flag = utils->read_bool(utils->data, "mi,mdss-dsi-panel-fod-lhbm-green-500nit-update-flag");
+		if (mi_cfg->fod_lhbm_green_500nit_update_flag) {
+			rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-fod-lhbm-green-500nit-update-d0-index", &mi_cfg->fod_lhbm_green_500nit_cfg.update_index);
+		}
+
+		mi_cfg->fod_lhbm_white_update_flag = utils->read_bool(utils->data, "mi,mdss-dsi-panel-fod-lhbm-white-update-flag");
+		if (mi_cfg->fod_lhbm_white_update_flag) {
+			rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-lhbm-white-1000nit-update-d0-index", &mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_1000NIT_GIRON].update_index);
+			mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_1000NIT_GIROFF].update_index = mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_1000NIT_GIRON].update_index;
+			rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-lhbm-white-110nit-update-d0-index", &mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_110NIT_GIRON].update_index);
+			mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_110NIT_GIROFF].update_index = mi_cfg->fod_lhbm_white_cfg[FOD_LHBM_WHITE_110NIT_GIRON].update_index;
+		}
+	}
+
+	mi_cfg->nolp_b2reg_ctrl_flag = utils->read_bool(utils->data,
+	"mi,mdss-dsi-panel-nolp-b2reg-ctrl-flag");
+	if (mi_cfg->nolp_b2reg_ctrl_flag) {
+		rc = utils->read_u32(of_node,
+			"mi,mdss-dsi-panel-nolp-b2reg-index", &mi_cfg->nolp_b2reg_index);
+		if (rc) {
+			pr_err("mi,mdss-dsi-panel-nolp-b2reg-index not defined,but need\n");
+		}
+	}
+	mi_cfg->disp_rate_gpio = utils->get_named_gpio(utils->data,
+		"mi,mdss-dsi-panel-disp-rate-gpio",0);
+	if (gpio_is_valid(mi_cfg->disp_rate_gpio)) {
+		rc = gpio_request(mi_cfg->disp_rate_gpio, "disp_rate");
+		if (rc) {
+			pr_err("request for disp_rate gpio failed, rc=%d\n", rc);
+		}
+		rc = gpio_direction_output(mi_cfg->disp_rate_gpio, 1);
+		if (rc) {
+			pr_err("unable to set dir for disp_rate gpio rc=%d\n", rc);
+		}
+	} else {
+		pr_info("panel disp_rate gpio not specified\n");
+	}
+
+	rc = utils->read_u32(of_node,
+		"mi,mdss-panel-on-dimming-delay", &mi_cfg->panel_on_dimming_delay);
+	if (rc) {
+		mi_cfg->panel_on_dimming_delay = 0;
+		pr_info("panel on dimming delay disabled\n");
+	} else {
+		pr_info("panel on dimming delay %d ms\n", mi_cfg->panel_on_dimming_delay);
+	}
+
+	if (mi_cfg->panel_on_dimming_delay)
+		INIT_DELAYED_WORK(&mi_cfg->dimming_enable_delayed_work, panelon_dimming_enable_delayed_work);
+
+	if (panel->host_config.cphy_strength)
+		INIT_DELAYED_WORK(&mi_cfg->cabc_delayed_work, panelon_cabc_delayed_work);
+
+	rc = utils->read_u32(of_node,
+			"mi,disp-fod-off-dimming-delay", &mi_cfg->fod_off_dimming_delay);
+	if (rc) {
+		mi_cfg->fod_off_dimming_delay = DEFAULT_FOD_OFF_DIMMING_DELAY;
+		pr_info("default fod_off_dimming_delay %d\n", DEFAULT_FOD_OFF_DIMMING_DELAY);
+	} else {
+		pr_info("fod_off_dimming_delay %d\n", mi_cfg->fod_off_dimming_delay);
+	}
+
+	mi_cfg->gamma_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-gamma-update-flag");
+	if (mi_cfg->gamma_update_flag) {
+		pr_info("mi,mdss-dsi-panel-gamma-update-flag feature is defined\n");
+
+		rc = dsi_panel_parse_gamma_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse gamma config\n");
+	} else {
+		pr_info("mi,mdss-dsi-panel-gamma-update-flag feature not defined\n");
+	}
+
+	mi_cfg->greenish_gamma_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-greenish-update-gamma-flag");
+	if (mi_cfg->greenish_gamma_update_flag) {
+		pr_info("mi,mdss-dsi-greenish-update-gamma-flag feature is defined\n");
+
+		rc = dsi_panel_parse_greenish_gamma_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse greenish gamma config\n");
+	} else {
+		pr_info("mi,mdss-dsi-greenish-update-gamma-flag feature not defined\n");
+	}
+
+	mi_cfg->dc_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-dc-update-flag");
+	if (mi_cfg->dc_update_flag) {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag feature is defined\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-update-d2-index",
+				&mi_cfg->dc_cfg.update_d2_index);
+		if (rc)
+			pr_info("failed to parse dc config\n");
+	} else {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag feature not defined\n");
+	}
+
+	mi_cfg->dc_update_flag_v2 = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-dc-update-flag-v2");
+	if (mi_cfg->dc_update_flag_v2) {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag-v2 feature is defined\n");
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-on-update-d2-index",
+				&mi_cfg->dc_cfg_v2[DC_LUT_D2].update_dc_on_reg_index);
+		rc |= utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-off-update-d2-index",
+				&mi_cfg->dc_cfg_v2[DC_LUT_D2].update_dc_off_reg_index);
+		if (rc) {
+			mi_cfg->dc_cfg_v2[DC_LUT_D2].update_dc_on_reg_index = -1;
+			mi_cfg->dc_cfg_v2[DC_LUT_D2].update_dc_off_reg_index = -1;
+			pr_info("failed to parse dc d2 config\n");
+		}
+
+		rc = utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-on-update-d4-index",
+				&mi_cfg->dc_cfg_v2[DC_LUT_D4].update_dc_on_reg_index);
+		rc |= utils->read_u32(of_node,
+				"mi,mdss-dsi-panel-dc-off-update-d4-index",
+				&mi_cfg->dc_cfg_v2[DC_LUT_D4].update_dc_off_reg_index);
+		if (rc) {
+			mi_cfg->dc_cfg_v2[DC_LUT_D4].update_dc_on_reg_index = -1;
+			mi_cfg->dc_cfg_v2[DC_LUT_D4].update_dc_off_reg_index = -1;
+			pr_info("failed to parse dc d4 config\n");
+		}
+	} else {
+		pr_info("mi,mdss-dsi-panel-dc-update-flag feature not defined\n");
+	}
+
+	mi_cfg->gir_update_flag = utils->read_bool(utils->data,
+			"mi,mdss-dsi-panel-gir-update-flag");
+	if (mi_cfg->gir_update_flag) {
+		pr_info("mi,mdss-dsi-panel-gir-update-flag is defined\n");
+		rc = utils->read_u32(utils->data, "mi,mdss-dsi-panel-gir-on-update-b9-index",
+				&mi_cfg->gir_cfg.update_index);
+		if (rc) {
+			mi_cfg->gir_cfg.update_index = -1;
+			pr_info("failed to get mi,mdss-dsi-panel-gir-on-update-b9-index\n");
+		}
+		rc = utils->read_u32(utils->data, "mi,mdss-dsi-panel-gir-on-update-b9-index-2",
+				&mi_cfg->gir_cfg.update_index2);
+		if (rc) {
+		    mi_cfg->gir_cfg.update_index2 = -1;
+		    pr_info("failed to get mi,mdss-dsi-panel-gir-on-update-b9-index-2\n");
+		}
+	} else {
+		pr_info("mi,mdss-dsi-panel-gir-update-flag not defined\n");
+	}
+
+	mi_cfg->wp_read_enabled= utils->read_bool(utils->data,
+				"mi,mdss-dsi-white-point-read-enabled");
+	if (mi_cfg->wp_read_enabled) {
+		rc = dsi_panel_parse_white_point_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse white point config\n");
+	} else {
+		pr_info("mi white point read not defined\n");
+	}
+
+	mi_cfg->elvss_dimming_check_enable = utils->read_bool(of_node,
+			"mi,elvss_dimming_check_enable");
+	if (mi_cfg->elvss_dimming_check_enable) {
+		pr_info("mi,elvss_dimming_check_enable is defined\n");
+
+		rc = dsi_panel_parse_elvss_dimming_config(panel, of_node);
+		if (rc)
+			pr_info("failed to parse elvss dimming config\n");
+	} else {
+		pr_info("mi,elvss_dimming_check_enable not defined\n");
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-dc-threshold", &mi_cfg->dc_threshold);
+	if (rc) {
+		mi_cfg->dc_threshold = 440;
+		pr_info("default dc backlight threshold is %d\n", mi_cfg->dc_threshold);
+	} else {
+		pr_info("dc backlight threshold %d \n", mi_cfg->dc_threshold);
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-dc-type", &mi_cfg->dc_type);
+	if (rc) {
+		mi_cfg->dc_type = 1;
+		pr_info("default dc backlight type is %d\n", mi_cfg->dc_type);
+	} else {
+		pr_info("dc backlight type %d \n", mi_cfg->dc_type);
+	}
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-hbm-brightness", &mi_cfg->hbm_brightness);
+	if (rc) {
+		mi_cfg->hbm_brightness = 0;
+		pr_info("default hbm brightness is %d\n", mi_cfg->hbm_brightness);
+	} else {
+		pr_info("hbm brightness %d \n", mi_cfg->hbm_brightness);
+	}
+
+	rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-max-brightness-clone", &mi_cfg->max_brightness_clone);
+	if (rc) {
+		mi_cfg->max_brightness_clone = 4095;
+		pr_info("default max_brightness_clone is %d\n", mi_cfg->max_brightness_clone);
+	} else {
+		pr_info("max_brightness_clone is %d \n", mi_cfg->max_brightness_clone);
+	}
+
+	if (mi_cfg->dc_type == 0 && mi_cfg->hbm_51_ctrl_flag) {
+		rc = of_property_read_u32(of_node,
+			"mi,mdss-dsi-panel-fod-on-b2-index", &mi_cfg->fod_on_b2_index);
+		if (rc) {
+			mi_cfg->fod_on_b2_index = 0;
+			pr_info("mi,mdss-dsi-panel-fod-on-b2-index not defined\n");
+		}
+	}
+
+	mi_cfg->is_tddi_flag = utils->read_bool(of_node,
+			"mi,is-tddi-flag");
+	if (mi_cfg->is_tddi_flag)
+		pr_info("panel is tddi\n");
+
+	mi_cfg->hbm_enabled = false;
+	mi_cfg->thermal_hbm_disabled = false;
+	mi_cfg->fod_hbm_enabled = false;
+	mi_cfg->fod_hbm_layer_enabled = false;
+	mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+	mi_cfg->unset_doze_brightness = DOZE_TO_NORMAL;
+	mi_cfg->dimming_state = STATE_NONE;
+	mi_cfg->fod_backlight_flag = false;
+	mi_cfg->fod_flag = false;
+	mi_cfg->in_aod = false;
+	mi_cfg->fod_hbm_off_time = ktime_get();
+	mi_cfg->fod_backlight_off_time = ktime_get();
+	mi_cfg->dc_enable = false;
+	mi_cfg->bl_enable = true;
+	mi_cfg->panel_dead_flag = false;
+	mi_cfg->tddi_doubleclick_flag = false;
+
+	mi_cfg->dither_enabled = false;
+	mi_cfg->local_hbm_cur_status = false;
+	mi_cfg->fod_lhbm_low_brightness_enabled = false;
+	mi_cfg->fp_status = 0;
+	mi_cfg->dim_fp_dbv_max_in_hbm_flag = false;
+
+	return rc;
+}
+
+int dsi_panel_esd_irq_ctrl(struct dsi_panel *panel,
+				bool enable)
+{
+	int ret  = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+	ret = dsi_panel_esd_irq_ctrl_locked(panel, enable);
+	mutex_unlock(&panel->panel_lock);
+
+	return ret;
+}
+
+int dsi_panel_esd_irq_ctrl_locked(struct dsi_panel *panel,
+				bool enable)
+{
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct irq_desc *desc;
+
+	if (!panel || !panel->panel_initialized) {
+		pr_err("Panel not ready!\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	if (gpio_is_valid(mi_cfg->esd_err_irq_gpio)) {
+		if (mi_cfg->esd_err_irq) {
+			if (enable) {
+				if (!mi_cfg->esd_err_enabled) {
+					desc = irq_to_desc(mi_cfg->esd_err_irq);
+					if (!irq_settings_is_level(desc))
+						desc->istate &= ~IRQS_PENDING;
+					enable_irq_wake(mi_cfg->esd_err_irq);
+					enable_irq(mi_cfg->esd_err_irq);
+					mi_cfg->esd_err_enabled = true;
+					pr_info("%s panel esd irq is enable\n", panel->type);
+				}
+			} else {
+				if (mi_cfg->esd_err_enabled) {
+					disable_irq_wake(mi_cfg->esd_err_irq);
+					disable_irq_nosync(mi_cfg->esd_err_irq);
+					mi_cfg->esd_err_enabled = false;
+					pr_info("%s panel esd irq is disable\n", panel->type);
+				}
+			}
+		}
+	} else {
+		pr_info("%s panel esd irq gpio invalid\n", panel->type);
+	}
+
+	return 0;
+}
+
+
+int dsi_panel_update_elvss_dimming(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_read_config elvss_dimming_read;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	u32 count;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	if (!mi_cfg->elvss_dimming_check_enable) {
+		pr_debug("elvss_dimming_check_enable not defined, return\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_ELVSS_DIMMING_OFFSET command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_ELVSS_DIMMING_READ];
+	elvss_dimming_read.read_cmd = *cmd_set;
+	elvss_dimming_read.cmds_rlen = mi_cfg->elvss_dimming_read_len;
+	elvss_dimming_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &elvss_dimming_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read elvss_dimming, rc=%d\n", panel->name, rc);
+		retval = -EAGAIN;
+	} else {
+		pr_info("elvss dimming read result %x\n", elvss_dimming_read.rbuf[0]);
+		cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].cmds;
+		count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].count;
+		if (cmds && count >= mi_cfg->update_hbm_fod_on_index) {
+			tx_buf = (u8 *)cmds[mi_cfg->update_hbm_fod_on_index].msg.tx_buf;
+			tx_buf[1] = elvss_dimming_read.rbuf[0] & 0x7F;
+		}
+		cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+		count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+		if (cmds && count >= mi_cfg->update_hbm_fod_off_index) {
+			tx_buf = (u8 *)cmds[mi_cfg->update_hbm_fod_off_index].msg.tx_buf;
+			tx_buf[1] = elvss_dimming_read.rbuf[0] & 0x7F;
+		}
+		retval = 0;
+	}
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_read_greenish_gamma_setting(struct dsi_panel *panel)
+{
+	int rc =0;
+	int retval = 0;
+	int i = 0;
+	int param_count = 0;
+	u32 count = 0;
+	u32 offset = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct greenish_gamma_cfg *greenish_gamma_cfg;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_read_config greenish_gamma_read;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	greenish_gamma_cfg = &mi_cfg->greenish_gamma_cfg;
+
+	if (!mi_cfg->greenish_gamma_update_flag) {
+		pr_debug("greenish_gamma_update_flag not defined, return\n");
+		return 0;
+	}
+
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+
+	/* level2-key-enable */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	/* pre read command */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_PRE_READ);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_PRE_READ command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	/* read 1st~6th param */
+	offset = greenish_gamma_cfg->greenish_gamma_update_offset;
+	param_count = greenish_gamma_cfg->greenish_gamma_update_param_count;
+	for(i = 1; i <= param_count; i++) {
+		switch (i) {
+		case 1:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_1ST_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 1st greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 1st para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_1st_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_1st_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 1st para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 2:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_2ND_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 2nd greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 2nd para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_2nd_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_2nd_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 2nd para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 3:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_3RD_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 3rd greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 3rd para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_3rd_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_3rd_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 3rd para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 4:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_4TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 4th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 4th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_4th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_4th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 4th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 5:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_5TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 5th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 5th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_5th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_5th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 5th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		case 6:
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_READ_6TH_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_READ_B7];
+			greenish_gamma_read.read_cmd = *cmd_set;
+			greenish_gamma_read.cmds_rlen = mi_cfg->greenish_gamma_read_len;
+			greenish_gamma_read.is_read = 1;
+
+			rc = dsi_panel_read_cmd_set(panel, &greenish_gamma_read);
+			if (rc <= 0) {
+				pr_err("[%s]failed to read 6th greenish_gamma, rc=%d\n", panel->name, rc);
+				retval = -EAGAIN;
+			} else {
+				pr_info("greenish gamma read result 6th para %x, %x\n",
+					greenish_gamma_read.rbuf[0], greenish_gamma_read.rbuf[1]);
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].count;
+				if (cmds && count >= greenish_gamma_cfg->index_6th_param) {
+					tx_buf = (u8 *)cmds[greenish_gamma_cfg->index_6th_param].msg.tx_buf;
+					if (greenish_gamma_read.rbuf[1] >= (u8)offset) {
+						tx_buf[1] = greenish_gamma_read.rbuf[0];
+						tx_buf[2] = greenish_gamma_read.rbuf[1] - (u8)offset;
+					} else {
+						tx_buf[1] = greenish_gamma_read.rbuf[0] - (u8)0x1;
+						tx_buf[2] = greenish_gamma_read.rbuf[1] + (u8)0x100 - (u8)offset;
+					}
+					pr_info("greenish gamma set result 6th para %x, %x\n", tx_buf[1], tx_buf[2]);
+				}
+				retval = 0;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* level2-key-disable */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		greenish_gamma_cfg->gamma_update_done = true;
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_update_greenish_gamma_setting(struct dsi_panel *panel)
+{
+	int rc =0;
+	int retval = 0;
+	int i = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_cmd_desc *cmds;
+	struct dsi_display_mode_priv_info *priv_info;
+	u8 *tx_buf;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+
+	if (!mi_cfg->greenish_gamma_update_flag || !mi_cfg->greenish_gamma_cfg.gamma_update_done) {
+		pr_debug("greenish_gamma_update_flag not defined or gamma update has not completed, return\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+	cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_B7].cmds;
+
+	/* greenish gamma seeting cmd */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_B7);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_B7 command\n");
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		pr_info("greenish gamma DSI_CMD_SET_MI_GAMMA_B7 set is\n");
+		for (i = 0; i <= 15; i++) {
+			tx_buf = (u8 *)cmds[i].msg.tx_buf;
+			pr_info("DSI_CMD_SET_MI_GAMMA_B7 %d line tx_buf %x %x\n", i,
+				tx_buf[0], tx_buf[1]);
+		}
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_match_fps_pen_setting(struct dsi_panel *panel,
+				struct dsi_display_mode *adj_mode)
+{
+	int rc =0;
+	int retval = 0;
+	struct dsi_display_mode_priv_info *priv_info;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info || !adj_mode) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+
+	if (!priv_info->cmd_sets[DSI_CMD_SET_DISP_PEN_120HZ].count) {
+		pr_debug("DSI_CMD_SET_DISP_PEN_120HZ not defined, return\n");
+		return 0;
+	}
+
+	/* match fps(120/60/30Hz) pen seeting cmd */
+	if (adj_mode->timing.refresh_rate == 120)
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_PEN_120HZ);
+	else if (adj_mode->timing.refresh_rate == 60)
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_PEN_60HZ);
+	else if (adj_mode->timing.refresh_rate == 30)
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_PEN_30HZ);
+
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_DISP_PEN_120HZ command\n");
+		retval = -EAGAIN;
+		goto error;
+	}else
+		pr_info("%s: refresh_rate[%d]\n", __func__, adj_mode->timing.refresh_rate);
+
+error:
+	return retval;
+}
+
+static int dsi_panel_read_gamma_opt_and_flash(struct dsi_panel *panel,
+				struct dsi_display_ctrl *ctrl)
+{
+	int rc = 0;
+	int retval = 0;
+	int i = 0;
+	int retry_cnt = 0;
+	u32 flags = 0;
+	struct dsi_display_mode *mode;
+	struct gamma_cfg *gamma_cfg;
+	struct dsi_cmd_desc *cmds;
+	enum dsi_cmd_set_state state;
+	u32 count = 0;
+	u32 param_index = 0;
+	u8 read_param_buf[200] = {0};
+	u8 read_fb_buf[16] = {0};
+	u8 *tx_buf;
+	bool checksum_pass = 0;
+
+	if (!panel || !ctrl || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mode = panel->cur_mode;
+	gamma_cfg = &panel->mi_cfg.gamma_cfg;
+
+	/* OTP Read 60hz gamma parameter */
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_ENABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	pr_debug("Gamma 0xC8 OPT Read 135 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C8].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C8].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_c8);
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_C8\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_c8, cmds->msg.rx_buf, sizeof(gamma_cfg->otp_read_c8));
+
+	pr_debug("Gamma 0xC9 OPT Read 180 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C9].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_C9].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_c9);
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_C9\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_c9, cmds->msg.rx_buf, sizeof(gamma_cfg->otp_read_c9));
+
+#if 0
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_OTP_READ_B3_PRE command\n");
+		goto error;
+	}
+#endif
+
+	pr_debug("Gamma 0xB3 OTP Read 45 Parameter (60Hz)\n");
+	flags = 0;
+	memset(read_param_buf, 0, sizeof(read_param_buf));
+	cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_B3].cmds;
+	state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_OTP_READ_B3].state;
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ | DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+	cmds->msg.rx_buf = read_param_buf;
+	cmds->msg.rx_len = sizeof(gamma_cfg->otp_read_b3) + 2;
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+	if (rc <= 0) {
+		pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_OTP_READ_B3\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	memcpy(gamma_cfg->otp_read_b3, &read_param_buf[2], sizeof(gamma_cfg->otp_read_b3));
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+	pr_info("OTP Read 60hz gamma done\n");
+
+	/* Flash Read 90hz gamma parameter */
+	do {
+		gamma_cfg->gamma_checksum = 0;
+
+		if (retry_cnt > 0) {
+			pr_err("Failed to flash read 90hz gamma parameters, retry_cnt = %d\n",
+					retry_cnt);
+			mdelay(80);
+		}
+
+		for(i = 0; i < gamma_cfg->flash_read_total_param; i++)
+		{
+			cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE].cmds;
+			count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE].count;
+			tx_buf = (u8 *)cmds[gamma_cfg->flash_read_c1_index].msg.tx_buf;
+			if (cmds && count >= gamma_cfg->flash_read_c1_index) {
+				tx_buf[2] = i >> 8;
+				tx_buf[3] = i & 0xFF;
+			}
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_GAMMA_FLASH_READ_PRE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			/* 0xFB Read 2 Parameter */
+			flags = 0;
+			cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB].cmds;
+			state = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB].state;
+			if (state == DSI_CMD_SET_STATE_LP)
+				cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+			if (cmds->last_command) {
+				cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+				flags |= DSI_CTRL_CMD_LAST_COMMAND;
+			}
+			flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ |
+						DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+			cmds->msg.rx_buf = read_fb_buf;
+			cmds->msg.rx_len = 2;
+			rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &cmds->msg, &flags);
+			if (rc <= 0) {
+				pr_err("Failed to read DSI_CMD_SET_MI_GAMMA_FLASH_READ_FB\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE);
+			if (rc) {
+				pr_err("Failed to send DSI_CMD_SET_MI_LEVEL2_KEY_DISABLE command\n");
+				retval = -EAGAIN;
+				goto error;
+			}
+
+			if (i < sizeof(gamma_cfg->flash_read_c8)) {
+				gamma_cfg->flash_read_c8[i] = read_fb_buf[1];
+			}
+			else if (i < (sizeof(gamma_cfg->flash_read_c8) +
+						sizeof(gamma_cfg->flash_read_c9))) {
+				param_index = i - sizeof(gamma_cfg->flash_read_c8);
+				gamma_cfg->flash_read_c9[param_index] = read_fb_buf[1];
+			}
+			else if (i < (sizeof(gamma_cfg->flash_read_c8) +
+					sizeof(gamma_cfg->flash_read_c9) +
+					sizeof(gamma_cfg->flash_read_b3))) {
+				param_index = i - (sizeof(gamma_cfg->flash_read_c8) +
+								sizeof(gamma_cfg->flash_read_c9));
+				gamma_cfg->flash_read_b3[param_index] = read_fb_buf[1];
+			}
+
+			if (i < (gamma_cfg->flash_read_total_param - 2)) {
+				gamma_cfg->gamma_checksum = read_fb_buf[1] + gamma_cfg->gamma_checksum;
+			} else {
+				if (i == (gamma_cfg->flash_read_total_param - 2))
+					gamma_cfg->flash_read_checksum[0] = read_fb_buf[1];
+				if (i == (gamma_cfg->flash_read_total_param - 1))
+					gamma_cfg->flash_read_checksum[1] = read_fb_buf[1];
+			}
+		}
+		if (gamma_cfg->gamma_checksum == ((gamma_cfg->flash_read_checksum[0] << 8)
+				+ gamma_cfg->flash_read_checksum[1])) {
+			checksum_pass = 1;
+			pr_info("Flash Read 90hz gamma done\n");
+		} else {
+			checksum_pass = 0;
+		}
+		retry_cnt++;
+	}
+	while (!checksum_pass && (retry_cnt < 5));
+
+	if (checksum_pass) {
+		gamma_cfg->read_done = 1;
+		pr_info("Gamma read done\n");
+		retval = 0;
+	} else {
+		pr_err("Failed to flash read 90hz gamma\n");
+		retval = -EAGAIN;
+	}
+
+error:
+	return retval;
+
+}
+
+int dsi_panel_read_gamma_param(struct dsi_panel *panel)
+{
+	int rc = 0, ret = 0;
+	struct dsi_display *display;
+	struct dsi_display_ctrl *ctrl;
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_debug("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (display == NULL)
+		return -EINVAL;
+
+	if (!panel->panel_initialized) {
+		pr_err("Panel not initialized\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (panel->mi_cfg.gamma_cfg.read_done) {
+		pr_info("Gamma parameter have read and stored at POWER ON sequence\n");
+		goto unlock;
+	}
+
+	rc = dsi_display_clk_ctrl(display->dsi_clk_handle, DSI_ALL_CLKS, DSI_CLK_ON);
+	if (rc) {
+		pr_err("[%s] failed to enable DSI clocks, rc=%d\n", display->name, rc);
+		goto unlock;
+	}
+
+	ctrl = &display->ctrl[display->cmd_master_idx];
+
+	rc = dsi_display_cmd_engine_enable(display);
+	if (rc) {
+		pr_err("[%s] failed to enable cmd engine, rc=%d\n",
+		       display->name, rc);
+		goto error_disable_clks;
+	}
+
+	if (display->tx_cmd_buf == NULL) {
+		rc = dsi_host_alloc_cmd_tx_buffer(display);
+		if (rc) {
+			pr_err("failed to allocate cmd tx buffer memory\n");
+			goto error_disable_cmd_engine;
+		}
+	}
+
+	rc = dsi_panel_read_gamma_opt_and_flash(panel, ctrl);
+	if (rc) {
+		pr_err("[%s]failed to get gamma parameter, rc=%d\n",
+		       display->name, rc);
+		goto error_disable_cmd_engine;
+	}
+
+error_disable_cmd_engine:
+	ret = dsi_display_cmd_engine_disable(display);
+	if (ret) {
+		pr_err("[%s]failed to disable DSI cmd engine, rc=%d\n",
+				display->name, ret);
+	}
+error_disable_clks:
+	ret = dsi_display_clk_ctrl(display->dsi_clk_handle,
+			DSI_ALL_CLKS, DSI_CLK_OFF);
+	if (ret) {
+		pr_err("[%s] failed to disable all DSI clocks, rc=%d\n",
+		       display->name, ret);
+	}
+unlock:
+	mutex_unlock(&panel->panel_lock);
+
+	return rc;
+}
+
+int dsi_panel_update_gamma_param(struct dsi_panel *panel)
+{
+	struct dsi_display *display;
+	struct dsi_display_mode *mode;
+	struct gamma_cfg *gamma_cfg;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 i, count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+	int rc;
+
+	if (!panel || !panel->host)
+		return -EINVAL;
+
+	display = to_dsi_display(panel->host);
+	if (!display)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_debug("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	gamma_cfg = &panel->mi_cfg.gamma_cfg;
+	if (!gamma_cfg->read_done) {
+		pr_err("gamma parameter not ready\n");
+		pr_err("gamma parameter should be read and stored at POWER ON sequence\n");
+		return -EAGAIN;
+	}
+
+	if (!display->modes) {
+		rc = dsi_display_get_modes(display, &mode);
+		if (rc) {
+			pr_err("failed to get display mode for update gamma parameter\n");
+			return rc;
+		}
+	}
+
+	memset(gamma_cmd_set, 0, 2 * sizeof(struct dsi_panel_cmd_set));
+
+	mutex_lock(&panel->panel_lock);
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		if (mode && mode->priv_info) {
+			if (60 == mode->timing.refresh_rate && !gamma_cfg->update_done_60hz) {
+				pr_info("Update GAMMA Parameter (60Hz)\n");
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].count;
+				if (cmds && count >= gamma_cfg->update_c8_index &&
+					count >= gamma_cfg->update_c9_index &&
+					count >= gamma_cfg->update_b3_index) {
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c8_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c8_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_c8), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_c8, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c9_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c9_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_c9), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_c9, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_b3_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_b3_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->otp_read_b3), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->otp_read_b3, param_len);
+
+					memcpy(&gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ],
+							&mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH],
+							sizeof(struct dsi_panel_cmd_set));
+
+					gamma_cfg->update_done_60hz = true;
+				} else {
+					pr_err("please check gamma update parameter index configuration\n");
+				}
+			}
+			if (90 == mode->timing.refresh_rate && !gamma_cfg->update_done_90hz) {
+				pr_info("Update GAMMA Parameter (90Hz)\n");
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH].count;
+				if (cmds && count >= gamma_cfg->update_c8_index &&
+					count >= gamma_cfg->update_c9_index &&
+					count >= gamma_cfg->update_b3_index) {
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c8_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c8_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_c8), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_c8, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_c9_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_c9_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_c9), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_c9, param_len);
+
+					tx_buf = (u8 *)cmds[gamma_cfg->update_b3_index].msg.tx_buf;
+					tx_len = cmds[gamma_cfg->update_b3_index].msg.tx_len;
+					param_len = min(sizeof(gamma_cfg->flash_read_b3), tx_len - 1);
+					memcpy(&tx_buf[1], gamma_cfg->flash_read_b3, param_len);
+
+					memcpy(&gamma_cmd_set[DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ],
+							&mode->priv_info->cmd_sets[DSI_CMD_SET_TIMING_SWITCH],
+							sizeof(struct dsi_panel_cmd_set));
+
+					gamma_cfg->update_done_90hz = true;
+				} else {
+					pr_err("please check gamma update parameter index configuration\n");
+				}
+			}
+		}
+	}
+	mutex_unlock(&panel->panel_lock);
+
+	return 0;
+}
+
+
+int mi_dsi_panel_read_lhbm_white_reg(struct dsi_panel *panel, int fod_lhbm_white_state)
+{
+	int rc = 0;
+	int retval = 0;
+	struct fod_lhbm_white_cfg * fod_lhbm_white_cfg;
+	struct dsi_read_config fod_lhbm_white_read;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_display *display = to_dsi_display(panel->host);
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info ||!display) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	fod_lhbm_white_cfg = &panel->mi_cfg.fod_lhbm_white_cfg[fod_lhbm_white_state];
+	if (fod_lhbm_white_cfg->update_done) {
+		pr_debug("fod lhbm %d param already updated\n",fod_lhbm_white_state);
+		rc = 0;
+		goto error;
+	}
+
+	switch(fod_lhbm_white_state) {
+		case FOD_LHBM_WHITE_1000NIT_GIROFF: {
+			fod_lhbm_white_cfg->lhbm_white_read_pre = DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_GIR_OFF_READ_REG_PRE;
+			fod_lhbm_white_cfg->lhbm_white_read_offset = DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_READ_OFFSET_REG;
+		}break;
+		case FOD_LHBM_WHITE_1000NIT_GIRON:{
+			fod_lhbm_white_cfg->lhbm_white_read_pre = DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_GIR_ON_READ_REG_PRE;
+			fod_lhbm_white_cfg->lhbm_white_read_offset = DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT_READ_OFFSET_REG;
+		}break;
+		case FOD_LHBM_WHITE_110NIT_GIROFF: {
+			fod_lhbm_white_cfg->lhbm_white_read_pre = DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_GIR_OFF_READ_REG_PRE;
+			fod_lhbm_white_cfg->lhbm_white_read_offset = DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_READ_OFFSET_REG;
+		}break;
+		case FOD_LHBM_WHITE_110NIT_GIRON:{
+			fod_lhbm_white_cfg->lhbm_white_read_pre = DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_GIR_ON_READ_REG_PRE;
+			fod_lhbm_white_cfg->lhbm_white_read_offset = DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT_READ_OFFSET_REG;
+		}break;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	rc = dsi_panel_tx_cmd_set(panel, fod_lhbm_white_cfg->lhbm_white_read_pre);
+	if (rc) {
+		pr_err("Failed to send lhbm_white_read_pre %d command\n",fod_lhbm_white_cfg->lhbm_white_read_pre);
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	rc = dsi_panel_tx_cmd_set(panel, fod_lhbm_white_cfg->lhbm_white_read_offset);
+
+	if (rc) {
+		pr_err("Failed to send lhbm_white_read_offset %d command\n",fod_lhbm_white_cfg->lhbm_white_read_offset);
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B2_REG];
+	fod_lhbm_white_read.read_cmd = *cmd_set;
+	fod_lhbm_white_read.cmds_rlen = 2;
+	fod_lhbm_white_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &fod_lhbm_white_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read b2 reg, rc = %d\n", panel->name, rc);
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		memcpy(&fod_lhbm_white_cfg->fod_lhbm_white_param[0], fod_lhbm_white_read.rbuf, 2);
+	}
+
+	rc = dsi_panel_tx_cmd_set(panel, fod_lhbm_white_cfg->lhbm_white_read_offset);
+
+	if (rc) {
+		pr_err("Failed to send lhbm_white_read_offset %d command\n",fod_lhbm_white_cfg->lhbm_white_read_offset);
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B5_REG];
+	fod_lhbm_white_read.read_cmd = *cmd_set;
+	fod_lhbm_white_read.cmds_rlen = 2;
+	fod_lhbm_white_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &fod_lhbm_white_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read b5 reg, rc = %d\n", panel->name, rc);
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		memcpy(&fod_lhbm_white_cfg->fod_lhbm_white_param[2], fod_lhbm_white_read.rbuf, 2);
+	}
+
+	rc = dsi_panel_tx_cmd_set(panel, fod_lhbm_white_cfg->lhbm_white_read_offset);
+
+	if (rc) {
+		pr_err("Failed to send lhbm_white_read_offset %d command\n",fod_lhbm_white_cfg->lhbm_white_read_offset);
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_READ_B8_REG];
+	fod_lhbm_white_read.read_cmd = *cmd_set;
+	fod_lhbm_white_read.cmds_rlen = 2;
+	fod_lhbm_white_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &fod_lhbm_white_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read b8 reg, rc = %d\n", panel->name, rc);
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		memcpy(&fod_lhbm_white_cfg->fod_lhbm_white_param[4], fod_lhbm_white_read.rbuf, 2);
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int mi_dsi_panel_read_lhbm_white_param(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_display *display = to_dsi_display(panel->host);
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info ||!display) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	rc = mi_dsi_panel_read_lhbm_white_reg(panel,FOD_LHBM_WHITE_1000NIT_GIROFF);
+	if (rc < 0) {
+		pr_err("[%s]failed to read FOD_LHBM_WHITE_1000NIT_GIROFF param, rc = %d\n", panel->name,rc);
+		retval = -EAGAIN;
+		goto error;
+	}
+	rc = mi_dsi_panel_read_lhbm_white_reg(panel,FOD_LHBM_WHITE_1000NIT_GIRON);
+	if (rc < 0) {
+		pr_err("[%s]failed to read FOD_LHBM_WHITE_1000NIT_GIRON param, rc = %d\n", panel->name,rc);
+		retval = -EAGAIN;
+		goto error;
+	}
+	rc = mi_dsi_panel_read_lhbm_white_reg(panel,FOD_LHBM_WHITE_110NIT_GIROFF);
+	if (rc < 0) {
+		pr_err("[%s]failed to read FOD_LHBM_WHITE_110NIT_GIROFF param, rc = %d\n", panel->name,rc);
+		retval = -EAGAIN;
+		goto error;
+	}
+	rc = mi_dsi_panel_read_lhbm_white_reg(panel,FOD_LHBM_WHITE_110NIT_GIRON);
+	if (rc < 0) {
+		pr_err("[%s]failed to read FOD_LHBM_WHITE_110NIT_GIRON param, rc = %d\n", panel->name,rc);
+		retval = -EAGAIN;
+		goto error;
+	}
+
+error:
+	return retval;
+}
+
+int mi_dsi_update_lhbm_cmd_b2reg(struct dsi_panel *panel, bool dc_status)
+{
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_cmd_desc *cmds = NULL;
+	struct dsi_panel_mi_cfg *mi_cfg  = NULL;
+	u32 count;
+	u8 *tx_buf;
+	int retval = 0;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	priv_info = panel->cur_mode->priv_info;
+
+	if (mi_cfg->fod_lhbm_87reg_ctrl_flag == false) {
+		pr_info("fod_lhbm_87reg_ctrl_flag = false not suport mi_dsi_update_lhbm_cmd_b2reg\n");
+		return 0;
+	}
+
+	cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT].cmds;
+	count = priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT].count;
+	if (cmds && count >= mi_cfg->fod_lhbm_white_1000nit_b2reg_index) {
+		tx_buf = (u8 *)cmds[mi_cfg->fod_lhbm_white_1000nit_b2reg_index].msg.tx_buf;
+		if(dc_status == true)
+			tx_buf[1] = 0x98;
+		else
+			tx_buf[1] = 0x18;
+	} else {
+		pr_err("please check 60hz mi,mdss-dsi-fod-lhbm-while-1000nit-command update parameter index configuration\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT].cmds;
+	count = priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT].count;
+	if (cmds && count >= mi_cfg->fod_lhbm_white_110nit_b2reg_index) {
+		tx_buf = (u8 *)cmds[mi_cfg->fod_lhbm_white_110nit_b2reg_index].msg.tx_buf;
+		if(dc_status == true)
+			tx_buf[1] = 0x98;
+		else
+			tx_buf[1] = 0x18;
+	} else {
+		pr_err("please check 60hz mi,mdss-dsi-fod-lhbm-while-110nit-command update parameter index configuration\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+error:
+	return retval;
+}
+
+int mi_dsi_update_nolp_b2reg(struct dsi_panel *panel, bool dc_status)
+{
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_cmd_desc *cmds = NULL;
+	struct dsi_panel_mi_cfg *mi_cfg  = NULL;
+	u32 count;
+	u8 *tx_buf;
+	int retval = 0;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	priv_info = panel->cur_mode->priv_info;
+
+	if (mi_cfg->nolp_b2reg_ctrl_flag == false) {
+		pr_info("nolp_b2reg_ctrl_flag = false not suport mi_dsi_update_nolp_b2reg\n");
+		return 0;
+	}
+
+	cmds = priv_info->cmd_sets[DSI_CMD_SET_NOLP].cmds;
+	count = priv_info->cmd_sets[DSI_CMD_SET_NOLP].count;
+	if (cmds && count >= mi_cfg->nolp_b2reg_index) {
+		tx_buf = (u8 *)cmds[mi_cfg->nolp_b2reg_index].msg.tx_buf;
+		if(dc_status == true)
+			tx_buf[1] = 0x98;
+		else
+			tx_buf[1] = 0x18;
+	} else {
+		pr_err("please check 60hz qcom,mdss-dsi-nolp-command update parameter index configuration\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+error:
+	return retval;
+}
+
+int mi_dsi_panel_update_lhbm_white_param(struct dsi_panel *panel, int fod_lhbm_white_state, int cmd_index)
+{
+	struct fod_lhbm_white_cfg * fod_lhbm_white_cfg;
+	struct dsi_display *display = to_dsi_display(panel->host);
+	struct dsi_display_mode *mode;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	int retval = 0;
+	int i;
+	u32 count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+
+	fod_lhbm_white_cfg = &panel->mi_cfg.fod_lhbm_white_cfg[fod_lhbm_white_state];
+
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		cmds = mode->priv_info->cmd_sets[cmd_index].cmds;
+		count = mode->priv_info->cmd_sets[cmd_index].count;
+		if (cmds && count >= fod_lhbm_white_cfg->update_index) {
+			tx_buf = (u8 *)cmds[fod_lhbm_white_cfg->update_index].msg.tx_buf;
+			tx_len = cmds[fod_lhbm_white_cfg->update_index].msg.tx_len;
+			param_len = min(sizeof(fod_lhbm_white_cfg->fod_lhbm_white_param), tx_len - 1);
+			memcpy(&tx_buf[1], fod_lhbm_white_cfg->fod_lhbm_white_param, param_len);
+			fod_lhbm_white_cfg->update_done = true;
+		} else {
+			pr_err("please check %dhz mi,mdss-dsi-fod-lhbm-white-command update parameter index configuration\n", mode->timing.refresh_rate);
+			retval = -EAGAIN;
+			goto error;
+		}
+	}
+
+error:
+	return retval;
+}
+
+int mi_dsi_panel_read_and_update_lhbm_green_500nit_param(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct fod_lhbm_green_500nit_cfg * fod_lhbm_green_500nit_cfg;
+	struct dsi_read_config fod_lhbm_green_500nit_read;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	int i;
+	struct dsi_display *display = to_dsi_display(panel->host);
+	struct dsi_display_mode *mode;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info ||!display) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	if (!panel->mi_cfg.fod_lhbm_green_500nit_update_flag) {
+		pr_debug("[%s] fod_lhbm_green_500nit_update_flag is not configed\n", panel->type);
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	fod_lhbm_green_500nit_cfg = &panel->mi_cfg.fod_lhbm_green_500nit_cfg;
+
+	if (fod_lhbm_green_500nit_cfg->update_done) {
+		pr_debug("fod lhbm green 500nit param already updated\n");
+		rc = 0;
+		goto error;
+	}
+
+	if (!panel->panel_initialized) {
+		pr_err("[%s] Panel not initialized\n", panel->type);
+		retval = -EINVAL;
+		goto error;
+	}
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT_READ_REG_PRE);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT_READ_REG_PRE command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT_READ_REG];
+	fod_lhbm_green_500nit_read.read_cmd = *cmd_set;
+	fod_lhbm_green_500nit_read.cmds_rlen = sizeof(fod_lhbm_green_500nit_cfg->fod_lhbm_green_500nit_param);
+	fod_lhbm_green_500nit_read.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &fod_lhbm_green_500nit_read);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read gir, rc=%d\n", panel->name, rc);
+		retval = -EAGAIN;
+		goto error;
+	} else {
+		memcpy(fod_lhbm_green_500nit_cfg->fod_lhbm_green_500nit_param, fod_lhbm_green_500nit_read.rbuf, sizeof(fod_lhbm_green_500nit_cfg->fod_lhbm_green_500nit_param));
+	}
+
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT].cmds;
+		count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT].count;
+		if (cmds && count >= fod_lhbm_green_500nit_cfg->update_index) {
+			tx_buf = (u8 *)cmds[fod_lhbm_green_500nit_cfg->update_index].msg.tx_buf;
+			tx_len = cmds[fod_lhbm_green_500nit_cfg->update_index].msg.tx_len;
+			param_len = min(sizeof(fod_lhbm_green_500nit_cfg->fod_lhbm_green_500nit_param), tx_len - 1);
+			memcpy(&tx_buf[3], fod_lhbm_green_500nit_cfg->fod_lhbm_green_500nit_param, param_len);
+			fod_lhbm_green_500nit_cfg->update_done = true;
+		} else {
+			pr_err("please check %dhz mi,mdss-dsi-fod-lhbm-green-500nit-command update parameter index configuration\n", mode->timing.refresh_rate);
+			retval = -EAGAIN;
+			goto error;
+		}
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int mi_dsi_panel_read_and_update_gir_param(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct gir_cfg * gir_cfg;
+	struct dsi_read_config gir_read;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	int i,j;
+	struct dsi_display *display = to_dsi_display(panel->host);
+	struct dsi_display_mode *mode;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+	int gir_update_index;
+	int gir_read_num = 1;
+	enum dsi_cmd_set_type gir_pre_read[2] = {DSI_CMD_SET_MI_GIR_READ_REG_PRE, DSI_CMD_SET_MI_GIR_OFF_READ_REG_PRE};
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info ||!display) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	if (!panel->mi_cfg.gir_update_flag) {
+		pr_debug("[%s] dc_update_flag is not configed\n", panel->type);
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	gir_cfg = &panel->mi_cfg.gir_cfg;
+
+	if (gir_cfg->update_done) {
+		pr_debug("gir param already updated\n");
+		rc = 0;
+		goto error;
+	}
+
+	if (!panel->panel_initialized) {
+		pr_err("[%s] Panel not initialized\n", panel->type);
+		retval = -EINVAL;
+		goto error;
+	}
+
+	if (panel->mi_cfg.panel_id == 0x4C440100420200) {
+		gir_read_num = 2;
+	}
+
+	for (i = 0; i < gir_read_num; i++) {
+		rc = dsi_panel_tx_cmd_set(panel, gir_pre_read[i]);
+		if (rc) {
+			pr_err("Failed to send DSI_CMD_SET_MI_FLAT_MODE_READ_REG_PRE command\n");
+			retval = -EAGAIN;
+			goto error;
+		}
+
+		priv_info = panel->cur_mode->priv_info;
+		cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_GIR_READ_REG];
+		gir_read.read_cmd = *cmd_set;
+		gir_read.cmds_rlen = sizeof(gir_cfg->gir_param);
+		gir_read.is_read = 1;
+
+		rc = dsi_panel_read_cmd_set(panel, &gir_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read gir, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			memcpy(gir_cfg->gir_param, gir_read.rbuf, sizeof(gir_cfg->gir_param));
+		}
+
+		total_modes = panel->num_display_modes;
+		for (j = 0; j < total_modes; j++) {
+			gir_update_index = gir_cfg->update_index;
+			mode = &display->modes[j];
+			if (1 == j && gir_cfg->update_index2 > 0 && panel->mi_cfg.panel_id == 0x4C440100420200) {
+				gir_update_index = gir_cfg->update_index2;
+			}
+			if (i == 0) {
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GIR_ON].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GIR_ON].count;
+			} else if (i == 1) {
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GIR_OFF].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_GIR_OFF].count;
+			}
+			if (cmds && count >= gir_update_index) {
+				tx_buf = (u8 *)cmds[gir_update_index].msg.tx_buf;
+				tx_len = cmds[gir_update_index].msg.tx_len;
+				param_len = min(sizeof(gir_cfg->gir_param), tx_len - 1);
+				memcpy(&tx_buf[1], gir_cfg->gir_param, param_len);
+				gir_cfg->update_done = true;
+			} else {
+				pr_err("please check %dhz gir on update parameter index configuration\n", mode->timing.refresh_rate);
+				retval = -EAGAIN;
+				goto error;
+			}
+		}
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int mi_dsi_panel_read_and_update_dc_param_v2(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_read_config dc_read;
+	struct dc_cfg_v2 *dc_cfg[DC_LUT_MAX];
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	int i, j;
+	struct dsi_display *display = to_dsi_display(panel->host);
+	struct dsi_display_mode *mode;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info ||!display) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	if (!panel->mi_cfg.dc_update_flag_v2) {
+		pr_debug("dc_update_flag is not configed\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SWITCH_PAGE4);
+	if (rc) {
+		pr_err("Failed to send DSI_CMD_SET_MI_SWITCH_PAGE4 command\n");
+		retval = -EAGAIN;
+		goto error;
+	}
+
+	dc_cfg[DC_LUT_D2] = &panel->mi_cfg.dc_cfg_v2[DC_LUT_D2];
+	if (dc_cfg[DC_LUT_D2]->update_dc_on_reg_index != -1) {
+		priv_info = panel->cur_mode->priv_info;
+		cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_DC_READ_D2];
+		dc_read.read_cmd = *cmd_set;
+		dc_read.cmds_rlen = sizeof(dc_cfg[DC_LUT_D2]->exit_dc_lut);
+		dc_read.is_read = 1;
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			memcpy(dc_cfg[DC_LUT_D2]->exit_dc_lut, dc_read.rbuf, sizeof(dc_cfg[DC_LUT_D2]->exit_dc_lut));
+			dc_cfg[DC_LUT_D2]->read_done = true;
+		}
+
+		for (i = 0; i < sizeof(dc_cfg[DC_LUT_D2]->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5) ; j++) {
+				if (j < ((i + 1) * 5 - 2))
+					dc_cfg[DC_LUT_D2]->enter_dc_lut[j] = dc_cfg[DC_LUT_D2]->exit_dc_lut[(i + 1) * 5 -3];
+				else
+					dc_cfg[DC_LUT_D2]->enter_dc_lut[j] = dc_cfg[DC_LUT_D2]->exit_dc_lut[j];
+			}
+		}
+	}
+	dc_cfg[DC_LUT_D4] = &panel->mi_cfg.dc_cfg_v2[DC_LUT_D4];
+	if (dc_cfg[DC_LUT_D4]->update_dc_on_reg_index != -1) {
+		priv_info = panel->cur_mode->priv_info;
+		cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_DC_READ_D4];
+		dc_read.read_cmd = *cmd_set;
+		dc_read.cmds_rlen = sizeof(dc_cfg[DC_LUT_D4]->exit_dc_lut);
+		dc_read.is_read = 1;
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			memcpy(dc_cfg[DC_LUT_D4]->exit_dc_lut, dc_read.rbuf, sizeof(dc_cfg[DC_LUT_D4]->exit_dc_lut));
+		}
+
+		for (i = 0; i < sizeof(dc_cfg[DC_LUT_D4]->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5) ; j++) {
+				if (j < ((i + 1) * 5 - 2))
+					dc_cfg[DC_LUT_D4]->enter_dc_lut[j] = dc_cfg[DC_LUT_D4]->exit_dc_lut[(i + 1) * 5 -3];
+				else
+					dc_cfg[DC_LUT_D4]->enter_dc_lut[j] = dc_cfg[DC_LUT_D4]->exit_dc_lut[j];
+			}
+		}
+	}
+
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+
+		cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].cmds;
+		count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].count;
+		if (dc_cfg[DC_LUT_D2]->read_done) {
+			if (cmds && count >= dc_cfg[DC_LUT_D2]->update_dc_off_reg_index) {
+				tx_buf = (u8 *)cmds[dc_cfg[DC_LUT_D2]->update_dc_off_reg_index].msg.tx_buf;
+				tx_len = cmds[dc_cfg[DC_LUT_D2]->update_dc_off_reg_index].msg.tx_len;
+				param_len = min(sizeof(dc_cfg[DC_LUT_D2]->exit_dc_lut), tx_len - 1);
+				memcpy(&tx_buf[1], dc_cfg[DC_LUT_D2]->exit_dc_lut, param_len);
+			} else {
+				pr_info("please check %dhz dc off update parameter d2 index configuration\n", mode->timing.refresh_rate);
+				continue;
+			}
+		}
+		if (dc_cfg[DC_LUT_D4]->read_done) {
+			if (cmds && count >= dc_cfg[DC_LUT_D4]->update_dc_off_reg_index) {
+				tx_buf = (u8 *)cmds[dc_cfg[DC_LUT_D4]->update_dc_off_reg_index].msg.tx_buf;
+				tx_len = cmds[dc_cfg[DC_LUT_D4]->update_dc_off_reg_index].msg.tx_len;
+				param_len = min(sizeof(dc_cfg[DC_LUT_D4]->exit_dc_lut), tx_len - 1);
+				memcpy(&tx_buf[1], dc_cfg[DC_LUT_D4]->exit_dc_lut, param_len);
+			} else {
+				pr_info("please check %dhz dc off update parameter d4 index configuration\n", mode->timing.refresh_rate);
+				continue;
+			}
+		}
+
+		cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].cmds;
+		count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].count;
+		if (dc_cfg[DC_LUT_D2]->read_done) {
+			if (cmds && count >= dc_cfg[DC_LUT_D2]->update_dc_on_reg_index) {
+				tx_buf = (u8 *)cmds[dc_cfg[DC_LUT_D2]->update_dc_on_reg_index].msg.tx_buf;
+				tx_len = cmds[dc_cfg[DC_LUT_D2]->update_dc_on_reg_index].msg.tx_len;
+				param_len = min(sizeof(dc_cfg[DC_LUT_D2]->enter_dc_lut), tx_len - 1);
+				memcpy(&tx_buf[1], dc_cfg[DC_LUT_D2]->enter_dc_lut, param_len);
+			} else {
+				pr_info("please check %dhz dc on update parameter d2 index configuration\n",mode->timing.refresh_rate);
+				continue;
+			}
+		}
+		if (dc_cfg[DC_LUT_D4]->read_done) {
+			if (cmds &&  count >= dc_cfg[DC_LUT_D4]->update_dc_on_reg_index) {
+				tx_buf = (u8 *)cmds[dc_cfg[DC_LUT_D4]->update_dc_on_reg_index].msg.tx_buf;
+				tx_len = cmds[dc_cfg[DC_LUT_D4]->update_dc_on_reg_index].msg.tx_len;
+				param_len = min(sizeof(dc_cfg[DC_LUT_D4]->enter_dc_lut), tx_len - 1);
+				memcpy(&tx_buf[1], dc_cfg[DC_LUT_D4]->enter_dc_lut, param_len);
+			} else {
+				pr_info("please check %dhz dc on update parameter d4 index configuration\n",mode->timing.refresh_rate);
+				continue;
+			}
+		}
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_read_dc_param(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int retval = 0;
+	struct dsi_read_config dc_read;
+	struct dc_cfg *dc_cfg;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+	int i, j;
+	int retry_cnt = 0;
+	u32 checksum1 = 0, checksum2 = 0;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	dc_cfg = &panel->mi_cfg.dc_cfg;
+	if (!panel->mi_cfg.dc_update_flag) {
+		pr_debug("dc_update_flag is not configed\n");
+		return 0;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	for (retry_cnt = 0; retry_cnt < 5; retry_cnt++) {
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SWITCH_PAGE4);
+		if (rc) {
+			pr_err("Failed to send DSI_CMD_SET_MI_SWITCH_PAGE4 command\n");
+			retval = -EAGAIN;
+			goto error;
+		}
+
+		priv_info = panel->cur_mode->priv_info;
+		cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_DC_READ];
+		dc_read.read_cmd = *cmd_set;
+		dc_read.cmds_rlen = sizeof(dc_cfg->exit_dc_lut);
+		dc_read.is_read = 1;
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			memcpy(dc_cfg->exit_dc_lut, dc_read.rbuf, sizeof(dc_cfg->exit_dc_lut));
+			for(i = 0; i < sizeof(dc_cfg->exit_dc_lut); i++)
+				checksum1 += dc_cfg->exit_dc_lut[i];
+		}
+
+		rc = dsi_panel_read_cmd_set(panel, &dc_read);
+		if (rc <= 0) {
+			pr_err("[%s]failed to read dc, rc=%d\n", panel->name, rc);
+			retval = -EAGAIN;
+			goto error;
+		} else {
+			for(i = 0; i < sizeof(dc_cfg->exit_dc_lut); i++)
+				checksum2 += dc_read.rbuf[i];
+		}
+
+		if (checksum1 == checksum2) {
+			dc_cfg->read_done = true;
+			break;
+		}
+	}
+
+	if (dc_cfg->read_done && (panel->mi_cfg.panel_id) != 0x4A315300420202) {
+		for (i = 0; i < sizeof(dc_cfg->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5) ; j++) {
+				dc_cfg->enter_dc_lut[j] = dc_cfg->exit_dc_lut[(i + 1) * 5 -1];
+			}
+		}
+		pr_info("[%s]DC parameter read done\n", panel->name);
+		retval = 0;
+	} else if ((panel->mi_cfg.panel_id) == 0x4A315300420202) {
+		for (i = 0; i < sizeof(dc_cfg->enter_dc_lut)/5; i++) {
+			for (j = i * 5; j < ((i + 1) * 5 - 1) ; j++) {
+				dc_cfg->enter_dc_lut[j] = dc_cfg->exit_dc_lut[(i + 1) * 5 -1];
+			}
+		}
+		pr_info("[%s]DC parameter read done\n", panel->name);
+		retval = 0;
+	} else {
+		pr_err("Failed to read DC parameter\n");
+		retval = -EAGAIN;
+	}
+
+error:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+int dsi_panel_update_dc_param(struct dsi_panel *panel)
+{
+	struct dsi_display *display;
+	struct dsi_display_mode *mode;
+	struct dc_cfg *dc_cfg;
+	struct dsi_cmd_desc *cmds;
+	int total_modes;
+	u32 i, count;
+	u8 *tx_buf;
+	size_t tx_len;
+	u32 param_len;
+	int rc;
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (!display)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.dc_update_flag) {
+		pr_debug("dc_update_flag is not configed\n");
+		return 0;
+	}
+
+	dc_cfg = &panel->mi_cfg.dc_cfg;
+	if (!dc_cfg->read_done) {
+		pr_err("DC parameter not ready\n");
+		return -EAGAIN;
+	}
+
+	if (!display->modes) {
+		rc = dsi_display_get_modes(display, &mode);
+		if (rc) {
+			pr_err("failed to get display mode for update gamma parameter\n");
+			return rc;
+		}
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	total_modes = panel->num_display_modes;
+	for (i = 0; i < total_modes; i++) {
+		mode = &display->modes[i];
+		if (mode && mode->priv_info) {
+			// J1S only update 120Hz fps DC mode parameter
+			if ((panel->mi_cfg.panel_id >> 8) == 0x4A3153004202) {
+				if (120 == mode->timing.refresh_rate ) {
+					cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].cmds;
+					count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].count;
+					if (cmds && count >= dc_cfg->update_d2_index) {
+						tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+						tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+						param_len = min(sizeof(dc_cfg->exit_dc_lut), tx_len - 1);
+						memcpy(&tx_buf[1], dc_cfg->exit_dc_lut, param_len);
+					} else {
+						pr_err("please check dc update parameter index configuration\n");
+					}
+
+					cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].cmds;
+					count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].count;
+					if (cmds && count >= dc_cfg->update_d2_index) {
+						tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+						tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+						param_len = min(sizeof(dc_cfg->enter_dc_lut), tx_len - 1);
+						memcpy(&tx_buf[1], dc_cfg->enter_dc_lut, param_len);
+					} else {
+						pr_err("please check dc update parameter index configuration\n");
+					}
+				}
+			} else {
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_OFF].count;
+				if (cmds && count >= dc_cfg->update_d2_index) {
+					tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+					tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+					param_len = min(sizeof(dc_cfg->exit_dc_lut), tx_len - 1);
+					memcpy(&tx_buf[1], dc_cfg->exit_dc_lut, param_len);
+				} else {
+					pr_err("please check dc update parameter index configuration\n");
+				}
+
+				cmds = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].cmds;
+				count = mode->priv_info->cmd_sets[DSI_CMD_SET_MI_DC_ON].count;
+				if (cmds && count >= dc_cfg->update_d2_index) {
+					tx_buf = (u8 *)cmds[dc_cfg->update_d2_index].msg.tx_buf;
+					tx_len = cmds[dc_cfg->update_d2_index].msg.tx_len;
+					param_len = min(sizeof(dc_cfg->enter_dc_lut), tx_len - 1);
+					memcpy(&tx_buf[1], dc_cfg->enter_dc_lut, param_len);
+				} else {
+					pr_err("please check dc update parameter index configuration\n");
+				}
+			}
+		}
+	}
+	dc_cfg->update_done = true;
+
+	mutex_unlock(&panel->panel_lock);
+
+	return 0;
+}
+
+int dsi_panel_switch_disp_rate_gpio(struct dsi_panel *panel)
+{
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display_mode *mode;
+
+	if (!panel || !panel->cur_mode)
+		return -EINVAL;
+
+	mi_cfg = &panel->mi_cfg;
+	mode = panel->cur_mode;
+
+	if (gpio_is_valid(mi_cfg->disp_rate_gpio)) {
+		if (60 == mode->timing.refresh_rate) {
+			gpio_set_value(mi_cfg->disp_rate_gpio, 1);
+		} else if (90 == mode->timing.refresh_rate) {
+			gpio_set_value(mi_cfg->disp_rate_gpio, 1);
+		} else {
+			pr_info("disp_rate gpio not change\n");
+		}
+	}
+	return 0;
+}
+
+int dsi_panel_write_gamma_cmd_set(struct dsi_panel *panel,
+				enum dsi_gamma_cmd_set_type type)
+{
+	int rc = 0, i = 0;
+	ssize_t len;
+	struct dsi_cmd_desc *cmds;
+	u32 count;
+	enum dsi_cmd_set_state state;
+	const struct mipi_dsi_host_ops *ops = panel->host->ops;
+
+	if (!panel)
+		return -EINVAL;
+
+	if (!panel->mi_cfg.gamma_update_flag) {
+		pr_err("gamma_update_flag is not configed\n");
+		return 0;
+	}
+
+	if (!panel->mi_cfg.gamma_cfg.update_done_60hz ||
+		!panel->mi_cfg.gamma_cfg.update_done_90hz) {
+		pr_err("gamma parameter not update\n");
+		return 0;
+	}
+
+	cmds = gamma_cmd_set[type].cmds;
+	count = gamma_cmd_set[type].count;
+	state = gamma_cmd_set[type].state;
+
+	if (!cmds || count == 0) {
+		pr_debug("[%s] No commands to be sent for state\n", panel->name);
+		goto error;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (state == DSI_CMD_SET_STATE_LP)
+			cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+
+		if (cmds->last_command)
+			cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+
+		len = ops->transfer(panel->host, &cmds->msg);
+		if (len < 0) {
+			rc = len;
+			pr_err("failed to set cmds, rc=%d\n", rc);
+			goto error;
+		}
+		if (cmds->post_wait_ms)
+			usleep_range(cmds->post_wait_ms * 1000,
+					((cmds->post_wait_ms * 1000) + 10));
+		cmds++;
+	}
+error:
+	return rc;
+}
+
+int dsi_panel_write_cmd_set(struct dsi_panel *panel,
+				struct dsi_panel_cmd_set *cmd_sets)
+{
+	int rc = 0, i = 0;
+	ssize_t len;
+	struct dsi_cmd_desc *cmds;
+	u32 count;
+	enum dsi_cmd_set_state state;
+	struct dsi_display_mode *mode;
+	const struct mipi_dsi_host_ops *ops = panel->host->ops;
+
+	if (!panel || !panel->cur_mode)
+		return -EINVAL;
+
+	mode = panel->cur_mode;
+
+	cmds = cmd_sets->cmds;
+	count = cmd_sets->count;
+	state = cmd_sets->state;
+
+	if (count == 0) {
+		pr_debug("[%s] No commands to be sent for state\n", panel->name);
+		goto error;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (state == DSI_CMD_SET_STATE_LP)
+			cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+
+		if (cmds->last_command)
+			cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+
+		len = ops->transfer(panel->host, &cmds->msg);
+		if (len < 0) {
+			rc = len;
+			pr_err("failed to set cmds, rc=%d\n", rc);
+			goto error;
+		}
+		if (cmds->post_wait_ms)
+			usleep_range(cmds->post_wait_ms * 1000,
+					((cmds->post_wait_ms * 1000) + 10));
+		cmds++;
+	}
+error:
+	return rc;
+}
+
+int dsi_panel_read_cmd_set(struct dsi_panel *panel,
+				struct dsi_read_config *read_config)
+{
+	struct mipi_dsi_host *host;
+	struct dsi_display *display;
+	struct dsi_display_ctrl *ctrl;
+	struct dsi_cmd_desc *cmds;
+	enum dsi_cmd_set_state state;
+	int i, rc = 0, count = 0;
+	u32 flags = 0;
+
+	if (panel == NULL || read_config == NULL)
+		return -EINVAL;
+
+	host = panel->host;
+	if (host) {
+		display = to_dsi_display(host);
+		if (display == NULL)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	if (!panel->panel_initialized) {
+		pr_info("Panel not initialized\n");
+		return -EINVAL;
+	}
+
+	if (!read_config->is_read) {
+		pr_info("read operation was not permitted\n");
+		return -EPERM;
+	}
+
+	dsi_display_clk_ctrl(display->dsi_clk_handle,
+		DSI_ALL_CLKS, DSI_CLK_ON);
+
+	ctrl = &display->ctrl[display->cmd_master_idx];
+
+	rc = dsi_display_cmd_engine_enable(display);
+	if (rc) {
+		pr_err("cmd engine enable failed\n");
+		rc = -EPERM;
+		goto exit_ctrl;
+	}
+
+	if (display->tx_cmd_buf == NULL) {
+		rc = dsi_host_alloc_cmd_tx_buffer(display);
+		if (rc) {
+			pr_err("failed to allocate cmd tx buffer memory\n");
+			goto exit;
+		}
+	}
+
+	count = read_config->read_cmd.count;
+	cmds = read_config->read_cmd.cmds;
+	state = read_config->read_cmd.state;
+	if (count == 0) {
+		pr_err("No commands to be sent\n");
+		goto exit;
+	}
+	if (cmds->last_command) {
+		cmds->msg.flags |= MIPI_DSI_MSG_LASTCOMMAND;
+		flags |= DSI_CTRL_CMD_LAST_COMMAND;
+	}
+	if (state == DSI_CMD_SET_STATE_LP)
+		cmds->msg.flags |= MIPI_DSI_MSG_USE_LPM;
+	flags |= (DSI_CTRL_CMD_FETCH_MEMORY | DSI_CTRL_CMD_READ |
+		  DSI_CTRL_CMD_CUSTOM_DMA_SCHED);
+
+	memset(read_config->rbuf, 0x0, sizeof(read_config->rbuf));
+	cmds->msg.rx_buf = read_config->rbuf;
+	cmds->msg.rx_len = read_config->cmds_rlen;
+
+	rc = dsi_ctrl_cmd_transfer(ctrl->ctrl, &(cmds->msg), &flags);
+	if (rc <= 0) {
+		pr_err("rx cmd transfer failed rc=%d\n", rc);
+		goto exit;
+	}
+
+	/* for debug log */
+	for (i = 0; i < read_config->cmds_rlen; i++)
+		pr_debug("[%d] = 0x%02X\n", i, read_config->rbuf[i]);
+
+exit:
+	dsi_display_cmd_engine_disable(display);
+exit_ctrl:
+	dsi_display_clk_ctrl(display->dsi_clk_handle,
+		DSI_ALL_CLKS, DSI_CLK_OFF);
+
+	return rc;
+}
+
+int dsi_panel_write_mipi_reg(struct dsi_panel *panel,
+				char *buf)
+{
+	struct dsi_panel_cmd_set cmd_sets = {0};
+	int retval = 0, dlen = 0;
+	u32 packet_count = 0;
+	char *token, *input_copy, *input_dup = NULL;
+	const char *delim = " ";
+	char *buffer = NULL;
+	u32 buf_size = 0;
+	u32 tmp_data = 0;
+
+	mutex_lock(&panel->panel_lock);
+
+	if (!panel || !panel->panel_initialized) {
+		pr_err("Panel not initialized!\n");
+		retval = -EAGAIN;
+		goto exit_unlock;
+	}
+
+	pr_debug("input buffer:{%s}\n", buf);
+
+	input_copy = kstrdup(buf, GFP_KERNEL);
+	if (!input_copy) {
+		retval = -ENOMEM;
+		goto exit_unlock;
+	}
+
+	input_dup = input_copy;
+	/* removes leading and trailing whitespace from input_copy */
+	input_copy = strim(input_copy);
+
+	/* Split a string into token */
+	token = strsep(&input_copy, delim);
+	if (token) {
+		retval = kstrtoint(token, 10, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free0;
+		}
+		g_dsi_read_cfg.is_read= !!tmp_data;
+	}
+
+	/* Removes leading whitespace from input_copy */
+	if (input_copy)
+		input_copy = skip_spaces(input_copy);
+	else
+		goto exit_free0;
+
+	token = strsep(&input_copy, delim);
+	if (token) {
+		retval = kstrtoint(token, 10, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free0;
+		}
+		if (tmp_data > sizeof(g_dsi_read_cfg.rbuf)) {
+			pr_err("read size exceeding the limit %d\n",
+					sizeof(g_dsi_read_cfg.rbuf));
+			goto exit_free0;
+		}
+		g_dsi_read_cfg.cmds_rlen = tmp_data;
+	}
+
+	/* Removes leading whitespace from input_copy */
+	if (input_copy)
+		input_copy = skip_spaces(input_copy);
+	else
+		goto exit_free0;
+
+	buffer = kzalloc(strlen(input_copy), GFP_KERNEL);
+	if (!buffer) {
+		retval = -ENOMEM;
+		goto exit_free0;
+	}
+
+	token = strsep(&input_copy, delim);
+	while (token) {
+		retval = kstrtoint(token, 16, &tmp_data);
+		if (retval) {
+			pr_err("input buffer conversion failed\n");
+			goto exit_free1;
+		}
+		pr_debug("buffer[%d] = 0x%02x\n", buf_size, tmp_data);
+		buffer[buf_size++] = (tmp_data & 0xff);
+		/* Removes leading whitespace from input_copy */
+		if (input_copy) {
+			input_copy = skip_spaces(input_copy);
+			token = strsep(&input_copy, delim);
+		} else {
+			token = NULL;
+		}
+	}
+
+	retval = dsi_panel_get_cmd_pkt_count(buffer, buf_size, &packet_count);
+	if (!packet_count) {
+		pr_err("get pkt count failed!\n");
+		goto exit_free1;
+	}
+
+	retval = dsi_panel_alloc_cmd_packets(&cmd_sets, packet_count);
+	if (retval) {
+		pr_err("failed to allocate cmd packets, ret=%d\n", retval);
+		goto exit_free1;
+	}
+
+	retval = dsi_panel_create_cmd_packets(buffer, dlen, packet_count,
+						  cmd_sets.cmds);
+	if (retval) {
+		pr_err("failed to create cmd packets, ret=%d\n", retval);
+		goto exit_free2;
+	}
+
+	if (g_dsi_read_cfg.is_read) {
+		g_dsi_read_cfg.read_cmd = cmd_sets;
+		retval = dsi_panel_read_cmd_set(panel, &g_dsi_read_cfg);
+		if (retval <= 0) {
+			pr_err("[%s]failed to read cmds, rc=%d\n", panel->name, retval);
+			goto exit_free3;
+		}
+	} else {
+		g_dsi_read_cfg.read_cmd = cmd_sets;
+		retval = dsi_panel_write_cmd_set(panel, &cmd_sets);
+		if (retval) {
+			pr_err("[%s] failed to send cmds, rc=%d\n", panel->name, retval);
+			goto exit_free3;
+		}
+	}
+
+	pr_debug("[%s]: done!\n", panel->name);
+	retval = 0;
+
+exit_free3:
+	dsi_panel_destroy_cmd_packets(&cmd_sets);
+exit_free2:
+	dsi_panel_dealloc_cmd_packets(&cmd_sets);
+exit_free1:
+	kfree(buffer);
+exit_free0:
+	kfree(input_dup);
+exit_unlock:
+	mutex_unlock(&panel->panel_lock);
+	return retval;
+}
+
+ssize_t dsi_panel_read_mipi_reg(struct dsi_panel *panel, char *buf)
+{
+	int i = 0;
+	ssize_t count = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	if (g_dsi_read_cfg.is_read) {
+		for (i = 0; i < g_dsi_read_cfg.cmds_rlen; i++) {
+			if (i == g_dsi_read_cfg.cmds_rlen - 1) {
+				count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X\n",
+				     g_dsi_read_cfg.rbuf[i]);
+			} else {
+				count += snprintf(buf + count, PAGE_SIZE - count, "0x%02X,",
+				     g_dsi_read_cfg.rbuf[i]);
+			}
+		}
+	}
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+ssize_t dsi_panel_read_wp_info(struct dsi_panel *panel, char *buf)
+{
+	int rc = 0;
+	int i = 0;
+	ssize_t count = 0;
+	struct dsi_read_config wp_read_config;
+	struct dsi_panel_cmd_set *cmd_set;
+	struct dsi_display_mode_priv_info *priv_info;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EAGAIN;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	priv_info = panel->cur_mode->priv_info;
+	cmd_set = &priv_info->cmd_sets[DSI_CMD_SET_MI_WHITE_POINT_READ];
+	wp_read_config.read_cmd = *cmd_set;
+	wp_read_config.cmds_rlen = panel->mi_cfg.wp_reg_read_len;
+	wp_read_config.is_read = 1;
+
+	rc = dsi_panel_read_cmd_set(panel, &wp_read_config);
+	if (rc <= 0) {
+		pr_err("[%s]failed to read wp_info, rc=%d\n", panel->name, rc);
+		count = -EAGAIN;
+	} else {
+		for (i = 0; i < panel->mi_cfg.wp_info_len; i++) {
+			if (i == panel->mi_cfg.wp_info_len - 1) {
+				count += snprintf(buf + count, PAGE_SIZE - count, "%02x\n",
+					 wp_read_config.rbuf[panel->mi_cfg.wp_info_index + i]);
+			} else {
+				count += snprintf(buf + count, PAGE_SIZE - count, "%02x",
+					wp_read_config.rbuf[panel->mi_cfg.wp_info_index + i]);
+			}
+		}
+	}
+
+	mutex_unlock(&panel->panel_lock);
+
+	return count;
+}
+
+int dsi_panel_set_doze_brightness(struct dsi_panel *panel,
+			int doze_brightness, bool need_panel_lock)
+{
+	int rc = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_display *display;
+	int cmd_type = DSI_CMD_SET_MAX;
+
+	if (!panel || !panel->host) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	display = to_dsi_display(panel->host);
+	if (!display || !display->drm_dev){
+		pr_err("invalid display or drm_dev ptr\n");
+		return -EINVAL;
+	}
+
+	if (need_panel_lock)
+		mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+
+	if (!mi_cfg || (doze_brightness >= DOZE_BRIGHTNESS_MAX)) {
+		pr_err("mi_cfg is null or doze_brightness %s\n", get_doze_brightness_name(doze_brightness));
+		goto exit;
+	}
+
+	if (!panel->panel_initialized) {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		pr_info("Panel not initialized! save unset_doze_brightness = %s\n",
+				get_doze_brightness_name(mi_cfg->unset_doze_brightness));
+		goto exit;
+	}
+
+	if (mi_cfg->fod_hbm_enabled || mi_cfg->local_hbm_cur_status) {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		pr_info("fod_hbm_enabled/local_hbm_cur_status set, save unset_doze_brightness = %s\n",
+			get_doze_brightness_name(mi_cfg->unset_doze_brightness));
+		if (mi_cfg->unset_doze_brightness == DOZE_TO_NORMAL) {
+			mi_cfg->doze_brightness_state = DOZE_TO_NORMAL;
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+			if (display->drm_conn && display->drm_conn->kdev)
+				sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "doze_brightness");
+		}
+
+		goto exit;
+	}
+
+	if (mi_cfg->in_aod) {
+		if (mi_cfg->doze_brightness_state != doze_brightness ||
+			mi_cfg->unset_doze_brightness != DOZE_TO_NORMAL) {
+			if (mi_cfg->into_aod_pending &&
+				!mi_cfg->layer_aod_flag &&
+				doze_brightness != DOZE_TO_NORMAL) {
+				/* After unlocking the fingerprint, request to enter aod mode,
+				 *but there is no aod layer, skip to set doze brightness */
+				pr_info("aod layer is not ready, skip to set doze brightness\n");
+				rc = -EAGAIN;
+			} else {
+				if (panel->mi_cfg.panel_id == 0x4C334100420200 || mi_cfg->fod_skip_nolp) {
+					if (doze_brightness == DOZE_BRIGHTNESS_HBM) {
+						cmd_type = DSI_CMD_SET_MI_DOZE_HBM;
+						mi_cfg->aod_backlight = 170;
+					} else if (doze_brightness == DOZE_BRIGHTNESS_LBM) {
+						cmd_type = DSI_CMD_SET_MI_DOZE_LBM;
+						mi_cfg->aod_backlight = 10;
+					}
+				} else {
+					if (doze_brightness == DOZE_BRIGHTNESS_HBM ||
+						mi_cfg->unset_doze_brightness == DOZE_BRIGHTNESS_HBM) {
+						cmd_type = DSI_CMD_SET_MI_DOZE_HBM;
+						mi_cfg->aod_backlight = 170;
+					} else if (doze_brightness == DOZE_BRIGHTNESS_LBM ||
+						mi_cfg->unset_doze_brightness == DOZE_BRIGHTNESS_LBM) {
+						cmd_type = DSI_CMD_SET_MI_DOZE_LBM;
+						mi_cfg->aod_backlight = 10;
+					}
+				}
+			}
+			if (cmd_type != DSI_CMD_SET_MAX) {
+				if (sde_kms_is_suspend_blocked(display->drm_dev)) {
+					pr_err("sde_kms is suspended, skip to set doze brightness\n");
+					mi_cfg->unset_doze_brightness = doze_brightness;
+					rc = -EBUSY;
+					goto exit;
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, cmd_type);
+					if (rc) {
+						pr_err("[%s] failed to send DSI_CMD_SET_MI_DOZE_%s cmd, rc=%d\n",
+							panel->name, cmd_type == DSI_CMD_SET_MI_DOZE_HBM ? "HBM" : "LBM", rc);
+					}
+				}
+			}
+
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+			mi_cfg->unset_doze_brightness = DOZE_TO_NORMAL;
+			mi_cfg->doze_brightness_state = doze_brightness;
+			if (display->drm_conn && display->drm_conn->kdev)
+				sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "doze_brightness");
+			pr_info("set doze brightness to %s\n", get_doze_brightness_name(doze_brightness));
+		} else {
+			pr_info("%s has been set, skip\n", get_doze_brightness_name(doze_brightness));
+		}
+	} else {
+		mi_cfg->unset_doze_brightness = doze_brightness;
+		if (mi_cfg->unset_doze_brightness != DOZE_TO_NORMAL)
+			pr_info("Not in Doze mode! save unset_doze_brightness = %s\n",
+					get_doze_brightness_name(doze_brightness));
+	}
+
+exit:
+	if (need_panel_lock)
+		mutex_unlock(&panel->panel_lock);
+
+	return rc;
+}
+
+int dsi_panel_lockdowninfo_param_read(struct dsi_panel *panel)
+{
+	int rc = 0;
+	int i = 0;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	struct dsi_panel_cmd_set *cmd_sets;
+	struct dsi_read_config ld_read_config;
+	struct dsi_panel_cmd_set read_cmd_set = {0};
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	if (!panel->panel_initialized) {
+		pr_err("panel not initialized\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+	cmd_sets = &panel->cur_mode->priv_info->cmd_sets[DSI_CMD_SET_MI_READ_LOCKDOWN_INFO];
+	if (cmd_sets->cmds) {
+		read_cmd_set.cmds = cmd_sets->cmds;
+		read_cmd_set.count = 1;
+		read_cmd_set.state = cmd_sets->state;
+		rc = dsi_panel_write_cmd_set(panel, &read_cmd_set);
+		if (rc) {
+			pr_err("[%s] failed to send cmds, rc=%d\n", panel->name, rc);
+			rc = -EIO;
+			goto done;
+		}
+
+		pr_info("[%s]", panel->name);
+		if (strcmp(panel->name,"xiaomi 42 02 0a video mode dual dsi cphy panel") &&
+			strcmp(panel->name,"xiaomi 35 02 0b video mode dual dsi cphy panel")) {
+
+			ld_read_config.is_read = 1;
+			ld_read_config.cmds_rlen = 8;
+			ld_read_config.read_cmd = read_cmd_set;
+			ld_read_config.read_cmd.cmds = &read_cmd_set.cmds[1];
+			rc = dsi_panel_read_cmd_set(panel, &ld_read_config);
+			if (rc <= 0) {
+				pr_err("[%s] failed to read cmds, rc=%d\n", panel->name, rc);
+				rc = -EIO;
+				goto done;
+			}
+
+			for(i = 0; i < 8; i++) {
+				pr_info("0x%x", ld_read_config.rbuf[i]);
+				mi_cfg->lockdowninfo_read.lockdowninfo[i] = ld_read_config.rbuf[i];
+			}
+
+			if (!strcmp(panel->name,"xiaomi 37 02 0b video mode dsc dsi panel")) {
+				mi_cfg->lockdowninfo_read.lockdowninfo[7] = 0x01;
+				pr_info("plockdowninfo[7] = 0x%d \n",
+					mi_cfg->lockdowninfo_read.lockdowninfo[7]);
+			}
+			mi_cfg->lockdowninfo_read.lockdowninfo_read_done = 1;
+		} else {
+			for(i = 0; i < 8; i++) {
+				ld_read_config.is_read = 1;
+				ld_read_config.cmds_rlen = 1;
+				ld_read_config.read_cmd = read_cmd_set;
+				ld_read_config.read_cmd.cmds = &read_cmd_set.cmds[i+1];
+				rc = dsi_panel_read_cmd_set(panel, &ld_read_config);
+				if (rc <= 0) {
+					pr_err("[%s] failed to read, rc=%d\n", panel->name, rc);
+					rc = -EIO;
+					goto done;
+				}
+
+				pr_info("0x%x", ld_read_config.rbuf[0]);
+				mi_cfg->lockdowninfo_read.lockdowninfo[i] = ld_read_config.rbuf[0];
+			}
+			mi_cfg->lockdowninfo_read.lockdowninfo_read_done = 1;
+
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L3_ON);
+
+		}
+	}
+
+done:
+	mutex_unlock(&panel->panel_lock);
+	return rc;
+
+}
+
+ssize_t dsi_panel_lockdown_info_read(unsigned char *plockdowninfo)
+{
+	int rc = 0;
+	int i = 0;
+	static int count = 0;
+
+	if (!g_panel || !plockdowninfo) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	while(!g_panel->mi_cfg.lockdowninfo_read.lockdowninfo_read_done  && count < 500) {
+		pr_debug("[%s][%s] waitting for panel priv_info initialized!\n", __func__, g_panel->name);
+		msleep_interruptible(1000);
+		count++;
+	}
+
+	for(i = 0; i < 8; i++) {
+		pr_info("0x%x",  g_panel->mi_cfg.lockdowninfo_read.lockdowninfo[i]);
+		plockdowninfo[i] = g_panel->mi_cfg.lockdowninfo_read.lockdowninfo[i];
+	}
+
+	rc = plockdowninfo[0];
+
+	return rc;
+}
+EXPORT_SYMBOL(dsi_panel_lockdown_info_read);
+
+int mi_mipi_dsi_dcs_set_pwm_value(u16 dbv_value)
+{
+	int rc = 0;
+
+	if(!g_panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	rc = mipi_dsi_dcs_set_display_brightness_big_endian(&g_panel->mipi_device, dbv_value);
+	if (rc < 0)
+		pr_err("failed to update pwm value:%d\n", dbv_value);
+
+	return 0;
+}
+EXPORT_SYMBOL(mi_mipi_dsi_dcs_set_pwm_value);
+
+ssize_t dsi_panel_vendor_info_read(unsigned char *plockdowninfo)
+{
+	int rc = 0;
+
+	if (!g_panel || !plockdowninfo) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+	pr_info("[%s]", g_panel->name);
+
+	if (!strcmp(g_panel->name,"xiaomi 42 02 0a video mode dual dsi cphy panel")) {
+		plockdowninfo[0] = 0x53;
+		plockdowninfo[1] = 0x42;
+	} else if (!strcmp(g_panel->name,"xiaomi 35 02 0b video mode dual dsi cphy panel")){
+		plockdowninfo[0] = 0x44;
+		plockdowninfo[1] = 0x35;
+	} else {
+		plockdowninfo[0] = 0xFF;
+		plockdowninfo[1] = 0xFF;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL(dsi_panel_vendor_info_read);
+
+
+void dsi_panel_doubleclick_enable(bool on)
+{
+	g_panel->mi_cfg.tddi_doubleclick_flag = on;
+}
+EXPORT_SYMBOL(dsi_panel_doubleclick_enable);
+
+int dsi_panel_power_turn_off(bool on)
+{
+	int rc = 0;
+	struct pinctrl_state *state;
+
+	if (!g_panel) {
+		pr_err("dsi_panel_power_turn_off invalid params\n");
+		return -EINVAL;
+	}
+
+	if ((g_panel->host_config.phy_type == DSI_PHY_TYPE_CPHY) &&
+		(g_panel->mi_cfg.tddi_doubleclick_flag == true)) {
+			pr_err("dsi_panel_power_turn_off in tddi doubleclick\n");
+	} else {
+		return 0;
+	}
+
+	if (gpio_is_valid(g_panel->reset_config.reset_gpio) &&
+					!g_panel->reset_gpio_always_on)
+		gpio_set_value(g_panel->reset_config.reset_gpio, 0);
+
+	if (gpio_is_valid(g_panel->reset_config.lcd_mode_sel_gpio))
+		gpio_set_value(g_panel->reset_config.lcd_mode_sel_gpio, 0);
+
+
+	state = g_panel->pinctrl.suspend;
+	rc = pinctrl_select_state(g_panel->pinctrl.pinctrl, state);
+	if (rc)
+		DSI_ERR("[%s] failed to set pin state, rc=%d\n",
+				g_panel->name, rc);
+
+	rc = dsi_pwr_enable_regulator(&g_panel->power_info, false);
+	if (rc)
+		pr_err("[%s] failed to enable vregs, rc=%d\n", g_panel->name, rc);
+
+	return rc;
+}
+
+int mi_dsi_panel_set_fod_brightness(struct mipi_dsi_device *dsi, u16 brightness)
+{
+	u8 payload[2] = {(fpr_alpha_set[brightness] >> 8) & 0x0f, fpr_alpha_set[brightness] & 0xff};
+	ssize_t err;
+
+	err = mipi_dsi_dcs_write(dsi, 0x87,
+				 payload, sizeof(payload));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int mi_dsi_update_lhbm_cmd_87reg(struct dsi_panel *panel,
+			enum dsi_cmd_set_type type, int bl_lvl)
+{
+	struct dsi_display_mode_priv_info *priv_info;
+	struct dsi_cmd_desc *cmds = NULL;
+	struct dsi_panel_mi_cfg *mi_cfg  = NULL;
+	u32 count;
+	u32 index;
+	u8 *tx_buf;
+	int rc = 0;
+
+	if (!panel || !panel->cur_mode || !panel->cur_mode->priv_info) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &panel->mi_cfg;
+	priv_info = panel->cur_mode->priv_info;
+
+	switch (type) {
+		case DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT:
+			index = mi_cfg->fod_lhbm_white_1000nit_87reg_index;
+			break;
+		case DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT:
+			index = mi_cfg->fod_lhbm_white_110nit_87reg_index;
+			break;
+		case DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT:
+			index = mi_cfg->fod_lhbm_green_500nit_87reg_index;
+			break;
+		default:
+			pr_err("%s panel wrong cmd type!\n", panel->type);
+			return -EINVAL;
+	}
+
+	pr_info("tpye=%d; bl_lvl=%d; index=%d\n", type, bl_lvl, index);
+
+	cmds = priv_info->cmd_sets[type].cmds;
+	count = priv_info->cmd_sets[type].count;
+	if (cmds && count >= index) {
+		tx_buf = (u8 *)cmds[index].msg.tx_buf;
+		if (tx_buf && tx_buf[0] == 0x87) {
+			tx_buf[1] = (fpr_alpha_set[bl_lvl] >> 8) & 0x0f;
+			tx_buf[2] = fpr_alpha_set[bl_lvl] & 0xff;
+			pr_info("panel fpr cmd[0x%02x] = 0x%02x 0x%02x\n", tx_buf[0], tx_buf[1], tx_buf[2]);
+		} else {
+			if (tx_buf) {
+				pr_err("%s panel fpr index = %d, tx_buf[0] = 0x%02X, check cmd[%d] 0x51 index\n",
+					panel->type, index, tx_buf[0], type);
+			} else {
+				pr_err("%s panel tx_buf is NULL pointer\n", panel->type);
+			}
+			rc = -EINVAL;
+		}
+	} else {
+		pr_err("%s panel fpr cmd[%d] 0x87 index(%d) error\n",
+			panel->type, type, index);
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+bool dsi_panel_is_need_tx_cmd(u32 param)
+{
+	if ((param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_ON
+		|| (param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_OFF
+		|| param != DISPPARAM_FOD_UNLOCK_SUCCESS
+		|| param != DISPPARAM_SET_THERMAL_HBM_DISABLE
+		|| param != DISPPARAM_CLEAR_THERMAL_HBM_DISABLE
+		|| (param & 0x0000F000) != DISPPARAM_LOW_BRIGHTNESS_FOD
+		|| (param & 0x0000F000) != DISPPARAM_FP_STATUS) {
+		return false;
+	}else
+		return true;
+}
+
+int dsi_panel_set_disp_param(struct dsi_panel *panel, u32 param)
+{
+	int rc = 0;
+	uint32_t temp = 0;
+	u32 fod_backlight = 0;
+	struct dsi_panel_mi_cfg *mi_cfg  = NULL;
+	struct dsi_cmd_desc *cmds = NULL;
+	struct dsi_display_mode_priv_info *priv_info;
+	static u8 backlight_delta = 0;
+	u32 resend_backlight;
+	u32 count;
+	u8 *tx_buf;
+	bool is_thermal_call = false;
+	u32 fod_lhbm_level = 0;
+	bool fod_lhbm_low_brightness_enabled = false;
+	bool fod_lhbm_low_brightness_allow = true;
+	u32 fp_status = 0;
+
+	if (!panel) {
+		pr_err("invalid params\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&panel->panel_lock);
+
+	mi_cfg = &panel->mi_cfg;
+	if (!mi_cfg->mi_feature_enabled) {
+		pr_err("mi feature not enable, exit!\n");
+		goto exit;
+	}
+
+	if (!panel->panel_initialized
+		&& (param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_ON
+		&& (param & 0x0F000000) != DISPPARAM_FOD_BACKLIGHT_OFF
+		&& param != DISPPARAM_FOD_UNLOCK_SUCCESS
+		&& param != DISPPARAM_SET_THERMAL_HBM_DISABLE
+		&& param != DISPPARAM_CLEAR_THERMAL_HBM_DISABLE
+		&& (param & 0x0000F000) != DISPPARAM_LOW_BRIGHTNESS_FOD
+		&& (param & 0x0000F000) != DISPPARAM_FP_STATUS) {
+		pr_err("Panel not initialized!\n");
+		goto exit;
+	}
+
+	if ((panel->host_config.phy_type == DSI_PHY_TYPE_CPHY)
+		&& (param & 0x700) && param != 0xF00) {
+			pr_info("save cabc status!\n");
+			panel->mi_cfg.cabc_temp_status = param & 0x700;
+			cancel_delayed_work(&mi_cfg->cabc_delayed_work);
+			pr_info("delayed_work schedule --- delay cabc mode\n");
+			__pm_wakeup_event(mi_cfg->aod_wakelock, DEFAULT_CABC_WRITE_DELAY + 100);
+			schedule_delayed_work(&mi_cfg->cabc_delayed_work, msecs_to_jiffies(DEFAULT_CABC_WRITE_DELAY));
+
+			param = param & 0xFFFFF0FF;
+			if(!param)
+				goto exit;
+	}
+
+	/* cur_mode ptr assignment in dsi_display_set_mode func after open drm node */
+	if (panel->cur_mode)
+		priv_info = panel->cur_mode->priv_info;
+	else
+		priv_info = NULL;
+
+	if ((param & 0x000F0000) == DISPPARAM_HBM_ON) {
+		is_thermal_call = (param & 0x1);
+		param = (param & 0xFFFFFFFE);
+	}
+	if ((param & 0x0000F000) == 0xD000) {
+		fod_lhbm_low_brightness_enabled = (param & 0x1);
+		param = (param & 0xFFFFFFFE);
+	} else if ((param & 0x0000F000) == 0xE000) {
+		fp_status = (param & 0x7);
+		fod_lhbm_low_brightness_allow = (param & 0x8);
+		param = (param & 0xFFFFFFF0);
+       }
+	if ((param & 0x00F00000) == 0xD00000) {
+		fod_backlight = (param & 0x01FFF);
+		param = (param & 0x0FF00000);
+	}
+	if (mi_cfg->local_hbm_enabled) {
+		if ((param & 0x000F0000) == 0x20000) {
+			fod_lhbm_level = (param & 0xF);
+			param = (param & 0xFFFFFFF0);
+		}
+	}
+
+	temp = param & 0x000000F0;
+	switch (temp) {
+	case DISPPARAM_CE_ON:
+		pr_info("ceon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CEON);
+		break;
+	case DISPPARAM_CE_OFF:
+		pr_info("ceoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CEOFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x00000F00;
+	switch (temp) {
+	case DISPPARAM_CABCUI_ON:
+		pr_info("cabcuion\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCUION);
+		break;
+	case DISPPARAM_CABCSTILL_ON:
+		pr_info("cabcstillon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCSTILLON);
+		break;
+	case DISPPARAM_CABCMOVIE_ON:
+		pr_info("cabcmovieon\n");
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCMOVIEON);
+		break;
+	case DISPPARAM_CABC_OFF:
+		pr_info("cabcoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CABCOFF);
+		break;
+	case DISPPARAM_SKIN_CE_CABCUI_ON:
+		pr_info("skince cabcuion\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCUION);
+		break;
+	case DISPPARAM_SKIN_CE_CABCSTILL_ON:
+		pr_info("skince cabcstillon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCSTILLON);
+		break;
+	case DISPPARAM_SKIN_CE_CABCMOVIE_ON:
+		pr_info("skince cabcmovieon\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCMOVIEON);
+		break;
+	case DISPPARAM_SKIN_CE_CABC_OFF:
+		pr_info("skince cabcoff\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SKINCE_CABCOFF);
+		break;
+	case DISPPARAM_DIMMING_OFF:
+		if (mi_cfg->dimming_state != STATE_DIM_BLOCK) {
+			pr_info("dimming off\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+		} else {
+			pr_info("skip dimming off due to hbm on\n");
+		}
+		break;
+	case DISPPARAM_DIMMING:
+		if (mi_cfg->dimming_state != STATE_DIM_BLOCK) {
+			if (ktime_after(ktime_get(), mi_cfg->fod_hbm_off_time)
+				&& ktime_after(ktime_get(), mi_cfg->fod_backlight_off_time)) {
+				pr_info("dimming on\n");
+				dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGON);
+			} else {
+				pr_info("skip dimming on due to hbm off\n");
+			}
+		} else {
+			pr_info("skip dimming on due to hbm on\n");
+		}
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x0000F000;
+	switch (temp) {
+	case DISPPARAM_ACL_L1:
+		pr_info("acl level 1\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L1);
+		break;
+	case DISPPARAM_ACL_L2:
+		pr_info("acl level 2\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L2);
+		break;
+	case DISPPARAM_ACL_L3:
+		pr_info("acl level 3\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_L3);
+		break;
+	case DISPPARAM_ACL_OFF:
+		pr_info("acl off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ACL_OFF);
+		break;
+	case DISPPARAM_LOW_BRIGHTNESS_FOD:
+		pr_info("DISPPARAM_LOW_BRIGHTNESS_FOD=%d\n", fod_lhbm_low_brightness_enabled);
+		mi_cfg->fod_lhbm_low_brightness_enabled = fod_lhbm_low_brightness_enabled;
+		break;
+	case DISPPARAM_FP_STATUS:
+		pr_info("DISPPARAM_FP_STATUS=%d\n", fp_status);
+		pr_info("fod_lhbm_low_brightness_allow=%d\n", fod_lhbm_low_brightness_allow);
+		mi_cfg->fp_status = fp_status;
+		mi_cfg->fod_lhbm_low_brightness_allow = fod_lhbm_low_brightness_allow;
+		if  (fp_status == ENROLL_STOP ||
+				fp_status == AUTH_STOP ||
+				fp_status == HEART_RATE_STOP) {
+			mi_disp_set_fod_queue_work(0, false);
+		}
+		break;
+	case DISPPARAM_ROUND_ON:
+		pr_info("DISPPARAM_ROUND_ON\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ROUND_ON);
+		break;
+	case DISPPARAM_ROUND_OFF:
+		pr_info("DISPPARAM_ROUND_OFF\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ROUND_OFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x000F0000;
+	switch (temp) {
+	case DISPPARAM_LCD_HBM_L1_ON:
+		pr_info("lcd hbm l1 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L1_ON);
+		break;
+	case DISPPARAM_LCD_HBM_L2_ON:
+		pr_info("lcd hbm  l2 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L2_ON);
+		break;
+	case DISPPARAM_LCD_HBM_L3_ON:
+		pr_info("lcd hbm  l3 on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_L3_ON);
+		break;
+	case DISPPARAM_LCD_HBM_OFF:
+		pr_info("lcd hbm off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_DISP_LCD_HBM_OFF);
+		break;
+	case DISPPARAM_HBM_ON:
+		pr_info("hbm on needed, thermal_hbm_disabled = %d, fod_hbm_enabled = %d\n", mi_cfg->thermal_hbm_disabled, mi_cfg->fod_hbm_enabled);
+		mi_cfg->hbm_enabled = true;
+		if (!mi_cfg->fod_hbm_enabled && !mi_cfg->thermal_hbm_disabled) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_ON);
+			pr_info("hbm on\n");
+			if (is_thermal_call) {
+				pr_info("thermal clear hbm limit, restore previous hbm on\n");
+			}
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+
+		}
+		break;
+	case DISPPARAM_HBM_OFF:
+		if (param & DISPPARAM_THERMAL_SET)
+			is_thermal_call = true;
+		pr_info("hbm off needed, thermal_hbm_disabled = %d, fod_hbm_enabled = %d\n", mi_cfg->thermal_hbm_disabled, mi_cfg->fod_hbm_enabled);
+		if (!mi_cfg->fod_hbm_enabled) {
+			if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+				/* restore last backlight value when hbm off */
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_OFF].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_OFF].count;
+				if (cmds && count >= mi_cfg->hbm_off_51_index) {
+					tx_buf = (u8 *)cmds[mi_cfg->hbm_off_51_index].msg.tx_buf;
+					if (tx_buf && tx_buf[0] == 0x51) {
+						tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+						tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+					} else {
+						if (tx_buf)
+							pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+						else
+							pr_err("tx_buf is NULL pointer\n");
+					}
+				} else {
+					pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+				}
+			}
+			if (mi_cfg->vi_setting_enabled) {
+				/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+				if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+				} else {
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+				}
+			}
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_OFF);
+			pr_info("hbm off\n");
+			mi_cfg->dimming_state = STATE_DIM_RESTORE;
+			if (is_thermal_call) {
+				pr_info("thermal set hbm limit, hbm off\n");
+			} else
+				mi_cfg->hbm_enabled = false;
+
+		}
+		break;
+	case DISPPARAM_HBM_HDR_ON:
+		pr_info("hbm hdr on\n");
+		if (!mi_cfg->fod_hbm_enabled && !mi_cfg->thermal_hbm_disabled)
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_HDR_ON);
+		mi_cfg->hbm_enabled = true;
+		mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		break;
+	case DISPPARAM_HBM_HDR_OFF:
+		pr_info("hbm hdr off\n");
+		if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+			/* restore last backlight value when hbm off */
+			cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_HDR_OFF].cmds;
+			count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_HDR_OFF].count;
+			if (cmds && count >= mi_cfg->hbm_off_51_index) {
+				tx_buf = (u8 *)cmds[mi_cfg->hbm_off_51_index].msg.tx_buf;
+				if (tx_buf && tx_buf[0] == 0x51) {
+					tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+					tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+					pr_info("DSI_CMD_SET_MI_HBM_HDR_OFF 0x%02X = 0x%02X 0x%02X\n",
+							tx_buf[0], tx_buf[1], tx_buf[2]);
+				} else {
+					if (tx_buf)
+						pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+					else
+						pr_err("tx_buf is NULL pointer\n");
+				}
+			} else {
+				pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+			}
+		}
+		if (mi_cfg->vi_setting_enabled) {
+			/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+			if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+			} else {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+			}
+		}
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_HDR_OFF);
+		mi_cfg->dimming_state = STATE_DIM_RESTORE;
+		mi_cfg->hbm_enabled = false;
+		break;
+	case DISPPARAM_HBM_FOD_ON:
+		if (mi_cfg->local_hbm_enabled) {
+			cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+			if (fod_lhbm_level == 1) {
+				pr_info("lhbm white 1000nit On\n");
+				mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT, mi_cfg->last_bl_level);
+				if (panel->power_mode == SDE_MODE_DPMS_LP1 ||panel->power_mode == SDE_MODE_DPMS_LP2){
+					switch (mi_cfg->doze_brightness_state) {
+						case DOZE_BRIGHTNESS_HBM:
+							mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT, mi_cfg->doze_hbm_dbv_level);
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT in doze_hbm_dbv_level\n");
+							break;
+						case DOZE_BRIGHTNESS_LBM:
+							mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT, mi_cfg->doze_lbm_dbv_level);
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT in doze_lbm_dbv_level\n");
+							break;
+						default:
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT defaults\n");
+							break;
+					}
+				}
+				if(mi_cfg->gir_enabled){
+					rc = mi_dsi_panel_update_lhbm_white_param(panel,FOD_LHBM_WHITE_1000NIT_GIRON, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT);
+				} else {
+					rc = mi_dsi_panel_update_lhbm_white_param(panel,FOD_LHBM_WHITE_1000NIT_GIROFF, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT);
+				}
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT);
+			} else if (fod_lhbm_level == 2) {
+				pr_info("lhbm white 110nit On\n");
+				mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT, mi_cfg->last_bl_level);
+				if (panel->power_mode == SDE_MODE_DPMS_LP1 ||panel->power_mode == SDE_MODE_DPMS_LP2){
+					switch (mi_cfg->doze_brightness_state) {
+						case DOZE_BRIGHTNESS_HBM:
+							mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT, mi_cfg->doze_hbm_dbv_level);
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT in doze_hbm_dbv_level\n");
+							break;
+						case DOZE_BRIGHTNESS_LBM:
+							mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT, mi_cfg->doze_lbm_dbv_level);
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT in doze_lbm_dbv_level\n");
+							break;
+						default:
+							pr_info("DSI_CMD_SET_MI_FOD_LHBM_WHITE_1000NIT defaults\n");
+							break;
+					}
+				}
+
+				if(mi_cfg->gir_enabled){
+					rc = mi_dsi_panel_update_lhbm_white_param(panel,FOD_LHBM_WHITE_110NIT_GIRON, DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT);
+				} else {
+					rc = mi_dsi_panel_update_lhbm_white_param(panel,FOD_LHBM_WHITE_110NIT_GIROFF, DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT);
+				}
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_WHITE_110NIT);
+			} else if (fod_lhbm_level == 3) {
+				pr_info("lhbm green 500nit On\n");
+				mi_dsi_update_lhbm_cmd_87reg(panel, DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT, mi_cfg->last_bl_level);
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_GREEN_500NIT);
+			}
+			mi_cfg->local_hbm_cur_status = true;
+		} else {
+			pr_info("hbm fod on\n");
+			cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+			if (mi_cfg->fod_on_b2_index && priv_info &&
+				((mi_cfg->panel_id >> 8) == 0x4A32004202 ||
+				(mi_cfg->panel_id >> 8) == 0x4A3153004202)) {
+				pr_info("Fod on b2 index is enabled\n");
+				cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].cmds;
+				count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_ON].count;
+				if (cmds && count >= mi_cfg->fod_on_b2_index + 2) {
+					tx_buf = (u8 *)cmds[mi_cfg->fod_on_b2_index].msg.tx_buf;
+					/* 0xB2(0) reg: if DC on (0xC8); if DC off (0x58) */
+					if (tx_buf && tx_buf[0] == 0xB2) {
+						if (mi_cfg->dc_enable) {
+							tx_buf[1] = 0xC8;
+						} else {
+							tx_buf[1] = 0x58;
+						}
+						pr_info("DSI_CMD_SET_MI_HBM_FOD_ON 0x%02X(9) = 0x%02X\n", tx_buf[0], tx_buf[1]);
+					} else {
+						if (tx_buf)
+							pr_err("tx_buf[0] = 0x%02X, check 0xB2 index\n", tx_buf[0]);
+						else
+							pr_err("tx_buf is NULL pointer\n");
+					}
+					tx_buf = (u8 *)cmds[mi_cfg->fod_on_b2_index + 2].msg.tx_buf;
+					/* 0xB2(9) reg: if DC on use 1 Pulse(0x00); if DC off use 4 Pulse(0x20) */
+					if (tx_buf && tx_buf[0] == 0xB2) {
+						if (mi_cfg->dc_enable) {
+							tx_buf[1] = 0x00;
+						} else {
+							tx_buf[1] = 0x20;
+						}
+						pr_info("DSI_CMD_SET_MI_HBM_FOD_ON 0x%02X(9) = 0x%02X\n", tx_buf[0], tx_buf[1]);
+					} else {
+						if (tx_buf)
+							pr_err("tx_buf[0] = 0x%02X, check 0xB2 index\n", tx_buf[0]);
+						else
+							pr_err("tx_buf is NULL pointer\n");
+					}
+				} else {
+					pr_err("0xB2 index(%d) error\n", mi_cfg->fod_on_b2_index);
+				}
+			}
+
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_ON);
+
+			if (mi_cfg->dc_type == 1)
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+			mi_cfg->fod_hbm_enabled = true;
+			mi_cfg->fod_to_nolp = false;
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		break;
+	case DISPPARAM_HBM_FOD2NORM:
+		pr_info("hbm fod to normal mode\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD2NORM);
+		break;
+	case DISPPARAM_HBM_FOD_OFF:
+		if (mi_cfg->local_hbm_enabled) {
+			pr_info("lhbm Off\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_OFF);
+			mi_cfg->local_hbm_cur_status = false;
+
+			if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+					panel->power_mode == SDE_MODE_DPMS_LP2) {
+				if (mi_cfg->fp_status == AUTH_START) {
+					pr_info("delayed_work schedule --- delay enter aod mode\n");
+					__pm_wakeup_event(mi_cfg->aod_wakelock, DEFAULT_FOD_OFF_ENTER_AOD_DELAY + 100);
+					schedule_delayed_work(&mi_cfg->enter_aod_delayed_work,
+						msecs_to_jiffies(DEFAULT_FOD_OFF_ENTER_AOD_DELAY));
+				}
+			}
+		} else {
+			pr_info("hbm fod off\n");
+			if (!mi_cfg->hbm_enabled) {
+				if (mi_cfg->hbm_51_ctrl_flag && priv_info) {
+					/* restore last backlight value when fod off */
+					cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+					count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+					if (cmds && count >= mi_cfg->fod_off_51_index) {
+						tx_buf = (u8 *)cmds[mi_cfg->fod_off_51_index].msg.tx_buf;
+						if (tx_buf && tx_buf[0] == 0x51) {
+							if (mi_cfg->layer_fod_unlock_success && !mi_cfg->last_bl_level) {
+								pr_err("fod hbm off, restore last bl: %d\n", mi_cfg->last_nonzero_bl_level);
+								tx_buf[1] = (mi_cfg->last_nonzero_bl_level >> 8) & 0x07;
+								tx_buf[2] = mi_cfg->last_nonzero_bl_level & 0xff;
+							} else {
+								tx_buf[1] = (mi_cfg->last_bl_level >> 8) & 0x07;
+								tx_buf[2] = mi_cfg->last_bl_level & 0xff;
+							}
+							pr_info("DSI_CMD_SET_MI_HBM_FOD_OFF 0x%02X = 0x%02X 0x%02X\n",
+									tx_buf[0], tx_buf[1], tx_buf[2]);
+						} else {
+							if (tx_buf)
+								pr_err("tx_buf[0] = 0x%02X, check 0x51 index\n", tx_buf[0]);
+							else
+								pr_err("tx_buf is NULL pointer\n");
+						}
+					} else {
+						pr_err("0x51 index(%d) error\n", mi_cfg->hbm_off_51_index);
+					}
+				}
+				if (mi_cfg->dc_type == 0 && mi_cfg->fod_off_b5_index && priv_info) {
+					cmds = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].cmds;
+					count = priv_info->cmd_sets[DSI_CMD_SET_MI_HBM_FOD_OFF].count;
+					if (cmds && count >= mi_cfg->fod_off_b5_index) {
+						tx_buf = (u8 *)cmds[mi_cfg->fod_off_b5_index].msg.tx_buf;
+						if (tx_buf && tx_buf[0] == 0xb5) {
+							if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+								panel->power_mode == SDE_MODE_DPMS_LP2) {
+								pr_info("Fod off to aod set elvss swire to -3.0V\n");
+								tx_buf[1] = 0x19;
+							} else if (panel->power_mode == SDE_MODE_DPMS_ON) {
+								pr_info("Fod off to normal set elvss swire to -4.5V\n");
+								tx_buf[1] = 0x0A;
+							}
+						}
+					}
+				}
+				if (mi_cfg->vi_setting_enabled) {
+					/* if last backlight >= vi_switch_threshold, set VI voltage -3.5V */
+					if (mi_cfg->last_bl_level >= mi_cfg->vi_switch_threshold) {
+						rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_HIGH);
+					} else {
+						rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_VI_SETTING_LOW);
+					}
+				}
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_FOD_OFF);
+				mi_cfg->dimming_state = STATE_DIM_RESTORE;
+			} else {
+				if (mi_cfg->thermal_hbm_disabled) {
+					pr_info("thermal set hbm limit, do not recovery hbm on\n");
+				} else {
+					pr_info("recovery hbm on mode\n");
+					rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_HBM_ON);
+					if (mi_cfg->hbm_brightness)
+						rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+				}
+			}
+			if (mi_cfg->dc_type == 0 && mi_cfg->dc_enable) {
+				rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_AOD_TO_DC_ON);
+				if (rc)
+					pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+						panel->name, rc);
+			}
+			mi_cfg->fod_hbm_enabled = false;
+			mi_cfg->fod_hbm_off_time = ktime_add_ms(ktime_get(),
+					mi_cfg->fod_off_dimming_delay);
+
+			if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+					panel->power_mode == SDE_MODE_DPMS_LP2) {
+				if (mi_cfg->layer_fod_unlock_success || mi_cfg->sysfs_fod_unlock_success) {
+					pr_info("[%d,%d]Fod fingerprint unlock success, skip into aod mode\n",
+						mi_cfg->layer_fod_unlock_success, mi_cfg->sysfs_fod_unlock_success);
+				} else {
+					pr_info("delayed_work schedule --- delay enter aod mode\n");
+					mi_cfg->into_aod_pending = true;
+					__pm_wakeup_event(mi_cfg->aod_wakelock, DEFAULT_FOD_OFF_ENTER_AOD_DELAY + 100);
+					schedule_delayed_work(&mi_cfg->enter_aod_delayed_work,
+						msecs_to_jiffies(DEFAULT_FOD_OFF_ENTER_AOD_DELAY));
+				}
+			}
+		}
+		break;
+	case DISPPARAM_FOD_UNLOCK_SUCCESS:
+		pr_info("Fod fingerprint unlock success\n");
+		mi_cfg->sysfs_fod_unlock_success = true;
+		mi_cfg->into_aod_pending = false;
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+			panel->power_mode == SDE_MODE_DPMS_LP2) {
+			cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+		}
+		break;
+	case DISPPARAM_FOD_UNLOCK_FAIL:
+		pr_info("Fod fingerprint unlock fail\n");
+		mi_cfg->sysfs_fod_unlock_success = false;
+		mi_cfg->into_aod_pending = false;
+		if(mi_cfg->local_hbm_enabled){
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FOD_LHBM_OFF);
+			mi_cfg->local_hbm_cur_status = false;
+		}
+		if (panel->power_mode == SDE_MODE_DPMS_LP1 ||
+				panel->power_mode == SDE_MODE_DPMS_LP2) {
+			cancel_delayed_work(&mi_cfg->enter_aod_delayed_work);
+			if (mi_cfg->layer_fod_unlock_success) {
+				pr_info("layer_fod_unlock_success is true, skip into aod mode\n");
+			} else {
+				if (!mi_cfg->unset_doze_brightness)
+					mi_cfg->unset_doze_brightness = mi_cfg->doze_brightness_state;
+				dsi_panel_set_doze_brightness(panel, mi_cfg->unset_doze_brightness, false);
+			}
+		}
+		break;
+	case DISPPARAM_DC_ON:
+		pr_info("DC on\n");
+		if (mi_cfg->dc_type == 0) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_ON);
+			if (rc)
+				pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_ON cmd, rc=%d\n",
+						panel->name, rc);
+			else
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+		}
+		if (panel->mi_cfg.panel_id == 0x4C334100420200) {
+			mi_dsi_update_lhbm_cmd_b2reg(panel, true);
+			mi_dsi_update_nolp_b2reg(panel, true);
+		}
+		mi_cfg->dc_enable = true;
+		break;
+	case DISPPARAM_DC_OFF:
+		pr_info("DC off\n");
+		if (mi_cfg->dc_type == 0) {
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DC_OFF);
+			if (rc)
+				pr_err("[%s] failed to send DSI_CMD_SET_MI_DC_OFF cmd, rc=%d\n",
+						panel->name, rc);
+			else
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+		}
+		if (panel->mi_cfg.panel_id == 0x4C334100420200) {
+			mi_dsi_update_lhbm_cmd_b2reg(panel, false);
+			mi_dsi_update_nolp_b2reg(panel, false);
+		}
+		mi_cfg->dc_enable = false;
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x00F00000;
+	switch (temp) {
+	case DISPPARAM_NORMALMODE1:
+		pr_info("normal mode1\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_NORMAL1);
+		break;
+	case DISPPARAM_P3:
+		pr_info("dci p3 mode\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_DCIP3);
+		break;
+	case DISPPARAM_SRGB:
+		pr_info("sRGB\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_SRGB);
+		break;
+	case DISPPARAM_DOZE_BRIGHTNESS_HBM:
+		if (mi_cfg->in_aod) {
+			pr_info("doze hbm On\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DOZE_HBM);
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		break;
+	case DISPPARAM_DOZE_BRIGHTNESS_LBM:
+		if (mi_cfg->in_aod) {
+			pr_info("doze lbm On\n");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DOZE_LBM);
+			mi_cfg->dimming_state = STATE_DIM_BLOCK;
+		}
+		break;
+	case DISPPARAM_DOZE_OFF:
+		pr_info("doze Off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_NOLP);
+		break;
+	case DISPPARAM_HBM_BACKLIGHT_RESEND:
+		dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGON);
+		backlight_delta++;
+		if (mi_cfg->last_bl_level >= panel->bl_config.bl_max_level - 1)
+			resend_backlight = mi_cfg->last_bl_level -
+				((backlight_delta%2 == 0) ? 1 : 2);
+		else
+			resend_backlight = mi_cfg->last_bl_level +
+				((backlight_delta%2 == 0) ? 1 : 2);
+
+		pr_info("backlight resend: last_bl_level = %d; resend_backlight = %d\n",
+				mi_cfg->last_bl_level, resend_backlight);
+		rc = dsi_panel_update_backlight(panel, resend_backlight);
+		break;
+	case DISPPARAM_FOD_BACKLIGHT:
+		if (fod_backlight == 0x1000) {
+			pr_info("FOD backlight restore last_bl_level=%d\n",
+				mi_cfg->last_bl_level);
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+			if (mi_cfg->dc_enable && mi_cfg->dc_type) {
+				pr_info("FOD backlight restore dc_threshold=%d",
+				mi_cfg->dc_threshold);
+				rc = dsi_panel_update_backlight(panel, mi_cfg->dc_threshold);
+			} else {
+				pr_info("FOD backlight restore last_bl_level=%d",
+				mi_cfg->last_bl_level);
+				rc = dsi_panel_update_backlight(panel, mi_cfg->last_bl_level);
+			}
+		} else if (fod_backlight >= 0) {
+			pr_info("FOD backlight set");
+			rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_DIMMINGOFF);
+			rc = dsi_panel_update_backlight(panel, fod_backlight);
+			mi_cfg->fod_target_backlight = fod_backlight;
+			mi_cfg->dimming_state = STATE_NONE;
+		}
+		break;
+	case DISPPARAM_CRC_OFF:
+		pr_info("crc off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_CRC_OFF);
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0x0F000000;
+	switch (temp) {
+	case DISPPARAM_FOD_BACKLIGHT_ON:
+		pr_info("fod_backlight_flag on\n");
+		mi_cfg->fod_backlight_flag = true;
+		break;
+	case DISPPARAM_FOD_BACKLIGHT_OFF:
+		pr_info("fod_backlight_flag off\n");
+		mi_cfg->fod_backlight_flag = false;
+		break;
+	case DISPPARAM_ELVSS_DIMMING_ON:
+		pr_info("elvss dimming on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFF);
+		break;
+	case DISPPARAM_ELVSS_DIMMING_OFF:
+		pr_info("elvss dimming off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_ELVSS_DIMMING_OFF);
+		break;
+	case DISPPARAM_FLAT_MODE_ON:
+		pr_info("flat mode on\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FLAT_MODE_ON);
+		break;
+	case DISPPARAM_FLAT_MODE_OFF:
+		pr_info("flat mode off\n");
+		rc = dsi_panel_tx_cmd_set(panel, DSI_CMD_SET_MI_FLAT_MODE_OFF);
+		break;
+	case DISPPARAM_DITHER_ON:
+		pr_info("dither on\n");
+		mi_cfg->dither_enabled = true;
+		break;
+	case DISPPARAM_DITHER_OFF:
+		pr_info("dither off\n");
+		mi_cfg->dither_enabled = false;
+		break;
+	case DISPPARAM_SET_THERMAL_HBM_DISABLE:
+		pr_info("set thermal hbm disable\n");
+		mi_cfg->thermal_hbm_disabled = true;
+		break;
+	case DISPPARAM_CLEAR_THERMAL_HBM_DISABLE:
+		pr_info("clear thermal hbm disable\n");
+		mi_cfg->thermal_hbm_disabled = false;
+		break;
+	default:
+		break;
+	}
+
+	temp = param & 0xF0000000;
+	switch (temp) {
+	case DISPPARAM_GIR_ON:
+		if (panel->mi_cfg.panel_id == 0x4C334100420200 && panel->mi_cfg.in_aod) {
+			DSI_INFO("In AOD, skip gir on \n");
+		} else {
+			pr_info("request gir on\n");
+			mi_cfg->request_gir_status = true;
+		}
+		break;
+	case DISPPARAM_GIR_OFF:
+		pr_info("request gir off\n");
+		mi_cfg->request_gir_status = false;
+		break;
+	default:
+		break;
+	}
+
+exit:
+	mutex_unlock(&panel->panel_lock);
+	return rc;
+}
+
diff --git a/techpack/display/msm/dsi/dsi_panel_mi.h b/techpack/display/msm/dsi/dsi_panel_mi.h
new file mode 100755
index 000000000000..f8351a9889fd
--- /dev/null
+++ b/techpack/display/msm/dsi/dsi_panel_mi.h
@@ -0,0 +1,415 @@
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _DSI_PANEL_MI_H_
+#define _DSI_PANEL_MI_H_
+
+#include <linux/of_device.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/backlight.h>
+#include <drm/drm_panel.h>
+#include <drm/msm_drm.h>
+
+#include "dsi_defs.h"
+#include "dsi_ctrl_hw.h"
+#include "dsi_clk.h"
+#include "dsi_pwr.h"
+#include "dsi_parser.h"
+#include "msm_drv.h"
+
+#define DEFAULT_FOD_OFF_DIMMING_DELAY     170
+#define DEFAULT_FOD_OFF_ENTER_AOD_DELAY   300
+#define DISPPARAM_THERMAL_SET             0x1
+#define DEFAULT_CABC_WRITE_DELAY          3000
+
+#define MAX_VSYNC_COUNT                   200
+
+enum doze_bkl {
+	DOZE_TO_NORMAL = 0,
+	DOZE_BRIGHTNESS_HBM,
+	DOZE_BRIGHTNESS_LBM,
+	DOZE_BRIGHTNESS_MAX,
+};
+
+enum bkl_dimming_state {
+	STATE_NONE,
+	STATE_DIM_BLOCK,
+	STATE_DIM_RESTORE,
+	STATE_ALL
+};
+
+enum dsi_gamma_cmd_set_type {
+	DSI_CMD_SET_MI_GAMMA_SWITCH_60HZ = 0,
+	DSI_CMD_SET_MI_GAMMA_SWITCH_90HZ,
+	DSI_CMD_SET_MI_GAMMA_SWITCH_MAX
+};
+
+/* 60Hz gamma and 90Hz gamma info */
+struct gamma_cfg {
+	bool read_done;
+	u8 otp_read_c8[135];
+	u8 otp_read_c9[180];
+	u8 otp_read_b3[45];
+
+	u32 flash_read_total_param;
+	u32 flash_read_c1_index;
+	u32 gamma_checksum;
+	u8 flash_read_c8[135];
+	u8 flash_read_c9[180];
+	u8 flash_read_b3[45];
+	u8 flash_read_checksum[2];
+
+	u32 update_c8_index;
+	u32 update_c9_index;
+	u32 update_b3_index;
+	bool update_done_60hz;
+	bool update_done_90hz;
+
+	bool black_setting_flag;
+};
+
+/* Enter/Exit DC_LUT info */
+struct dc_cfg {
+	bool read_done;
+	bool update_done;
+	u32 update_d2_index;
+	u8 enter_dc_lut[75];
+	u8 exit_dc_lut[75];
+};
+
+struct dc_cfg_v2 {
+	bool read_done;
+	bool update_done;
+	int update_dc_on_reg_index;
+	int update_dc_off_reg_index;
+	u8 enter_dc_lut[75];
+	u8 exit_dc_lut[75];
+};
+
+enum dc_lut_state {
+	DC_LUT_D2,
+	DC_LUT_D4,
+	DC_LUT_MAX
+};
+
+enum fingerprint_status {
+	FINGERPRINT_NONE = 0,
+	ENROLL_START = 1,
+	ENROLL_STOP = 2,
+	AUTH_START = 3,
+	AUTH_STOP = 4,
+	HEART_RATE_START = 5,
+	HEART_RATE_STOP = 6,
+};
+
+struct lockdowninfo_cfg {
+	u8 lockdowninfo[16];
+	bool lockdowninfo_read_done;
+};
+
+struct greenish_gamma_cfg {
+	u32 index_1st_param;
+	u32 index_2nd_param;
+	u32 index_3rd_param;
+	u32 index_4th_param;
+	u32 index_5th_param;
+	u32 index_6th_param;
+
+	u32 greenish_gamma_update_offset;
+	u32 greenish_gamma_update_param_count;
+
+	bool gamma_update_done;
+};
+
+typedef struct brightness_alpha {
+	uint32_t brightness;
+	uint32_t alpha;
+} brightness_alpha;
+
+struct gir_cfg {
+	bool update_done;
+	int update_index;
+	int update_index2;
+	u8 gir_param[4];
+};
+
+struct fod_lhbm_green_500nit_cfg {
+	bool update_done;
+	int update_index;
+	u8 fod_lhbm_green_500nit_param[2];
+};
+
+struct fod_lhbm_white_cfg {
+	bool update_done;
+	int update_index;
+	int lhbm_white_read_pre;
+	int lhbm_white_read_offset;
+	u8 fod_lhbm_white_param[6];
+};
+
+enum fod_lhbm_white_state {
+	FOD_LHBM_WHITE_1000NIT_GIROFF,
+	FOD_LHBM_WHITE_1000NIT_GIRON,
+	FOD_LHBM_WHITE_110NIT_GIROFF,
+	FOD_LHBM_WHITE_110NIT_GIRON,
+	FOD_LHBM_WHITE_MAX
+};
+
+struct dsi_panel_mi_cfg {
+	struct dsi_panel *dsi_panel;
+
+	/* xiaomi panel id */
+	u64 panel_id;
+
+	/* xiaomi feature enable flag */
+	bool mi_feature_enabled;
+
+	/* bl_is_big_endian indicate brightness value
+	 * high byte to 1st parameter, low byte to 2nd parameter
+	 * eg: 0x51 { 0x03, 0xFF } ->
+	 * u8 payload[2] = { brightness >> 8, brightness & 0xff}
+	 */
+	bool bl_is_big_endian;
+	u32 last_bl_level;
+	u32 last_nonzero_bl_level;
+
+	/* indicate refresh frequency Fps gpio */
+	int disp_rate_gpio;
+
+	/* gamma read */
+	bool gamma_update_flag;
+	struct gamma_cfg gamma_cfg;
+
+	/* greenish gamma read */
+	bool greenish_gamma_update_flag;
+	u32 greenish_gamma_read_len;
+	struct greenish_gamma_cfg greenish_gamma_cfg;
+
+	/* dc read */
+	bool dc_update_flag;
+	struct dc_cfg dc_cfg;
+	bool dc_update_flag_v2;
+	struct dc_cfg_v2 dc_cfg_v2[DC_LUT_MAX];
+
+	/* white point coordinate info */
+	bool wp_read_enabled;
+	u32 wp_reg_read_len;
+	u32 wp_info_index;
+	u32 wp_info_len;
+
+	/* HBM and brightness use 51 reg ctrl */
+	bool hbm_51_ctrl_flag;
+	u32 hbm_off_51_index;
+	u32 fod_off_51_index;
+	u32 fod_off_b5_index;
+	u32 fod_on_b2_index;
+	bool vi_setting_enabled;
+	u32 vi_switch_threshold;
+
+	bool dynamic_elvss_enabled;
+
+	int esd_err_irq_gpio;
+	int esd_err_irq;
+	int esd_err_irq_flags;
+	bool esd_err_enabled;
+
+	/* elvss dimming info */
+	bool elvss_dimming_check_enable;
+	u32 elvss_dimming_read_len;
+	u32 update_hbm_fod_on_index;
+	u32 update_hbm_fod_off_index;
+
+	u32 dimming_state;
+	u32 panel_on_dimming_delay;
+	struct delayed_work dimming_enable_delayed_work;
+
+	struct delayed_work enter_aod_delayed_work;
+
+	struct delayed_work cabc_delayed_work;
+
+	bool hbm_enabled;
+	bool thermal_hbm_disabled;
+	bool fod_hbm_enabled;
+	bool fod_hbm_layer_enabled;
+	bool fod_skip_nolp;
+	bool fod_to_nolp;
+	u32 doze_brightness_state;
+	u32 unset_doze_brightness;
+	u32 fod_off_dimming_delay;
+	ktime_t fod_backlight_off_time;
+	ktime_t fod_hbm_off_time;
+	u32 fod_ui_ready;
+	bool layer_fod_unlock_success;
+	bool sysfs_fod_unlock_success;
+	bool into_aod_pending;
+	bool layer_aod_flag;
+	struct wakeup_source *aod_wakelock;
+
+	bool fod_backlight_flag;
+	u32 fod_target_backlight;
+	bool fod_flag;
+	/* set doze hbm/lbm only in AOD */
+	bool in_aod;
+	u32 dc_threshold;
+	bool dc_enable;
+	u32 dc_type;
+	u32 hbm_brightness;
+	u32 max_brightness_clone;
+	u32 aod_backlight;
+	uint32_t doze_brightness;
+	bool bl_wait_frame;
+	bool bl_enable;
+	bool is_tddi_flag;
+	bool tddi_doubleclick_flag;
+	bool panel_dead_flag;
+
+	bool fod_dimlayer_enabled;
+	bool prepare_before_fod_hbm_on;
+	bool delay_before_fod_hbm_on;
+	bool delay_after_fod_hbm_on;
+	bool delay_before_fod_hbm_off;
+	bool delay_after_fod_hbm_off;
+	uint32_t brightnes_alpha_lut_item_count;
+	brightness_alpha *brightness_alpha_lut;
+
+	struct lockdowninfo_cfg lockdowninfo_read;
+
+	bool dither_enabled;
+	u32 cabc_current_status;
+	u32 cabc_temp_status;
+	int current_tp_code_fps;
+
+	bool local_hbm_enabled;
+	bool fod_lhbm_87reg_ctrl_flag;
+	u32 fod_lhbm_white_1000nit_87reg_index;
+	u32 fod_lhbm_white_110nit_87reg_index;
+	u32 fod_lhbm_green_500nit_87reg_index;
+	bool fod_lhbm_b2reg_ctrl_flag;
+	u32 fod_lhbm_white_1000nit_b2reg_index;
+	u32 fod_lhbm_white_110nit_b2reg_index;
+	bool local_hbm_cur_status;
+	bool fod_lhbm_low_brightness_enabled;
+	bool fod_lhbm_low_brightness_allow;
+	u32 fp_status;
+	int doze_hbm_dbv_level;
+	int doze_lbm_dbv_level;
+	int lhbm_target;
+	int pending_lhbm_state;
+	bool fod_lhbm_green_500nit_update_flag;
+	struct fod_lhbm_green_500nit_cfg fod_lhbm_green_500nit_cfg;
+	bool fod_lhbm_white_update_flag;
+	struct fod_lhbm_white_cfg fod_lhbm_white_cfg[FOD_LHBM_WHITE_MAX];
+	bool fod_anim_layer_enabled;
+	bool dim_fp_dbv_max_in_hbm_flag;
+
+	bool gir_update_flag;
+	struct gir_cfg gir_cfg;
+	bool gir_enabled;
+	bool request_gir_status;
+
+	bool nolp_b2reg_ctrl_flag;
+	u32 nolp_b2reg_index;
+};
+
+struct dsi_read_config {
+	bool is_read;
+	struct dsi_panel_cmd_set read_cmd;
+	u32 cmds_rlen;
+	u8 rbuf[256];
+};
+
+static inline const char *get_doze_brightness_name(__u32 doze_brightness)
+{
+	switch (doze_brightness) {
+	case DOZE_TO_NORMAL:
+		return "doze_to_normal";
+	case DOZE_BRIGHTNESS_HBM:
+		return "doze_brightness_high";
+	case DOZE_BRIGHTNESS_LBM:
+		return "doze_brightness_low";
+	default:
+		return "Unknown";
+	}
+}
+
+int dsi_panel_parse_esd_gpio_config(struct dsi_panel *panel);
+
+int dsi_panel_parse_mi_config(struct dsi_panel *panel,
+				struct device_node *of_node);
+
+int dsi_panel_esd_irq_ctrl(struct dsi_panel *panel,
+				bool enable);
+
+int dsi_panel_esd_irq_ctrl_locked(struct dsi_panel *panel,
+			bool enable);
+
+int dsi_panel_write_cmd_set(struct dsi_panel *panel,
+				struct dsi_panel_cmd_set *cmd_sets);
+
+int dsi_panel_read_cmd_set(struct dsi_panel *panel,
+				struct dsi_read_config *read_config);
+
+int dsi_panel_write_mipi_reg(struct dsi_panel *panel, char *buf);
+
+ssize_t dsi_panel_read_mipi_reg(struct dsi_panel *panel, char *buf);
+
+bool dsi_panel_is_need_tx_cmd(u32 param);
+
+int dsi_panel_set_disp_param(struct dsi_panel *panel, u32 param);
+
+int dsi_panel_read_gamma_param(struct dsi_panel *panel);
+
+int dsi_panel_update_gamma_param(struct dsi_panel *panel);
+
+int dsi_panel_write_gamma_cmd_set(struct dsi_panel *panel,
+				enum dsi_gamma_cmd_set_type type);
+
+int dsi_panel_read_dc_param(struct dsi_panel *panel);
+
+int dsi_panel_update_dc_param(struct dsi_panel *panel);
+
+int mi_dsi_panel_read_and_update_dc_param_v2(struct dsi_panel *panel);
+
+int mi_dsi_panel_read_and_update_gir_param(struct dsi_panel *panel);
+
+int mi_dsi_panel_read_and_update_lhbm_green_500nit_param(struct dsi_panel *panel);
+int mi_dsi_panel_read_lhbm_white_param(struct dsi_panel *panel);
+int mi_dsi_panel_read_lhbm_white_reg(struct dsi_panel *panel, int fod_lhbm_white_state);
+int mi_dsi_panel_update_lhbm_white_param(struct dsi_panel *panel, int fod_lhbm_white_state, int cmd_index);
+
+int dsi_panel_switch_disp_rate_gpio(struct dsi_panel *panel);
+
+ssize_t dsi_panel_read_wp_info(struct dsi_panel *panel, char *buf);
+
+int dsi_panel_set_doze_brightness(struct dsi_panel *panel,
+				int doze_brightness, bool need_panel_lock);
+
+int dsi_panel_update_elvss_dimming(struct dsi_panel *panel);
+
+int dsi_panel_read_greenish_gamma_setting(struct dsi_panel *panel);
+
+int dsi_panel_update_greenish_gamma_setting(struct dsi_panel *panel);
+
+int dsi_panel_match_fps_pen_setting(struct dsi_panel *panel,
+				struct dsi_display_mode *adj_mode);
+
+int dsi_panel_lockdowninfo_param_read(struct dsi_panel *panel);
+
+int dsi_panel_power_turn_off(bool on);
+
+int mi_dsi_panel_set_fod_brightness(struct mipi_dsi_device *dsi, u16 brightness);
+
+#endif /* _DSI_PANEL_MI_H_ */
diff --git a/techpack/display/msm/dsi/dsi_phy.c b/techpack/display/msm/dsi/dsi_phy.c
index 2f116bfb855c..e661b6a275f9 100644
--- a/techpack/display/msm/dsi/dsi_phy.c
+++ b/techpack/display/msm/dsi/dsi_phy.c
@@ -885,6 +885,8 @@ int dsi_phy_enable(struct msm_dsi_phy *phy,
 	phy->cfg.data_lanes = config->common_config.data_lanes;
 	phy->cfg.pll_source = pll_source;
 	phy->cfg.bit_clk_rate_hz = config->bit_clk_rate_hz;
+	phy->cfg.clk_strength = config->common_config.clk_strength;
+	phy->cfg.cphy_strength = config->common_config.cphy_strength;
 
 	/**
 	 * If PHY timing parameters are not present in panel dtsi file,
diff --git a/techpack/display/msm/dsi/dsi_phy_hw.h b/techpack/display/msm/dsi/dsi_phy_hw.h
index ef60301f6b08..6ecc741da62a 100644
--- a/techpack/display/msm/dsi/dsi_phy_hw.h
+++ b/techpack/display/msm/dsi/dsi_phy_hw.h
@@ -115,6 +115,8 @@ struct dsi_phy_cfg {
 	enum dsi_phy_type phy_type;
 	unsigned long bit_clk_rate_hz;
 	u32 data_lanes;
+	unsigned long clk_strength;
+	bool cphy_strength;
 };
 
 struct dsi_phy_hw;
diff --git a/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c b/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
index d33eea206452..45d3f44cb6ab 100644
--- a/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
+++ b/techpack/display/msm/dsi/dsi_phy_hw_v4_0.c
@@ -290,6 +290,14 @@ static void dsi_phy_hw_cphy_enable(struct dsi_phy_hw *phy,
 			glbl_rescode_bot_ctrl);
 	DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);
 
+	if (cfg->cphy_strength) {
+		DSI_W32(phy, DSIPHY_CMN_VREG_CTRL_0, 0x50);
+		DSI_W32(phy, DSIPHY_CMN_VREG_CTRL_1, 0x54);
+		DSI_W32(phy, DSIPHY_CMN_GLBL_RESCODE_OFFSET_TOP_CTRL, 0x1F);
+		DSI_W32(phy, DSIPHY_CMN_GLBL_RESCODE_OFFSET_BOT_CTRL, 0x1F);
+		DSI_W32(phy, DSIPHY_CMN_GLBL_RESCODE_OFFSET_MID_CTRL, 0x1F);
+	}
+
 	/* Remove power down from all blocks */
 	DSI_W32(phy, DSIPHY_CMN_CTRL_0, 0x7f);
 
@@ -355,12 +363,21 @@ static void dsi_phy_hw_dphy_enable(struct dsi_phy_hw *phy,
 		vreg_ctrl_0 = less_than_1500_mhz ? 0x53 : 0x52;
 		glbl_rescode_top_ctrl = less_than_1500_mhz ? 0x3d :  0x00;
 		glbl_rescode_bot_ctrl = less_than_1500_mhz ? 0x39 :  0x3c;
-		glbl_str_swi_cal_sel_ctrl = 0x00;
-		glbl_hstx_str_ctrl_0 = 0x88;
+		if (cfg->clk_strength == 0) {
+			glbl_str_swi_cal_sel_ctrl = 0x00;
+			glbl_hstx_str_ctrl_0 = 0x88;
+		} else {
+			glbl_str_swi_cal_sel_ctrl = 0x03;
+			glbl_hstx_str_ctrl_0 = cfg->clk_strength;
+		}
 	} else {
 		vreg_ctrl_0 = less_than_1500_mhz ? 0x5B : 0x59;
 		glbl_str_swi_cal_sel_ctrl = less_than_1500_mhz ? 0x03 : 0x00;
-		glbl_hstx_str_ctrl_0 = less_than_1500_mhz ? 0x66 : 0x88;
+		if (cfg->clk_strength == 0) {
+			glbl_hstx_str_ctrl_0 = less_than_1500_mhz ? 0x66 : 0x88;
+		} else {
+			glbl_hstx_str_ctrl_0 = cfg->clk_strength;
+		}
 		glbl_rescode_top_ctrl = 0x03;
 		glbl_rescode_bot_ctrl = 0x3c;
 	}
@@ -397,7 +414,11 @@ static void dsi_phy_hw_dphy_enable(struct dsi_phy_hw *phy,
 			glbl_rescode_top_ctrl);
 	DSI_W32(phy, DSIPHY_CMN_GLBL_RESCODE_OFFSET_BOT_CTRL,
 			glbl_rescode_bot_ctrl);
-	DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);
+	if (cfg->clk_strength == 0) {
+		DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, 0x55);
+	} else {
+		DSI_W32(phy, DSIPHY_CMN_GLBL_LPTX_STR_CTRL, cfg->clk_strength);
+	}
 
 	/* Remove power down from all blocks */
 	DSI_W32(phy, DSIPHY_CMN_CTRL_0, 0x7f);
diff --git a/techpack/display/msm/dsi/mi_disp_lhbm.c b/techpack/display/msm/dsi/mi_disp_lhbm.c
new file mode 100644
index 000000000000..e3bb2142d54e
--- /dev/null
+++ b/techpack/display/msm/dsi/mi_disp_lhbm.c
@@ -0,0 +1,340 @@
+#include "mi_disp_lhbm.h"
+
+struct disp_lhbm *g_disp_lhbm = NULL;
+static atomic_t fod_work_status = ATOMIC_INIT(FOD_WORK_INIT);
+static atomic_t touch_current_status = ATOMIC_INIT(-1);
+static atomic_t touch_last_status = ATOMIC_INIT(-1);
+
+extern void sde_crtc_fod_ui_ready(struct dsi_display *display, int type, int value);
+
+int mi_get_disp_id(struct dsi_display *display)
+{
+	if (!strncmp(display->display_type, "primary", 7))
+		return MI_DISP_PRIMARY;
+	else
+		return MI_DISP_SECONDARY;
+}
+
+static int mi_disp_fod_thread_create(struct disp_lhbm *dl_ptr, int disp_id)
+{
+	int ret = 0;
+	struct disp_thread *dt_ptr = NULL;
+	struct sched_param param = { 0 };
+
+	param.sched_priority = 16;
+
+	dt_ptr = &dl_ptr->fod_thread;
+	dt_ptr->dd_ptr = &dl_ptr->d_display[disp_id];
+
+	kthread_init_worker(&dt_ptr->worker);
+	dt_ptr->thread = kthread_run(kthread_worker_fn,
+			&dt_ptr->worker, "disp_fod:%d", disp_id);
+
+	ret = sched_setscheduler(dt_ptr->thread, SCHED_FIFO, &param);
+	if (ret)
+		pr_err("%s display thread priority update failed: %d\n", LHBM_TAG, ret);
+
+	if (IS_ERR(dt_ptr->thread)) {
+		pr_err("%s failed to create disp_feature kthread\n", LHBM_TAG);
+		dt_ptr->thread = NULL;
+	}
+	pr_info("%s create disp_fod:%d kthread success\n", LHBM_TAG, disp_id);
+
+	return ret;
+}
+
+static int mi_get_fod_lhbm_target_brightness(struct dsi_display *display)
+{
+	int target = LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_1000NIT;
+
+	if(display->panel->mi_cfg.fp_status == HEART_RATE_START) {
+		target = LOCAL_LHBM_TARGET_BRIGHTNESS_GREEN_500NIT;
+	} else if (display->panel->mi_cfg.fod_lhbm_low_brightness_enabled && display->panel->mi_cfg.fod_lhbm_low_brightness_allow){
+		target = LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_110NIT;
+	}
+
+	if(display->panel->mi_cfg.fp_status == ENROLL_START) {
+		target = LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_1000NIT;
+	}
+
+	return target;
+}
+
+static int mi_dsi_panel_set_fod_lhbm(struct dsi_panel *panel, int lhbm_target)
+{
+	int rc = 0;
+
+	if (!panel) {
+		pr_err("%s invalid params\n", LHBM_TAG);
+		return -EINVAL;
+	}
+	if (!panel->panel_initialized){
+		pr_err("%s Panel not initialized!\n", LHBM_TAG);
+		return -ENODEV;
+	}
+
+	if (lhbm_target == LOCAL_LHBM_TARGET_BRIGHTNESS_NONE) {
+		if (panel->mi_cfg.local_hbm_cur_status == true)	{
+			rc = dsi_panel_set_disp_param(panel, DISPPARAM_HBM_FOD_OFF);
+		}
+	} else {
+		if (panel->mi_cfg.local_hbm_cur_status == false) {
+			rc = dsi_panel_set_disp_param(panel, DISPPARAM_HBM_FOD_ON|lhbm_target);
+			if(panel->mi_cfg.in_aod == true) {
+				pr_info("%s in aod status delay 30 ms lhbm on\n", LHBM_TAG);
+				mdelay(70);
+			}
+		}
+	}
+	return rc;
+}
+
+static int mi_sde_connector_fod_lhbm(struct drm_connector *connector, bool from_touch, int fod_btn)
+{
+	int rc = 0;
+	struct sde_connector *c_conn;
+	struct dsi_display *display;
+	bool btn_down;
+	int lhbm_target;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	if (!connector) {
+		pr_err("%s invalid connector ptr\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		pr_err("%s not DRM_MODE_CONNECTOR_DSI\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	display = (struct dsi_display *) c_conn->display;
+	if (!display || !display->panel) {
+		pr_err("%s invalid display/panel ptr\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	if (mi_get_disp_id(display) != MI_DISP_PRIMARY) {
+		pr_err("%s not MI_DISP_PRIMARY\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	mi_cfg = &display->panel->mi_cfg;
+	btn_down = (fod_btn == 1);
+
+	pr_info("%s dsi_mi_sde_connector_fod_lhbm=%d\n", LHBM_TAG, btn_down);
+	if (btn_down) {
+		if (!mi_cfg->pending_lhbm_state && !from_touch) {
+			rc = -EINVAL;
+			pr_info("%s LHBM on from display skip\n", LHBM_TAG);
+		} else {
+			lhbm_target = mi_get_fod_lhbm_target_brightness(display);
+			rc = mi_dsi_panel_set_fod_lhbm(display->panel, lhbm_target);
+			display->panel->mi_cfg.lhbm_target = lhbm_target;
+			if (!rc) {
+				mi_cfg->pending_lhbm_state = 0;
+			} else if (rc == -ENODEV) {
+				pr_info("%s LHBM on !panel_initialized rc=%d\n", LHBM_TAG, rc);
+				mi_cfg->pending_lhbm_state = 1;
+			} else {
+				pr_err("%s LHBM on failed rc=%d\n", LHBM_TAG, rc);
+			}
+		}
+	} else {
+		rc = mi_dsi_panel_set_fod_lhbm(display->panel, LOCAL_LHBM_TARGET_BRIGHTNESS_NONE);
+		display->panel->mi_cfg.lhbm_target = LOCAL_LHBM_TARGET_BRIGHTNESS_NONE;
+		mi_cfg->pending_lhbm_state = 0;
+		if (rc) {
+			pr_err("%s LHBM off failed rc=%d\n", LHBM_TAG, rc);
+		}
+	}
+
+	return rc;
+}
+
+static void mi_disp_set_fod_work_handler(struct kthread_work *work)
+{
+	int rc = 0;
+	struct fod_work_data *fod_data = NULL;
+	struct disp_work *cur_work = container_of(work,
+					struct disp_work, work);
+
+	fod_data = (struct fod_work_data *)(cur_work->data);
+
+	if (!fod_data || !fod_data->display) {
+		pr_err("%s invalid params\n", LHBM_TAG);
+		return;
+	}
+
+	if (fod_data->from_touch) {
+		atomic_set(&fod_work_status, FOD_WORK_DOING);
+		do {
+			pr_debug("%s from touch, current(%d),last(%d)\n",
+				LHBM_TAG, atomic_read(&touch_current_status), atomic_read(&touch_last_status));
+			atomic_set(&touch_current_status, atomic_read(&touch_last_status));
+			if (atomic_read(&touch_current_status) == 0) {
+				//mi_sde_connector_fod_lhbm_notify(fod_data->display->drm_conn,
+					//atomic_read(&touch_current_status));
+				sde_crtc_fod_ui_ready(fod_data->display, 2, atomic_read(&touch_current_status));
+			}
+
+			rc = mi_sde_connector_fod_lhbm(fod_data->display->drm_conn, true, atomic_read(&touch_current_status));
+
+			if (atomic_read(&touch_current_status) == 1) {
+				if (rc) {
+					pr_err("%s LHBM on failed rc=%d, not notify\n", LHBM_TAG, rc);
+				} else {
+					//mi_sde_connector_fod_lhbm_notify(fod_data->display->drm_conn,
+						//atomic_read(&touch_current_status));
+					sde_crtc_fod_ui_ready(fod_data->display, 2, atomic_read(&touch_current_status));
+				}
+			}
+		} while (atomic_read(&touch_current_status) != atomic_read(&touch_last_status));
+		atomic_set(&fod_work_status, FOD_WORK_DONE);
+	} else {
+		pr_debug("%s not from touch, fod_btn(%d)\n", LHBM_TAG, fod_data->fod_btn);
+		if (fod_data->fod_btn == 0) {
+			sde_crtc_fod_ui_ready(fod_data->display, 2, fod_data->fod_btn);
+		}
+
+		rc = mi_sde_connector_fod_lhbm(fod_data->display->drm_conn, false, fod_data->fod_btn);
+
+		if (fod_data->fod_btn == 1) {
+			if (rc) {
+				pr_err("%s LHBM on failed rc=%d, not notify\n", LHBM_TAG, rc);
+			} else {
+				sde_crtc_fod_ui_ready(fod_data->display, 2, fod_data->fod_btn);
+			}
+		}
+	}
+
+	kfree(cur_work);
+	pr_debug("%s fod work handler done\n", LHBM_TAG);
+}
+
+int mi_disp_set_fod_queue_work(u32 fod_btn, bool from_touch)
+{
+	struct disp_lhbm *dl_ptr = g_disp_lhbm;
+	struct disp_work *cur_work;
+	struct dsi_display *display = NULL;
+	struct fod_work_data *fod_data;
+	int fp_status = FINGERPRINT_NONE;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	static bool ignore_fod_btn = false;
+
+	if (!dl_ptr) {
+		pr_err("%s invalid params\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	display = (struct dsi_display *)dl_ptr->d_display[MI_DISP_PRIMARY].display;
+	if (!display || !display->panel) {
+		pr_err("%s invalid params\n", LHBM_TAG);
+		return -EINVAL;
+	}
+
+	mi_cfg = &display->panel->mi_cfg;
+	fp_status = mi_cfg->fp_status;
+
+	if (from_touch) {
+		if (atomic_read(&fod_work_status) == FOD_WORK_DOING) {
+			pr_debug("%s work doing: from touch current(%d), new fod_btn(%d), skip\n",
+				LHBM_TAG, atomic_read(&touch_current_status), fod_btn);
+			atomic_set(&touch_last_status, fod_btn);
+			return 0;
+		} else {
+			if (ignore_fod_btn) {
+				if (fod_btn == 1) {
+					return 0;
+				} else {
+					ignore_fod_btn = false;
+					pr_info("%s clear ignore state\n", LHBM_TAG);
+					return 0;
+				}
+			}
+
+			if (atomic_read(&touch_current_status) == fod_btn) {
+				pr_debug("%s from touch fod_btn(%d), skip\n", LHBM_TAG, fod_btn);
+				return 0;
+			} else {
+				mutex_lock(&display->display_lock);
+				if (display->panel->power_mode == SDE_MODE_DPMS_ON && atomic_read(&touch_current_status) == 0
+							&& fod_btn == 1 && !mi_cfg->fod_anim_layer_enabled) {
+					pr_info("%s ignore fod_btn due to fod anim is disable!\n", LHBM_TAG);
+					ignore_fod_btn = true;
+					mutex_unlock(&display->display_lock);
+					return 0;
+				}
+				mutex_unlock(&display->display_lock);
+
+				atomic_set(&touch_last_status, fod_btn);
+				pr_debug("%s from touch fod_btn=%d\n", LHBM_TAG, fod_btn);
+			}
+		}
+	}
+
+	fp_status = display->panel->mi_cfg.fp_status;
+	if (fp_status == ENROLL_STOP || fp_status == AUTH_STOP || fp_status == HEART_RATE_STOP) {
+		if (fod_btn == 1) {
+			pr_info("%s fp_state=%d, skip\n", LHBM_TAG, fp_status);
+			return 0;
+		}
+	}
+
+	cur_work = kzalloc(sizeof(*cur_work) + sizeof(*fod_data), GFP_ATOMIC);
+	if (!cur_work)
+		return -ENOMEM;
+
+	fod_data = (struct fod_work_data *)((u8 *)cur_work + sizeof(struct disp_work));
+	fod_data->display = display;
+	fod_data->fod_btn = fod_btn;
+	fod_data->from_touch = from_touch;
+
+	kthread_init_work(&cur_work->work, mi_disp_set_fod_work_handler);
+	cur_work->dd_ptr = &dl_ptr->d_display[MI_DISP_PRIMARY];
+	//cur_work->wq = &dl_ptr->fod_pending_wq;
+	cur_work->data = fod_data;
+
+	pr_info("%s fod_queue_work: fod_btn(%d)\n", LHBM_TAG, fod_btn);
+	kthread_queue_work(&dl_ptr->fod_thread.worker, &cur_work->work);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(mi_disp_set_fod_queue_work);
+
+int mi_disp_lhbm_attach_primary_dsi_display(struct dsi_display *display)
+{
+	struct disp_lhbm *dl_ptr = NULL;
+	struct disp_display *dd_ptr = NULL;
+	int ret = 0;
+
+	if (!strncmp(display->display_type, "primary", 7)) {
+		dl_ptr = kzalloc(sizeof(struct disp_lhbm), GFP_KERNEL);
+		if (!dl_ptr) {
+			pr_err("%s can not allocate Buffer\n", LHBM_TAG);
+			return -ENOMEM;
+		}
+
+		dd_ptr = &dl_ptr->d_display[MI_DISP_PRIMARY];
+		dd_ptr->display = (void *)display;
+
+		ret = mi_disp_fod_thread_create(dl_ptr, MI_DISP_PRIMARY);
+		if (ret) {
+			kfree(dl_ptr);
+			pr_err("%s failed to create fod kthread\n", LHBM_TAG);
+			goto err_exit;
+		}
+
+		g_disp_lhbm = dl_ptr;
+
+		pr_info("%s lhbm attach primary_dsi_display success\n", LHBM_TAG);
+	} else {
+		pr_debug("%s is not primary_dsi_display\n", LHBM_TAG);
+	}
+
+err_exit:
+	return ret;
+}
diff --git a/techpack/display/msm/dsi/mi_disp_lhbm.h b/techpack/display/msm/dsi/mi_disp_lhbm.h
new file mode 100644
index 000000000000..bf0ac4aff2d3
--- /dev/null
+++ b/techpack/display/msm/dsi/mi_disp_lhbm.h
@@ -0,0 +1,78 @@
+#ifndef _MI_DISP_LHBM_H_
+#define _MI_DISP_LHBM_H_
+
+#include <linux/kthread.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <uapi/linux/sched/types.h>
+#include "dsi_display.h"
+#include "sde_connector.h"
+#include "dsi_panel_mi.h"
+#include "dsi_mi_feature.h"
+
+#define LHBM_TAG "[mi-lhbm]"
+
+enum disp_display_type {
+	MI_DISP_PRIMARY = 0,
+	MI_DISP_SECONDARY,
+	MI_DISP_MAX,
+};
+
+struct disp_work {
+	struct kthread_work work;
+	struct kthread_delayed_work delayed_work;
+	struct disp_display *dd_ptr;
+	wait_queue_head_t *wq;
+	void *data;
+};
+
+struct disp_thread {
+	struct task_struct *thread;
+	struct kthread_worker worker;
+	struct disp_display *dd_ptr;
+};
+
+struct disp_display {
+	void *display;
+	int intf_type;
+	struct mutex mutex_lock;
+};
+
+struct disp_lhbm {
+	struct disp_display d_display[MI_DISP_MAX];
+	struct disp_thread fod_thread;
+	//wait_queue_head_t fod_pending_wq;
+};
+
+struct fod_work_data {
+	struct dsi_display *display;
+	int fod_btn;
+	bool from_touch;
+};
+
+enum {
+	FOD_WORK_INIT = 0,
+	FOD_WORK_DOING = 1,
+	FOD_WORK_DONE = 2,
+};
+
+enum mi_panel_op_code {
+	MI_FOD_HBM_ON = 0,
+	MI_FOD_HBM_OFF,
+	MI_FOD_AOD_TO_NORMAL,
+	MI_FOD_NORMAL_TO_AOD,
+};
+
+enum local_lhbm_target_brightness {
+	LOCAL_LHBM_TARGET_BRIGHTNESS_NONE,
+	LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_1000NIT,
+	LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_110NIT,
+	LOCAL_LHBM_TARGET_BRIGHTNESS_GREEN_500NIT,
+	LOCAL_LHBM_TARGET_BRIGHTNESS_MAX
+};
+
+int mi_disp_set_fod_queue_work(u32 fod_btn, bool from_touch);
+#endif
+
diff --git a/techpack/display/msm/dsi/mi_disp_nvt_alpha_data.h b/techpack/display/msm/dsi/mi_disp_nvt_alpha_data.h
new file mode 100644
index 000000000000..47e3dda9515e
--- /dev/null
+++ b/techpack/display/msm/dsi/mi_disp_nvt_alpha_data.h
@@ -0,0 +1,420 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ */
+
+#ifndef _MI_DISP_NVT_ALPHA_DATA_H_
+#define _MI_DISP_NVT_ALPHA_DATA_H_
+static const int fpr_alpha_set[4096] = {
+0x000, 0x071, 0x0af, 0x0d2, 0x0f0, 0x10a, 0x121, 0x135, 0x14d, 0x15b,
+0x16c, 0x17a, 0x188, 0x196, 0x1a4, 0x1b2, 0x1bd, 0x1cb, 0x1d6, 0x1e2,
+0x1f1, 0x1fe, 0x209, 0x214, 0x224, 0x22c, 0x232, 0x23c, 0x246, 0x24f,
+0x258, 0x261, 0x26a, 0x273, 0x27b, 0x282, 0x28a, 0x294, 0x29c, 0x2a4,
+0x2ac, 0x2b4, 0x2bb, 0x2c5, 0x2ca, 0x2d6, 0x2dd, 0x2e4, 0x2ed, 0x2f6,
+0x2fd, 0x302, 0x309, 0x30d, 0x314, 0x31d, 0x323, 0x326, 0x32a, 0x330,
+0x337, 0x33d, 0x343, 0x349, 0x34f, 0x355, 0x35b, 0x361, 0x367, 0x36d,
+0x372, 0x378, 0x37c, 0x383, 0x387, 0x38c, 0x394, 0x399, 0x39f, 0x3a4,
+0x3aa, 0x3af, 0x3b4, 0x3b9, 0x3bf, 0x3c4, 0x3c9, 0x3ce, 0x3d3, 0x3d8,
+0x3dd, 0x3e2, 0x3e7, 0x3f0, 0x3f7, 0x3fa, 0x401, 0x407, 0x40a, 0x40f,
+0x416, 0x418, 0x41f, 0x424, 0x426, 0x42d, 0x432, 0x436, 0x439, 0x43f,
+0x444, 0x448, 0x44b, 0x44f, 0x457, 0x45c, 0x45e, 0x463, 0x467, 0x46d,
+0x46f, 0x476, 0x47a, 0x47c, 0x484, 0x485, 0x48d, 0x48f, 0x495, 0x495,
+0x49d, 0x49f, 0x4a3, 0x4a9, 0x4ad, 0x4af, 0x4b7, 0x4b9, 0x4bd, 0x4c3,
+0x4c5, 0x4c7, 0x4cb, 0x4d1, 0x4d5, 0x4db, 0x4df, 0x4e0, 0x4e6, 0x4e8,
+0x4ec, 0x4f0, 0x4f5, 0x4f9, 0x4fd, 0x4ff, 0x504, 0x50a, 0x50c, 0x50f,
+0x515, 0x519, 0x51a, 0x51e, 0x522, 0x527, 0x52b, 0x52e, 0x52e, 0x535,
+0x537, 0x53a, 0x53e, 0x545, 0x547, 0x548, 0x54e, 0x553, 0x555, 0x558,
+0x55a, 0x561, 0x561, 0x564, 0x567, 0x56d, 0x56e, 0x573, 0x575, 0x57a,
+0x57d, 0x57f, 0x584, 0x589, 0x58b, 0x58e, 0x591, 0x592, 0x596, 0x597,
+0x59c, 0x59f, 0x5a1, 0x5a2, 0x5a7, 0x5aa, 0x5ab, 0x5af, 0x5b2, 0x5b7,
+0x5b8, 0x5bb, 0x5be, 0x5c0, 0x5c1, 0x5c4, 0x5c9, 0x5ca, 0x5cb, 0x5d4,
+0x5d5, 0x5da, 0x5dd, 0x5e0, 0x5e1, 0x5e4, 0x5e6, 0x5e7, 0x5ec, 0x5eb,
+0x5f2, 0x5f1, 0x5f4, 0x5f5, 0x5f9, 0x5fa, 0x5ff, 0x602, 0x607, 0x606,
+0x609, 0x60c, 0x60f, 0x612, 0x613, 0x618, 0x61d, 0x61f, 0x620, 0x623,
+0x626, 0x629, 0x62e, 0x62f, 0x634, 0x634, 0x637, 0x63a, 0x63d, 0x63c,
+0x642, 0x645, 0x648, 0x649, 0x64e, 0x64e, 0x653, 0x658, 0x659, 0x65b,
+0x65e, 0x661, 0x662, 0x66c, 0x66f, 0x670, 0x673, 0x677, 0x678, 0x67b,
+0x67f, 0x680, 0x683, 0x685, 0x688, 0x68b, 0x691, 0x690, 0x695, 0x695,
+0x698, 0x69b, 0x69d, 0x69c, 0x69f, 0x6a3, 0x6a4, 0x6aa, 0x6ad, 0x6ac,
+0x6b6, 0x6b9, 0x6bb, 0x6bc, 0x6be, 0x6c1, 0x6c4, 0x6c6, 0x6cb, 0x6cb,
+0x6cc, 0x6d2, 0x6d5, 0x6d9, 0x6da, 0x6dd, 0x6dd, 0x6e2, 0x6e2, 0x6e5,
+0x6e7, 0x6ea, 0x6ec, 0x6ed, 0x6f1, 0x6f4, 0x6fc, 0x6fd, 0x6ff, 0x701,
+0x700, 0x700, 0x703, 0x707, 0x708, 0x708, 0x709, 0x70b, 0x711, 0x710,
+0x714, 0x713, 0x713, 0x716, 0x71a, 0x71c, 0x71d, 0x71d, 0x71e, 0x722,
+0x722, 0x725, 0x727, 0x729, 0x72c, 0x726, 0x729, 0x72b, 0x72d, 0x730,
+0x732, 0x734, 0x737, 0x739, 0x73b, 0x73e, 0x740, 0x73a, 0x73d, 0x73f,
+0x741, 0x744, 0x746, 0x748, 0x74a, 0x74d, 0x74f, 0x751, 0x754, 0x74e,
+0x758, 0x75a, 0x75d, 0x75f, 0x759, 0x75c, 0x75e, 0x760, 0x762, 0x765,
+0x767, 0x769, 0x76b, 0x76e, 0x770, 0x772, 0x76c, 0x76e, 0x771, 0x773,
+0x775, 0x777, 0x77a, 0x77c, 0x77e, 0x780, 0x782, 0x785, 0x787, 0x789,
+0x78b, 0x78d, 0x788, 0x78a, 0x78c, 0x78e, 0x790, 0x792, 0x795, 0x797,
+0x799, 0x79b, 0x79d, 0x79f, 0x7a1, 0x7a4, 0x7a6, 0x7a8, 0x7a2, 0x7a4,
+0x7a6, 0x7a8, 0x7ab, 0x7ad, 0x7af, 0x7b1, 0x7b3, 0x7b5, 0x7b7, 0x7b9,
+0x7bb, 0x7b6, 0x7c0, 0x7c2, 0x7c4, 0x7c6, 0x7c0, 0x7ca, 0x7c4, 0x7ce,
+0x7c8, 0x7d2, 0x7d5, 0x7cf, 0x7d1, 0x7d3, 0x7d5, 0x7d7, 0x7d9, 0x7db,
+0x7dd, 0x7df, 0x7e1, 0x7db, 0x7e5, 0x7df, 0x7e1, 0x7e3, 0x7e5, 0x7e7,
+0x7e9, 0x7eb, 0x7ed, 0x7f0, 0x7f2, 0x7f4, 0x7f6, 0x7f8, 0x7fa, 0x7fc,
+0x7fe, 0x800, 0x802, 0x804, 0x806, 0x800, 0x80a, 0x804, 0x806, 0x808,
+0x812, 0x814, 0x80e, 0x80f, 0x811, 0x813, 0x815, 0x817, 0x819, 0x81b,
+0x81d, 0x81f, 0x821, 0x823, 0x825, 0x827, 0x829, 0x82b, 0x82d, 0x82f,
+0x831, 0x833, 0x835, 0x837, 0x839, 0x83a, 0x83c, 0x83e, 0x838, 0x842,
+0x844, 0x846, 0x840, 0x84a, 0x844, 0x84e, 0x850, 0x851, 0x853, 0x855,
+0x857, 0x859, 0x85b, 0x85d, 0x85f, 0x861, 0x863, 0x864, 0x866, 0x868,
+0x86a, 0x86c, 0x86e, 0x870, 0x872, 0x873, 0x875, 0x877, 0x879, 0x87b,
+0x87d, 0x87f, 0x881, 0x882, 0x884, 0x886, 0x888, 0x88a, 0x88c, 0x88d,
+0x88f, 0x891, 0x893, 0x895, 0x897, 0x899, 0x89a, 0x89c, 0x89e, 0x8a0,
+0x8a2, 0x8a4, 0x8a5, 0x8a7, 0x8a9, 0x8ab, 0x8ad, 0x8ae, 0x8b8, 0x8ba,
+0x8bc, 0x8b6, 0x8bf, 0x8c1, 0x8c3, 0x8c5, 0x8c7, 0x8c8, 0x8ca, 0x8cc,
+0x8ce, 0x8d0, 0x8d1, 0x8d3, 0x8d5, 0x8d7, 0x8d9, 0x8e2, 0x8dc, 0x8de,
+0x8e0, 0x8e1, 0x8e3, 0x8e5, 0x8e7, 0x8e9, 0x8ea, 0x8ec, 0x8ee, 0x8f0,
+0x8f1, 0x8f3, 0x8f5, 0x8f7, 0x900, 0x902, 0x904, 0x906, 0x907, 0x909,
+0x90b, 0x90d, 0x90e, 0x910, 0x912, 0x914, 0x915, 0x917, 0x919, 0x91b,
+0x91c, 0x91e, 0x920, 0x921, 0x923, 0x925, 0x927, 0x928, 0x92a, 0x92c,
+0x92d, 0x937, 0x931, 0x933, 0x93c, 0x93e, 0x938, 0x939, 0x93b, 0x93d,
+0x93f, 0x948, 0x94a, 0x944, 0x94d, 0x94f, 0x951, 0x952, 0x954, 0x956,
+0x957, 0x959, 0x95b, 0x95d, 0x95e, 0x960, 0x962, 0x963, 0x96d, 0x967,
+0x970, 0x972, 0x96c, 0x96d, 0x96f, 0x979, 0x97a, 0x97c, 0x97e, 0x977,
+0x981, 0x983, 0x984, 0x986, 0x988, 0x989, 0x98b, 0x98d, 0x98e, 0x990,
+0x991, 0x99b, 0x995, 0x996, 0x998, 0x99a, 0x99b, 0x9a5, 0x99f, 0x9a8,
+0x9a2, 0x9a3, 0x9ad, 0x9af, 0x9b0, 0x9b2, 0x9ac, 0x9b5, 0x9b7, 0x9b8,
+0x9ba, 0x9bc, 0x9bd, 0x9bf, 0x9c1, 0x9c2, 0x9c4, 0x9c5, 0x9c7, 0x9c9,
+0x9d2, 0x9cc, 0x9d5, 0x9d7, 0x9d1, 0x9d2, 0x9dc, 0x9dd, 0x9df, 0x9e1,
+0x9e2, 0x9e4, 0x9e5, 0x9e7, 0x9e9, 0x9ea, 0x9ec, 0x9ed, 0x9ef, 0x9f1,
+0x9f2, 0x9f4, 0x9f5, 0x9f7, 0xa01, 0xa02, 0xa04, 0xa05, 0x9ff, 0xa08,
+0xa0a, 0xa0c, 0xa0d, 0xa0f, 0xa10, 0xa12, 0xa13, 0xa1d, 0xa16, 0xa18,
+0xa1a, 0xa1b, 0xa25, 0xa1e, 0xa28, 0xa21, 0xa2b, 0xa2d, 0xa2e, 0xa30,
+0xa31, 0xa33, 0xa34, 0xa36, 0xa37, 0xa39, 0xa3a, 0xa3c, 0xa3e, 0xa3f,
+0xa41, 0xa42, 0xa4c, 0xa45, 0xa4f, 0xa50, 0xa52, 0xa53, 0xa55, 0xa56,
+0xa58, 0xa59, 0xa5b, 0xa5d, 0xa5e, 0xa60, 0xa61, 0xa63, 0xa6c, 0xa66,
+0xa6c, 0xa71, 0xa6c, 0xa71, 0xa72, 0xa74, 0xa78, 0xa7a, 0xa7b, 0xa7d,
+0xa7e, 0xa80, 0xa81, 0xa83, 0xa8a, 0xa86, 0xa8d, 0xa89, 0xa8d, 0xa8f,
+0xa8d, 0xa8f, 0xa90, 0xa92, 0xa93, 0xa95, 0xa96, 0xa98, 0xa96, 0xa9b,
+0xa9c, 0xa9b, 0xa9f, 0xa9e, 0xa9f, 0xaa1, 0xa9f, 0xaa1, 0xaa5, 0xaa4,
+0xaa5, 0xaaa, 0xaa8, 0xaaa, 0xaab, 0xaac, 0xaab, 0xaaf, 0xaab, 0xaaf,
+0xab1, 0xab2, 0xab1, 0xab5, 0xab4, 0xab5, 0xaba, 0xab8, 0xaba, 0xab8,
+0xabf, 0xabe, 0xabf, 0xac4, 0xac5, 0xac4, 0xac8, 0xac4, 0xac8, 0xaca,
+0xac8, 0xac9, 0xace, 0xacc, 0xace, 0xacf, 0xad1, 0xacf, 0xad4, 0xad5,
+0xad3, 0xad8, 0xad6, 0xad8, 0xad9, 0xad8, 0xad9, 0xade, 0xadc, 0xadd,
+0xae2, 0xae3, 0xae2, 0xae6, 0xae2, 0xae6, 0xae7, 0xae6, 0xae7, 0xae9,
+0xae7, 0xaec, 0xaea, 0xaee, 0xaf0, 0xaee, 0xaf3, 0xaf1, 0xaef, 0xaf4,
+0xaf5, 0xaf4, 0xaf8, 0xafa, 0xaf8, 0xafc, 0xafb, 0xaf9, 0xafe, 0xaff,
+0xb00, 0xb02, 0xb00, 0xb02, 0xb03, 0xb04, 0xb03, 0xb04, 0xb06, 0xb07,
+0xb08, 0xb0d, 0xb0b, 0xb0d, 0xb0e, 0xb0f, 0xb11, 0xb0f, 0xb11, 0xb12,
+0xb13, 0xb15, 0xb13, 0xb15, 0xb19, 0xb14, 0xb1c, 0xb1d, 0xb1b, 0xb1d,
+0xb1e, 0xb20, 0xb27, 0xb25, 0xb2a, 0xb2b, 0xb2a, 0xb28, 0xb2c, 0xb2b,
+0xb2c, 0xb30, 0xb32, 0xb30, 0xb2f, 0xb33, 0xb31, 0xb36, 0xb37, 0xb35,
+0xb3a, 0xb35, 0xb39, 0xb3b, 0xb3c, 0xb3b, 0xb3f, 0xb3d, 0xb3f, 0xb40,
+0xb44, 0xb40, 0xb44, 0xb45, 0xb44, 0xb48, 0xb4a, 0xb4b, 0xb49, 0xb4e,
+0xb49, 0xb4d, 0xb52, 0xb4d, 0xb51, 0xb53, 0xb51, 0xb55, 0xb57, 0xb55,
+0xb54, 0xb56, 0xb57, 0xb58, 0xb5a, 0xb5b, 0xb5c, 0xb5e, 0xb5f, 0xb60,
+0xb62, 0xb63, 0xb64, 0xb66, 0xb67, 0xb68, 0xb6a, 0xb6b, 0xb6c, 0xb6e,
+0xb67, 0xb70, 0xb6a, 0xb73, 0xb74, 0xb6e, 0xb6f, 0xb70, 0xb72, 0xb7b,
+0xb74, 0xb76, 0xb77, 0xb78, 0xb7a, 0xb7b, 0xb7c, 0xb7e, 0xb7f, 0xb80,
+0xb82, 0xb83, 0xb84, 0xb86, 0xb87, 0xb88, 0xb89, 0xb8b, 0xb8c, 0xb85,
+0xb8f, 0xb90, 0xb89, 0xb93, 0xb94, 0xb95, 0xb97, 0xb98, 0xb91, 0xba2,
+0xba4, 0xba5, 0xba6, 0xbb0, 0xba9, 0xbaa, 0xbac, 0xbad, 0xbae, 0xbb7,
+0xbb1, 0xbb2, 0xbb3, 0xbb5, 0xbb6, 0xbb7, 0xbb9, 0xbba, 0xbbb, 0xbbc,
+0xbbe, 0xbbf, 0xbc0, 0xbc2, 0xbc3, 0xbc4, 0xbc5, 0xbc7, 0xbc8, 0xbc9,
+0xbcb, 0xbcc, 0xbcd, 0xbce, 0xbc8, 0xbd1, 0xbd2, 0xbd3, 0xbcd, 0xbce,
+0xbcf, 0xbd1, 0xbd2, 0xbd3, 0xbd4, 0xbd6, 0xbd7, 0xbd8, 0xbda, 0xbcb,
+0xbcc, 0xbcd, 0xbcf, 0xbd0, 0xbd1, 0xbd2, 0xbd4, 0xbd5, 0xbd6, 0xbd7,
+0xbd9, 0xbe2, 0xbdb, 0xbdc, 0xbde, 0xbdf, 0xbe0, 0xbe2, 0xbe3, 0xbdc,
+0xbe5, 0xbe7, 0xbe8, 0xbe1, 0xbea, 0xbe4, 0xbe5, 0xbee, 0xbef, 0xbe9,
+0xbf2, 0xbeb, 0xbf4, 0xbee, 0xbf7, 0xbf0, 0xbf1, 0xbf3, 0xbf4, 0xbfd,
+0xbf6, 0xbf8, 0xc01, 0xbfa, 0xbfb, 0xbfd, 0xbfe, 0xbff, 0xc00, 0xc02,
+0xc03, 0xc04, 0xc05, 0xc06, 0xc08, 0xc09, 0xc0a, 0xc0b, 0xc15, 0xc0e,
+0xc0f, 0xc10, 0xc12, 0xc13, 0xc14, 0xc0d, 0xc0f, 0xc18, 0xc19, 0xc1a,
+0xc13, 0xc1d, 0xc16, 0xc1f, 0xc20, 0xc1a, 0xc1b, 0xc1c, 0xc1d, 0xc26,
+0xc20, 0xc21, 0xc22, 0xc23, 0xc25, 0xc26, 0xc27, 0xc28, 0xc29, 0xc2b,
+0xc2c, 0xc2d, 0xc2e, 0xc30, 0xc31, 0xc32, 0xc33, 0xc34, 0xc36, 0xc37,
+0xc40, 0xc41, 0xc3a, 0xc3c, 0xc3d, 0xc46, 0xc3f, 0xc40, 0xc42, 0xc43,
+0xc4c, 0xc45, 0xc47, 0xc48, 0xc49, 0xc4a, 0xc4b, 0xc4d, 0xc4e, 0xc4f,
+0xc50, 0xc51, 0xc53, 0xc54, 0xc55, 0xc56, 0xc57, 0xc59, 0xc5a, 0xc5b,
+0xc5c, 0xc5d, 0xc5f, 0xc60, 0xc61, 0xc62, 0xc63, 0xc64, 0xc66, 0xc67,
+0xc68, 0xc69, 0xc6a, 0xc6c, 0xc6d, 0xc6e, 0xc6f, 0xc70, 0xc72, 0xc73,
+0xc74, 0xc75, 0xc76, 0xc77, 0xc79, 0xc7a, 0xc7b, 0xc7c, 0xc75, 0xc7f,
+0xc80, 0xc81, 0xc82, 0xc7b, 0xc84, 0xc86, 0xc87, 0xc80, 0xc89, 0xc8a,
+0xc84, 0xc8d, 0xc86, 0xc87, 0xc90, 0xc91, 0xc93, 0xc94, 0xc95, 0xc96,
+0xc97, 0xc98, 0xc9a, 0xc9b, 0xc94, 0xc9d, 0xc96, 0xc9f, 0xca1, 0xc9a,
+0xca3, 0xc9c, 0xca5, 0xca6, 0xca8, 0xca1, 0xcaa, 0xca3, 0xca4, 0xcad,
+0xca7, 0xca8, 0xcb1, 0xcaa, 0xcb3, 0xcb4, 0xcad, 0xcaf, 0xcb8, 0xcb1,
+0xcb2, 0xcb3, 0xcb4, 0xcb6, 0xcb7, 0xcb8, 0xcb9, 0xcc2, 0xcbb, 0xcbc,
+0xcbe, 0xcbf, 0xcc0, 0xcc9, 0xcc2, 0xcc3, 0xcc5, 0xcc6, 0xcc7, 0xcd0,
+0xcd1, 0xcca, 0xccb, 0xccd, 0xcd6, 0xcd7, 0xcd0, 0xcd9, 0xcd2, 0xcdb,
+0xcd5, 0xcde, 0xcdf, 0xcd8, 0xce1, 0xce2, 0xce3, 0xcdd, 0xce6, 0xce7,
+0xce8, 0xce9, 0xcea, 0xceb, 0xcec, 0xcee, 0xce7, 0xcf0, 0xcf1, 0xcf2,
+0xcf3, 0xcf4, 0xcf6, 0xcf7, 0xcf8, 0xcf9, 0xcfa, 0xcfb, 0xcf4, 0xcf5,
+0xcf7, 0xcf8, 0xcf9, 0xd02, 0xd03, 0xd04, 0xd05, 0xd06, 0xd08, 0xd09,
+0xd0a, 0xd0b, 0xd0c, 0xd0d, 0xd0e, 0xd0f, 0xd11, 0xd12, 0xd13, 0xd14,
+0xd15, 0xd16, 0xd17, 0xd18, 0xd1a, 0xd1b, 0xd1c, 0xd1d, 0xd1e, 0xd1f,
+0xd20, 0xd21, 0xd22, 0xd24, 0xd25, 0xd26, 0xd27, 0xd28, 0xd29, 0xd2a,
+0xd2b, 0xd2c, 0xd2e, 0xd2f, 0xd30, 0xd31, 0xd32, 0xd33, 0xd34, 0xd35,
+0xd36, 0xd38, 0xd39, 0xd3a, 0xd3b, 0xd3c, 0xd3d, 0xd3e, 0xd3f, 0xd40,
+0xd41, 0xd43, 0xd44, 0xd45, 0xd46, 0xd47, 0xd48, 0xd49, 0xd4a, 0xd4b,
+0xd4c, 0xd4e, 0xd4f, 0xd50, 0xd51, 0xd52, 0xd4b, 0xd54, 0xd55, 0xd4e,
+0xd57, 0xd58, 0xd52, 0xd5b, 0xd5c, 0xd55, 0xd5e, 0xd5f, 0xd58, 0xd61,
+0xd62, 0xd63, 0xd64, 0xd66, 0xd67, 0xd68, 0xd69, 0xd6a, 0xd73, 0xd74,
+0xd6d, 0xd6e, 0xd6f, 0xd70, 0xd72, 0xd7b, 0xd74, 0xd75, 0xd76, 0xd77,
+0xd78, 0xd79, 0xd82, 0xd7b, 0xd84, 0xd7d, 0xd7f, 0xd80, 0xd81, 0xd82,
+0xd8b, 0xd84, 0xd8d, 0xd8e, 0xd87, 0xd88, 0xd91, 0xd8a, 0xd93, 0xd94,
+0xd8e, 0xd97, 0xd98, 0xd91, 0xd92, 0xd9b, 0xd9c, 0xd95, 0xd96, 0xd9f,
+0xda0, 0xda1, 0xda2, 0xda3, 0xda5, 0xda6, 0xd9f, 0xda8, 0xda9, 0xdaa,
+0xdab, 0xdac, 0xdad, 0xdae, 0xdaf, 0xdb0, 0xdb1, 0xdb2, 0xdb3, 0xdb5,
+0xdb6, 0xdb7, 0xdb8, 0xdb9, 0xdba, 0xdbb, 0xdbc, 0xdbd, 0xdbe, 0xdbf,
+0xdc0, 0xdc1, 0xdc2, 0xdc3, 0xdc4, 0xdc5, 0xdc7, 0xdc8, 0xdc9, 0xdca,
+0xdcb, 0xdcc, 0xdcd, 0xdce, 0xdcf, 0xdd0, 0xdd1, 0xdd2, 0xddb, 0xdd4,
+0xdd5, 0xdd6, 0xdd7, 0xdd8, 0xdd9, 0xddb, 0xddc, 0xddd, 0xdde, 0xddf,
+0xde0, 0xde1, 0xde2, 0xde3, 0xde4, 0xde5, 0xdee, 0xdef, 0xde8, 0xdf1,
+0xdea, 0xdeb, 0xdf4, 0xdf5, 0xdee, 0xdf7, 0xdf8, 0xdf2, 0xdfb, 0xdfc,
+0xdf5, 0xdfe, 0xdff, 0xe00, 0xe01, 0xe02, 0xe03, 0xe04, 0xe05, 0xe06,
+0xe07, 0xe08, 0xe09, 0xe0a, 0xe0b, 0xe0c, 0xe0d, 0xe0e, 0xe0f, 0xe10,
+0xe11, 0xe12, 0xe13, 0xe14, 0xe16, 0xe17, 0xe18, 0xe19, 0xe1a, 0xe1b,
+0xe1c, 0xe1d, 0xe1e, 0xe1f, 0xe20, 0xe21, 0xe22, 0xe23, 0xe24, 0xe25,
+0xe26, 0xe2f, 0xe28, 0xe29, 0xe32, 0xe2b, 0xe2c, 0xe2d, 0xe2e, 0xe2f,
+0xe38, 0xe39, 0xe32, 0xe33, 0xe3c, 0xe3d, 0xe36, 0xe3f, 0xe38, 0xe41,
+0xe42, 0xe43, 0xe3c, 0xe45, 0xe47, 0xe48, 0xe49, 0xe42, 0xe4b, 0xe4c,
+0xe4d, 0xe4e, 0xe4f, 0xe50, 0xe49, 0xe52, 0xe4b, 0xe54, 0xe55, 0xe4e,
+0xe4f, 0xe50, 0xe59, 0xe5a, 0xe5b, 0xe5c, 0xe55, 0xe5e, 0xe5f, 0xe60,
+0xe61, 0xe6a, 0xe63, 0xe64, 0xe6d, 0xe66, 0xe67, 0xe68, 0xe69, 0xe6a,
+0xe6b, 0xe6c, 0xe6d, 0xe6e, 0xe6f, 0xe70, 0xe79, 0xe72, 0xe73, 0xe7c,
+0xe75, 0xe7e, 0xe7f, 0xe80, 0xe81, 0xe82, 0xe83, 0xe84, 0xe85, 0xe7e,
+0xe87, 0xe88, 0xe89, 0xe8a, 0xe8b, 0xe8c, 0xe8d, 0xe8e, 0xe8f, 0xe90,
+0xe91, 0xe92, 0xe93, 0xe94, 0xe95, 0xe96, 0xe97, 0xe98, 0xe99, 0xe9a,
+0xe9b, 0xe9c, 0xe9d, 0xe9e, 0xe9f, 0xea0, 0xea1, 0xea2, 0xea3, 0xeac,
+0xea5, 0xea6, 0xea7, 0xea8, 0xea9, 0xeb2, 0xeab, 0xeac, 0xeb5, 0xeae,
+0xeaf, 0xeb8, 0xeb9, 0xeba, 0xebb, 0xeb4, 0xebd, 0xebe, 0xebf, 0xec0,
+0xec1, 0xec2, 0xebb, 0xec4, 0xec5, 0xec6, 0xec7, 0xec7, 0xec8, 0xec9,
+0xeca, 0xecb, 0xecc, 0xecd, 0xece, 0xecf, 0xed0, 0xed1, 0xed2, 0xed3,
+0xed4, 0xed5, 0xede, 0xed7, 0xed8, 0xee1, 0xeda, 0xedb, 0xee4, 0xee5,
+0xede, 0xee7, 0xee0, 0xee9, 0xeea, 0xee3, 0xeec, 0xeed, 0xeee, 0xeef,
+0xee8, 0xef1, 0xef2, 0xeeb, 0xef4, 0xeed, 0xef6, 0xef7, 0xef0, 0xef8,
+0xef9, 0xefa, 0xefb, 0xefc, 0xefd, 0xefe, 0xeff, 0xf00, 0xf01, 0xf0a,
+0xf0b, 0xf04, 0xf0d, 0xf06, 0xf07, 0xf10, 0xf11, 0xf0a, 0xf13, 0xf0c,
+0xf0d, 0xf16, 0xf17, 0xf18, 0xf19, 0xf1a, 0xf13, 0xf1c, 0xf1c, 0xf1d,
+0xf1e, 0xf1f, 0xf20, 0xf21, 0xf22, 0xf23, 0xf24, 0xf25, 0xf26, 0xf27,
+0xf28, 0xf29, 0xf2a, 0xf2b, 0xf2c, 0xf2d, 0xf36, 0xf2f, 0xf30, 0xf39,
+0xf32, 0xf33, 0xf3b, 0xf34, 0xf3d, 0xf3e, 0xf3f, 0xf38, 0xf41, 0xf42,
+0xf43, 0xf44, 0xf45, 0xf46, 0xf47, 0xf48, 0xf49, 0xf4a, 0xf4b, 0xf4c,
+0xf4d, 0xf4e, 0xf4f, 0xf4f, 0xf50, 0xf51, 0xf52, 0xf53, 0xf4c, 0xf55,
+0xf56, 0xf57, 0xf58, 0xf59, 0xf5a, 0xf5b, 0xf5c, 0xf5d, 0xf5e, 0xf5f,
+0xf60, 0xf69, 0xf69, 0xf6a, 0xf6b, 0xf6c, 0xf6d, 0xf6e, 0xf6f, 0xf68,
+0xf71, 0xf72, 0xf73, 0xf74, 0xf75, 0xf76, 0xf77, 0xf78, 0xf79, 0xf79,
+0xf7a, 0xf7b, 0xf7c, 0xf7d, 0xf7e, 0xf7f, 0xf80, 0xf81, 0xf82, 0xf83,
+0xf8c, 0xf85, 0xf86, 0xf8f, 0xf88, 0xf90, 0xf89, 0xf8a, 0xf93, 0xf94,
+0xf95, 0xf96, 0xf97, 0xf90, 0xf91, 0xf9a, 0xf9b, 0xf9c, 0xf9d, 0xf9e,
+0xf9e, 0xf9f, 0xfa0, 0xfa1, 0xfa2, 0xfa3, 0xfa4, 0xfa5, 0xfa6, 0xfa7,
+0xfa8, 0xfa9, 0xfaa, 0xfab, 0xfb3, 0xfac, 0xfad, 0xfae, 0xfaf, 0xfb0,
+0xfb9, 0xfba, 0xfbb, 0xfb4, 0xfbd, 0xfbe, 0xfbf, 0xfb7, 0xfc0, 0xfc1,
+0xfc2, 0xfc3, 0xfc4, 0xfc5, 0xfc6, 0xfc7, 0xfc8, 0xfc9, 0xfca, 0xfcb,
+0xfcb, 0xfcc, 0xfcd, 0xfce, 0xfcf, 0xfd0, 0xfd1, 0xfda, 0xfd3, 0xfd4,
+0xfd5, 0xfd6, 0xfd7, 0xfd7, 0xfd8, 0xfe1, 0xfda, 0xfdb, 0xfdc, 0xfdd,
+0xfde, 0xfdf, 0xfe0, 0xfe9, 0xfea, 0xfea, 0xfeb, 0xfec, 0xfed, 0xfee,
+0xfef, 0xff0, 0xff1, 0xff2, 0xff3, 0xff4, 0xff4, 0xff5, 0xff6, 0xff7,
+0xff8, 0xff9, 0xffa, 0xffb, 0xffc, 0xffd, 0xffe, 0xfff, 0xc43, 0xc43,
+0xc44, 0xc41, 0xc41, 0xc42, 0xc46, 0xc43, 0xc43, 0xc44, 0xc44, 0xc45,
+0xc46, 0xc46, 0xc47, 0xc47, 0xc48, 0xc48, 0xc49, 0xc49, 0xc4a, 0xc4b,
+0xc4b, 0xc4c, 0xc4c, 0xc4d, 0xc4d, 0xc4e, 0xc4e, 0xc4f, 0xc50, 0xc50,
+0xc51, 0xc51, 0xc52, 0xc52, 0xc53, 0xc53, 0xc54, 0xc55, 0xc55, 0xc56,
+0xc56, 0xc57, 0xc57, 0xc58, 0xc58, 0xc59, 0xc5a, 0xc5a, 0xc5b, 0xc5b,
+0xc5c, 0xc5c, 0xc5d, 0xc5d, 0xc5a, 0xc5e, 0xc5f, 0xc60, 0xc5c, 0xc5d,
+0xc5d, 0xc5e, 0xc5e, 0xc5f, 0xc5f, 0xc60, 0xc61, 0xc61, 0xc62, 0xc62,
+0xc5f, 0xc63, 0xc64, 0xc64, 0xc65, 0xc65, 0xc66, 0xc67, 0xc67, 0xc68,
+0xc68, 0xc69, 0xc69, 0xc66, 0xc66, 0xc67, 0xc6b, 0xc68, 0xc65, 0xc6d,
+0xc6a, 0xc6a, 0xc67, 0xc6f, 0xc6c, 0xc6c, 0xc71, 0xc69, 0xc6e, 0xc6b,
+0xc6f, 0xc70, 0xc6c, 0xc71, 0xc71, 0xc72, 0xc72, 0xc73, 0xc73, 0xc70,
+0xc71, 0xc75, 0xc72, 0xc72, 0xc73, 0xc77, 0xc78, 0xc78, 0xc75, 0xc75,
+0xc76, 0xc77, 0xc77, 0xc7c, 0xc78, 0xc79, 0xc79, 0xc7e, 0xc7e, 0xc7f,
+0xc7f, 0xc80, 0xc81, 0xc81, 0xc82, 0xc8a, 0xc8b, 0xc8b, 0xc8c, 0xc8c,
+0xc8d, 0xc8d, 0xc8e, 0xc8e, 0xc8f, 0xc8c, 0xc90, 0xc8d, 0xc91, 0xc92,
+0xc92, 0xc8f, 0xc8f, 0xc90, 0xc94, 0xc95, 0xc95, 0xc92, 0xc93, 0xc93,
+0xc94, 0xc94, 0xc95, 0xc95, 0xc96, 0xc96, 0xc93, 0xc97, 0xc98, 0xc98,
+0xc99, 0xc96, 0xc96, 0xc97, 0xc9b, 0xc9c, 0xc9c, 0xc9d, 0xc99, 0xc9a,
+0xc9a, 0xc9b, 0xc9f, 0xc9c, 0xca1, 0xc9d, 0xc9e, 0xc9e, 0xc9b, 0xc9f,
+0xca0, 0xca0, 0xca1, 0xca1, 0xca2, 0xca2, 0xca7, 0xc9f, 0xca4, 0xca1,
+0xca5, 0xca6, 0xcaa, 0xca7, 0xca7, 0xca8, 0xca8, 0xca9, 0xca9, 0xcaa,
+0xca6, 0xcab, 0xcab, 0xcac, 0xcad, 0xca9, 0xcae, 0xcae, 0xcaf, 0xcaf,
+0xcac, 0xcac, 0xcad, 0xcb1, 0xcb2, 0xcb2, 0xcaf, 0xcb3, 0xcb0, 0xcb1,
+0xcb1, 0xcb2, 0xcb6, 0xcb3, 0xcb3, 0xcb4, 0xcb4, 0xcb5, 0xcb5, 0xcba,
+0xcb6, 0xcb7, 0xcb7, 0xcb8, 0xcbc, 0xcb9, 0xcba, 0xcba, 0xcbb, 0xcbb,
+0xcbc, 0xcc0, 0xcbd, 0xcbd, 0xcba, 0xcba, 0xcbb, 0xcbf, 0xcc0, 0xcbc,
+0xcc1, 0xcbd, 0xcc2, 0xcbf, 0xcc3, 0xcc0, 0xcc4, 0xcc1, 0xcc1, 0xcc2,
+0xcc2, 0xccb, 0xcc7, 0xccc, 0xccc, 0xcc9, 0xcc9, 0xcce, 0xcd2, 0xccf,
+0xccb, 0xccc, 0xccd, 0xcd1, 0xcce, 0xcd2, 0xccf, 0xccf, 0xcd0, 0xcd0,
+0xcd1, 0xcd1, 0xcd2, 0xcd2, 0xcd3, 0xcd3, 0xcd4, 0xcd4, 0xcd5, 0xcd5,
+0xcd6, 0xcd7, 0xcd7, 0xcd4, 0xcd4, 0xcd5, 0xcd5, 0xcda, 0xcd6, 0xcd7,
+0xcd7, 0xcd8, 0xcdc, 0xcd5, 0xcdd, 0xcda, 0xcda, 0xcd7, 0xcdb, 0xcd8,
+0xcdc, 0xcdd, 0xcdd, 0xcda, 0xcdb, 0xcdb, 0xce0, 0xce0, 0xcdd, 0xcdd,
+0xcde, 0xcde, 0xce3, 0xcdf, 0xce0, 0xce0, 0xce1, 0xce1, 0xcde, 0xce2,
+0xce3, 0xce3, 0xce0, 0xce4, 0xce1, 0xce1, 0xce2, 0xce2, 0xce3, 0xce4,
+0xce8, 0xce5, 0xce5, 0xce6, 0xce6, 0xce7, 0xce7, 0xce8, 0xce8, 0xce9,
+0xce9, 0xcea, 0xcea, 0xceb, 0xceb, 0xce8, 0xce8, 0xced, 0xced, 0xcea,
+0xcea, 0xcef, 0xcef, 0xcf0, 0xcf0, 0xced, 0xcee, 0xcee, 0xcef, 0xcf3,
+0xcf0, 0xcf0, 0xcf1, 0xcf1, 0xcf2, 0xcf2, 0xcf3, 0xcf3, 0xcf8, 0xcf4,
+0xcf5, 0xcf5, 0xcf6, 0xcfa, 0xcf7, 0xcf7, 0xcf8, 0xcf8, 0xcf5, 0xcf9,
+0xcfa, 0xcfa, 0xcfb, 0xcfb, 0xcfc, 0xcfc, 0xcfd, 0xcfd, 0xd06, 0xd07,
+0xd03, 0xd04, 0xd04, 0xd05, 0xd05, 0xd06, 0xd0a, 0xd0b, 0xd0b, 0xd08,
+0xd08, 0xd09, 0xd0d, 0xd0a, 0xd0a, 0xd0b, 0xd0b, 0xd0c, 0xd0c, 0xd0d,
+0xd0d, 0xd12, 0xd12, 0xd13, 0xd13, 0xd14, 0xd14, 0xd11, 0xd15, 0xd0e,
+0xd16, 0xd1b, 0xd17, 0xd14, 0xd18, 0xd15, 0xd19, 0xd16, 0xd1a, 0xd1b,
+0xd1b, 0xd18, 0xd1c, 0xd1d, 0xd1a, 0xd1a, 0xd1b, 0xd1b, 0xd1c, 0xd1c,
+0xd1d, 0xd21, 0xd1e, 0xd22, 0xd1f, 0xd1f, 0xd24, 0xd20, 0xd21, 0xd21,
+0xd22, 0xd22, 0xd1f, 0xd23, 0xd20, 0xd24, 0xd25, 0xd25, 0xd26, 0xd26,
+0xd23, 0xd27, 0xd28, 0xd28, 0xd25, 0xd25, 0xd26, 0xd26, 0xd27, 0xd2b,
+0xd28, 0xd2c, 0xd29, 0xd29, 0xd2e, 0xd2a, 0xd2b, 0xd2b, 0xd2c, 0xd2c,
+0xd2d, 0xd29, 0xd2a, 0xd2e, 0xd33, 0xd33, 0xd34, 0xd30, 0xd31, 0xd35,
+0xd36, 0xd32, 0xd37, 0xd37, 0xd30, 0xd34, 0xd39, 0xd35, 0xd36, 0xd3a,
+0xd37, 0xd3b, 0xd38, 0xd3c, 0xd3d, 0xd3d, 0xd3a, 0xd3e, 0xd3b, 0xd3f,
+0xd40, 0xd40, 0xd3d, 0xd3d, 0xd3e, 0xd3e, 0xd3b, 0xd43, 0xd40, 0xd40,
+0xd45, 0xd41, 0xd42, 0xd42, 0xd4b, 0xd4b, 0xd4c, 0xd4c, 0xd4d, 0xd4d,
+0xd4e, 0xd4e, 0xd4b, 0xd4f, 0xd4c, 0xd50, 0xd51, 0xd4d, 0xd4e, 0xd4e,
+0xd4f, 0xd53, 0xd50, 0xd50, 0xd51, 0xd51, 0xd52, 0xd52, 0xd53, 0xd53,
+0xd50, 0xd54, 0xd55, 0xd55, 0xd52, 0xd56, 0xd53, 0xd53, 0xd58, 0xd54,
+0xd55, 0xd59, 0xd5a, 0xd56, 0xd53, 0xd57, 0xd58, 0xd58, 0xd5d, 0xd59,
+0xd5a, 0xd5a, 0xd5b, 0xd5f, 0xd5c, 0xd5c, 0xd5d, 0xd5d, 0xd5e, 0xd5e,
+0xd5f, 0xd5f, 0xd60, 0xd60, 0xd61, 0xd61, 0xd62, 0xd62, 0xd63, 0xd63,
+0xd64, 0xd60, 0xd65, 0xd65, 0xd62, 0xd66, 0xd63, 0xd63, 0xd64, 0xd68,
+0xd69, 0xd69, 0xd6a, 0xd6a, 0xd67, 0xd67, 0xd68, 0xd68, 0xd69, 0xd69,
+0xd6a, 0xd66, 0xd6f, 0xd6f, 0xd70, 0xd70, 0xd6d, 0xd71, 0xd6e, 0xd72,
+0xd73, 0xd73, 0xd74, 0xd70, 0xd71, 0xd71, 0xd7a, 0xd76, 0xd73, 0xd73,
+0xd74, 0xd78, 0xd75, 0xd79, 0xd7a, 0xd7a, 0xd77, 0xd77, 0xd78, 0xd78,
+0xd79, 0xd79, 0xd79, 0xd7a, 0xd76, 0xd7b, 0xd77, 0xd7c, 0xd7c, 0xd7d,
+0xd7d, 0xd7e, 0xd7a, 0xd7f, 0xd7b, 0xd7c, 0xd7c, 0xd81, 0xd81, 0xd7e,
+0xd82, 0xd87, 0xd87, 0xd84, 0xd88, 0xd89, 0xd85, 0xd8a, 0xd8a, 0xd8b,
+0xd87, 0xd8c, 0xd88, 0xd89, 0xd8d, 0xd8a, 0xd8e, 0xd8b, 0xd8f, 0xd8c,
+0xd8c, 0xd8d, 0xd8d, 0xd92, 0xd8e, 0xd8f, 0xd8f, 0xd93, 0xd90, 0xd90,
+0xd8d, 0xd95, 0xd92, 0xd92, 0xd93, 0xd93, 0xd98, 0xd94, 0xd99, 0xd95,
+0xd96, 0xd9a, 0xd97, 0xd93, 0xd94, 0xd9c, 0xd99, 0xd99, 0xd9a, 0xd9a,
+0xd9b, 0xd9b, 0xd9c, 0xd9c, 0xd9d, 0xd9d, 0xd9a, 0xda2, 0xd9f, 0xda3,
+0xda4, 0xda4, 0xda1, 0xda1, 0xda5, 0xd9e, 0xda2, 0xda3, 0xda3, 0xda0,
+0xda4, 0xda5, 0xda5, 0xda6, 0xda6, 0xda7, 0xdab, 0xda8, 0xda8, 0xda9,
+0xda9, 0xdaa, 0xdaa, 0xdab, 0xdaf, 0xdac, 0xdac, 0xdad, 0xda9, 0xdae,
+0xdae, 0xdab, 0xdaf, 0xdab, 0xdac, 0xdb0, 0xdb1, 0xdad, 0xdb2, 0xdae,
+0xdb3, 0xdb3, 0xdb0, 0xdb0, 0xdb5, 0xdb1, 0xdb2, 0xdb2, 0xdb3, 0xdb3,
+0xdb4, 0xdb4, 0xdb5, 0xdb5, 0xdb6, 0xdb6, 0xdb7, 0xdb7, 0xdb8, 0xdb4,
+0xdb8, 0xdb9, 0xdb9, 0xdba, 0xdba, 0xdbb, 0xdbb, 0xdbc, 0xdb8, 0xdb9,
+0xdb9, 0xdbe, 0xdbe, 0xdbf, 0xdbb, 0xdbc, 0xdc0, 0xdc5, 0xdc5, 0xdc6,
+0xdc6, 0xdc7, 0xdc7, 0xdc7, 0xdc4, 0xdc8, 0xdc9, 0xdc9, 0xdc6, 0xdc6,
+0xdcb, 0xdcf, 0xdcc, 0xdcc, 0xdcd, 0xdcd, 0xdca, 0xdce, 0xdcf, 0xdcf,
+0xdcc, 0xdcc, 0xdc9, 0xdcd, 0xdd2, 0xdd2, 0xdd2, 0xdd3, 0xdd3, 0xdd4,
+0xdd0, 0xdd1, 0xdd5, 0xdd2, 0xdda, 0xdd3, 0xdd7, 0xdd4, 0xdd8, 0xdd9,
+0xdd9, 0xdd6, 0xdd6, 0xdd7, 0xdd7, 0xddb, 0xdd8, 0xdd8, 0xdd9, 0xdd9,
+0xdd2, 0xdda, 0xddb, 0xddb, 0xddc, 0xdd8, 0xddd, 0xddd, 0xdde, 0xdde,
+0xddb, 0xddb, 0xddc, 0xddc, 0xddd, 0xddd, 0xde1, 0xdde, 0xdde, 0xddf,
+0xddf, 0xde0, 0xde0, 0xde1, 0xde1, 0xdde, 0xde2, 0xde3, 0xde3, 0xde4,
+0xde4, 0xde1, 0xde5, 0xde5, 0xde6, 0xde6, 0xde7, 0xde7, 0xde8, 0xde8,
+0xde9, 0xde5, 0xdea, 0xdea, 0xdeb, 0xdeb, 0xde8, 0xdec, 0xded, 0xdf5,
+0xdf1, 0xdf6, 0xdf2, 0xdf3, 0xdf3, 0xdf4, 0xdf8, 0xdf5, 0xdf5, 0xdf6,
+0xdf2, 0xdf7, 0xdf7, 0xdf8, 0xdf8, 0xdf9, 0xdf1, 0xdf9, 0xdf6, 0xdfa,
+0xdfb, 0xdfb, 0xdf8, 0xdfc, 0xdf9, 0xdf9, 0xdfe, 0xdfe, 0xdfb, 0xdff,
+0xdfc, 0xdfc, 0xdfd, 0xdfd, 0xe09, 0xe0a, 0xe06, 0xe0b, 0xe07, 0xe0c,
+0xe08, 0xe09, 0xe09, 0xe0a, 0xe0a, 0xe0b, 0xe0b, 0xe08, 0xe0c, 0xe10,
+0xe0d, 0xe11, 0xe0e, 0xe0e, 0xe13, 0xe13, 0xe10, 0xe10, 0xe11, 0xe11,
+0xe12, 0xe12, 0xe17, 0xe13, 0xe13, 0xe14, 0xe18, 0xe15, 0xe19, 0xe1a,
+0xe1a, 0xe1b, 0xe1b, 0xe18, 0xe18, 0xe15, 0xe19, 0xe1e, 0xe1a, 0xe1e,
+0xe1b, 0xe1b, 0xe1c, 0xe1c, 0xe1d, 0xe21, 0xe1a, 0xe1e, 0xe1f, 0xe1f,
+0xe20, 0xe20, 0xe20, 0xe21, 0xe21, 0xe22, 0xe22, 0xe23, 0xe23, 0xe24,
+0xe24, 0xe25, 0xe29, 0xe26, 0xe26, 0xe27, 0xe23, 0xe27, 0xe28, 0xe28,
+0xe29, 0xe25, 0xe26, 0xe26, 0xe27, 0xe27, 0xe28, 0xe28, 0xe29, 0xe29,
+0xe29, 0xe26, 0xe2a, 0xe27, 0xe27, 0xe2c, 0xe2c, 0xe29, 0xe29, 0xe2e,
+0xe2e, 0xe2f, 0xe2b, 0xe2b, 0xe2c, 0xe30, 0xe2d, 0xe2d, 0xe2e, 0xe32,
+0xe2f, 0xe2f, 0xe30, 0xe30, 0xe31, 0xe31, 0xe31, 0xe32, 0xe2e, 0xe33,
+0xe2f, 0xe34, 0xe34, 0xe31, 0xe35, 0xe32, 0xe32, 0xe37, 0xe37, 0xe37,
+0xe34, 0xe38, 0xe35, 0xe39, 0xe3a, 0xe3a, 0xe3b, 0xe3b, 0xe38, 0xe3c,
+0xe44, 0xe41, 0xe41, 0xe42, 0xe42, 0xe43, 0xe43, 0xe48, 0xe48, 0xe49,
+0xe49, 0xe46, 0xe46, 0xe46, 0xe4b, 0xe4b, 0xe48, 0xe48, 0xe45, 0xe49,
+0xe4e, 0xe4e, 0xe4b, 0xe4f, 0xe4b, 0xe4c, 0xe4c, 0xe51, 0xe4d, 0xe4e,
+0xe4e, 0xe4f, 0xe4f, 0xe4c, 0xe50, 0xe50, 0xe51, 0xe51, 0xe56, 0xe52,
+0xe53, 0xe57, 0xe58, 0xe54, 0xe59, 0xe59, 0xe56, 0xe56, 0xe5a, 0xe57,
+0xe5b, 0xe5c, 0xe58, 0xe59, 0xe5d, 0xe5e, 0xe5e, 0xe5f, 0xe5b, 0xe5f,
+0xe5c, 0xe60, 0xe5d, 0xe5d, 0xe5a, 0xe5e, 0xe5f, 0xe63, 0xe60, 0xe64,
+0xe64, 0xe65, 0xe61, 0xe62, 0xe62, 0xe63, 0xe63, 0xe64, 0xe64, 0xe65,
+0xe65, 0xe65, 0xe66, 0xe66, 0xe67, 0xe67, 0xe6c, 0xe68, 0xe69, 0xe69,
+0xe69, 0xe6a, 0xe6a, 0xe6b, 0xe6b, 0xe6c, 0xe6c, 0xe6d, 0xe71, 0xe6e,
+0xe6e, 0xe6e, 0xe6f, 0xe6f, 0xe70, 0xe70, 0xe71, 0xe71, 0xe6e, 0xe76,
+0xe73, 0xe73, 0xe73, 0xe74, 0xe74, 0xe71, 0xe79, 0xe76, 0xe76, 0xe77,
+0xe77, 0xe77, 0xe74, 0xe78, 0xe79, 0xe79, 0xe7a, 0xe7a, 0xe7b, 0xe7b,
+0xe80, 0xe7c, 0xe7c, 0xe7d, 0xe79, 0xe7e, 0xe7a, 0xe83, 0xe83, 0xe84,
+0xe84, 0xe84, 0xe85, 0xe85, 0xe86, 0xe86, 0xe8b, 0xe87, 0xe84, 0xe84,
+0xe89, 0xe89, 0xe85, 0xe86, 0xe8e, 0xe87, 0xe87, 0xe8c, 0xe90, 0xe89,
+0xe89, 0xe89, 0xe8e, 0xe8a, 0xe8f, 0xe8b, 0xe8c, 0xe8c, 0xe91, 0xe91,
+0xe8d, 0xe8e, 0xe92, 0xe8f, 0xe93, 0xe90, 0xe94, 0xe91, 0xe95, 0xe96,
+0xe96, 0xe96, 0xe97, 0xe93, 0xe98, 0xe98, 0xe99, 0xe9d, 0xe9a, 0xe9a,
+0xe9a, 0xe9b, 0xe9f, 0xe9c, 0xe9c, 0xe99, 0xe99, 0xe9e, 0xe9e, 0xe9e,
+0xea3, 0xe9f, 0xea4, 0xea0, 0xea1, 0xea1, 0xe9e, 0xea2, 0xea2, 0xea3,
+0xea3, 0xea4, 0xea8, 0xea1, 0xea9, 0xeaa, 0xea6, 0xea6, 0xea7, 0xea7,
+0xea8, 0xea8, 0xea9, 0xea5, 0xea6, 0xeaa, 0xeaa, 0xeab, 0xeab, 0xea8,
+0xeac, 0xead, 0xead, 0xeae, 0xeaa, 0xeae, 0xeab, 0xeab, 0xeac, 0xeb0,
+0xeb1, 0xead, 0xeae, 0xeb2, 0xeae, 0xeaf, 0xeb3, 0xeb4, 0xeb8, 0xeb5,
+0xeb5, 0xeb6, 0xeb6, 0xeb6, 0xeb7, 0xeb7, 0xeb4, 0xeb4, 0xeb9, 0xeb9,
+0xeb6, 0xeba, 0xeba, 0xeb7, 0xeb7, 0xebc, 0xebc, 0xebd, 0xeb9, 0xebd,
+0xeba, 0xeba, 0xebb, 0xec3, 0xec0, 0xec4, 0xec1, 0xec1, 0xec5, 0xec2,
+0xec6, 0xec7, 0xec7, 0xec8, 0xec8, 0xec5, 0xec9, 0xec5, 0xeca, 0xeca,
+0xecb, 0xecb, 0xec8, 0xecc, 0xec8, 0xec9, 0xec9, 0xeca, 0xeca, 0xecb,
+0xecb, 0xecc, 0xecc, 0xecc, 0xecd, 0xecd, 0xece, 0xed2, 0xed3, 0xed3,
+0xed4, 0xed8, 0xed4, 0xed1, 0xed5, 0xed6, 0xed6, 0xed3, 0xecf, 0xedb,
+0xed8, 0xed4, 0xed9, 0xed9, 0xed6, 0xeda, 0xed7, 0xedb, 0xedb, 0xedc,
+0xedc, 0xedd, 0xedd, 0xede, 0xeda, 0xede, 0xedf, 0xedf, 0xedc, 0xedc,
+0xedd, 0xedd, 0xee2, 0xede, 0xede, 0xee3, 0xedf, 0xee4, 0xee4, 0xee1,
+0xee5, 0xee1, 0xee2, 0xee2, 0xee3, 0xee7, 0xee8, 0xee4, 0xee9, 0xee9,
+0xee5, 0xee6, 0xeee, 0xee7, 0xee7, 0xee8, 0xee8, 0xee8, 0xeed, 0xeed,
+0xeee, 0xeee, 0xeeb, 0xeeb, 0xeef, 0xef0, 0xef4, 0xeed, 0xeed, 0xef2,
+0xeee, 0xeef, 0xeef, 0xeef, 0xef0, 0xef0, 0xef1, 0xef1, 0xef2, 0xef2,
+0xef2, 0xef3, 0xef3, 0xef4, 0xef4, 0xef1, 0xef5, 0xef1, 0xef6, 0xef6,
+0xef3, 0xef7, 0xef4, 0xef8, 0xef1, 0xef9, 0xef1, 0xefa, 0xef6, 0xefb,
+0xf03, 0xf04, 0xf08, 0xf04, 0xf05, 0xf05, 0xf06, 0xf06, 0xf07, 0xf0b,
+0xf03, 0xf08, 0xf04, 0xf09, 0xf09, 0xf0a, 0xf0a, 0xf0a, 0xf0b, 0xf0b,
+0xf10, 0xf10, 0xf0d, 0xf0d, 0xf0d, 0xf0e, 0xf0e, 0xf0f, 0xf13, 0xf10,
+0xf10, 0xf10, 0xf11, 0xf15, 0xf12, 0xf12, 0xf13, 0xf13, 0xf10, 0xf14,
+0xf14, 0xf15, 0xf15, 0xf16, 0xf1a, 0xf13, 0xf17, 0xf1b, 0xf1c, 0xf18,
+0xf19, 0xf19, 0xf1a, 0xf1a, 0xf16, 0xf1b, 0xf1b, 0xf1c, 0xf20, 0xf1d,
+0xf19, 0xf21, 0xf1e, 0xf1e, 0xf1f, 0xf1f, 0xf1c, 0xf20, 0xf20, 0xf25,
+0xf21, 0xf22, 0xf22, 0xf23, 0xf23, 0xf23, 0xf20, 0xf24, 0xf25, 0xf25,
+0xf22, 0xf22, 0xf22, 0xf23, 0xf27, 0xf24, 0xf24, 0xf25, 0xf29, 0xf25,
+0xf2a, 0xf22, 0xf23, 0xf2b, 0xf28, 0xf2c, 0xf2c, 0xf29, 0xf29, 0xf2a,
+0xf2a, 0xf2b, 0xf27, 0xf2b, 0xf2c, 0xf2c, 0xf2d, 0xf2d, 0xf2a, 0xf32,
+0xf32, 0xf2f, 0xf2f, 0xf30, 0xf30, 0xf30, 0xf35, 0xf31, 0xf32, 0xf36,
+0xf33, 0xf33, 0xf37, 0xf34, 0xf34, 0xf35, 0xf35, 0xf36, 0xf32, 0xf3a,
+0xf37, 0xf37, 0xf38, 0xf34, 0xf39, 0xf39, 0xf45, 0xf42, 0xf46, 0xf47,
+0xf47, 0xf48, 0xf48, 0xf48, 0xf45, 0xf49, 0xf4a, 0xf4a, 0xf4b, 0xf4b,
+0xf47, 0xf4c, 0xf48, 0xf49, 0xf51, 0xf4e, 0xf4e, 0xf4a, 0xf4f, 0xf4f,
+0xf4c, 0xf50, 0xf50, 0xf51, 0xf51, 0xf52, 0xf52, 0xf4f, 0xf57, 0xf53,
+0xf54, 0xf54, 0xf59, 0xf59, 0xf56, 0xf56, 0xf56, 0xf57, 0xf57, 0xf58,
+0xf58, 0xf59, 0xf59, 0xf59, 0xf5a, 0xf5a, 0xf57, 0xf5b, 0xf5b, 0xf58,
+0xf58, 0xf5d, 0xf59, 0xf5e, 0xf5e, 0xf5e, 0xf5b, 0xf5f, 0xf5c, 0xf5c,
+0xf5d, 0xf5d, 0xf5d, 0xf5e, 0xf5e, 0xf5f, 0xf5f, 0xf5f, 0xf5c, 0xf60,
+0xf61, 0xf61, 0xf5e, 0xf62, 0xf5e, 0xf63, 0xf63, 0xf60, 0xf64, 0xf61,
+0xf65, 0xf65, 0xf66, 0xf66, 0xf63, 0xf67, 0xf67, 0xf68, 0xf68, 0xf69,
+0xf69, 0xf66, 0xf6a, 0xf6a, 0xf6b, 0xf6b, 0xf6c, 0xf6c, 0xf6d, 0xf6d,
+0xf6d, 0xf72, 0xf6e, 0xf6f, 0xf73, 0xf73, 0xf74, 0xf70, 0xf75, 0xf75,
+0xf72, 0xf72, 0xf76, 0xf77, 0xf77, 0xf74, 0xf78, 0xf78, 0xf79, 0xf79,
+0xf7a, 0xf7a, 0xf7b, 0xf77, 0xf7b, 0xf78, 0xf7c, 0xf7d, 0xf7d, 0xf7d,
+0xf7a, 0xf7a, 0xf7f, 0xf83, 0xf84, 0xf84, 0xf84, 0xf81, 0xf85, 0xf86,
+0xf86, 0xf83, 0xf83, 0xf87, 0xf84, 0xf84, 0xf85, 0xf89, 0xf89, 0xf86,
+0xf86, 0xf87, 0xf87, 0xf8c, 0xf8c, 0xf88, 0xf89, 0xf89, 0xf8a, 0xf8a,
+0xf8a, 0xf93, 0xf8b, 0xf8c, 0xf88, 0xf89, 0xf8d, 0xf91, 0xf8e, 0xf92,
+0xf8b, 0xf8f, 0xf8f, 0xf94, 0xf94, 0xf91, 0xf91, 0xf95, 0xf96, 0xf96,
+0xf97, 0xf97, 0xf98, 0xf98, 0xf98, 0xf99, 0xf99, 0xf9a, 0xf9a, 0xf96,
+0xf9b, 0xf9b, 0xf9c, 0xf9c, 0xf9d, 0xf9d, 0xfa1, 0xf9e, 0xf9e, 0xf9b,
+0xf9f, 0xf9f, 0xfa0, 0xfa0, 0xf9d, 0xfa5, 0xf9e, 0xfa2, 0xfa2, 0xf9f,
+0xfa3, 0xfa0, 0xfa0, 0xfa4, 0xfa5, 0xfa5, 0xfa2, 0xf9e, 0xfa2, 0xfa3,
+0xfa3, 0xfa4, 0xfa8, 0xfa5, 0xfa5, 0xfa5, 0xfa6, 0xfaa, 0xfa7, 0xfa7,
+0xfa7, 0xfa8, 0xfa8, 0xfa9, 0xfa9, 0xfaa, 0xfae, 0xfaa, 0xfab, 0xfaf,
+0xfb0, 0xfac, 0xfb0, 0xfb1, 0xfb1, 0xfae, 0xfb2, 0xfae, 0xfb3, 0xfaf,
+0xfb4, 0xfb4, 0xfad, 0xfb1, 0xfb5, 0xfb6, 0xfb6, 0xfb7, 0xfb3, 0xfb7,
+0xfb4, 0xfb4, 0xfb9, 0xfb9, 0xfb9, 0xfba, 0xfba, 0xfb7, 0xfb7, 0xfc3,
+0xfc0, 0xfc4, 0xfc1, 0xfbd, 0xfc2, 0xfbe, 0xfc6, 0xfc3, 0xfc3, 0xfc4,
+0xfc0, 0xfc0, 0xfc1, 0xfc5, 0xfc2, 0xfc2, 0xfc6, 0xfc3, 0xfc3, 0xfc8,
+0xfc8, 0xfc5, 0xfc5, 0xfc5, 0xfca, 0xfca, 0xfcb, 0xfcb, 0xfcb, 0xfc8,
+0xfcc, 0xfc9, 0xfc9, 0xfcd, 0xfce, 0xfca, 0xfcf, 0xfcf, 0xfcf, 0xfd0,
+0xfd0, 0xfd1, 0xfd1, 0xfca, 0xfd2, 0xfd2, 0xfcf, 0xfd3, 0xfd4, 0xfd4,
+0xfd4, 0xfd5, 0xfd1, 0xfd2, 0xfd6, 0xfd6, 0xfd7, 0xfdf, 0xfdc, 0xfdc,
+0xfe0, 0xfe1, 0xfe1, 0xfde, 0xfde, 0xfde, 0xfdf, 0xfe3, 0xfe4, 0xfe4,
+0xfdd, 0xfe1, 0xfe1, 0xfe6, 0xfe2, 0xfe3, 0xfe3, 0xfe7, 0xfe4, 0xfe4,
+0xfe9, 0xfe9, 0xfe9, 0xfea, 0xfe6, 0xfe7, 0xfe7, 0xfe7, 0xfec, 0xfe8,
+0xfe9, 0xfe9, 0xfe9, 0xfea, 0xfea, 0xfeb, 0xfeb, 0xff0, 0xfec, 0xfec,
+0xff1, 0xff1, 0xff2, 0xff2, 0xff2, 0xfef, 0xfeb, 0xff0, 0xff4, 0xff4,
+0xff5, 0xff1, 0xff6, 0xff6, 0xff6, 0xff7, 0xff7, 0xff8, 0xff8, 0xff8,
+0xff9, 0xff5, 0xffa, 0xffa, 0xffa, 0xff7, 0xff3, 0xffc, 0xff8, 0xffc,
+0xffd, 0xffd, 0xffa, 0xffa, 0xfff, 0xfff
+	};
+#endif /* _MI_DISP_NVT_ALPHA_DATA_H_ */
diff --git a/techpack/display/msm/msm_drv.c b/techpack/display/msm/msm_drv.c
index 7025d9d84f1f..4b6c0569460e 100644
--- a/techpack/display/msm/msm_drv.c
+++ b/techpack/display/msm/msm_drv.c
@@ -47,6 +47,7 @@
 #include "msm_mmu.h"
 #include "sde_wb.h"
 #include "sde_dbg.h"
+#include "dsi/dsi_panel_mi.h"
 
 /*
  * MSM driver version:
@@ -2060,6 +2061,8 @@ static void msm_pdev_shutdown(struct platform_device *pdev)
 		return;
 	}
 
+	dsi_panel_power_turn_off(false);
+
 	msm_lastclose(ddev);
 
 	/* set this after lastclose to allow kickoff from lastclose */
diff --git a/techpack/display/msm/msm_drv.h b/techpack/display/msm/msm_drv.h
index 4ba732d86d7c..7c5dae0ad4e4 100644
--- a/techpack/display/msm/msm_drv.h
+++ b/techpack/display/msm/msm_drv.h
@@ -128,6 +128,7 @@ enum msm_mdp_plane_property {
 	PLANE_PROP_SRC_CONFIG,
 	PLANE_PROP_FB_TRANSLATION_MODE,
 	PLANE_PROP_MULTIRECT_MODE,
+	PLANE_PROP_MI_LAYER_INFO,
 
 	/* total # of properties */
 	PLANE_PROP_COUNT
@@ -164,6 +165,7 @@ enum msm_mdp_crtc_property {
 	CRTC_PROP_CAPTURE_OUTPUT,
 
 	CRTC_PROP_IDLE_PC_STATE,
+	CRTC_PROP_MI_FOD_SYNC_INFO,
 
 	/* total # of properties */
 	CRTC_PROP_COUNT
diff --git a/techpack/display/msm/sde/clone_cooling_device.c b/techpack/display/msm/sde/clone_cooling_device.c
new file mode 100644
index 000000000000..82d99090aa45
--- /dev/null
+++ b/techpack/display/msm/sde/clone_cooling_device.c
@@ -0,0 +1,165 @@
+#include <linux/err.h>
+#include <linux/slab.h>
+#include "sde_dbg.h"
+
+#include "clone_cooling_device.h"
+#include "../dsi/dsi_display.h"
+#include "../dsi/dsi_panel_mi.h"
+
+#define BL_NODE_NAME_SIZE 32
+
+static int bd_cdev_get_max_brightness_clone(struct thermal_cooling_device *cdev,
+					unsigned long *state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	struct backlight_device *bd;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	if (!cdev_clone->panel)
+		return -ENODEV;
+
+	*state = cdev_clone->panel->mi_cfg.max_brightness_clone;
+	return 0;
+}
+
+static int bd_cdev_get_cur_brightness_clone(struct thermal_cooling_device *cdev,
+                                        unsigned long *state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	struct backlight_device *bd;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	*state = cdev_clone->panel->mi_cfg.max_brightness_clone - bd->thermal_brightness_clone_limit;
+	return 0;
+}
+
+static int bd_cdev_set_cur_brightness_clone(struct thermal_cooling_device *cdev,
+					unsigned long state)
+{
+	struct sde_clone_cdev *cdev_clone;
+	unsigned long brightness_lvl;
+	struct backlight_device *bd;
+	int rc = 0;
+
+	if (!cdev)
+		return -EINVAL;
+
+	cdev_clone = (struct sde_clone_cdev *)cdev->devdata;
+	if (!cdev_clone)
+		return -EINVAL;
+
+	bd = cdev_clone->bd;
+	if (!bd)
+		return -ENODEV;
+
+	if (state > cdev_clone->panel->mi_cfg.max_brightness_clone)
+		return -EINVAL;
+
+	brightness_lvl = cdev_clone->panel->mi_cfg.max_brightness_clone - state;
+	if (brightness_lvl == bd->thermal_brightness_clone_limit)
+		return 0;
+	bd->thermal_brightness_clone_limit = brightness_lvl;
+	SDE_INFO("backup_brightness_clone[%d], thermal limit[%d]\n", bd->props.brightness_clone_backup, bd->thermal_brightness_clone_limit);
+#ifndef CONFIG_THERMAL_DIMMING
+	brightness_lvl = (bd->props.brightness_clone_backup
+				<= bd->thermal_brightness_clone_limit) ?
+				bd->props.brightness_clone_backup :
+				bd->thermal_brightness_clone_limit;
+	bd->props.brightness_clone = brightness_lvl;
+        sysfs_notify(&bd->dev.kobj, NULL, "brightness_clone");
+#else
+	sysfs_notify(&cdev->device.kobj, NULL, "cur_state");
+#endif
+
+	return rc;
+}
+
+static struct thermal_cooling_device_ops bd_cdev_clone_ops = {
+	.get_max_state = bd_cdev_get_max_brightness_clone,
+	.get_cur_state = bd_cdev_get_cur_brightness_clone,
+	.set_cur_state = bd_cdev_set_cur_brightness_clone,
+};
+
+int backlight_clone_cdev_register(struct sde_clone_cdev *cdev_clone,
+					struct device *parent,
+					struct backlight_device *bd)
+{
+	static int display_clone_count;
+	char bl_node_name[BL_NODE_NAME_SIZE];
+
+	if (!bd || !parent || !cdev_clone)
+		return -EINVAL;
+	if (!of_find_property(parent->of_node, "#cooling-cells", NULL))
+		return -ENODEV;
+	snprintf(bl_node_name, BL_NODE_NAME_SIZE, "brightness%u-clone", display_clone_count++);
+
+	cdev_clone->bd = bd;
+	cdev_clone->cdev = thermal_of_cooling_device_register(parent->of_node,
+				bl_node_name, cdev_clone, &bd_cdev_clone_ops);
+
+	if (!&(cdev_clone->cdev)) {
+		pr_err("Cooling device register failed\n");
+		return -EINVAL;
+	}
+	else
+		display_clone_count++;
+
+	return 0;
+}
+
+void backlight_clone_cdev_unregister(struct sde_clone_cdev *cdev_clone)
+{
+	if (!cdev_clone)
+		return;
+
+	thermal_cooling_device_unregister(cdev_clone->cdev);
+}
+
+int sde_backlight_clone_setup(struct sde_connector *c_conn, struct device *parent, struct backlight_device *bd)
+{
+	struct dsi_display *display;
+	struct sde_clone_cdev *cdev_clone = NULL;
+	int rc = 0;
+
+	if (!c_conn || !parent || !bd)
+		return -ENOMEM;
+
+	display = (struct dsi_display *) c_conn->display;
+	if (!display || !display->panel)
+		return -ENOMEM;
+
+	cdev_clone = devm_kzalloc(parent, sizeof(*cdev_clone), GFP_KERNEL);
+	if (!cdev_clone)
+		return -ENOMEM;
+
+	cdev_clone->panel = display->panel;
+	bd->thermal_brightness_clone_limit = cdev_clone->panel->mi_cfg.max_brightness_clone;
+	rc = backlight_clone_cdev_register(cdev_clone, parent, bd);
+	if (rc) {
+		pr_err("Failed to register backlight_clone_cdev\n");
+		return -ENODEV;
+	}
+	c_conn->cdev_clone = cdev_clone;
+
+	return 0;
+}
diff --git a/techpack/display/msm/sde/clone_cooling_device.h b/techpack/display/msm/sde/clone_cooling_device.h
new file mode 100644
index 000000000000..e10dd28151d8
--- /dev/null
+++ b/techpack/display/msm/sde/clone_cooling_device.h
@@ -0,0 +1,19 @@
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/thermal.h>
+#include <linux/notifier.h>
+
+#include "sde_connector.h"
+#include "dsi_panel.h"
+
+struct sde_connector;
+struct sde_clone_cdev {
+	struct thermal_cooling_device *cdev;
+	struct backlight_device *bd;
+	struct dsi_panel *panel;
+};
+
+int sde_backlight_clone_setup(struct sde_connector *c_conn,
+			struct device *dev,
+			struct backlight_device *bd);
+void backlight_clone_cdev_unregister(struct sde_clone_cdev *cdev_clone);
diff --git a/techpack/display/msm/sde/sde_color_processing.c b/techpack/display/msm/sde/sde_color_processing.c
index 806076ddb419..d8871623059f 100644
--- a/techpack/display/msm/sde/sde_color_processing.c
+++ b/techpack/display/msm/sde/sde_color_processing.c
@@ -19,6 +19,7 @@
 #include "sde_core_irq.h"
 #include "dsi_panel.h"
 #include "sde_hw_color_proc_common_v4.h"
+#include "sde_connector.h"
 
 struct sde_cp_node {
 	u32 property_id;
@@ -44,6 +45,16 @@ struct sde_cp_prop_attach {
 	uint64_t val;
 };
 
+struct pcc_check_info {
+	uint32_t crtc_id;
+	bool initialized;
+	struct drm_property pcc_property;
+	uint64_t pcc_val;
+	uint64_t fod_val;
+};
+
+static struct pcc_check_info pcc_info;
+
 #define ALIGNED_OFFSET (U32_MAX & ~(LTM_GUARD_BYTES))
 
 static void dspp_pcc_install_property(struct drm_crtc *crtc);
@@ -235,16 +246,62 @@ static int set_dspp_vlut_feature(struct sde_hw_dspp *hw_dspp,
 	return ret;
 }
 
+static struct drm_msm_pcc color_transform_pcc_cfg = {
+	.r.c = 0, .r.r = 32768, .r.g = 0, .r.b = 0,
+	.g.c = 0, .g.r = 0, .g.g = 32768, .g.b = 0,
+	.b.c = 0, .b.r = 0, .b.g = 0, .b.b = 32768,};
+static struct drm_msm_pcc pcc_cfg_clear;
+
+void sde_dspp_clear_pcc(struct sde_hw_cp_cfg *hw_cfg)
+{
+	if (!hw_cfg->payload) {
+		DRM_INFO("hw_cfg->payload in NULL\n");
+		return;
+	}
+
+	hw_cfg->payload_clear = &pcc_cfg_clear;
+
+	pcc_cfg_clear.r.c = color_transform_pcc_cfg.r.c;
+	pcc_cfg_clear.r.r = color_transform_pcc_cfg.r.r;
+	pcc_cfg_clear.r.g = color_transform_pcc_cfg.r.g;
+	pcc_cfg_clear.r.b = color_transform_pcc_cfg.r.b;
+	pcc_cfg_clear.g.c = color_transform_pcc_cfg.g.c;
+	pcc_cfg_clear.g.r = color_transform_pcc_cfg.g.r;
+	pcc_cfg_clear.g.g = color_transform_pcc_cfg.g.g;
+	pcc_cfg_clear.g.b = color_transform_pcc_cfg.g.b;
+	pcc_cfg_clear.b.c = color_transform_pcc_cfg.b.c;
+	pcc_cfg_clear.b.r = color_transform_pcc_cfg.b.r;
+	pcc_cfg_clear.b.g = color_transform_pcc_cfg.b.g;
+	pcc_cfg_clear.b.b = color_transform_pcc_cfg.b.b;
+}
+
 static int set_dspp_pcc_feature(struct sde_hw_dspp *hw_dspp,
 				struct sde_hw_cp_cfg *hw_cfg,
 				struct sde_crtc *hw_crtc)
 {
 	int ret = 0;
+	struct drm_msm_pcc *pcc_cfg;
 
 	if (!hw_dspp || !hw_dspp->ops.setup_pcc)
 		ret = -EINVAL;
-	else
+	else {
+
+		if (hw_cfg->payload) {
+			pcc_cfg = hw_cfg->payload;
+		}
+
+		if (hw_crtc->mi_dimlayer_type & MI_DIMLAYER_FOD_HBM_OVERLAY) {
+			sde_dspp_clear_pcc(hw_cfg);
+		} else {
+			hw_cfg->payload_clear = NULL;
+		}
+
+		if (hw_cfg->payload_clear) {
+			pcc_cfg = hw_cfg->payload_clear;
+		}
+
 		hw_dspp->ops.setup_pcc(hw_dspp, hw_cfg);
+	}
 	return ret;
 }
 
@@ -1314,7 +1371,7 @@ static void _sde_cp_crtc_enable_hist_irq(struct sde_crtc *sde_crtc)
 	struct sde_hw_dspp *hw_dspp = NULL;
 	struct sde_crtc_irq_info *node = NULL;
 	int i, irq_idx, ret = 0;
-	unsigned long flags;
+	unsigned long flags, state_flags;
 
 	if (!crtc_drm) {
 		DRM_ERROR("invalid crtc %pK\n", crtc_drm);
@@ -1344,12 +1401,13 @@ static void _sde_cp_crtc_enable_hist_irq(struct sde_crtc *sde_crtc)
 
 	spin_lock_irqsave(&sde_crtc->spin_lock, flags);
 	node = _sde_cp_get_intr_node(DRM_EVENT_HISTOGRAM, sde_crtc);
-	spin_unlock_irqrestore(&sde_crtc->spin_lock, flags);
 
-	if (!node)
+	if (!node) {
+		spin_unlock_irqrestore(&sde_crtc->spin_lock, flags);
 		return;
+	}
 
-	spin_lock_irqsave(&node->state_lock, flags);
+	spin_lock_irqsave(&node->state_lock, state_flags);
 	if (node->state == IRQ_DISABLED) {
 		ret = sde_core_irq_enable(kms, &irq_idx, 1);
 		if (ret)
@@ -1357,7 +1415,8 @@ static void _sde_cp_crtc_enable_hist_irq(struct sde_crtc *sde_crtc)
 		else
 			node->state = IRQ_ENABLED;
 	}
-	spin_unlock_irqrestore(&node->state_lock, flags);
+	spin_unlock_irqrestore(&node->state_lock, state_flags);
+	spin_unlock_irqrestore(&sde_crtc->spin_lock, flags);
 }
 
 static int sde_cp_crtc_checkfeature(struct sde_cp_node *prop_node,
@@ -1467,6 +1526,7 @@ static void sde_cp_crtc_setfeature(struct sde_cp_node *prop_node,
 			hw_cfg.mixer_info = hw_lm;
 			hw_cfg.displayh = num_mixers * hw_lm->cfg.out_width;
 			hw_cfg.displayv = hw_lm->cfg.out_height;
+			hw_cfg.mi_dimlayer_type = sde_crtc->mi_dimlayer_type;
 
 			ret = set_feature(hw_dspp, &hw_cfg, sde_crtc);
 			if (ret)
@@ -1931,6 +1991,12 @@ int sde_cp_crtc_set_property(struct drm_crtc *crtc,
 	struct sde_crtc *sde_crtc = NULL;
 	int ret = 0, i = 0, dspp_cnt, lm_cnt;
 	u8 found = 0;
+	bool fod_changed = false;
+
+	if (!pcc_info.initialized) {
+		pcc_info.crtc_id = crtc->base.id;
+		pcc_info.initialized = true;
+	}
 
 	if (!crtc || !property) {
 		DRM_ERROR("invalid crtc %pK property %pK\n", crtc, property);
@@ -1943,11 +2009,36 @@ int sde_cp_crtc_set_property(struct drm_crtc *crtc,
 		return -EINVAL;
 	}
 
+	if (!strncmp(property->name, "mi_fod_sync_info", sizeof("mi_fod_sync_info"))
+		&& pcc_info.crtc_id == crtc->base.id) {
+		if ((val & MI_DIMLAYER_FOD_HBM_OVERLAY) != (pcc_info.fod_val & MI_DIMLAYER_FOD_HBM_OVERLAY)) {
+			fod_changed = true;
+		}
+		pcc_info.fod_val = val;
+	}
+
 	mutex_lock(&sde_crtc->crtc_cp_lock);
-	list_for_each_entry(prop_node, &sde_crtc->feature_list, feature_list) {
-		if (property->base.id == prop_node->property_id) {
-			found = 1;
-			break;
+
+	if (!strncmp(property->name, "SDE_DSPP_PCC_V4", sizeof("SDE_DSPP_PCC_V4"))
+		&& pcc_info.crtc_id == crtc->base.id) {
+		pcc_info.pcc_val = val;
+		pcc_info.pcc_property.flags = property->flags;
+		pcc_info.pcc_property.base.id = property->base.id;
+	}
+
+	if (fod_changed) {
+		list_for_each_entry(prop_node, &sde_crtc->feature_list, feature_list) {
+			if (pcc_info.pcc_property.base.id == prop_node->property_id) {
+				found = 1;
+				break;
+			}
+		}
+	} else {
+		list_for_each_entry(prop_node, &sde_crtc->feature_list, feature_list) {
+			if (property->base.id == prop_node->property_id) {
+				found = 1;
+				break;
+			}
 		}
 	}
 
@@ -1999,11 +2090,17 @@ int sde_cp_crtc_set_property(struct drm_crtc *crtc,
 	/* remove the property from dirty list */
 	list_del_init(&prop_node->dirty_list);
 
-	if (!val)
+	if (!val) {
 		ret = sde_cp_disable_crtc_property(crtc, property, prop_node);
-	else
-		ret = sde_cp_enable_crtc_property(crtc, property,
+	} else {
+		if (fod_changed) {
+			ret = sde_cp_enable_crtc_property(crtc, &pcc_info.pcc_property,
+							  prop_node, pcc_info.pcc_val);
+		} else {
+			ret = sde_cp_enable_crtc_property(crtc, property,
 						  prop_node, val);
+		}
+	}
 
 	if (!ret) {
 		/* remove the property from active list */
@@ -2011,6 +2108,10 @@ int sde_cp_crtc_set_property(struct drm_crtc *crtc,
 		/* Mark the feature as dirty */
 		sde_cp_update_list(prop_node, sde_crtc, true);
 	}
+
+	if (fod_changed) {
+		ret = -ENOENT;
+	}
 exit:
 	mutex_unlock(&sde_crtc->crtc_cp_lock);
 	return ret;
@@ -2091,6 +2192,7 @@ void sde_cp_crtc_destroy_properties(struct drm_crtc *crtc)
 	}
 	sde_crtc->ltm_buffer_cnt = 0;
 	sde_crtc->ltm_hist_en = false;
+	sde_crtc->hist_irq_idx = -1;
 
 	mutex_destroy(&sde_crtc->crtc_cp_lock);
 	INIT_LIST_HEAD(&sde_crtc->active_list);
@@ -2186,6 +2288,7 @@ void sde_cp_crtc_clear(struct drm_crtc *crtc)
 	}
 	sde_crtc->ltm_buffer_cnt = 0;
 	sde_crtc->ltm_hist_en = false;
+	sde_crtc->hist_irq_idx = -1;
 	INIT_LIST_HEAD(&sde_crtc->ltm_buf_free);
 	INIT_LIST_HEAD(&sde_crtc->ltm_buf_busy);
 }
@@ -2392,9 +2495,15 @@ static void dspp_ltm_install_property(struct drm_crtc *crtc)
 	char feature_name[256];
 	struct sde_kms *kms = NULL;
 	struct sde_mdss_cfg *catalog = NULL;
-	u32 version;
+	u32 version = 0, ltm_sw_fuse = 0;
 
 	kms = get_kms(crtc);
+	if (!kms || !kms->hw_sw_fuse) {
+		DRM_ERROR("!kms = %d\n", !kms);
+		return;
+	}
+
+	ltm_sw_fuse = sde_hw_get_ltm_sw_fuse_value(kms->hw_sw_fuse);
 	catalog = kms->catalog;
 	version = catalog->dspp[0].sblk->ltm.version >> 16;
 	snprintf(feature_name, ARRAY_SIZE(feature_name), "%s%d",
@@ -2965,45 +3074,20 @@ static void sde_cp_hist_interrupt_cb(void *arg, int irq_idx)
 	struct sde_crtc *crtc = arg;
 	struct drm_crtc *crtc_drm = &crtc->base;
 	struct sde_hw_dspp *hw_dspp;
-	struct sde_kms *kms;
-	struct sde_crtc_irq_info *node = NULL;
+	u32 lock_hist = 1;
 	u32 i;
-	int ret = 0;
-	unsigned long flags;
-
-	/* disable histogram irq */
-	kms = get_kms(crtc_drm);
-	spin_lock_irqsave(&crtc->spin_lock, flags);
-	node = _sde_cp_get_intr_node(DRM_EVENT_HISTOGRAM, crtc);
-	spin_unlock_irqrestore(&crtc->spin_lock, flags);
-
-	if (!node) {
-		DRM_DEBUG_DRIVER("cannot find histogram event node in crtc\n");
-		return;
-	}
-
-	spin_lock_irqsave(&node->state_lock, flags);
-	if (node->state == IRQ_ENABLED) {
-		if (sde_core_irq_disable_nolock(kms, irq_idx)) {
-			DRM_ERROR("failed to disable irq %d, ret %d\n",
-				irq_idx, ret);
-			spin_unlock_irqrestore(&node->state_lock, flags);
-			return;
-		}
-		node->state = IRQ_DISABLED;
-	}
-	spin_unlock_irqrestore(&node->state_lock, flags);
 
 	/* lock histogram buffer */
 	for (i = 0; i < crtc->num_mixers; i++) {
 		hw_dspp = crtc->mixers[i].hw_dspp;
 		if (hw_dspp && hw_dspp->ops.lock_histogram)
-			hw_dspp->ops.lock_histogram(hw_dspp, NULL);
+			hw_dspp->ops.lock_histogram(hw_dspp, &lock_hist);
 	}
 
+	crtc->hist_irq_idx = irq_idx;
 	/* notify histogram event */
 	sde_crtc_event_queue(crtc_drm, sde_cp_notify_hist_event,
-							NULL, true);
+						&crtc->hist_irq_idx, true);
 }
 
 static void sde_cp_notify_hist_event(struct drm_crtc *crtc_drm, void *arg)
@@ -3013,10 +3097,12 @@ static void sde_cp_notify_hist_event(struct drm_crtc *crtc_drm, void *arg)
 	struct drm_event event;
 	struct drm_msm_hist *hist_data;
 	struct sde_kms *kms;
-	int ret;
-	u32 i;
+	struct sde_crtc_irq_info *node = NULL;
+	unsigned long flags, state_flags;
+	int ret, irq_idx;
+	u32 i, lock_hist = 0;
 
-	if (!crtc_drm) {
+	if (!crtc_drm || !arg) {
 		DRM_ERROR("invalid crtc %pK\n", crtc_drm);
 		return;
 	}
@@ -3027,15 +3113,70 @@ static void sde_cp_notify_hist_event(struct drm_crtc *crtc_drm, void *arg)
 		return;
 	}
 
-	if (!crtc->hist_blob)
-		return;
-
 	kms = get_kms(crtc_drm);
 	if (!kms || !kms->dev) {
 		SDE_ERROR("invalid arg(s)\n");
 		return;
 	}
 
+	/* disable histogram irq */
+	spin_lock_irqsave(&crtc->spin_lock, flags);
+	node = _sde_cp_get_intr_node(DRM_EVENT_HISTOGRAM, crtc);
+
+	if (!node) {
+		spin_unlock_irqrestore(&crtc->spin_lock, flags);
+		DRM_DEBUG_DRIVER("cannot find histogram event node in crtc\n");
+		/* unlock histogram */
+		ret = pm_runtime_get_sync(kms->dev->dev);
+		if (ret < 0) {
+			SDE_ERROR("failed to enable power resource %d\n", ret);
+			SDE_EVT32(ret, SDE_EVTLOG_ERROR);
+			return;
+		}
+		for (i = 0; i < crtc->num_mixers; i++) {
+			hw_dspp = crtc->mixers[i].hw_dspp;
+			if (hw_dspp && hw_dspp->ops.lock_histogram)
+				hw_dspp->ops.lock_histogram(hw_dspp,
+					&lock_hist);
+		}
+		pm_runtime_put_sync(kms->dev->dev);
+		return;
+	}
+
+	irq_idx = *(int *)arg;
+	spin_lock_irqsave(&node->state_lock, state_flags);
+	if (node->state == IRQ_ENABLED) {
+		ret = sde_core_irq_disable_nolock(kms, irq_idx);
+		if (ret) {
+			DRM_ERROR("failed to disable irq %d, ret %d\n",
+				irq_idx, ret);
+			spin_unlock_irqrestore(&node->state_lock, state_flags);
+			spin_unlock_irqrestore(&crtc->spin_lock, flags);
+			ret = pm_runtime_get_sync(kms->dev->dev);
+			if (ret < 0) {
+				SDE_ERROR("failed to enable power %d\n", ret);
+				SDE_EVT32(ret, SDE_EVTLOG_ERROR);
+				return;
+			}
+
+			/* unlock histogram */
+			for (i = 0; i < crtc->num_mixers; i++) {
+				hw_dspp = crtc->mixers[i].hw_dspp;
+				if (hw_dspp && hw_dspp->ops.lock_histogram)
+					hw_dspp->ops.lock_histogram(hw_dspp,
+						&lock_hist);
+			}
+			pm_runtime_put_sync(kms->dev->dev);
+			return;
+		}
+		node->state = IRQ_DISABLED;
+	}
+	spin_unlock_irqrestore(&node->state_lock, state_flags);
+	spin_unlock_irqrestore(&crtc->spin_lock, flags);
+
+	if (!crtc->hist_blob)
+		return;
+
 	ret = pm_runtime_get_sync(kms->dev->dev);
 	if (ret < 0) {
 		SDE_ERROR("failed to enable power resource %d\n", ret);
diff --git a/techpack/display/msm/sde/sde_connector.c b/techpack/display/msm/sde/sde_connector.c
index 35f678373c1d..aca1ef68e6c3 100644
--- a/techpack/display/msm/sde/sde_connector.c
+++ b/techpack/display/msm/sde/sde_connector.c
@@ -14,9 +14,16 @@
 #include <linux/backlight.h>
 #include <linux/string.h>
 #include "dsi_drm.h"
+#include "dsi_defs.h"
 #include "dsi_display.h"
 #include "sde_crtc.h"
 #include "sde_rm.h"
+#include "sde_trace.h"
+#include "dsi_mi_feature.h"
+#include "dsi_display.h"
+#include "dsi_panel_mi.h"
+#include "clone_cooling_device.h"
+#include "mi_disp_lhbm.h"
 
 #define BL_NODE_NAME_SIZE 32
 #define HDR10_PLUS_VSIF_TYPE_CODE      0x81
@@ -78,13 +85,19 @@ static int sde_backlight_device_update_status(struct backlight_device *bd)
 
 	brightness = bd->props.brightness;
 
+	c_conn = bl_get_data(bd);
+	display = (struct dsi_display *) c_conn->display;
+
+	if((display->panel->mi_cfg.panel_id == 0x4C38314100420400) && (bd->thermal_brightness_limit != 0)) {
+		brightness = (brightness <= bd->thermal_brightness_limit) ? brightness : bd->thermal_brightness_limit;
+		bd->props.brightness = brightness;
+	}
+
 	if ((bd->props.power != FB_BLANK_UNBLANK) ||
 			(bd->props.state & BL_CORE_FBBLANK) ||
 			(bd->props.state & BL_CORE_SUSPENDED))
 		brightness = 0;
 
-	c_conn = bl_get_data(bd);
-	display = (struct dsi_display *) c_conn->display;
 	if (brightness > display->panel->bl_config.bl_max_level)
 		brightness = display->panel->bl_config.bl_max_level;
 
@@ -111,6 +124,7 @@ static int sde_backlight_device_update_status(struct backlight_device *bd)
 		rc = c_conn->ops.set_backlight(&c_conn->base,
 				c_conn->display, bl_lvl);
 		c_conn->unset_bl_level = 0;
+		c_conn->mi_dimlayer_state.current_backlight = bl_lvl;
 	}
 
 	return rc;
@@ -134,6 +148,7 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 	struct dsi_backlight_config *bl_config;
 	static int display_count;
 	char bl_node_name[BL_NODE_NAME_SIZE];
+	int rc = 0;
 
 	if (!c_conn || !dev || !dev->dev) {
 		SDE_ERROR("invalid param\n");
@@ -149,7 +164,7 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 	display = (struct dsi_display *) c_conn->display;
 	bl_config = &display->panel->bl_config;
 	props.max_brightness = bl_config->brightness_max_level;
-	props.brightness = bl_config->brightness_max_level;
+	props.brightness = bl_config->brightness_init_level;
 	snprintf(bl_node_name, BL_NODE_NAME_SIZE, "panel%u-backlight",
 							display_count);
 	c_conn->bl_device = backlight_device_register(bl_node_name, dev->dev,
@@ -161,7 +176,15 @@ static int sde_backlight_setup(struct sde_connector *c_conn,
 		return -ENODEV;
 	}
 	display_count++;
-
+	rc = sde_backlight_clone_setup(c_conn, dev->dev, c_conn->bl_device);
+	if (rc) {
+		SDE_ERROR("Failed to register backlight_clone_cdev: %ld\n",
+				    PTR_ERR(c_conn->cdev_clone));
+		backlight_clone_cdev_unregister(c_conn->cdev_clone);
+		backlight_device_unregister(c_conn->bl_device);
+		c_conn->bl_device = NULL;
+		return -ENODEV;
+	}
 	return 0;
 }
 
@@ -547,6 +570,9 @@ static int _sde_connector_update_power_locked(struct sde_connector *c_conn)
 	SDE_DEBUG("conn %d - dpms %d, lp %d, panel %d\n", connector->base.id,
 			c_conn->dpms_mode, c_conn->lp_mode, mode);
 
+	if (SDE_MODE_DPMS_OFF == mode)
+		c_conn->fod_frame_count = 0;
+
 	if (mode != c_conn->last_panel_power_mode && c_conn->ops.set_power) {
 		display = c_conn->display;
 		set_power = c_conn->ops.set_power;
@@ -760,6 +786,347 @@ struct sde_connector_dyn_hdr_metadata *sde_connector_get_dyn_hdr_meta(
 	return &c_state->dyn_hdr_meta;
 }
 
+void sde_crtc_fod_ui_ready(struct dsi_display *display, int type, int value)
+{
+	if (!display)
+		return;
+
+	if (type == 1) /* HBM */
+	{
+		if (value == 0)
+			display->panel->mi_cfg.fod_ui_ready &= ~0x01;
+		else if (value == 1)
+			display->panel->mi_cfg.fod_ui_ready |= 0x01;
+	}
+
+	if (type == 2) /* ICON */
+	{
+		if (display->panel->mi_cfg.local_hbm_enabled) {
+			if (value == 0)
+				display->panel->mi_cfg.fod_ui_ready &= ~0x07;
+			else if (value == 1) {
+				if (display->panel->mi_cfg.lhbm_target == LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_110NIT)
+					display->panel->mi_cfg.fod_ui_ready |= 0x07;
+				else if (display->panel->mi_cfg.lhbm_target == LOCAL_LHBM_TARGET_BRIGHTNESS_WHITE_1000NIT
+					|| display->panel->mi_cfg.lhbm_target == LOCAL_LHBM_TARGET_BRIGHTNESS_GREEN_500NIT)
+					display->panel->mi_cfg.fod_ui_ready |= 0x03;
+			}
+
+		} else {
+			if (value == 0)
+				display->panel->mi_cfg.fod_ui_ready &= ~0x02;
+			else if (value == 1)
+				display->panel->mi_cfg.fod_ui_ready |= 0x02;
+		}
+
+	}
+
+	SDE_INFO("fod_ui_ready notify=%d", display->panel->mi_cfg.fod_ui_ready);
+	sysfs_notify(&display->drm_conn->kdev->kobj, NULL, "fod_ui_ready");
+}
+
+int mi_sde_connector_gir_fence(struct drm_connector *connector)
+{
+	int rc = 0;
+	struct sde_connector *c_conn;
+	struct dsi_display *dsi_display;
+	struct dsi_panel_mi_cfg *mi_cfg;
+
+	if (!connector) {
+		SDE_ERROR("invalid connector ptr\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI)
+		return 0;
+
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel ptr\n");
+		return -EINVAL;
+	}
+
+	if (strncmp(dsi_display->display_type, "primary", 7))
+		return -EINVAL;
+
+	mi_cfg = &dsi_display->panel->mi_cfg;
+	mutex_lock(&dsi_display->panel->panel_lock);
+	if (mi_cfg->request_gir_status == true && mi_cfg->gir_enabled == false) {
+		SDE_ATRACE_BEGIN("DISP_FEATURE_GIR_ON");
+		SDE_INFO("mi-dsi-panel: gir on\n");
+		dsi_panel_tx_cmd_set(dsi_display->panel, DSI_CMD_SET_MI_GIR_ON);
+		sde_encoder_wait_for_event(c_conn->encoder,MSM_ENC_VBLANK);
+		SDE_ATRACE_END("DISP_FEATURE_GIR_ON");
+		mi_cfg->gir_enabled = true;
+	} else if (mi_cfg->request_gir_status == false && mi_cfg->gir_enabled == true) {
+		SDE_ATRACE_BEGIN("DISP_FEATURE_GIR_OFF");
+		SDE_INFO("mi-dsi-panel: gir off\n");
+		dsi_panel_tx_cmd_set(dsi_display->panel, DSI_CMD_SET_MI_GIR_OFF);
+		sde_encoder_wait_for_event(c_conn->encoder,MSM_ENC_VBLANK);
+		SDE_ATRACE_END("DISP_FEATURE_GIR_OFF");
+		mi_cfg->gir_enabled = false;
+	}
+	mutex_unlock(&dsi_display->panel->panel_lock);
+
+	return rc;
+}
+
+static int _sde_connector_mi_dimlayer_hbm_fence(struct drm_connector *connector)
+{
+	int rc = 0;
+	struct sde_connector *c_conn;
+	struct dsi_display *dsi_display;
+	bool skip = false;
+	bool Prepare_Kickoff = false;
+	bool Ready_Kickoff = false;
+	static int skip_frame_count = 0;
+	bool hbm_overlay;
+	static bool last_fod_unlock_success;
+	static bool last_layer_aod_flag;
+	bool crc_off_after_delay_of_hbm_on = false;
+	struct dsi_panel_mi_cfg *mi_cfg;
+	bool anim;
+	static bool last_anim = false;
+
+	if (!connector) {
+		SDE_ERROR("invalid argument\n");
+		return -EINVAL;
+	}
+
+	c_conn = to_sde_connector(connector);
+	Prepare_Kickoff = get_sde_encoder_virt_prepare_kickoff(connector);
+	Ready_Kickoff = get_sde_encoder_virt_ready_kickoff(connector);
+
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI)
+		return 0;
+
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return -EINVAL;
+	}
+
+	mi_cfg = &dsi_display->panel->mi_cfg;
+	if (!mi_cfg) {
+		SDE_ERROR("invalid mi_cfg\n");
+		return -EINVAL;
+	}
+
+	if (!c_conn->allow_bl_update) {
+		/*Skip 2 frames after panel on to avoid hbm flicker*/
+		if (mi_cfg->dc_type == 1 && dsi_display->panel->power_mode == SDE_MODE_DPMS_ON)
+			skip_frame_count = 2;
+		return 0;
+	}
+
+	if (skip_frame_count) {
+		SDE_INFO("skip_frame_count=%d\n", skip_frame_count);
+		skip_frame_count--;
+		return 0;
+	}
+
+	mi_cfg->layer_fod_unlock_success =
+			c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_FOD_UNLOCK_SUCCESS;
+	if (last_fod_unlock_success != mi_cfg->layer_fod_unlock_success)
+		SDE_INFO("layer_fod_unlock_success = %d\n",
+					mi_cfg->layer_fod_unlock_success);
+
+	last_fod_unlock_success = mi_cfg->layer_fod_unlock_success;
+
+	mi_cfg->layer_aod_flag = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_AOD;
+	if (last_layer_aod_flag != mi_cfg->layer_aod_flag)
+		SDE_INFO("layer_aod_flag = %d\n", mi_cfg->layer_aod_flag);
+
+	last_layer_aod_flag = mi_cfg->layer_aod_flag;
+
+	hbm_overlay = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_HBM_OVERLAY;
+	if (hbm_overlay) {
+		/* TODO: mutex_lock(&panel->panel_lock); */
+		if (mi_cfg->fod_hbm_layer_enabled == false) {
+			/* in AOD, first frame should be skipped for hardware limitation */
+			if (mi_cfg->dc_type != 2 &&
+					(dsi_display->panel->power_mode == SDE_MODE_DPMS_LP1 ||
+					 dsi_display->panel->power_mode == SDE_MODE_DPMS_LP2)) {
+				SDE_INFO("fod_frame_count=%d\n", c_conn->fod_frame_count);
+				if (c_conn->fod_frame_count == 0)
+					skip = true;
+
+				c_conn->fod_frame_count++;
+			} else {
+				c_conn->fod_frame_count = 0;
+			}
+			if (skip == false) {
+				/* dimming off before hbm ctl */
+				if (mi_cfg->prepare_before_fod_hbm_on && ((mi_cfg->panel_id >> 8) == 0x4A3232003808)) {
+					/* Set flags to disable dimming and backlight */
+					mi_cfg->dimming_state = STATE_DIM_BLOCK;
+					mi_cfg->fod_hbm_enabled = true;
+
+					sde_connector_pre_hbm_ctl(connector);
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+				}
+
+				if (mi_cfg->delay_before_fod_hbm_on)
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+				if (mi_cfg->fod_dimlayer_enabled)
+					sde_connector_hbm_ctl(connector, DISPPARAM_HBM_FOD_ON);
+
+				/* Send crc off cmd before delay only if DC off(MIUI-1755728) */
+				if (mi_cfg->dc_type == 2) {
+					if (!mi_cfg->dc_enable || (mi_cfg->dc_enable &&
+						mi_cfg->last_bl_level > mi_cfg->dc_threshold)) {
+						dsi_panel_acquire_panel_lock(dsi_display->panel);
+						rc = dsi_panel_tx_cmd_set(dsi_display->panel,
+								DSI_CMD_SET_MI_CRC_OFF);
+						dsi_panel_release_panel_lock(dsi_display->panel);
+					} else {
+						crc_off_after_delay_of_hbm_on = true;
+					}
+				}
+
+				if (mi_cfg->delay_after_fod_hbm_on) {
+					sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+				}
+
+				/* Turn off crc after delay of hbm on can avoid flash high
+				 * brightness if DC on (MIUI-1755728) */
+				if (mi_cfg->dc_type == 2 && crc_off_after_delay_of_hbm_on) {
+					dsi_panel_acquire_panel_lock(dsi_display->panel);
+					rc = dsi_panel_tx_cmd_set(dsi_display->panel,
+							DSI_CMD_SET_MI_CRC_OFF);
+					dsi_panel_release_panel_lock(dsi_display->panel);
+				}
+
+				mi_cfg->fod_hbm_layer_enabled = true;
+				/*sde_crtc_fod_ui_ready(dsi_display, 1, 1);*/
+			}
+		}
+	} else {
+		if (mi_cfg->fod_hbm_layer_enabled == true) {
+			SDE_INFO("layer_fod_unlock_success = %d, sysfs_fod_unlock_success = %d\n",
+					mi_cfg->layer_fod_unlock_success,
+					mi_cfg->sysfs_fod_unlock_success);
+			if (mi_cfg->delay_before_fod_hbm_off)
+				sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+			sde_connector_hbm_ctl(connector, DISPPARAM_HBM_FOD_OFF);
+			if (mi_cfg->dc_type)
+				sysfs_notify(&c_conn->bl_device->dev.kobj, NULL, "brightness_clone");
+			if (mi_cfg->delay_after_fod_hbm_off)
+				sde_encoder_wait_for_event(c_conn->encoder, MSM_ENC_VBLANK);
+
+			mi_cfg->fod_hbm_layer_enabled = false;
+			/*sde_crtc_fod_ui_ready(dsi_display, 1, 0);*/
+		}
+	}
+#if 0
+	icon = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_ICON;
+	if (last_icon != icon) {
+		if (icon) {
+			sde_crtc_fod_ui_ready(dsi_display, 2, 1);
+		} else {
+			if (last_icon)
+				sde_crtc_fod_ui_ready(dsi_display, 2, 0);
+		}
+	}
+	last_icon = icon;
+#endif
+	//for l3a && j11
+	if (mi_cfg->panel_id == 0x4C334100420200 || mi_cfg->panel_id == 0x4A323200380801) {
+		if (!mi_cfg->layer_aod_flag) {
+			if (c_conn->lp_mode == SDE_MODE_DPMS_ON)
+				mi_cfg->bl_enable = true;
+			if (!mi_cfg->bl_wait_frame && c_conn->lp_mode == SDE_MODE_DPMS_ON) {
+				set_sde_encoder_virt_ready_kickoff(connector,true);
+				if (Prepare_Kickoff) {
+					SDE_ATRACE_BEGIN("set_backlight_after_aod");
+					mutex_lock(&dsi_display->panel->panel_lock);
+					dsi_panel_set_backlight(dsi_display->panel, dsi_display->panel->mi_cfg.last_bl_level);
+					mutex_unlock(&dsi_display->panel->panel_lock);
+					SDE_ATRACE_END("set_backlight_after_aod");
+					SDE_INFO("backlight %d set after aod layer\n", mi_cfg->last_bl_level);
+					mi_cfg->bl_wait_frame = true;
+					set_sde_encoder_virt_ready_kickoff(connector,false);
+					set_sde_encoder_virt_prepare_kickoff(connector,false);
+				}
+			} else
+				set_sde_encoder_virt_ready_kickoff(connector,false);
+		}
+	}
+
+	anim = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_LAYER_FOD_ANIM;
+	if (last_anim != anim) {
+		if (anim) {
+			mi_cfg->fod_anim_layer_enabled = true;
+		} else {
+			mi_cfg->fod_anim_layer_enabled = false;
+		}
+	}
+	last_anim = anim;
+
+	return rc;
+}
+
+void sde_connector_fod_notify(struct drm_connector *conn)
+{
+	struct sde_connector *c_conn;
+	bool icon, hbm_state;
+	static bool last_icon = false;
+	static bool last_hbm_state = false;
+	struct dsi_display *dsi_display;
+
+	if (!conn) {
+		SDE_ERROR("invalid params\n");
+		return;
+	}
+
+	c_conn = to_sde_connector(conn);
+	if (c_conn->connector_type != DRM_MODE_CONNECTOR_DSI) {
+		SDE_ERROR("not DRM_MODE_CONNECTOR_DSIl\n");
+		return;
+	}
+
+	dsi_display = (struct dsi_display *) c_conn->display;
+	if (!dsi_display || !dsi_display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return;
+	}
+
+	icon = c_conn->mi_dimlayer_state.mi_dimlayer_type & MI_DIMLAYER_FOD_ICON;
+	if (last_icon != icon) {
+		if (icon) {
+			/* Make sure icon was displayed on panel before notifying
+			 * fingerprint to capture image */
+			if (dsi_display->panel->mi_cfg.fod_hbm_layer_enabled) {
+				sde_encoder_wait_for_event(c_conn->encoder,
+						MSM_ENC_TX_COMPLETE);
+			}
+
+			sde_crtc_fod_ui_ready(dsi_display, 2, 1);
+		} else {
+			sde_crtc_fod_ui_ready(dsi_display, 2, 0);
+		}
+	}
+	last_icon = icon;
+
+	hbm_state = dsi_display->panel->mi_cfg.fod_hbm_layer_enabled;
+	if (last_hbm_state != hbm_state) {
+		if (hbm_state) {
+		   /* The black screen fingerprint unlocks, waits for HBM effect */
+			if (icon) {
+				sde_encoder_wait_for_event(c_conn->encoder,
+						MSM_ENC_TX_COMPLETE);
+			}
+			sde_crtc_fod_ui_ready(dsi_display, 1, 1);
+		} else {
+			sde_crtc_fod_ui_ready(dsi_display, 1, 0);
+		}
+	}
+	last_hbm_state = hbm_state;
+}
+
 int sde_connector_pre_kickoff(struct drm_connector *connector)
 {
 	struct sde_connector *c_conn;
@@ -805,6 +1172,11 @@ int sde_connector_pre_kickoff(struct drm_connector *connector)
 
 	SDE_EVT32_VERBOSE(connector->base.id);
 
+	mi_sde_connector_gir_fence(connector);
+
+	/* fingerprint hbm fence */
+	_sde_connector_mi_dimlayer_hbm_fence(connector);
+
 	rc = c_conn->ops.pre_kickoff(connector, c_conn->display, &params);
 
 	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI)
@@ -909,10 +1281,20 @@ void sde_connector_helper_bridge_enable(struct drm_connector *connector)
 				MSM_ENC_TX_COMPLETE);
 	c_conn->allow_bl_update = true;
 
+	if (display->panel->mi_cfg.pending_lhbm_state) {
+		mi_disp_set_fod_queue_work(1, false);
+	}
+
 	if (c_conn->bl_device) {
 		c_conn->bl_device->props.power = FB_BLANK_UNBLANK;
 		c_conn->bl_device->props.state &= ~BL_CORE_FBBLANK;
-		backlight_update_status(c_conn->bl_device);
+		if (!(display->panel->cur_mode->dsi_mode_flags & DSI_MODE_FLAG_DMS)
+			&& !(display->panel->cur_mode->dsi_mode_flags & DSI_MODE_FLAG_DMS_FPS)){
+			if(c_conn->bl_device->props.brightness != 0)
+			{
+				backlight_update_status(c_conn->bl_device);
+			}
+		}
 	}
 	c_conn->panel_dead = false;
 }
@@ -966,7 +1348,8 @@ void sde_connector_destroy(struct drm_connector *connector)
 		drm_property_blob_put(c_conn->blob_mode_info);
 	if (c_conn->blob_ext_hdr)
 		drm_property_blob_put(c_conn->blob_ext_hdr);
-
+	if (c_conn->cdev_clone)
+		backlight_clone_cdev_unregister(c_conn->cdev_clone);
 	if (c_conn->bl_device)
 		backlight_device_unregister(c_conn->bl_device);
 	drm_connector_unregister(connector);
@@ -1452,11 +1835,13 @@ static int sde_connector_atomic_set_property(struct drm_connector *connector,
 	 * atomic set property framework.
 	 */
 	case CONNECTOR_PROP_BL_SCALE:
-		c_conn->bl_scale = val;
+		//c_conn->bl_scale = val;
+		c_conn->bl_scale = MAX_BL_SCALE_LEVEL;
 		c_conn->bl_scale_dirty = true;
 		break;
 	case CONNECTOR_PROP_SV_BL_SCALE:
-		c_conn->bl_scale_sv = val;
+		//c_conn->bl_scale_sv = val;
+		c_conn->bl_scale_sv = MAX_SV_BL_SCALE_LEVEL;
 		c_conn->bl_scale_dirty = true;
 		break;
 	case CONNECTOR_PROP_HDR_METADATA:
@@ -2149,6 +2534,7 @@ static void _sde_connector_report_panel_dead(struct sde_connector *conn,
 	bool skip_pre_kickoff)
 {
 	struct drm_event event;
+	struct dsi_display *display = (struct dsi_display *)(conn->display);
 
 	if (!conn)
 		return;
@@ -2162,6 +2548,7 @@ static void _sde_connector_report_panel_dead(struct sde_connector *conn,
 		return;
 
 	conn->panel_dead = true;
+	display->panel->mi_cfg.panel_dead_flag = true;
 	event.type = DRM_EVENT_PANEL_DEAD;
 	event.length = sizeof(bool);
 	msm_mode_object_event_notify(&conn->base.base,
@@ -2256,6 +2643,103 @@ static void sde_connector_check_status_work(struct work_struct *work)
 	_sde_connector_report_panel_dead(conn, false);
 }
 
+static irqreturn_t esd_err_irq_handle(int irq, void *data)
+{
+	struct sde_connector *c_conn = data;
+	struct dsi_display *display = c_conn->display;
+	struct drm_event event;
+	int power_mode;
+
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel\n");
+		return IRQ_HANDLED;
+	}
+
+	if (gpio_get_value(display->panel->mi_cfg.esd_err_irq_gpio) &&
+		display->panel->host_config.cphy_strength) {
+		SDE_ERROR("trigger esd by mistake,return\n");
+		return IRQ_HANDLED;
+	}
+
+	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI) {
+		dsi_panel_acquire_panel_lock(display->panel);
+		dsi_panel_esd_irq_ctrl_locked(display->panel, false);
+
+		if (!dsi_panel_initialized(display->panel)) {
+			SDE_ERROR("%s display panel not initialized!\n",
+					display->display_type);
+			dsi_panel_release_panel_lock(display->panel);
+			return IRQ_HANDLED;
+		}
+
+		if (atomic_read(&(display->panel->esd_recovery_pending))) {
+			DSI_INFO("%s display ESD recovery already pending\n",
+					display->display_type);
+			dsi_panel_release_panel_lock(display->panel);
+			return IRQ_HANDLED;
+		}
+
+		if (!c_conn->panel_dead) {
+			atomic_set(&display->panel->esd_recovery_pending, 1);
+		} else {
+			DSI_INFO("%s display already notify PANEL_DEAD\n",
+					display->display_type);
+			dsi_panel_release_panel_lock(display->panel);
+			return IRQ_HANDLED;
+		}
+
+		power_mode = display->panel->power_mode;
+
+		dsi_panel_release_panel_lock(display->panel);
+
+		if (power_mode == SDE_MODE_DPMS_ON ||
+			power_mode == SDE_MODE_DPMS_LP1) {
+			_sde_connector_report_panel_dead(c_conn, false);
+		} else {
+			c_conn->panel_dead = true;
+			event.type = DRM_EVENT_PANEL_DEAD;
+			event.length = sizeof(bool);
+			msm_mode_object_event_notify(&c_conn->base.base,
+				c_conn->base.dev, &event, (u8 *)&c_conn->panel_dead);
+			SDE_EVT32(SDE_EVTLOG_ERROR);
+			SDE_ERROR("%s display esd irq check failed report"
+				" PANEL_DEAD conn_id: %d enc_id: %d\n",
+				display->display_type,
+				c_conn->base.base.id, c_conn->encoder->base.id);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sde_connector_register_esd_irq(struct sde_connector *c_conn)
+{
+	struct dsi_display *display = c_conn->display;
+	int rc = 0;
+
+	/* register esd irq and enable it after panel enabled */
+	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI) {
+		if (!display || !display->panel) {
+			SDE_ERROR("invalid display/panel\n");
+			return -EINVAL;
+		}
+		if (display->panel->mi_cfg.esd_err_irq_gpio > 0) {
+			rc = request_threaded_irq(display->panel->mi_cfg.esd_err_irq,
+				NULL, esd_err_irq_handle,
+				display->panel->mi_cfg.esd_err_irq_flags,
+				"esd_err_irq", c_conn);
+			if (rc) {
+				SDE_ERROR("register esd irq failed\n");
+			} else {
+				SDE_INFO("register esd irq success\n");
+				disable_irq(display->panel->mi_cfg.esd_err_irq);
+			}
+		}
+	}
+
+	return rc;
+}
+
 static const struct drm_connector_helper_funcs sde_connector_helper_ops = {
 	.get_modes =    sde_connector_get_modes,
 	.mode_valid =   sde_connector_mode_valid,
@@ -2709,6 +3193,8 @@ struct drm_connector *sde_connector_init(struct drm_device *dev,
 	INIT_DELAYED_WORK(&c_conn->status_work,
 			sde_connector_check_status_work);
 
+	sde_connector_register_esd_irq(c_conn);
+
 	return &c_conn->base;
 
 error_destroy_property:
@@ -2807,3 +3293,107 @@ int sde_connector_event_notify(struct drm_connector *connector, uint32_t type,
 
 	return ret;
 }
+
+int sde_connector_hbm_ctl(struct drm_connector *connector, uint32_t op_code)
+{
+	int ret = 0;
+	ret = dsi_display_hbm_set_disp_param(connector, op_code);
+	return ret;
+}
+
+int sde_connector_pre_hbm_ctl(struct drm_connector *connector)
+{
+	int ret;
+	/* close dimming */
+	ret = dsi_display_hbm_set_disp_param(connector, DISPPARAM_HBM_BACKLIGHT_RESEND);
+	return ret;
+}
+
+#define to_dsi_bridge(x)     container_of((x), struct dsi_bridge, base)
+
+static uint32_t interpolate(uint32_t x, uint32_t xa, uint32_t xb, uint32_t ya, uint32_t yb)
+{
+	uint32_t bf;
+
+	bf = ya - (ya - yb) * (x - xa) / (xb - xa);
+
+	return bf;
+}
+
+static uint32_t brightness_to_alpha(struct dsi_panel_mi_cfg *mi_cfg, uint32_t brightness)
+{
+	int i;
+	int level = mi_cfg->brightnes_alpha_lut_item_count;
+
+	if (brightness == 0x0)
+		return mi_cfg->brightness_alpha_lut[0].alpha;
+
+	for (i = 0; i < level; i++){
+		if (mi_cfg->brightness_alpha_lut[i].brightness >= brightness)
+			break;
+	}
+
+	if (i == level)
+		return mi_cfg->brightness_alpha_lut[i - 1].alpha;
+	else
+		return interpolate(brightness,
+							mi_cfg->brightness_alpha_lut[i-1].brightness, mi_cfg->brightness_alpha_lut[i].brightness,
+							mi_cfg->brightness_alpha_lut[i-1].alpha, mi_cfg->brightness_alpha_lut[i].alpha);
+}
+
+void sde_connector_mi_get_current_alpha(struct drm_connector *connector, uint32_t brightness, uint32_t *alpha)
+{
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+	struct dsi_panel_mi_cfg *mi_cfg = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		SDE_ERROR("Invalid connector/encoder/bridge ptr\n");
+		return;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel ptr\n");
+		return;
+	}
+
+	mi_cfg = &display->panel->mi_cfg;
+
+	*alpha = brightness_to_alpha(mi_cfg, brightness);
+	return;
+}
+
+void sde_connector_mi_get_current_backlight(struct drm_connector *connector, uint32_t *brightness)
+{
+	struct sde_connector *c_conn = to_sde_connector(connector);
+	struct dsi_display *display = NULL;
+	struct dsi_bridge *c_bridge = NULL;
+
+	if (!connector || !connector->encoder || !connector->encoder->bridge) {
+		SDE_ERROR("Invalid connector/encoder/bridge ptr\n");
+		return;
+	}
+
+	c_bridge =  to_dsi_bridge(connector->encoder->bridge);
+	display = c_bridge->display;
+	if (!display || !display->panel) {
+		SDE_ERROR("invalid display/panel ptr\n");
+		return;
+	}
+
+	if (display->panel->mi_cfg.in_aod) {
+		*brightness = display->panel->mi_cfg.aod_backlight;
+		return;
+	}
+
+	*brightness = c_conn->mi_dimlayer_state.current_backlight;
+}
+
+void sde_connector_mi_update_dimlayer_state(struct drm_connector *connector,
+	enum mi_dimlayer_type mi_dimlayer_type)
+{
+	struct sde_connector *c_conn = to_sde_connector(connector);
+	c_conn->mi_dimlayer_state.mi_dimlayer_type = mi_dimlayer_type;
+}
diff --git a/techpack/display/msm/sde/sde_connector.h b/techpack/display/msm/sde/sde_connector.h
index cbc6bfa0ce7f..ba9616da3b56 100644
--- a/techpack/display/msm/sde/sde_connector.h
+++ b/techpack/display/msm/sde/sde_connector.h
@@ -389,6 +389,22 @@ struct sde_connector_dyn_hdr_metadata {
 	bool dynamic_hdr_update;
 };
 
+enum mi_dimlayer_type {
+	MI_DIMLAYER_NULL = 0x0,
+	MI_DIMLAYER_FOD_HBM_OVERLAY = 0x1,
+	MI_DIMLAYER_FOD_ICON = 0x2,
+	MI_DIMLAYER_AOD = 0x4,
+	MI_LAYER_FOD_ANIM = 0x8,
+	MI_FOD_UNLOCK_SUCCESS = 0x10,
+	MI_DIMLAYER_MAX,
+};
+
+struct mi_dimlayer_state
+{
+	enum mi_dimlayer_type mi_dimlayer_type;
+	uint32_t current_backlight;
+};
+
 /**
  * struct sde_connector - local sde connector structure
  * @base: Base drm connector structure
@@ -468,6 +484,7 @@ struct sde_connector {
 	spinlock_t event_lock;
 
 	struct backlight_device *bl_device;
+	struct sde_clone_cdev *cdev_clone;
 	struct delayed_work status_work;
 	u32 esd_status_interval;
 	bool panel_dead;
@@ -486,6 +503,9 @@ struct sde_connector {
 
 	bool last_cmd_tx_sts;
 	bool hdr_capable;
+
+	struct mi_dimlayer_state mi_dimlayer_state;
+	u32 fod_frame_count;
 };
 
 /**
@@ -971,4 +991,22 @@ int sde_connector_get_panel_vfp(struct drm_connector *connector,
  */
 int sde_connector_esd_status(struct drm_connector *connector);
 
+/**
+ * sde_connector_hbm_ctl - mi function to control hbm
+ * @connector: Pointer to DRM connector object
+ * @op_code: hbm operation code
+ */
+int sde_connector_hbm_ctl(struct drm_connector *connector, uint32_t op_code);
+
+int sde_connector_pre_hbm_ctl(struct drm_connector *connector);
+
+void sde_connector_mi_update_dimlayer_state(struct drm_connector *connector,
+	enum mi_dimlayer_type mi_dimlayer_type);
+
+void sde_connector_mi_get_current_backlight(struct drm_connector *connector, uint32_t *brightness);
+
+void sde_connector_mi_get_current_alpha(struct drm_connector *connector, uint32_t brightness, uint32_t *alpha);
+
+void sde_connector_fod_notify(struct drm_connector *connector);
+
 #endif /* _SDE_CONNECTOR_H_ */
diff --git a/techpack/display/msm/sde/sde_crtc.c b/techpack/display/msm/sde/sde_crtc.c
index 602476ba8a4a..5f4760fb6d3d 100644
--- a/techpack/display/msm/sde/sde_crtc.c
+++ b/techpack/display/msm/sde/sde_crtc.c
@@ -2161,12 +2161,12 @@ static void sde_crtc_frame_event_cb(void *data, u32 event)
 	SDE_DEBUG("crtc%d\n", crtc->base.id);
 	SDE_EVT32_VERBOSE(DRMID(crtc), event);
 
-	spin_lock_irqsave(&sde_crtc->spin_lock, flags);
+	spin_lock_irqsave(&sde_crtc->fevent_spin_lock, flags);
 	fevent = list_first_entry_or_null(&sde_crtc->frame_event_list,
 			struct sde_crtc_frame_event, list);
 	if (fevent)
 		list_del_init(&fevent->list);
-	spin_unlock_irqrestore(&sde_crtc->spin_lock, flags);
+	spin_unlock_irqrestore(&sde_crtc->fevent_spin_lock, flags);
 
 	if (!fevent) {
 		SDE_ERROR("crtc%d event %d overflow\n",
@@ -2206,6 +2206,14 @@ static void sde_crtc_frame_event_cb(void *data, u32 event)
 	kthread_queue_work(&priv->event_thread[crtc_id].worker, &fevent->work);
 }
 
+static void _sde_crtc_mi_update_state(struct sde_crtc_state *cstate, enum mi_dimlayer_type dimlayer_state)
+{
+	int i = 0;
+
+	for (i = 0; i < cstate->num_connectors; i++)
+		sde_connector_mi_update_dimlayer_state(cstate->connectors[i], dimlayer_state);
+}
+
 void sde_crtc_prepare_commit(struct drm_crtc *crtc,
 		struct drm_crtc_state *old_state)
 {
@@ -2447,9 +2455,9 @@ static void sde_crtc_frame_event_work(struct kthread_work *work)
 		SDE_ERROR("crtc%d ts:%lld received panel dead event\n",
 				crtc->base.id, ktime_to_ns(fevent->ts));
 
-	spin_lock_irqsave(&sde_crtc->spin_lock, flags);
+	spin_lock_irqsave(&sde_crtc->fevent_spin_lock, flags);
 	list_add_tail(&fevent->list, &sde_crtc->frame_event_list);
-	spin_unlock_irqrestore(&sde_crtc->spin_lock, flags);
+	spin_unlock_irqrestore(&sde_crtc->fevent_spin_lock, flags);
 	SDE_ATRACE_END("crtc_frame_event");
 }
 
@@ -2498,6 +2506,7 @@ void _sde_crtc_clear_dim_layers_v1(struct drm_crtc_state *state)
 		memset(&cstate->dim_layer[i], 0, sizeof(cstate->dim_layer[i]));
 
 	cstate->num_dim_layers = 0;
+	cstate->num_dim_layers_bank = 0;
 }
 
 /**
@@ -2546,6 +2555,7 @@ static void _sde_crtc_set_dim_layer_v1(struct drm_crtc *crtc,
 
 	/* populate from user space */
 	cstate->num_dim_layers = count;
+	cstate->num_dim_layers_bank = count;
 	for (i = 0; i < count; i++) {
 		user_cfg = &dim_layer_v1.layer_cfg[i];
 
@@ -3158,6 +3168,8 @@ static void sde_crtc_atomic_begin(struct drm_crtc *crtc,
 	struct sde_splash_display *splash_display;
 	bool cont_splash_enabled = false;
 	size_t i;
+	uint32_t fod_sync_info;
+	struct sde_crtc_state *cstate;
 
 	if (!crtc) {
 		SDE_ERROR("invalid crtc\n");
@@ -3235,8 +3247,14 @@ static void sde_crtc_atomic_begin(struct drm_crtc *crtc,
 	}
 
 	if (sde_kms_is_cp_operation_allowed(sde_kms) &&
-			(cont_splash_enabled || sde_crtc->enabled))
+			(cont_splash_enabled || sde_crtc->enabled)) {
+
+		cstate = to_sde_crtc_state(crtc->state);
+		fod_sync_info = sde_crtc_get_mi_fod_sync_info(cstate);
+		sde_crtc->mi_dimlayer_type = fod_sync_info;
+
 		sde_cp_crtc_apply_properties(crtc);
+	}
 
 	/*
 	 * PP_DONE irq is only used by command mode for now.
@@ -3588,6 +3606,7 @@ void sde_crtc_commit_kickoff(struct drm_crtc *crtc,
 	unsigned long flags;
 	enum sde_crtc_idle_pc_state idle_pc_state;
 	struct sde_encoder_kickoff_params params = { 0 };
+	uint32_t fod_sync_info;
 
 	if (!crtc) {
 		SDE_ERROR("invalid argument\n");
@@ -3617,6 +3636,9 @@ void sde_crtc_commit_kickoff(struct drm_crtc *crtc,
 
 	idle_pc_state = sde_crtc_get_property(cstate, CRTC_PROP_IDLE_PC_STATE);
 
+	fod_sync_info = sde_crtc_get_mi_fod_sync_info(cstate);
+	_sde_crtc_mi_update_state(cstate, fod_sync_info);
+
 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 		if (encoder->crtc != crtc)
 			continue;
@@ -4921,6 +4943,157 @@ static int sde_crtc_atomic_check(struct drm_crtc *crtc,
 	return rc;
 }
 
+static uint32_t get_current_brightness(struct sde_crtc_state *cstate)
+{
+	int i;
+	uint32_t brightness;
+	for (i = 0; i < cstate->num_connectors; i++) {
+		sde_connector_mi_get_current_backlight(cstate->connectors[i], &brightness);
+	}
+	return brightness;
+}
+
+static uint32_t get_current_alpha(struct sde_crtc_state *cstate, uint32_t brightness)
+{
+	int i;
+	uint32_t alpha;
+	for (i = 0; i < cstate->num_connectors; i++) {
+		sde_connector_mi_get_current_alpha(cstate->connectors[i], brightness, &alpha);
+	}
+	return alpha;
+}
+
+static uint32_t _sde_crtc_config_mi_dim_layer_lapha(struct sde_crtc_state *cstate)
+{
+	uint32_t alpha, current_brightness;
+
+	current_brightness = get_current_brightness(cstate);
+	if(cstate->mi_state.dimlayer_backlight_stash == current_brightness)
+		return cstate->mi_state.dimlayer_alpha_stash;
+
+	alpha = get_current_alpha(cstate, current_brightness) & 0x000000FF;
+	cstate->mi_state.dimlayer_backlight_stash = current_brightness;
+	cstate->mi_state.dimlayer_alpha_stash = alpha;
+
+	return alpha;
+}
+
+void _sde_crtc_config_mi_dim_layer(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+				struct drm_crtc_state *drm_state, uint32_t dim_layer_stage)
+{
+	uint32_t alpha;
+	struct sde_hw_mixer *lm;
+	struct sde_crtc_mixer *mixer;
+	struct drm_display_mode *display_mode = &drm_state->adjusted_mode;
+	alpha = _sde_crtc_config_mi_dim_layer_lapha(cstate);
+	mixer = sde_crtc->mixers;
+	lm = mixer->hw_lm;
+
+	cstate->mi_state.mi_dim_layer = cstate->dim_layer;
+	if (lm && lm->ops.setup_dim_layer) {
+		if (cstate->num_dim_layers_bank <= SDE_MAX_DIM_LAYERS) {
+			cstate->dim_layer[cstate->num_dim_layers_bank].flags = SDE_DRM_DIM_LAYER_INCLUSIVE;
+			cstate->dim_layer[cstate->num_dim_layers_bank].stage = dim_layer_stage + SDE_STAGE_0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.x = 0x0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.y = 0x0;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.w = display_mode->hdisplay;
+			cstate->dim_layer[cstate->num_dim_layers_bank].rect.h = display_mode->vdisplay;
+			cstate->dim_layer[cstate->num_dim_layers_bank].color_fill = (struct sde_mdss_color) {0x0, 0x0, 0x0, alpha};
+			cstate->num_dim_layers = cstate->num_dim_layers_bank + 1;
+			_sde_crtc_mi_update_state(cstate, MI_DIMLAYER_FOD_ICON);
+		} else {
+			SDE_ERROR("invalid number of dim_layers:%d", cstate->num_dim_layers);
+		}
+	}
+}
+
+int sde_crtc_mi_atomic_check(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+		void *pstates, int cnt)
+{
+	uint32_t i;
+	uint32_t mi_plane;
+
+	uint32_t dim_layer_stage = 0x0;
+	uint32_t mi_aodlayer_index = 0x0;
+	uint32_t mi_iconlayer_index = 0x0;
+	uint32_t mi_pressed_Iconlayer_index = 0x0;
+	bool mi_dimlayer_switch_enable = true;
+	int max_stage = 0;
+	struct plane_state *pstates_ = (struct plane_state *)pstates;
+
+	/* dimlayer switch for FOD and DC function */
+	if (!mi_dimlayer_switch_enable)
+		return 0;
+
+	for (i = 0; i < cnt; i++) {
+		mi_plane = sde_plane_get_mi_layer_info(pstates_[i].drm_pstate);
+
+		switch (mi_plane) {
+		case MI_LAYER_FOD_HBM_OVERLAY:
+			mi_pressed_Iconlayer_index = i;
+			break;
+		case MI_LAYER_FOD_ICON:
+			mi_iconlayer_index = i;
+			break;
+		case MI_LAYER_AOD:
+			mi_aodlayer_index = i;
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* Create mi dim layer under index layer */
+	if (mi_pressed_Iconlayer_index > 0) {
+		dim_layer_stage = pstates_[mi_pressed_Iconlayer_index].stage;
+		for (i = 0; i < cnt; i++) {
+			if (pstates_[i].stage >= dim_layer_stage) {
+				pstates_[i].stage++;
+				pstates_[i].sde_pstate->stage++;
+				if (pstates_[i].stage > max_stage)
+					max_stage = pstates_[i].stage;
+			}
+		}
+
+		/* do not use same stage */
+		for (i = 0; i < cstate->num_dim_layers; i++) {
+			if (cstate->dim_layer[i].stage >= dim_layer_stage &&
+				cstate->dim_layer[i].stage <= max_stage)
+				cstate->dim_layer[i].stage++;
+		}
+	} else if ((mi_iconlayer_index > 0)) {
+		for (i = 0; i < cnt; i++) {
+			if (pstates_[i].stage > dim_layer_stage)
+				dim_layer_stage = pstates_[i].stage;
+		}
+
+		/* do not use same stage */
+		for (i = 0; i < cstate->num_dim_layers; i++) {
+			if (cstate->dim_layer[i].stage > dim_layer_stage )
+				cstate->dim_layer[i].stage = dim_layer_stage++;
+		}
+
+		dim_layer_stage++;
+	}
+
+	if (dim_layer_stage > SDE_STAGE_MAX - SDE_STAGE_0) {
+		SDE_ERROR(" > %d plane stages assigned\n", SDE_STAGE_MAX - SDE_STAGE_0);
+		return 0;
+	 }
+
+	if (dim_layer_stage > 0x0 && cstate->mi_state.mi_dim_layer == NULL) {
+		SDE_ATRACE_BEGIN("dimlayer_show");
+		_sde_crtc_config_mi_dim_layer(sde_crtc, cstate, &cstate->base, dim_layer_stage);
+		SDE_ATRACE_END("dimlayer_show");
+	} else {
+		cstate->mi_state.mi_dim_layer = NULL;
+		_sde_crtc_mi_update_state(cstate, MI_DIMLAYER_NULL);
+	}
+
+	return 0;
+}
+
 /**
  * sde_crtc_get_num_datapath - get the number of datapath active
  *				of primary connector
@@ -5072,6 +5245,10 @@ static void sde_crtc_install_properties(struct drm_crtc *crtc,
 		return;
 	}
 
+	/* mi properties */
+	msm_property_install_range(&sde_crtc->property_info, "mi_fod_sync_info",
+		0x0, 0, U32_MAX, 0, CRTC_PROP_MI_FOD_SYNC_INFO);
+
 	/* range properties */
 	msm_property_install_range(&sde_crtc->property_info,
 		"input_fence_timeout", 0x0, 0, SDE_CRTC_MAX_INPUT_FENCE_TIMEOUT,
@@ -6283,6 +6460,7 @@ struct drm_crtc *sde_crtc_init(struct drm_device *dev, struct drm_plane *plane)
 
 	mutex_init(&sde_crtc->crtc_lock);
 	spin_lock_init(&sde_crtc->spin_lock);
+	spin_lock_init(&sde_crtc->fevent_spin_lock);
 	atomic_set(&sde_crtc->frame_pending, 0);
 	mutex_init(&sde_crtc->vblank_modeset_ctrl_lock);
 
@@ -6618,3 +6796,11 @@ void sde_crtc_update_cont_splash_settings(struct drm_crtc *crtc)
 					rate : kms->perf.max_core_clk_rate;
 	sde_crtc->cur_perf.core_clk_rate = kms->perf.max_core_clk_rate;
 }
+
+uint32_t sde_crtc_get_mi_fod_sync_info(struct sde_crtc_state *cstate)
+{
+	if (!cstate)
+		return 0;
+
+	return sde_crtc_get_property(cstate, CRTC_PROP_MI_FOD_SYNC_INFO);
+}
diff --git a/techpack/display/msm/sde/sde_crtc.h b/techpack/display/msm/sde/sde_crtc.h
index bd16cd3da6fe..4705ec1038b1 100644
--- a/techpack/display/msm/sde/sde_crtc.h
+++ b/techpack/display/msm/sde/sde_crtc.h
@@ -340,6 +340,7 @@ struct sde_crtc {
 	struct sde_crtc_frame_event frame_events[SDE_CRTC_FRAME_EVENT_SIZE];
 	struct list_head frame_event_list;
 	spinlock_t spin_lock;
+	spinlock_t fevent_spin_lock;
 
 	/* for handling internal event thread */
 	struct sde_crtc_event event_cache[SDE_CRTC_MAX_EVENT_COUNT];
@@ -373,14 +374,60 @@ struct sde_crtc {
 	struct mutex ltm_buffer_lock;
 	spinlock_t ltm_lock;
 	bool needs_hw_reset;
+	int hist_irq_idx;
 
 	int comp_ratio;
+	uint32_t mi_dimlayer_type;
 
 	struct drm_property_blob *dspp_blob_info;
 };
 
 #define to_sde_crtc(x) container_of(x, struct sde_crtc, base)
 
+/**
+ * enum sde_crtc_mi_layer_type: type of mi layer
+ * @MI_LAYER_FOD_PRESSED_ICON: FOD touched icon layer
+ * @MI_LAYER_FOD_ICON: FOD untouch icon layer
+ * @MI_LAYER_AOD: AOD layer
+ */
+enum sde_crtc_mi_layer_type {
+	MI_LAYER_NULL = 0x0,
+	MI_LAYER_FOD_HBM_OVERLAY = 0x1,
+	MI_LAYER_FOD_ICON = 0x2,
+	MI_LAYER_AOD = 0x4,
+	MI_LAYER_MAX,
+};
+
+/**
+ * sde_crtc_mi_dc_backlight - mi dc backlight
+ * @mi_dc_bl_state: dc backlihgt state
+ * @mi_dc_backlight_level: last backlight stash
+ * @mi_dc_layer_alpha: dc dim layer alpha
+ */
+typedef struct sde_crtc_mi_dc_backlight
+{
+	uint8_t mi_dc_bl_state;
+	int32_t mi_dc_bl_level;
+	int32_t mi_dc_bl_layer_alpha;
+} sde_crtc_mi_dc_backlight;
+
+typedef struct sde_crtc_mi_layer
+{
+	int32_t layer_index;
+	enum sde_crtc_mi_layer_type last_state;
+} sde_crtc_mi_layer;
+
+/**
+ * sde_crtc_mi_state - mi crtc state
+ * @mi_dim_layer: dim layer added by Mi
+ */
+struct sde_crtc_mi_state {
+	struct sde_hw_dim_layer *mi_dim_layer;
+	struct sde_crtc_mi_layer mi_layer;
+	uint32_t dimlayer_backlight_stash;
+	uint8_t  dimlayer_alpha_stash;
+};
+
 /**
  * struct sde_crtc_state - sde container for atomic crtc state
  * @base: Base drm crtc state structure
@@ -438,6 +485,10 @@ struct sde_crtc_state {
 	struct sde_hw_scaler3_lut_cfg scl3_lut_cfg;
 
 	struct sde_core_perf_params new_perf;
+    /* Mi crtc state */
+	struct sde_crtc_mi_state mi_state;
+	uint32_t num_dim_layers_bank;
+  
 	int secure_session;
 };
 
@@ -860,6 +911,25 @@ void sde_crtc_misr_setup(struct drm_crtc *crtc, bool enable, u32 frame_count);
 void sde_crtc_get_misr_info(struct drm_crtc *crtc,
 		struct sde_crtc_misr_info *crtc_misr_info);
 
+/**
+ * sde_crtc_mi_atomic_check - to do crtc mi atomic check
+ * @crtc: Pointer to sde crtc state structure
+ * @cstate: Pointer to sde crtc state structure
+ * @pstates: Pointer to sde plane state structure
+ * @cnt: plane refence count
+ */
+int sde_crtc_mi_atomic_check(struct sde_crtc *sde_crtc, struct sde_crtc_state *cstate,
+		void *pstates, int cnt);
+
+/**
+ * sde_crtc_mi_atomic_check - to do crtc mi atomic check
+ * @crtc: Pointer to sde crtc state structure
+ * @cstate: Pointer to sde crtc state structure
+ * @pstates: Pointer to sde plane state structure
+ * @cnt: plane refence count
+ */
+uint32_t sde_crtc_get_mi_fod_sync_info(struct sde_crtc_state *cstate);
+
 /**
  * sde_crtc_get_num_datapath - get the number of datapath active
  *				of primary connector
diff --git a/techpack/display/msm/sde/sde_encoder.c b/techpack/display/msm/sde/sde_encoder.c
index 71bbeaf7b01a..4efe5bab4fba 100644
--- a/techpack/display/msm/sde/sde_encoder.c
+++ b/techpack/display/msm/sde/sde_encoder.c
@@ -40,6 +40,9 @@
 #include "sde_core_irq.h"
 #include "sde_hw_top.h"
 #include "sde_hw_qdss.h"
+#include "dsi_display.h"
+#include "dsi_panel_mi.h"
+#include "dsi_drm.h"
 
 #define SDE_DEBUG_ENC(e, fmt, ...) SDE_DEBUG("enc%d " fmt,\
 		(e) ? (e)->base.base.id : -1, ##__VA_ARGS__)
@@ -283,6 +286,7 @@ struct sde_encoder_virt {
 	struct kthread_delayed_work delayed_off_work;
 	struct kthread_work vsync_event_work;
 	struct kthread_work input_event_work;
+	struct kthread_work touch_notify_work;
 	struct kthread_work esd_trigger_work;
 	struct input_handler *input_handler;
 	struct msm_display_topology topology;
@@ -300,10 +304,45 @@ struct sde_encoder_virt {
 	bool elevated_ahb_vote;
 	struct pm_qos_request pm_qos_cpu_req;
 	struct msm_mode_info mode_info;
+	bool prepare_kickoff;
+	bool ready_kickoff;
 };
 
 #define to_sde_encoder_virt(x) container_of(x, struct sde_encoder_virt, base)
 
+bool get_sde_encoder_virt_prepare_kickoff(struct drm_connector *connector)
+{
+	struct sde_encoder_virt *sde_enc;
+
+	sde_enc = to_sde_encoder_virt(connector->encoder);
+	return sde_enc->prepare_kickoff;
+}
+
+bool get_sde_encoder_virt_ready_kickoff(struct drm_connector *connector)
+{
+	struct sde_encoder_virt *sde_enc;
+
+	sde_enc = to_sde_encoder_virt(connector->encoder);
+	return sde_enc->ready_kickoff;
+}
+
+void set_sde_encoder_virt_prepare_kickoff(struct drm_connector *connector,bool enable)
+{
+	struct sde_encoder_virt *sde_enc;
+
+	sde_enc = to_sde_encoder_virt(connector->encoder);
+	sde_enc->prepare_kickoff = enable;
+}
+
+void set_sde_encoder_virt_ready_kickoff(struct drm_connector *connector,bool enable)
+{
+	struct sde_encoder_virt *sde_enc;
+
+	sde_enc = to_sde_encoder_virt(connector->encoder);
+	sde_enc->ready_kickoff = enable;
+}
+
+
 void sde_encoder_uidle_enable(struct drm_encoder *drm_enc, bool enable)
 {
 	struct sde_encoder_virt *sde_enc;
@@ -2336,9 +2375,13 @@ static void sde_encoder_input_event_handler(struct input_handle *handle,
 	SDE_EVT32_VERBOSE(DRMID(drm_enc));
 
 	disp_thread = &priv->disp_thread[sde_enc->crtc->index];
-
 	kthread_queue_work(&disp_thread->worker,
-				&sde_enc->input_event_work);
+				&sde_enc->touch_notify_work);
+
+	/* Only consider EV_ABS (touch) events in QC original design */
+	if (type == EV_ABS && sde_encoder_check_curr_mode(drm_enc, MSM_DISPLAY_CMD_MODE))
+		kthread_queue_work(&disp_thread->worker,
+					&sde_enc->input_event_work);
 }
 
 void sde_encoder_control_idle_pc(struct drm_encoder *drm_enc, bool enable)
@@ -3175,6 +3218,10 @@ static const struct input_device_id sde_input_ids[] = {
 					BIT_MASK(ABS_MT_POSITION_X) |
 					BIT_MASK(ABS_MT_POSITION_Y) },
 	},
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+	},
 	{ },
 };
 
@@ -3184,8 +3231,10 @@ static void _sde_encoder_input_handler_register(
 	struct sde_encoder_virt *sde_enc = to_sde_encoder_virt(drm_enc);
 	int rc;
 
+#if 0
 	if (!sde_encoder_check_curr_mode(drm_enc, MSM_DISPLAY_CMD_MODE))
 		return;
+#endif
 
 	if (sde_enc->input_handler && !sde_enc->input_handler->private) {
 		sde_enc->input_handler->private = sde_enc;
@@ -3205,8 +3254,10 @@ static void _sde_encoder_input_handler_unregister(
 {
 	struct sde_encoder_virt *sde_enc = to_sde_encoder_virt(drm_enc);
 
+#if 0
 	if (!sde_encoder_check_curr_mode(drm_enc, MSM_DISPLAY_CMD_MODE))
 		return;
+#endif
 
 	if (sde_enc->input_handler && sde_enc->input_handler->private) {
 		input_unregister_handler(sde_enc->input_handler);
@@ -4477,11 +4528,29 @@ static void _sde_encoder_setup_dither(struct sde_encoder_phys *phys)
 	struct msm_display_dsc_info *dsc = NULL;
 	struct sde_encoder_virt *sde_enc;
 	struct sde_hw_pingpong *hw_pp;
+	struct dsi_display *dsi_display;
+	struct sde_connector *c_conn;
+	struct dsi_panel_mi_cfg *mi_cfg;
 
 	if (!phys || !phys->connector || !phys->hw_pp ||
 			!phys->hw_pp->ops.setup_dither || !phys->parent)
 		return;
 
+	c_conn = to_sde_connector(phys->connector);
+	if (c_conn->connector_type == DRM_MODE_CONNECTOR_DSI) {
+		dsi_display = (struct dsi_display *) c_conn->display;
+		if (!dsi_display || !dsi_display->panel) {
+			SDE_ERROR("invalid display/panel\n");
+			return;
+		}
+
+		mi_cfg = &dsi_display->panel->mi_cfg;
+		if (!mi_cfg->dither_enabled) {
+			SDE_DEBUG("dither_enabled = %d\n", mi_cfg->dither_enabled);
+			return;
+		}
+	}
+
 	topology = sde_connector_get_topology_name(phys->connector);
 	if ((topology == SDE_RM_TOPOLOGY_PPSPLIT) &&
 			(phys->split_role == ENC_ROLE_SLAVE))
@@ -4639,6 +4708,26 @@ static void sde_encoder_input_event_work_handler(struct kthread_work *work)
 			SDE_ENC_RC_EVENT_EARLY_WAKEUP);
 }
 
+static void sde_encoder_touch_notify_work_handler(struct kthread_work *work)
+{
+	struct dsi_bridge *c_bridge = NULL;
+	struct dsi_display *dsi_display = NULL;
+	struct drm_encoder *drm_enc = NULL;
+	struct sde_encoder_virt *sde_enc = container_of(work,
+				struct sde_encoder_virt, touch_notify_work);
+
+	if (!sde_enc) {
+		SDE_ERROR("invalid encoder for the touch notify\n");
+		return;
+	}
+
+	drm_enc = &sde_enc->base;
+
+	c_bridge = container_of(drm_enc->bridge, struct dsi_bridge, base);
+	if (c_bridge)
+		dsi_display = c_bridge->display;
+}
+
 static void sde_encoder_vsync_event_work_handler(struct kthread_work *work)
 {
 	struct sde_encoder_virt *sde_enc = container_of(work,
@@ -4976,6 +5065,9 @@ int sde_encoder_prepare_for_kickoff(struct drm_encoder *drm_enc,
 				sde_enc->cur_master, sde_kms->qdss_enabled);
 
 end:
+	if (sde_enc->ready_kickoff) {
+		sde_enc->prepare_kickoff = true;
+	}
 	SDE_ATRACE_END("sde_encoder_prepare_for_kickoff");
 	return ret;
 }
@@ -5023,8 +5115,13 @@ void sde_encoder_kickoff(struct drm_encoder *drm_enc, bool is_error)
 {
 	struct sde_encoder_virt *sde_enc;
 	struct sde_encoder_phys *phys;
+	struct dsi_bridge *bridge = NULL;
+	struct dsi_display *dsi_display = NULL;
+	struct dsi_display_mode adj_mode;
 	ktime_t wakeup_time;
 	unsigned int i;
+	struct sde_kms *sde_kms = NULL;
+	struct msm_drm_private *priv = NULL;
 
 	if (!drm_enc) {
 		SDE_ERROR("invalid encoder\n");
@@ -5039,6 +5136,20 @@ void sde_encoder_kickoff(struct drm_encoder *drm_enc, bool is_error)
 	if (is_error)
 		_sde_encoder_reset_ctl_hw(drm_enc);
 
+	if (sde_enc->disp_info.intf_type == DRM_MODE_CONNECTOR_DSI
+		&& drm_enc->bridge)
+		bridge = container_of(drm_enc->bridge, struct dsi_bridge, base);
+	if (bridge) {
+		adj_mode = bridge->dsi_mode;
+		dsi_display = bridge->display;
+		if (dsi_display && dsi_display->panel
+			&& (dsi_display->panel->host_config.phy_type == DSI_PHY_TYPE_CPHY || dsi_display->panel->mi_cfg.panel_id == 0x4C38314100420400)
+			&& adj_mode.dsi_mode_flags & DSI_MODE_FLAG_VRR) {
+			mutex_lock(&dsi_display->panel->panel_lock);
+			sde_encoder_vid_wait_for_active(drm_enc);
+		}
+	}
+
 	/* All phys encs are ready to go, trigger the kickoff */
 	_sde_encoder_kickoff_phys(sde_enc);
 
@@ -5056,6 +5167,19 @@ void sde_encoder_kickoff(struct drm_encoder *drm_enc, bool is_error)
 				nsecs_to_jiffies(ktime_to_ns(wakeup_time)));
 	}
 
+	if (dsi_display && dsi_display->panel
+		&& (dsi_display->panel->host_config.phy_type == DSI_PHY_TYPE_CPHY || dsi_display->panel->mi_cfg.panel_id == 0x4C38314100420400)
+		&& adj_mode.dsi_mode_flags & DSI_MODE_FLAG_VRR) {
+		dsi_panel_match_fps_pen_setting(dsi_display->panel, &adj_mode);
+		mutex_unlock(&dsi_display->panel->panel_lock);
+	}
+
+	priv = sde_enc->base.dev->dev_private;
+	if (priv != NULL) {
+		sde_kms = to_sde_kms(priv->kms);
+		sde_kms_kickoff_count(sde_kms);
+	}
+
 	SDE_ATRACE_END("encoder_kickoff");
 }
 
@@ -5815,7 +5939,7 @@ struct drm_encoder *sde_encoder_init_with_ops(
 		sde_enc->rsc_client = NULL;
 	}
 
-	if (disp_info->capabilities & MSM_DISPLAY_CAP_CMD_MODE) {
+	if (disp_info->capabilities & (MSM_DISPLAY_CAP_CMD_MODE | MSM_DISPLAY_CAP_VID_MODE)) {
 		ret = _sde_encoder_input_handler(sde_enc);
 		if (ret)
 			SDE_ERROR(
@@ -5834,6 +5958,9 @@ struct drm_encoder *sde_encoder_init_with_ops(
 	kthread_init_work(&sde_enc->input_event_work,
 			sde_encoder_input_event_work_handler);
 
+	kthread_init_work(&sde_enc->touch_notify_work,
+			sde_encoder_touch_notify_work_handler);
+
 	kthread_init_work(&sde_enc->esd_trigger_work,
 			sde_encoder_esd_trigger_work_handler);
 
@@ -5858,6 +5985,37 @@ struct drm_encoder *sde_encoder_init(
 	return sde_encoder_init_with_ops(dev, disp_info, NULL);
 }
 
+int sde_encoder_vid_wait_for_active(
+			struct drm_encoder *drm_enc)
+{
+	struct drm_display_mode mode;
+	struct sde_encoder_virt *sde_enc = NULL;
+	u32 ln_cnt, min_ln_cnt, active_mark_region;
+	u32 i, retry = 15;
+	if (!drm_enc) {
+		SDE_ERROR("invalid encoder\n");
+		return -EINVAL;
+	}
+	sde_enc = to_sde_encoder_virt(drm_enc);
+	for (i = 0; i < sde_enc->num_phys_encs; i++) {
+		struct sde_encoder_phys *phys = sde_enc->phys_encs[i];
+		if (!phys || (phys->ops.is_master && !phys->ops.is_master(phys)))
+			continue;
+		mode = phys->cached_mode;
+		min_ln_cnt = (mode.vtotal - mode.vsync_start) +
+			(mode.vsync_end - mode.vsync_start);
+		active_mark_region = mode.vdisplay + min_ln_cnt - mode.vdisplay / 4;
+		while (retry) {
+			ln_cnt = phys->ops.get_line_count(phys);
+			if ((ln_cnt > min_ln_cnt) && (ln_cnt < active_mark_region))
+				return 0;
+			udelay(2000);
+			retry--;
+		}
+	}
+	return -EINVAL;
+}
+
 int sde_encoder_wait_for_event(struct drm_encoder *drm_enc,
 	enum msm_event_wait event)
 {
diff --git a/techpack/display/msm/sde/sde_encoder.h b/techpack/display/msm/sde/sde_encoder.h
index ebee140da628..ccb395fbe8be 100644
--- a/techpack/display/msm/sde/sde_encoder.h
+++ b/techpack/display/msm/sde/sde_encoder.h
@@ -372,6 +372,13 @@ void sde_encoder_needs_hw_reset(struct drm_encoder *enc);
  */
 void sde_encoder_uidle_enable(struct drm_encoder *drm_enc, bool enable);
 
+/**
+ * sde_encoder_vid_wait_for_active - wait Vactive region for some mark region
+ * @drm_enc:    Pointer to drm encoder structure
+ * @Return:     non zero value if wait timeout occurred
+ */
+int sde_encoder_vid_wait_for_active(struct drm_encoder *enc);
+
 /**
  * sde_encoder_virt_reset - delay encoder virt reset
  * @drm_enc:	Pointer to drm encoder structure
@@ -399,4 +406,12 @@ static inline struct sde_kms *sde_encoder_get_kms(struct drm_encoder *drm_enc)
 	return to_sde_kms(priv->kms);
 }
 
+bool get_sde_encoder_virt_prepare_kickoff(struct drm_connector *connector);
+
+bool get_sde_encoder_virt_ready_kickoff(struct drm_connector *connector);
+
+void set_sde_encoder_virt_prepare_kickoff(struct drm_connector *connector,bool enable);
+
+void set_sde_encoder_virt_ready_kickoff(struct drm_connector *connector,bool enable);
+
 #endif /* __SDE_ENCODER_H__ */
diff --git a/techpack/display/msm/sde/sde_hw_color_proc_v4.c b/techpack/display/msm/sde/sde_hw_color_proc_v4.c
index 19ccb2549760..a6d494102493 100644
--- a/techpack/display/msm/sde/sde_hw_color_proc_v4.c
+++ b/techpack/display/msm/sde/sde_hw_color_proc_v4.c
@@ -222,7 +222,11 @@ void sde_setup_dspp_pccv4(struct sde_hw_dspp *ctx, void *cfg)
 		return;
 	}
 
-	pcc_cfg = hw_cfg->payload;
+	if (hw_cfg->payload_clear) {
+		pcc_cfg = hw_cfg->payload_clear;
+	} else {
+		pcc_cfg = hw_cfg->payload;
+	}
 
 	for (i = 0; i < PCC_NUM_PLANES; i++) {
 		base = ctx->cap->sblk->pcc.base + (i * sizeof(u32));
diff --git a/techpack/display/msm/sde/sde_hw_color_processing_v1_7.c b/techpack/display/msm/sde/sde_hw_color_processing_v1_7.c
index e7920320fab2..fa35f8d52200 100644
--- a/techpack/display/msm/sde/sde_hw_color_processing_v1_7.c
+++ b/techpack/display/msm/sde/sde_hw_color_processing_v1_7.c
@@ -688,7 +688,11 @@ void sde_setup_dspp_pcc_v1_7(struct sde_hw_dspp *ctx, void *cfg)
 		return;
 	}
 	DRM_DEBUG_DRIVER("Enable PCC feature\n");
-	pcc = hw_cfg->payload;
+	if (hw_cfg->payload_clear) {
+		pcc = hw_cfg->payload_clear;
+	} else {
+		pcc = hw_cfg->payload;
+	}
 
 	SDE_REG_WRITE(&ctx->hw, ctx->cap->sblk->pcc.base + PCC_CONST_COEFF_OFF,
 				  pcc->r.c & PCC_CONST_COEFF_MASK);
@@ -951,17 +955,17 @@ void sde_read_dspp_hist_v1_7(struct sde_hw_dspp *ctx, void *cfg)
 
 void sde_lock_dspp_hist_v1_7(struct sde_hw_dspp *ctx, void *cfg)
 {
-	u32 offset_ctl;
+	u32 offset_ctl, val;
 
-	if (!ctx) {
+	if (!ctx || !cfg) {
 		DRM_ERROR("invalid parameters ctx %pK", ctx);
 		return;
 	}
 
 	offset_ctl = ctx->cap->sblk->hist.base + PA_HIST_CTRL_DSPP_OFF;
 
-	/* lock hist buffer */
-	SDE_REG_WRITE(&ctx->hw, offset_ctl, 1);
+	val = (*(u32 *)cfg) & 0x1;
+	SDE_REG_WRITE(&ctx->hw, offset_ctl, val);
 }
 
 void sde_setup_dspp_dither_v1_7(struct sde_hw_dspp *ctx, void *cfg)
diff --git a/techpack/display/msm/sde/sde_hw_mdss.h b/techpack/display/msm/sde/sde_hw_mdss.h
index 15f0b91d3c2a..3cefb241a364 100644
--- a/techpack/display/msm/sde/sde_hw_mdss.h
+++ b/techpack/display/msm/sde/sde_hw_mdss.h
@@ -552,6 +552,8 @@ struct sde_hw_cp_cfg {
 	u32 displayh;
 	struct sde_hw_dspp *dspp[DSPP_MAX];
 	bool broadcast_disabled;
+	u32 mi_dimlayer_type;
+	void *payload_clear;
 };
 
 /**
diff --git a/techpack/display/msm/sde/sde_hw_reg_dma_v1_color_proc.c b/techpack/display/msm/sde/sde_hw_reg_dma_v1_color_proc.c
index 54629ab004fd..f52891f7a6cc 100644
--- a/techpack/display/msm/sde/sde_hw_reg_dma_v1_color_proc.c
+++ b/techpack/display/msm/sde/sde_hw_reg_dma_v1_color_proc.c
@@ -1278,7 +1278,12 @@ void reg_dmav1_setup_dspp_pccv4(struct sde_hw_dspp *ctx, void *cfg)
 		return;
 	}
 
-	pcc_cfg = hw_cfg->payload;
+	if (hw_cfg->payload_clear) {
+		pcc_cfg = hw_cfg->payload_clear;
+	} else {
+		pcc_cfg = hw_cfg->payload;
+	}
+
 	dma_ops = sde_reg_dma_get_ops();
 	dma_ops->reset_reg_dma_buf(dspp_buf[PCC][ctx->idx]);
 
diff --git a/techpack/display/msm/sde/sde_hw_top.c b/techpack/display/msm/sde/sde_hw_top.c
index b02cd17cbb28..d01ab8f1c18b 100644
--- a/techpack/display/msm/sde/sde_hw_top.c
+++ b/techpack/display/msm/sde/sde_hw_top.c
@@ -50,6 +50,8 @@
 #define MDP_WD_TIMER_4_CTL2               0x444
 #define MDP_WD_TIMER_4_LOAD_VALUE         0x448
 
+#define LTM_SW_FUSE_OFFSET 0x10
+
 #define MDP_TICK_COUNT                    16
 #define XO_CLK_RATE                       19200
 #define MS_TICKS_IN_SEC                   1000
@@ -649,3 +651,33 @@ void sde_hw_mdp_destroy(struct sde_hw_mdp *mdp)
 	kfree(mdp);
 }
 
+struct sde_hw_sw_fuse *sde_hw_sw_fuse_init(void __iomem *addr,
+	u32 sw_fuse_len, const struct sde_mdss_cfg *m)
+{
+	struct sde_hw_sw_fuse *c;
+
+	c = kzalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return ERR_PTR(-ENOMEM);
+
+	c->hw.base_off = addr;
+	c->hw.blk_off = 0;
+	c->hw.length = sw_fuse_len;
+	c->hw.hwversion = m->hwversion;
+
+	return c;
+}
+
+void sde_hw_sw_fuse_destroy(struct sde_hw_sw_fuse *sw_fuse)
+{
+	kfree(sw_fuse);
+}
+
+u32 sde_hw_get_ltm_sw_fuse_value(struct sde_hw_sw_fuse *sw_fuse)
+{
+	u32 ltm_sw_fuse = 0;
+
+	if (sw_fuse)
+		ltm_sw_fuse = SDE_REG_READ(&sw_fuse->hw, LTM_SW_FUSE_OFFSET);
+	return ltm_sw_fuse;
+}
diff --git a/techpack/display/msm/sde/sde_hw_top.h b/techpack/display/msm/sde/sde_hw_top.h
index 21f1daf1098f..7f188abfb359 100644
--- a/techpack/display/msm/sde/sde_hw_top.h
+++ b/techpack/display/msm/sde/sde_hw_top.h
@@ -242,6 +242,12 @@ struct sde_hw_sid {
 	struct sde_hw_blk_reg_map hw;
 };
 
+#define SW_FUSE_ENABLE 0x1
+struct sde_hw_sw_fuse {
+	/* sw fuse base */
+	struct sde_hw_blk_reg_map hw;
+};
+
 /**
  * sde_hw_sid_rotator_set - initialize the sid blk reg map
  * @addr: Mapped register io address
@@ -279,4 +285,23 @@ struct sde_hw_mdp *sde_hw_mdptop_init(enum sde_mdp idx,
 
 void sde_hw_mdp_destroy(struct sde_hw_mdp *mdp);
 
+/**
+ * sde_hw_sw_fuse_init - initialize the sw fuse blk reg map
+ * @addr: Mapped register io address
+ * @sw_fuse_len: Length of block
+ * @m: Pointer to mdss catalog data
+ */
+struct sde_hw_sw_fuse *sde_hw_sw_fuse_init(void __iomem *addr,
+		u32 sw_fuse_len, const struct sde_mdss_cfg *m);
+/**
+ * sde_hw_sw_fuse_destroy - free memory for sw fuse
+ * @sw_fuse: sde_hw_sw_fuse
+ */
+void sde_hw_sw_fuse_destroy(struct sde_hw_sw_fuse *sw_fuse);
+
+/**
+ * sde_hw_get_ltm_sw_fuse_value - read LTM sw fuse register value
+ * @sw_fuse: sde_hw_sw_fuse
+ */
+u32 sde_hw_get_ltm_sw_fuse_value(struct sde_hw_sw_fuse *sw_fuse);
 #endif /*_SDE_HW_TOP_H */
diff --git a/techpack/display/msm/sde/sde_kms.c b/techpack/display/msm/sde/sde_kms.c
index 2b8e9e6ff190..7a92002933d7 100644
--- a/techpack/display/msm/sde/sde_kms.c
+++ b/techpack/display/msm/sde/sde_kms.c
@@ -1199,6 +1199,8 @@ static void sde_kms_complete_commit(struct msm_kms *kms,
 			pr_err("Connector Post kickoff failed rc=%d\n",
 					 rc);
 		}
+
+		sde_connector_fod_notify(connector);
 	}
 
 	_sde_kms_drm_check_dpms(old_state, DRM_PANEL_EVENT_BLANK);
@@ -1930,6 +1932,14 @@ static void _sde_kms_hw_destroy(struct sde_kms *sde_kms,
 		msm_iounmap(pdev, sde_kms->sid);
 	sde_kms->sid = NULL;
 
+	if (sde_kms->hw_sw_fuse)
+		sde_hw_sw_fuse_destroy(sde_kms->hw_sw_fuse);
+	sde_kms->hw_sw_fuse = NULL;
+
+	if (sde_kms->sw_fuse)
+		msm_iounmap(pdev, sde_kms->sw_fuse);
+	sde_kms->sw_fuse = NULL;
+
 	if (sde_kms->reg_dma)
 		msm_iounmap(pdev, sde_kms->reg_dma);
 	sde_kms->reg_dma = NULL;
@@ -3552,6 +3562,19 @@ static int _sde_kms_hw_init_ioremap(struct sde_kms *sde_kms,
 	if (rc)
 		SDE_ERROR("dbg base register sid failed: %d\n", rc);
 
+	sde_kms->sw_fuse = msm_ioremap(platformdev, "swfuse_phys",
+					"swfuse_phys");
+	if (IS_ERR(sde_kms->sw_fuse)) {
+		sde_kms->sw_fuse = NULL;
+		SDE_DEBUG("sw_fuse is not defined");
+	} else {
+		sde_kms->sw_fuse_len = msm_iomap_size(platformdev,
+							"swfuse_phys");
+		rc =  sde_dbg_reg_register_base("sw_fuse", sde_kms->sw_fuse,
+						sde_kms->sw_fuse_len);
+		if (rc)
+			SDE_ERROR("dbg base register sw_fuse failed: %d\n", rc);
+	}
 error:
 	return rc;
 }
@@ -3756,6 +3779,17 @@ static int _sde_kms_hw_init_blocks(struct sde_kms *sde_kms,
 		goto perf_err;
 	}
 
+	if (sde_kms->sw_fuse) {
+		sde_kms->hw_sw_fuse = sde_hw_sw_fuse_init(sde_kms->sw_fuse,
+				sde_kms->sw_fuse_len, sde_kms->catalog);
+		if (IS_ERR(sde_kms->hw_sw_fuse)) {
+			SDE_ERROR("failed to init sw_fuse %ld\n",
+					PTR_ERR(sde_kms->hw_sw_fuse));
+			sde_kms->hw_sw_fuse = NULL;
+		}
+	} else {
+		sde_kms->hw_sw_fuse = NULL;
+	}
 	/*
 	 * _sde_kms_drm_obj_init should create the DRM related objects
 	 * i.e. CRTCs, planes, encoders, connectors and so forth
@@ -3933,3 +3967,17 @@ int sde_kms_handle_recovery(struct drm_encoder *encoder)
 	SDE_EVT32(DRMID(encoder), MSM_ENC_ACTIVE_REGION);
 	return sde_encoder_wait_for_event(encoder, MSM_ENC_ACTIVE_REGION);
 }
+
+void sde_kms_kickoff_count(struct sde_kms *sde_kms)
+{
+	int i;
+	struct dsi_display *display = NULL;
+
+	if (sde_kms != NULL) {
+		for (i = 0; i < sde_kms->dsi_display_count; ++i) {
+			display = sde_kms->dsi_displays[i];
+		}
+	}
+
+	return;
+}
diff --git a/techpack/display/msm/sde/sde_kms.h b/techpack/display/msm/sde/sde_kms.h
index 6882cdfdb00f..fff0c9f32950 100644
--- a/techpack/display/msm/sde/sde_kms.h
+++ b/techpack/display/msm/sde/sde_kms.h
@@ -249,9 +249,10 @@ struct sde_kms {
 
 	/* io/register spaces: */
 	void __iomem *mmio, *vbif[VBIF_MAX], *reg_dma, *sid,
-		*imem;
+		*imem, *sw_fuse;
 	unsigned long mmio_len, vbif_len[VBIF_MAX],
 		reg_dma_len, sid_len, imem_len;
+	unsigned long sw_fuse_len;
 
 	struct regulator *vdd;
 	struct regulator *mmagic;
@@ -277,6 +278,7 @@ struct sde_kms {
 	struct sde_hw_mdp *hw_mdp;
 	struct sde_hw_uidle *hw_uidle;
 	struct sde_hw_sid *hw_sid;
+	struct sde_hw_sw_fuse *hw_sw_fuse;
 	int dsi_display_count;
 	void **dsi_displays;
 	int wb_display_count;
@@ -662,6 +664,8 @@ void sde_kms_timeline_status(struct drm_device *dev);
  */
 int sde_kms_handle_recovery(struct drm_encoder *encoder);
 
+void sde_kms_kickoff_count(struct sde_kms *sde_kms);
+
 /**
  * sde_kms_update_pm_qos_irq_request - Update Qos vote for CPU receiving
  *					display IRQ
diff --git a/techpack/display/msm/sde/sde_plane.c b/techpack/display/msm/sde/sde_plane.c
index 0264cefe1ddd..5d8e6df779e0 100644
--- a/techpack/display/msm/sde/sde_plane.c
+++ b/techpack/display/msm/sde/sde_plane.c
@@ -3418,6 +3418,18 @@ void sde_plane_restore(struct drm_plane *plane)
 	sde_plane_atomic_update(plane, plane->state);
 }
 
+uint32_t sde_plane_get_mi_layer_info(const struct drm_plane_state *drm_state)
+{
+	struct sde_plane_state *pstate;
+
+	if (!drm_state)
+		return 0;
+
+	pstate = to_sde_plane_state(drm_state);
+
+	return sde_plane_get_property(pstate, PLANE_PROP_MI_LAYER_INFO);
+}
+
 bool sde_plane_is_cache_required(struct drm_plane *plane)
 {
 	struct sde_plane_state *pstate;
@@ -3574,6 +3586,9 @@ static void _sde_plane_install_properties(struct drm_plane *plane,
 		zpos_def = drm_plane_index(plane) + 1;
 	}
 
+	msm_property_install_range(&psde->property_info, "mi_layer_info",
+		0x0, 0, U32_MAX, 0, PLANE_PROP_MI_LAYER_INFO);
+
 	msm_property_install_range(&psde->property_info, "zpos",
 		0x0, 0, zpos_max, zpos_def, PLANE_PROP_ZPOS);
 
diff --git a/techpack/display/msm/sde/sde_plane.h b/techpack/display/msm/sde/sde_plane.h
index 316bd75f47d9..bcf3a946d0ac 100644
--- a/techpack/display/msm/sde/sde_plane.h
+++ b/techpack/display/msm/sde/sde_plane.h
@@ -308,4 +308,10 @@ void sde_plane_setup_src_split_order(struct drm_plane *plane,
  */
 bool sde_plane_is_cache_required(struct drm_plane *plane);
 
+/*
+ * sde_plane_get_mi_layer_info - get mi layer info
+ * @plane: Pointer to DRM plane object
+ */
+uint32_t sde_plane_get_mi_layer_info(const struct drm_plane_state *drm_state);
+
 #endif /* _SDE_PLANE_H_ */
diff --git a/techpack/display/msm/sde/sde_rm.c b/techpack/display/msm/sde/sde_rm.c
index e77f9905ce3c..fba9be90ad45 100644
--- a/techpack/display/msm/sde/sde_rm.c
+++ b/techpack/display/msm/sde/sde_rm.c
@@ -2075,6 +2075,38 @@ void sde_rm_release(struct sde_rm *rm, struct drm_encoder *enc, bool nxt)
 	mutex_unlock(&rm->rm_lock);
 }
 
+static void _sde_rm_check_and_modify_commit_rsvps(
+		struct sde_rm *rm,
+		struct sde_rm_rsvp *rsvp)
+{
+
+	struct sde_rm_hw_blk *blk;
+	enum sde_hw_blk_type type;
+	bool modify = false;
+
+	if (!rsvp)
+		return;
+	for (type = 0; type < SDE_HW_BLK_MAX; type++) {
+		list_for_each_entry(blk, &rm->hw_blks[type], list) {
+			if (blk->rsvp_nxt &&  blk->rsvp_nxt->enc_id == rsvp->enc_id
+					 && blk->rsvp_nxt != rsvp) {
+				modify = true;
+			}
+		}
+	}
+
+	if (modify) {
+		for (type = 0; type < SDE_HW_BLK_MAX; type++) {
+			list_for_each_entry(blk, &rm->hw_blks[type], list) {
+				if (blk->rsvp_nxt && blk->rsvp_nxt->enc_id
+						 == rsvp->enc_id) {
+					blk->rsvp_nxt = rsvp;
+				}
+			}
+		}
+	}
+}
+
 static int _sde_rm_commit_rsvp(
 		struct sde_rm *rm,
 		struct sde_rm_rsvp *rsvp,
@@ -2084,6 +2116,8 @@ static int _sde_rm_commit_rsvp(
 	enum sde_hw_blk_type type;
 	int ret = 0;
 
+	_sde_rm_check_and_modify_commit_rsvps(rm, rsvp);
+
 	/* Swap next rsvp to be the active */
 	for (type = 0; type < SDE_HW_BLK_MAX; type++) {
 		list_for_each_entry(blk, &rm->hw_blks[type], list) {
diff --git a/techpack/display/pll/dsi_pll_7nm.c b/techpack/display/pll/dsi_pll_7nm.c
index b08a8555cd1e..9f49d65a1d4a 100644
--- a/techpack/display/pll/dsi_pll_7nm.c
+++ b/techpack/display/pll/dsi_pll_7nm.c
@@ -594,6 +594,10 @@ static void dsi_pll_setup_config(struct dsi_pll_7nm *pll,
 	config->enable_ssc = rsc->ssc_en;
 	config->ssc_center = rsc->ssc_center;
 
+	if (pll->cphy_enabled) {
+		config->enable_ssc = false;
+	}
+
 	if (config->enable_ssc) {
 		if (rsc->ssc_freq)
 			config->ssc_freq = rsc->ssc_freq;
diff --git a/techpack/display/pll/pll_drv.c b/techpack/display/pll/pll_drv.c
index 5e0cd4cf4e7a..62df2332acd2 100644
--- a/techpack/display/pll/pll_drv.c
+++ b/techpack/display/pll/pll_drv.c
@@ -227,6 +227,7 @@ static int mdss_pll_probe(struct platform_device *pdev)
 	int rc = 0;
 	const char *label;
 	struct mdss_pll_resources *pll_res;
+	bool ssc_disable;
 
 	if (!pdev->dev.of_node) {
 		pr_err("MDSS pll driver only supports device tree probe\n");
@@ -256,6 +257,13 @@ static int mdss_pll_probe(struct platform_device *pdev)
 	pll_res->ssc_en = of_property_read_bool(pdev->dev.of_node,
 						"qcom,dsi-pll-ssc-en");
 
+	ssc_disable = of_property_read_bool(pdev->dev.of_node,
+						"qcom,dsi-pll-ssc-disable");
+	if (pll_res->ssc_en == true && ssc_disable == true) {
+		pll_res->ssc_en = false;
+		pr_info("ssc disable due to qcom,dsi-pll-ssc-disable is defined\n");
+	}
+
 	if (pll_res->ssc_en) {
 		pr_info("%s: label=%s PLL SSC enabled\n", __func__, label);
 
-- 
2.48.1

