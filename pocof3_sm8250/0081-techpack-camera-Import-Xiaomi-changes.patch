From b13d1eec55bbdd480928f5caca2cbb1011fe5bf1 Mon Sep 17 00:00:00 2001
From: Sebastiano Barezzi <barezzisebastiano@gmail.com>
Date: Fri, 18 Nov 2022 21:23:55 +0100
Subject: [PATCH 081/157] techpack: camera: Import Xiaomi changes

* From dagu-s-oss

Change-Id: I46515dbb384d723a65279345fe7b5931a739997d
---
 techpack/camera/drivers/Makefile              |    4 +
 techpack/camera/drivers/cam_cdm/cam_cdm.h     |    4 +-
 .../drivers/cam_cdm/cam_cdm_core_common.c     |   42 +-
 .../drivers/cam_cdm/cam_cdm_core_common.h     |    3 +-
 .../camera/drivers/cam_cdm/cam_cdm_hw_core.c  |   59 +-
 .../camera/drivers/cam_cdm/cam_cdm_intf.c     |   29 +-
 .../camera/drivers/cam_cdm/cam_cdm_intf_api.h |   11 +-
 .../camera/drivers/cam_cdm/cam_cdm_util.c     |  170 +-
 .../camera/drivers/cam_cdm/cam_cdm_util.h     |   45 +-
 .../camera/drivers/cam_core/cam_context.c     |   69 +-
 .../camera/drivers/cam_core/cam_context.h     |   49 -
 .../drivers/cam_core/cam_context_utils.c      |  157 +-
 .../drivers/cam_core/cam_context_utils.h      |    3 +-
 .../camera/drivers/cam_core/cam_hw_mgr_intf.h |   51 +-
 techpack/camera/drivers/cam_core/cam_node.c   |   77 -
 techpack/camera/drivers/cam_core/cam_subdev.c |    2 -
 .../camera/drivers/cam_cpas/cam_cpas_hw.c     |  407 +--
 .../camera/drivers/cam_cpas/cam_cpas_hw.h     |   14 +-
 .../drivers/cam_cpas/cam_cpas_hw_intf.h       |    3 +-
 .../camera/drivers/cam_cpas/cam_cpas_intf.c   |   46 +-
 .../camera/drivers/cam_cpas/cam_cpas_soc.c    |   56 +-
 .../camera/drivers/cam_cpas/cam_cpas_soc.h    |    4 +-
 .../cam_cpas/cpas_top/cam_cpastop_hw.c        |  274 +-
 .../cam_cpas/cpas_top/cam_cpastop_hw.h        |   38 +-
 .../cam_cpas/cpas_top/cpastop_v150_100.h      |    8 +-
 .../cam_cpas/cpas_top/cpastop_v170_110.h      |    8 +-
 .../cam_cpas/cpas_top/cpastop_v175_100.h      |    8 +-
 .../cam_cpas/cpas_top/cpastop_v175_101.h      |    8 +-
 .../cam_cpas/cpas_top/cpastop_v175_120.h      |    9 +-
 .../cam_cpas/cpas_top/cpastop_v175_130.h      |    9 +-
 .../cam_cpas/cpas_top/cpastop_v480_100.h      |    9 +-
 .../drivers/cam_cpas/include/cam_cpas_api.h   |  102 +-
 .../drivers/cam_cust/cam_custom_context.c     |  458 +---
 .../drivers/cam_cust/cam_custom_context.h     |    2 -
 .../cam_custom_csid/cam_custom_csid480.h      |    8 +-
 .../cam_custom_hw_mgr/cam_custom_hw_mgr.c     |  348 ++-
 .../camera/drivers/cam_fd/cam_fd_context.c    |   18 +-
 techpack/camera/drivers/cam_fd/cam_fd_dev.c   |   18 +-
 .../drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.c  |  234 +-
 .../drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.h  |   13 +-
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.c   |   97 +-
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.h   |    5 +-
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_dev.c    |    6 +-
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_intf.h   |   38 +-
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_soc.c    |   40 +
 .../cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_v501.h   |    4 +-
 .../camera/drivers/cam_icp/cam_icp_context.c  |   17 +-
 .../camera/drivers/cam_icp/cam_icp_subdev.c   |    3 -
 .../camera/drivers/cam_icp/fw_inc/hfi_intf.h  |    7 +-
 .../drivers/cam_icp/fw_inc/hfi_sys_defs.h     |    7 -
 techpack/camera/drivers/cam_icp/hfi.c         |    9 +-
 .../drivers/cam_icp/icp_hw/a5_hw/a5_core.c    |   79 +-
 .../icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c        |  483 +---
 .../icp_hw/icp_hw_mgr/cam_icp_hw_mgr.h        |   14 +-
 .../icp_hw_mgr/include/cam_a5_hw_intf.h       |    3 +-
 .../icp_hw/include/cam_icp_hw_mgr_intf.h      |   33 +-
 .../camera/drivers/cam_isp/cam_isp_context.c  | 1485 +----------
 .../camera/drivers/cam_isp/cam_isp_context.h  |  170 +-
 techpack/camera/drivers/cam_isp/cam_isp_dev.c |    4 -
 .../cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c       | 2238 ++++-------------
 .../cam_isp/isp_hw_mgr/cam_ife_hw_mgr.h       |   30 +-
 .../hw_utils/cam_isp_packet_parser.c          |  150 +-
 .../hw_utils/include/cam_isp_packet_parser.h  |   39 +-
 .../irq_controller/cam_irq_controller.c       |    4 +-
 .../isp_hw_mgr/include/cam_isp_hw_mgr_intf.h  |   33 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid170.h      |    6 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid175.h      |    6 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid175_200.h  |    6 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid17x.c      |   12 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid480.h      |    6 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid_core.c    | 1578 ++----------
 .../isp_hw/ife_csid_hw/cam_ife_csid_core.h    |   77 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid_lite17x.h |    8 +-
 .../isp_hw/ife_csid_hw/cam_ife_csid_lite480.h |    6 +-
 .../isp_hw/include/cam_ife_csid_hw_intf.h     |   63 +-
 .../isp_hw_mgr/isp_hw/include/cam_isp_hw.h    |   76 +-
 .../isp_hw/include/cam_vfe_hw_intf.h          |   57 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_core.c   |   27 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.c    |   22 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.h    |   15 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe.c |    7 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe170.h         |   46 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe175.h         |   35 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe175_130.h     |  223 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe480.h         |   18 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe_lite17x.h    |   13 +-
 .../isp_hw/vfe_hw/vfe17x/cam_vfe_lite48x.h    |    3 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/Makefile |    1 -
 .../vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.c      |  662 ++---
 .../vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.h      |    3 +-
 .../isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.c  |  427 +---
 .../isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.h  |   53 +-
 .../isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.c  |  276 +-
 .../isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.h  |   18 +-
 .../isp_hw_mgr/isp_hw/vfe_hw/vfe_top/Makefile |    1 -
 .../vfe_hw/vfe_top/cam_vfe_camif_lite_ver2.c  |   72 +-
 .../vfe_hw/vfe_top/cam_vfe_camif_lite_ver3.c  |   93 +-
 .../vfe_hw/vfe_top/cam_vfe_camif_ver2.c       |  230 +-
 .../vfe_hw/vfe_top/cam_vfe_camif_ver2.h       |    4 +-
 .../vfe_hw/vfe_top/cam_vfe_camif_ver3.c       |  283 +--
 .../vfe_hw/vfe_top/cam_vfe_camif_ver3.h       |    3 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.c       |  139 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.h       |   11 +-
 .../vfe_hw/vfe_top/cam_vfe_top_common.h       |   30 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.c  |  274 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.h  |    7 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.c  |  149 +-
 .../isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.h  |   10 +-
 .../drivers/cam_jpeg/cam_jpeg_context.c       |   16 +-
 .../camera/drivers/cam_jpeg/cam_jpeg_dev.c    |    8 +-
 .../camera/drivers/cam_jpeg/cam_jpeg_dev.h    |    6 +-
 .../cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.c        |  169 +-
 .../cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.h        |   10 +-
 .../jpeg_hw/include/cam_jpeg_hw_intf.h        |   20 +-
 .../jpeg_hw/include/cam_jpeg_hw_mgr_intf.h    |    4 +-
 .../cam_jpeg_enc_hw_info_ver_4_2_0.h          |    6 +-
 .../jpeg_hw/jpeg_enc_hw/jpeg_enc_core.c       |  135 +-
 .../jpeg_hw/jpeg_enc_hw/jpeg_enc_core.h       |    8 +-
 techpack/camera/drivers/cam_log/cam_log.c     |  194 ++
 techpack/camera/drivers/cam_log/cam_log.h     |   23 +
 .../drivers/cam_lrme/cam_lrme_context.c       |   18 +-
 .../camera/drivers/cam_lrme/cam_lrme_dev.c    |    5 -
 .../cam_lrme/lrme_hw_mgr/cam_lrme_hw_mgr.c    |   56 +-
 .../lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.c    |  164 +-
 .../lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.h    |   20 +-
 .../lrme_hw_mgr/lrme_hw/cam_lrme_hw_dev.c     |   10 +-
 .../lrme_hw_mgr/lrme_hw/cam_lrme_hw_intf.h    |   21 +-
 techpack/camera/drivers/cam_req_mgr/Makefile  |    2 +-
 .../camera/drivers/cam_req_mgr/cam_mem_mgr.c  |   88 +-
 .../camera/drivers/cam_req_mgr/cam_mem_mgr.h  |    8 +-
 .../drivers/cam_req_mgr/cam_req_mgr_core.c    |  520 ++--
 .../drivers/cam_req_mgr/cam_req_mgr_core.h    |   28 +-
 .../drivers/cam_req_mgr/cam_req_mgr_debug.c   |    9 +-
 .../drivers/cam_req_mgr/cam_req_mgr_dev.c     |  116 +-
 .../drivers/cam_req_mgr/cam_req_mgr_dev.h     |    2 -
 .../cam_req_mgr/cam_req_mgr_interface.h       |   59 +-
 .../drivers/cam_req_mgr/cam_req_mgr_timer.c   |    4 +-
 .../drivers/cam_req_mgr/cam_req_mgr_timer.h   |    1 +
 .../drivers/cam_req_mgr/cam_req_mgr_util.c    |   21 +-
 .../drivers/cam_req_mgr/cam_req_mgr_workq.c   |   13 +-
 .../drivers/cam_req_mgr/cam_req_mgr_workq.h   |   14 +-
 .../camera/drivers/cam_req_mgr/cam_subdev.h   |   54 +-
 .../cam_actuator/cam_actuator_core.c          |   73 +-
 .../cam_actuator/cam_actuator_dev.c           |   33 +-
 .../cam_actuator/cam_actuator_dev.h           |    3 +-
 .../cam_sensor_module/cam_cci/cam_cci_core.c  |  233 +-
 .../cam_sensor_module/cam_cci/cam_cci_dev.c   |    8 +-
 .../cam_sensor_module/cam_cci/cam_cci_dev.h   |   20 +-
 .../cam_sensor_module/cam_cci/cam_cci_soc.c   |  271 +-
 .../cam_sensor_module/cam_cci/cam_cci_soc.h   |    5 +-
 .../cam_csiphy/cam_csiphy_core.c              |  781 ++----
 .../cam_csiphy/cam_csiphy_dev.c               |   84 +-
 .../cam_csiphy/cam_csiphy_dev.h               |  148 +-
 .../cam_csiphy/cam_csiphy_soc.c               |  111 +-
 .../cam_csiphy/cam_csiphy_soc.h               |   12 +-
 .../cam_csiphy/include/cam_csiphy_1_0_hwreg.h |    3 +-
 .../cam_csiphy/include/cam_csiphy_1_1_hwreg.h |    3 +-
 .../include/cam_csiphy_1_2_1_hwreg.h          |  158 +-
 .../cam_csiphy/include/cam_csiphy_1_2_hwreg.h |   22 +-
 .../cam_csiphy/include/cam_csiphy_2_0_hwreg.h |    3 +-
 .../cam_eeprom/cam_eeprom_core.c              |   18 +-
 .../cam_eeprom/cam_eeprom_dev.c               |   35 +-
 .../cam_eeprom/cam_eeprom_dev.h               |    3 +-
 .../cam_flash/cam_flash_core.c                |  198 +-
 .../cam_flash/cam_flash_dev.c                 |   67 +-
 .../cam_flash/cam_flash_dev.h                 |   15 +-
 .../cam_sensor_module/cam_ois/cam_ois_core.c  |  661 ++++-
 .../cam_sensor_module/cam_ois/cam_ois_dev.c   |   34 +-
 .../cam_sensor_module/cam_ois/cam_ois_dev.h   |   20 +-
 .../cam_res_mgr/cam_res_mgr.c                 |   17 +-
 .../cam_sensor/cam_sensor_core.c              |  429 ++--
 .../cam_sensor/cam_sensor_dev.c               |   42 +-
 .../cam_sensor/cam_sensor_dev.h               |    3 +-
 .../cam_sensor_io/cam_sensor_cci_i2c.c        |    9 +-
 .../cam_sensor_io/cam_sensor_i2c.h            |    2 +-
 .../cam_sensor_io/cam_sensor_io.c             |    2 +-
 .../cam_sensor_io/cam_sensor_io.h             |    2 +-
 .../cam_sensor_utils/cam_sensor_cmn_header.h  |   25 +-
 .../cam_sensor_utils/cam_sensor_util.c        |  381 +--
 .../cam_sensor_utils/cam_sensor_util.h        |    7 +-
 techpack/camera/drivers/cam_smmu/Makefile     |    1 -
 .../camera/drivers/cam_smmu/cam_smmu_api.c    |  164 +-
 techpack/camera/drivers/cam_sync/cam_sync.c   |   44 +-
 .../camera/drivers/cam_sync/cam_sync_api.h    |   11 +-
 .../drivers/cam_sync/cam_sync_private.h       |    5 +-
 .../camera/drivers/cam_sync/cam_sync_util.c   |   34 +-
 .../camera/drivers/cam_sync/cam_sync_util.h   |   12 +
 .../drivers/cam_utils/cam_common_util.h       |   19 -
 .../camera/drivers/cam_utils/cam_cx_ipeak.c   |    4 +-
 .../camera/drivers/cam_utils/cam_debug_util.h |    4 -
 .../camera/drivers/cam_utils/cam_io_util.c    |    4 +-
 .../drivers/cam_utils/cam_packet_util.c       |   55 +-
 .../drivers/cam_utils/cam_packet_util.h       |   16 +-
 .../camera/drivers/cam_utils/cam_soc_util.c   |  351 +--
 .../camera/drivers/cam_utils/cam_soc_util.h   |   77 +-
 techpack/camera/drivers/cam_utils/cam_trace.h |   23 -
 .../camera/include/uapi/media/cam_custom.h    |   17 -
 techpack/camera/include/uapi/media/cam_defs.h |   24 +-
 techpack/camera/include/uapi/media/cam_isp.h  |   71 +-
 .../camera/include/uapi/media/cam_req_mgr.h   |   36 +-
 .../camera/include/uapi/media/cam_sensor.h    |   15 +-
 201 files changed, 4357 insertions(+), 15334 deletions(-)
 create mode 100644 techpack/camera/drivers/cam_log/cam_log.c
 create mode 100644 techpack/camera/drivers/cam_log/cam_log.h
 mode change 100644 => 100755 techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c
 mode change 100644 => 100755 techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_core.c

diff --git a/techpack/camera/drivers/Makefile b/techpack/camera/drivers/Makefile
index 13edfb587419..428b045e76e6 100644
--- a/techpack/camera/drivers/Makefile
+++ b/techpack/camera/drivers/Makefile
@@ -12,3 +12,7 @@ obj-$(CONFIG_SPECTRA_CAMERA) += cam_jpeg/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_fd/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_lrme/
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_cust/
+
+cameralog-y := \
+    cam_log/cam_log.o
+obj-$(CONFIG_SPECTRA_CAMERA) += cameralog.o
\ No newline at end of file
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm.h b/techpack/camera/drivers/cam_cdm/cam_cdm.h
index 3e4950720df3..ab12ab52f293 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm.h
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CDM_H_
@@ -52,7 +52,6 @@ enum cam_cdm_hw_process_intf_cmd {
 	CAM_CDM_HW_INTF_CMD_RELEASE,
 	CAM_CDM_HW_INTF_CMD_SUBMIT_BL,
 	CAM_CDM_HW_INTF_CMD_RESET_HW,
-	CAM_CDM_HW_INTF_CMD_HANG_DETECT,
 	CAM_CDM_HW_INTF_CMD_INVALID,
 };
 
@@ -218,7 +217,6 @@ struct cam_cdm {
 	atomic_t bl_done;
 	struct cam_cdm_hw_mem gen_irq;
 	uint32_t cpas_handle;
-	atomic_t work_record;
 };
 
 /* struct cam_cdm_private_dt_data - CDM hw custom dt data */
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.c b/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.c
index 56c915cceb97..e903dc805ed0 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.c
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/delay.h>
@@ -201,7 +201,6 @@ void cam_cdm_notify_clients(struct cam_hw_info *cdm_hw,
 
 	for (i = 0; i < CAM_PER_CDM_MAX_REGISTERED_CLIENTS; i++) {
 		if (core->clients[i] != NULL) {
-			mutex_lock(&cdm_hw->hw_mutex);
 			client = core->clients[i];
 			mutex_lock(&client->lock);
 			CAM_DBG(CAM_CDM, "Found client slot %d", i);
@@ -222,7 +221,6 @@ void cam_cdm_notify_clients(struct cam_hw_info *cdm_hw,
 					client->handle);
 			}
 			mutex_unlock(&client->lock);
-			mutex_unlock(&cdm_hw->hw_mutex);
 		}
 	}
 }
@@ -241,34 +239,35 @@ int cam_cdm_stream_ops_internal(void *hw_priv,
 		return -EINVAL;
 
 	core = (struct cam_cdm *)cdm_hw->core_info;
-	mutex_lock(&cdm_hw->hw_mutex);
 	client_idx = CAM_CDM_GET_CLIENT_IDX(*handle);
 	client = core->clients[client_idx];
 	if (!client) {
 		CAM_ERR(CAM_CDM, "Invalid client %pK hdl=%x", client, *handle);
-		mutex_unlock(&cdm_hw->hw_mutex);
 		return -EINVAL;
 	}
 	cam_cdm_get_client_refcount(client);
 	if (*handle != client->handle) {
 		CAM_ERR(CAM_CDM, "client id given handle=%x invalid", *handle);
-		rc = -EINVAL;
-		goto end;
+		cam_cdm_put_client_refcount(client);
+		return -EINVAL;
 	}
 	if (operation == true) {
 		if (true == client->stream_on) {
 			CAM_ERR(CAM_CDM,
 				"Invalid CDM client is already streamed ON");
-			goto end;
+			cam_cdm_put_client_refcount(client);
+			return rc;
 		}
 	} else {
 		if (client->stream_on == false) {
 			CAM_ERR(CAM_CDM,
 				"Invalid CDM client is already streamed Off");
-			goto end;
+			cam_cdm_put_client_refcount(client);
+			return rc;
 		}
 	}
 
+	mutex_lock(&cdm_hw->hw_mutex);
 	if (operation == true) {
 		if (!cdm_hw->open_count) {
 			struct cam_ahb_vote ahb_vote;
@@ -580,31 +579,6 @@ int cam_cdm_process_cmd(void *hw_priv,
 			*((uint32_t *)cmd_args));
 		break;
 	}
-	case CAM_CDM_HW_INTF_CMD_HANG_DETECT: {
-		uint32_t *handle = cmd_args;
-		int idx;
-		struct cam_cdm_client *client;
-
-		if (sizeof(uint32_t) != arg_size) {
-			CAM_ERR(CAM_CDM,
-				"Invalid CDM cmd %d size=%x for handle=%x",
-				cmd, arg_size, *handle);
-				return -EINVAL;
-		}
-
-		idx = CAM_CDM_GET_CLIENT_IDX(*handle);
-		mutex_lock(&cdm_hw->hw_mutex);
-		client = core->clients[idx];
-		if ((!client) || (*handle != client->handle)) {
-			CAM_ERR(CAM_CDM, "Invalid client %pK hdl=%x",
-				client, *handle);
-			mutex_unlock(&cdm_hw->hw_mutex);
-			break;
-		}
-		rc = cam_hw_cdm_hang_detect(cdm_hw, *handle);
-		mutex_unlock(&cdm_hw->hw_mutex);
-		break;
-	}
 	default:
 		CAM_ERR(CAM_CDM, "CDM HW intf command not valid =%d", cmd);
 		break;
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.h b/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.h
index 64dc52dd597d..8dcbe8ed1971 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.h
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_core_common.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CDM_CORE_COMMON_H_
@@ -37,7 +37,6 @@ int cam_virtual_cdm_submit_bl(struct cam_hw_info *cdm_hw,
 int cam_hw_cdm_submit_bl(struct cam_hw_info *cdm_hw,
 	struct cam_cdm_hw_intf_cmd_submit_bl *req,
 	struct cam_cdm_client *client);
-int cam_hw_cdm_hang_detect(struct cam_hw_info *cdm_hw, uint32_t handle);
 struct cam_cdm_bl_cb_request_entry *cam_cdm_find_request_by_bl_tag(
 	uint32_t tag, struct list_head *bl_list);
 void cam_cdm_notify_clients(struct cam_hw_info *cdm_hw,
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_hw_core.c b/techpack/camera/drivers/cam_cdm/cam_cdm_hw_core.c
index e215bea9d984..6eb601cf8091 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_hw_core.c
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_hw_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/delay.h>
@@ -19,7 +19,6 @@
 #include "cam_cdm_soc.h"
 #include "cam_io_util.h"
 #include "cam_hw_cdm170_reg.h"
-#include "cam_trace.h"
 
 #define CAM_HW_CDM_CPAS_0_NAME "qcom,cam170-cpas-cdm0"
 #define CAM_HW_CDM_IPE_0_NAME "qcom,cam170-ipe0-cdm"
@@ -381,8 +380,6 @@ int cam_hw_cdm_submit_gen_irq(struct cam_hw_info *cdm_hw,
 		rc = -EIO;
 	}
 
-	trace_cam_log_event("CDM_START", "CDM_START_IRQ", req->data->cookie, 0);
-
 end:
 	return rc;
 }
@@ -563,10 +560,6 @@ static void cam_hw_cdm_work(struct work_struct *work)
 			CAM_DBG(CAM_CDM, "inline IRQ data=0x%x",
 				payload->irq_data);
 			mutex_lock(&cdm_hw->hw_mutex);
-
-			if (atomic_read(&core->work_record))
-				atomic_dec(&core->work_record);
-
 			list_for_each_entry_safe(node, tnode,
 					&core->bl_request_list, entry) {
 				if (node->request_type ==
@@ -667,35 +660,28 @@ irqreturn_t cam_hw_cdm_irq(int irq_num, void *data)
 				&payload->irq_status)) {
 			CAM_ERR(CAM_CDM, "Failed to read CDM HW IRQ status");
 		}
-		if (!payload->irq_status) {
-			CAM_ERR_RATE_LIMIT(CAM_CDM, "Invalid irq received\n");
-			kfree(payload);
-			return IRQ_HANDLED;
-		}
-		if (cam_cdm_write_hw_reg(cdm_hw, CDM_IRQ_CLEAR,
-			payload->irq_status))
-			CAM_ERR(CAM_CDM, "Failed to Write CDM HW IRQ Clear");
-		if (cam_cdm_write_hw_reg(cdm_hw, CDM_IRQ_CLEAR_CMD, 0x01))
-			CAM_ERR(CAM_CDM, "Failed to Write CDM HW IRQ cmd");
-
-		if (payload->irq_status &
-			CAM_CDM_IRQ_STATUS_INFO_INLINE_IRQ_MASK) {
+        if (!payload->irq_status) {
+            CAM_ERR_RATE_LIMIT(CAM_CDM, "Invalid irq received\n");
+            kfree(payload);
+            return IRQ_HANDLED;
+        }
+        if (cam_cdm_write_hw_reg(cdm_hw, CDM_IRQ_CLEAR,
+                                 payload->irq_status))
+            CAM_ERR(CAM_CDM, "Failed to Write CDM HW IRQ Clear");
+        if (cam_cdm_write_hw_reg(cdm_hw, CDM_IRQ_CLEAR_CMD, 0x01))
+            CAM_ERR(CAM_CDM, "Failed to Write CDM HW IRQ cmd");
+        if (payload->irq_status &
+            CAM_CDM_IRQ_STATUS_INFO_INLINE_IRQ_MASK) {
 			if (cam_cdm_read_hw_reg(cdm_hw, CDM_IRQ_USR_DATA,
 				&payload->irq_data)) {
 				CAM_ERR(CAM_CDM,
 					"Failed to read CDM HW IRQ data");
 			}
 		}
-		trace_cam_log_event("CDM_DONE", "CDM_DONE_IRQ",
-			payload->irq_status,
-			cdm_hw->soc_info.index);
 		CAM_DBG(CAM_CDM, "Got payload=%d", payload->irq_status);
 		payload->hw = cdm_hw;
 		INIT_WORK((struct work_struct *)&payload->work,
 			cam_hw_cdm_work);
-		if (payload->irq_status &
-			CAM_CDM_IRQ_STATUS_INFO_INLINE_IRQ_MASK)
-			atomic_inc(&cdm_core->work_record);
 		work_status = queue_work(cdm_core->work_queue, &payload->work);
 		if (work_status == false) {
 			CAM_ERR(CAM_CDM, "Failed to queue work for irq=0x%x",
@@ -707,22 +693,6 @@ irqreturn_t cam_hw_cdm_irq(int irq_num, void *data)
 	return IRQ_HANDLED;
 }
 
-int cam_hw_cdm_hang_detect(struct cam_hw_info *cdm_hw, uint32_t handle)
-{
-	struct cam_cdm *cdm_core = NULL;
-	int rc = -1;
-
-	cdm_core = (struct cam_cdm *)cdm_hw->core_info;
-
-	if (atomic_read(&cdm_core->work_record)) {
-		CAM_WARN(CAM_CDM,
-			"workqueue got delayed, work_record :%u",
-			 atomic_read(&cdm_core->work_record));
-		rc = 0;
-	}
-	return rc;
-}
-
 int cam_hw_cdm_alloc_genirq_mem(void *hw_priv)
 {
 	struct cam_hw_info *cdm_hw = hw_priv;
@@ -798,7 +768,6 @@ int cam_hw_cdm_init(void *hw_priv,
 	CAM_DBG(CAM_CDM, "Enable soc done");
 
 /* Before triggering the reset to HW, clear the reset complete */
-	atomic_set(&cdm_core->work_record, 0);
 	atomic_set(&cdm_core->error, 0);
 	atomic_set(&cdm_core->bl_done, 0);
 	reinit_completion(&cdm_core->reset_complete);
@@ -848,7 +817,6 @@ int cam_hw_cdm_deinit(void *hw_priv,
 
 	soc_info = &cdm_hw->soc_info;
 	cdm_core = cdm_hw->core_info;
-	atomic_set(&cdm_core->work_record, 0);
 	rc = cam_soc_util_disable_platform_resource(soc_info, true, true);
 	if (rc) {
 		CAM_ERR(CAM_CDM, "disable platform failed");
@@ -913,7 +881,6 @@ int cam_hw_cdm_probe(struct platform_device *pdev)
 		cdm_core->flags = CAM_CDM_FLAG_PRIVATE_CDM;
 
 	cdm_core->bl_tag = 0;
-	atomic_set(&cdm_core->work_record, 0);
 	cdm_core->id = cam_hw_cdm_get_id_by_name(cdm_core->name);
 	if (cdm_core->id >= CAM_CDM_MAX) {
 		CAM_ERR(CAM_CDM, "Failed to get CDM HW name for %s",
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_intf.c b/techpack/camera/drivers/cam_cdm/cam_cdm_intf.c
index 9b6a4e9a67d5..94e2f36d0544 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_intf.c
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_intf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/delay.h>
@@ -379,33 +379,6 @@ int cam_cdm_reset_hw(uint32_t handle)
 }
 EXPORT_SYMBOL(cam_cdm_reset_hw);
 
-int cam_cdm_detect_hang_error(uint32_t handle)
-{
-	uint32_t hw_index;
-	int rc = -EINVAL;
-	struct cam_hw_intf *hw;
-
-	if (get_cdm_mgr_refcount()) {
-		CAM_ERR(CAM_CDM, "CDM intf mgr get refcount failed");
-		rc = -EPERM;
-		return rc;
-	}
-
-	hw_index = CAM_CDM_GET_HW_IDX(handle);
-	if (hw_index < CAM_CDM_INTF_MGR_MAX_SUPPORTED_CDM) {
-		hw = cdm_mgr.nodes[hw_index].device;
-		if (hw && hw->hw_ops.process_cmd)
-			rc = hw->hw_ops.process_cmd(hw->hw_priv,
-				CAM_CDM_HW_INTF_CMD_HANG_DETECT,
-				&handle,
-				sizeof(handle));
-	}
-	put_cdm_mgr_refcount();
-
-	return rc;
-}
-EXPORT_SYMBOL(cam_cdm_detect_hang_error);
-
 int cam_cdm_intf_register_hw_cdm(struct cam_hw_intf *hw,
 	struct cam_cdm_private_dt_data *data, enum cam_cdm_type type,
 	uint32_t *index)
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_intf_api.h b/techpack/camera/drivers/cam_cdm/cam_cdm_intf_api.h
index 466ead30c358..3e89b22b1b18 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_intf_api.h
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_intf_api.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CDM_API_H_
@@ -199,13 +199,4 @@ int cam_cdm_stream_off(uint32_t handle);
  */
 int cam_cdm_reset_hw(uint32_t handle);
 
-/**
- * @brief : API to detect hang in previously acquired CDM,
- *          this should be only performed only if the CDM is private.
- *
- * @handle : Input handle of the CDM to detect hang
- *
- * @return 0 on success
- */
-int cam_cdm_detect_hang_error(uint32_t handle);
 #endif /* _CAM_CDM_API_H_ */
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_util.c b/techpack/camera/drivers/cam_cdm/cam_cdm_util.c
index 9f440b778c17..278dadb18db4 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_util.c
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_util.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/types.h>
@@ -715,171 +715,3 @@ void cam_cdm_util_dump_cmd_buf(
 		}
 	} while (buf_now <= cmd_buf_end);
 }
-
-static uint32_t cam_cdm_util_dump_reg_cont_cmd_v2(
-	uint32_t                         *cmd_buf_addr,
-	struct cam_cdm_cmd_buf_dump_info *dump_info)
-{
-	int                             i;
-	long                            ret;
-	uint8_t                        *dst;
-	size_t                          remain_len;
-	uint32_t                       *temp_ptr = cmd_buf_addr;
-	uint32_t                       *addr, *start;
-	uint32_t                        min_len;
-	struct cdm_regcontinuous_cmd   *p_regcont_cmd;
-	struct cam_cdm_cmd_dump_header *hdr;
-
-	p_regcont_cmd = (struct cdm_regcontinuous_cmd *)temp_ptr;
-	temp_ptr += cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT);
-	ret = cdm_get_cmd_header_size(CAM_CDM_CMD_REG_CONT);
-
-	min_len = (sizeof(uint32_t) * p_regcont_cmd->count) +
-		sizeof(struct cam_cdm_cmd_dump_header) +
-		(2 * sizeof(uint32_t));
-	remain_len = dump_info->dst_max_size - dump_info->dst_offset;
-
-	if (remain_len < min_len) {
-		CAM_WARN_RATE_LIMIT(CAM_CDM,
-			"Dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return ret;
-	}
-
-	dst = (char *)dump_info->dst_start + dump_info->dst_offset;
-	hdr = (struct cam_cdm_cmd_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_CDM_CMD_TAG_MAX_LEN, "CDM_REG_CONT:");
-	hdr->word_size = sizeof(uint32_t);
-	addr = (uint32_t *)(dst + sizeof(struct cam_cdm_cmd_dump_header));
-	start = addr;
-	*addr++ = p_regcont_cmd->offset;
-	*addr++ = p_regcont_cmd->count;
-	for (i = 0; i < p_regcont_cmd->count; i++) {
-		*addr = *temp_ptr;
-		temp_ptr++;
-		addr++;
-		ret++;
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	dump_info->dst_offset += hdr->size +
-		sizeof(struct cam_cdm_cmd_dump_header);
-
-	return ret;
-}
-
-static uint32_t cam_cdm_util_dump_reg_random_cmd_v2(
-	uint32_t                         *cmd_buf_addr,
-	struct cam_cdm_cmd_buf_dump_info *dump_info)
-{
-	int                             i;
-	long                            ret;
-	uint8_t                        *dst;
-	uint32_t                       *temp_ptr = cmd_buf_addr;
-	uint32_t                       *addr, *start;
-	size_t                          remain_len;
-	uint32_t                        min_len;
-	struct cdm_regrandom_cmd       *p_regrand_cmd;
-	struct cam_cdm_cmd_dump_header *hdr;
-
-	p_regrand_cmd = (struct cdm_regrandom_cmd *)temp_ptr;
-	temp_ptr += cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM);
-	ret = cdm_get_cmd_header_size(CAM_CDM_CMD_REG_RANDOM);
-
-	min_len = (2 * sizeof(uint32_t) * p_regrand_cmd->count) +
-		sizeof(struct cam_cdm_cmd_dump_header) + sizeof(uint32_t);
-	remain_len = dump_info->dst_max_size - dump_info->dst_offset;
-
-	if (remain_len < min_len) {
-		CAM_WARN_RATE_LIMIT(CAM_CDM,
-			"Dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return ret;
-	}
-
-	dst = (char *)dump_info->dst_start + dump_info->dst_offset;
-	hdr = (struct cam_cdm_cmd_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_CDM_CMD_TAG_MAX_LEN, "CDM_REG_RANDOM:");
-	hdr->word_size = sizeof(uint32_t);
-	addr = (uint32_t *)(dst + sizeof(struct cam_cdm_cmd_dump_header));
-	start = addr;
-	*addr++ = p_regrand_cmd->count;
-	for (i = 0; i < p_regrand_cmd->count; i++) {
-		addr[0] = temp_ptr[0] & CAM_CDM_REG_OFFSET_MASK;
-		addr[1] = temp_ptr[1];
-		temp_ptr += 2;
-		addr += 2;
-		ret += 2;
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	dump_info->dst_offset += hdr->size +
-		sizeof(struct cam_cdm_cmd_dump_header);
-	return ret;
-}
-
-int cam_cdm_util_dump_cmd_bufs_v2(
-	struct cam_cdm_cmd_buf_dump_info *dump_info)
-{
-	uint32_t  cmd;
-	uint32_t *buf_now;
-	int rc = 0;
-
-	if (!dump_info || !dump_info->src_start || !dump_info->src_end ||
-		!dump_info->dst_start) {
-		CAM_INFO(CAM_CDM, "Invalid args");
-		return -EINVAL;
-	}
-
-	buf_now = dump_info->src_start;
-	do {
-		if (dump_info->dst_offset >= dump_info->dst_max_size) {
-			CAM_WARN(CAM_CDM,
-				"Dump overshoot offset %zu size %zu",
-				dump_info->dst_offset,
-				dump_info->dst_max_size);
-			return -ENOSPC;
-		}
-		cmd = *buf_now;
-		cmd = cmd >> CAM_CDM_COMMAND_OFFSET;
-
-		switch (cmd) {
-		case CAM_CDM_CMD_DMI:
-		case CAM_CDM_CMD_DMI_32:
-		case CAM_CDM_CMD_DMI_64:
-			buf_now += cdm_get_cmd_header_size(CAM_CDM_CMD_DMI);
-			break;
-		case CAM_CDM_CMD_REG_CONT:
-			buf_now += cam_cdm_util_dump_reg_cont_cmd_v2(buf_now,
-				dump_info);
-			break;
-		case CAM_CDM_CMD_REG_RANDOM:
-			buf_now += cam_cdm_util_dump_reg_random_cmd_v2(buf_now,
-				dump_info);
-			break;
-		case CAM_CDM_CMD_BUFF_INDIRECT:
-			buf_now += cdm_get_cmd_header_size(
-				CAM_CDM_CMD_BUFF_INDIRECT);
-			break;
-		case CAM_CDM_CMD_GEN_IRQ:
-			buf_now += cdm_get_cmd_header_size(
-				CAM_CDM_CMD_GEN_IRQ);
-			break;
-		case CAM_CDM_CMD_WAIT_EVENT:
-			buf_now += cdm_get_cmd_header_size(
-				CAM_CDM_CMD_WAIT_EVENT);
-			break;
-		case CAM_CDM_CMD_CHANGE_BASE:
-			buf_now += cdm_get_cmd_header_size(
-				CAM_CDM_CMD_CHANGE_BASE);
-			break;
-		case CAM_CDM_CMD_PERF_CTRL:
-			buf_now += cdm_get_cmd_header_size(
-				CAM_CDM_CMD_PERF_CTRL);
-			break;
-		default:
-			CAM_ERR(CAM_CDM, "Invalid CMD: 0x%x", cmd);
-			buf_now++;
-			break;
-		}
-	} while (buf_now <= dump_info->src_end);
-	return rc;
-}
diff --git a/techpack/camera/drivers/cam_cdm/cam_cdm_util.h b/techpack/camera/drivers/cam_cdm/cam_cdm_util.h
index 30fcbe5c6c66..663eca92a5fe 100644
--- a/techpack/camera/drivers/cam_cdm/cam_cdm_util.h
+++ b/techpack/camera/drivers/cam_cdm/cam_cdm_util.h
@@ -1,14 +1,11 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CDM_UTIL_H_
 #define _CAM_CDM_UTIL_H_
 
-/* Max len for tag name for header while dumping cmd buffer*/
-#define CAM_CDM_CMD_TAG_MAX_LEN 32
-
 enum cam_cdm_command {
 	CAM_CDM_CMD_UNUSED = 0x0,
 	CAM_CDM_CMD_DMI = 0x1,
@@ -147,34 +144,6 @@ void (*cdm_write_genirq)(
 	uint32_t  userdata);
 };
 
-/**
- * struct cam_cdm_cmd_buf_dump_info; - Camera CDM dump info
- * @dst_offset:      dst offset
- * @dst_max_size     max size of destination buffer
- * @src_start:       source start address
- * @src_end:         source end   address
- * @dst_start:       dst start address
- */
-struct cam_cdm_cmd_buf_dump_info {
-	size_t    dst_offset;
-	size_t    dst_max_size;
-	uint32_t *src_start;
-	uint32_t *src_end;
-	uintptr_t dst_start;
-};
-
-/**
- * struct cam_cdm_cmd_dump_header- Camera CDM dump header
- * @tag:       tag name for header
- * @size:      size of data
- * @word_size: size of each word
- */
-struct cam_cdm_cmd_dump_header {
-	uint8_t   tag[CAM_CDM_CMD_TAG_MAX_LEN];
-	uint64_t  size;
-	uint32_t  word_size;
-};
-
 /**
  * cam_cdm_util_log_cmd_bufs()
  *
@@ -187,18 +156,6 @@ struct cam_cdm_cmd_dump_header {
 void cam_cdm_util_dump_cmd_buf(
 	uint32_t *cmd_buffer_start, uint32_t *cmd_buffer_end);
 
-/**
- * cam_cdm_util_dump_cmd_bufs_v2()
- *
- * @brief:        Util function to cdm command buffers
- *                to a buffer
- *
- * @dump_info:    Information about source and destination buffers
- *
- * return SUCCESS/FAILURE
- */
-int cam_cdm_util_dump_cmd_bufs_v2(
-	struct cam_cdm_cmd_buf_dump_info *dump_info);
 
 
 #endif /* _CAM_CDM_UTIL_H_ */
diff --git a/techpack/camera/drivers/cam_core/cam_context.c b/techpack/camera/drivers/cam_core/cam_context.c
index 9e24505fe213..1c17422d01d0 100644
--- a/techpack/camera/drivers/cam_core/cam_context.c
+++ b/techpack/camera/drivers/cam_core/cam_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -230,34 +230,6 @@ int cam_context_handle_crm_process_evt(struct cam_context *ctx,
 	return rc;
 }
 
-int cam_context_handle_crm_dump_req(struct cam_context *ctx,
-	struct cam_req_mgr_dump_info *dump)
-{
-	int rc = 0;
-
-	if (!ctx) {
-		CAM_ERR(CAM_CORE, "Invalid Context");
-		return -EINVAL;
-	}
-	if (!ctx->state_machine) {
-		CAM_ERR(CAM_CORE, "Context %s ctx_id %d is not ready",
-			ctx->dev_name, ctx->ctx_id);
-		return -EINVAL;
-	}
-	mutex_lock(&ctx->ctx_mutex);
-
-	if (ctx->state_machine[ctx->state].crm_ops.dump_req)
-		rc = ctx->state_machine[ctx->state].crm_ops.dump_req(ctx,
-			dump);
-	else
-		CAM_ERR(CAM_CORE, "No crm dump req for %s dev %d, state %d",
-			ctx->dev_name, ctx->dev_hdl, ctx->state);
-
-	mutex_unlock(&ctx->ctx_mutex);
-
-	return rc;
-}
-
 int cam_context_dump_pf_info(struct cam_context *ctx, unsigned long iova,
 	uint32_t buf_info)
 {
@@ -268,7 +240,6 @@ int cam_context_dump_pf_info(struct cam_context *ctx, unsigned long iova,
 		return -EINVAL;
 	}
 
-	mutex_lock(&ctx->ctx_mutex);
 	if ((ctx->state > CAM_CTX_AVAILABLE) &&
 		(ctx->state < CAM_CTX_STATE_MAX)) {
 		if (ctx->state_machine[ctx->state].pagefault_ops) {
@@ -279,7 +250,6 @@ int cam_context_dump_pf_info(struct cam_context *ctx, unsigned long iova,
 				ctx->dev_hdl, ctx->state);
 		}
 	}
-	mutex_unlock(&ctx->ctx_mutex);
 
 	return rc;
 }
@@ -554,43 +524,6 @@ int cam_context_handle_info_dump(void *context,
 	return rc;
 }
 
-int cam_context_handle_dump_dev(struct cam_context *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int rc = 0;
-
-	if (!ctx) {
-		CAM_ERR(CAM_CORE, "Invalid Context");
-		return -EINVAL;
-	}
-
-	if (!ctx->state_machine) {
-		CAM_ERR(CAM_CORE, "Context %s ctx_id %d is not ready",
-			ctx->dev_name, ctx->ctx_id);
-		return -EINVAL;
-	}
-
-	if (!cmd) {
-		CAM_ERR(CAM_CORE,
-			"Context %s ctx_id %d Invalid dump command payload",
-			ctx->dev_name, ctx->ctx_id);
-		return -EINVAL;
-	}
-
-	mutex_lock(&ctx->ctx_mutex);
-	CAM_DBG(CAM_CORE, "dump device in dev %d, name %s state %d",
-		ctx->dev_hdl, ctx->dev_name, ctx->state);
-	if (ctx->state_machine[ctx->state].ioctl_ops.dump_dev)
-		rc = ctx->state_machine[ctx->state].ioctl_ops.dump_dev(
-			ctx, cmd);
-	else
-		CAM_WARN(CAM_CORE, "No dump device in dev %d, name %s state %d",
-			ctx->dev_hdl, ctx->dev_name, ctx->state);
-	mutex_unlock(&ctx->ctx_mutex);
-
-	return rc;
-}
-
 int cam_context_init(struct cam_context *ctx,
 	const char *dev_name,
 	uint64_t dev_id,
diff --git a/techpack/camera/drivers/cam_core/cam_context.h b/techpack/camera/drivers/cam_core/cam_context.h
index 770451faadf2..2c1c685e76b8 100644
--- a/techpack/camera/drivers/cam_core/cam_context.h
+++ b/techpack/camera/drivers/cam_core/cam_context.h
@@ -23,12 +23,6 @@ struct cam_context;
 #define CAM_CTX_CFG_MAX              20
 #define CAM_CTX_RES_MAX              20
 
-/* max tag  dump header string length*/
-#define CAM_CTXT_DUMP_TAG_MAX_LEN 32
-
-/* Number of words to be dumped for context*/
-#define CAM_CTXT_DUMP_NUM_WORDS 10
-
 /**
  * enum cam_ctx_state -  context top level states
  *
@@ -92,7 +86,6 @@ struct cam_ctx_request {
  * @flush_dev:             Function pointer for flush device
  * @acquire_hw:            Function pointer for acquire hw
  * @release_hw:            Function pointer for release hw
- * @dump_dev:              Function pointer for dump dev
  *
  */
 struct cam_ctx_ioctl_ops {
@@ -110,8 +103,6 @@ struct cam_ctx_ioctl_ops {
 			struct cam_flush_dev_cmd *cmd);
 	int (*acquire_hw)(struct cam_context *ctx, void *args);
 	int (*release_hw)(struct cam_context *ctx, void *args);
-	int (*dump_dev)(struct cam_context *ctx,
-			struct cam_dump_req_cmd *cmd);
 };
 
 /**
@@ -123,7 +114,6 @@ struct cam_ctx_ioctl_ops {
  * @apply_req:             Apply setting for the context
  * @flush_req:             Flush request to remove request ids
  * @process_evt:           Handle event notification from CRM.(optional)
- * @dump_req:              Dump information for the issue request
  *
  */
 struct cam_ctx_crm_ops {
@@ -139,8 +129,6 @@ struct cam_ctx_crm_ops {
 			struct cam_req_mgr_flush_request *flush);
 	int (*process_evt)(struct cam_context *ctx,
 			struct cam_req_mgr_link_evt_data *evt_data);
-	int (*dump_req)(struct cam_context *ctx,
-			struct cam_req_mgr_dump_info *dump);
 };
 
 
@@ -231,19 +219,6 @@ struct cam_context {
 	uint32_t                     last_flush_req;
 };
 
-/**
- * struct cam_context_dump_header -  Function for context dump header
- *
- * @tag         :    Tag for context dump header
- * @size        :    Size of data
- * @word_size   :    Word size of data
- */
-struct cam_context_dump_header {
-	uint8_t   tag[CAM_CTXT_DUMP_TAG_MAX_LEN];
-	uint64_t  size;
-	uint32_t  word_size;
-};
-
 /**
  * cam_context_shutdown()
  *
@@ -326,18 +301,6 @@ int cam_context_handle_crm_flush_req(struct cam_context *ctx,
 int cam_context_handle_crm_process_evt(struct cam_context *ctx,
 	struct cam_req_mgr_link_evt_data *process_evt);
 
-/**
- * cam_context_handle_crm_dump_req()
- *
- * @brief:        Handle CRM dump request
- *
- * @ctx:          Object pointer for cam_context
- * @dump:         Dump request command payload
- *
- */
-int cam_context_handle_crm_dump_req(struct cam_context *ctx,
-	struct cam_req_mgr_dump_info *dump);
-
 /**
  * cam_context_dump_pf_info()
  *
@@ -447,18 +410,6 @@ int cam_context_handle_start_dev(struct cam_context *ctx,
 int cam_context_handle_stop_dev(struct cam_context *ctx,
 		struct cam_start_stop_dev_cmd *cmd);
 
-/**
- * cam_context_handle_dump_dev()
- *
- * @brief:        Handle dump device command
- *
- * @ctx:          Object pointer for cam_context
- * @cmd:          Dump device command payload
- *
- */
-int cam_context_handle_dump_dev(struct cam_context *ctx,
-	struct cam_dump_req_cmd *cmd);
-
 /**
  * cam_context_handle_info_dump()
  *
diff --git a/techpack/camera/drivers/cam_core/cam_context_utils.c b/techpack/camera/drivers/cam_core/cam_context_utils.c
index 480d66e60606..423961aaf2af 100644
--- a/techpack/camera/drivers/cam_core/cam_context_utils.c
+++ b/techpack/camera/drivers/cam_core/cam_context_utils.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/debugfs.h>
@@ -296,13 +296,6 @@ int32_t cam_context_config_dev_to_hw(
 		return rc;
 	}
 
-	if ((len < sizeof(struct cam_packet)) ||
-		(cmd->offset >= (len - sizeof(struct cam_packet)))) {
-		CAM_ERR(CAM_CTXT, "Not enough buf, len : %zu offset = %llu",
-			len, cmd->offset);
-		return -EINVAL;
-
-	}
 	packet = (struct cam_packet *) ((uint8_t *)packet_addr +
 		(uint32_t)cmd->offset);
 
@@ -458,20 +451,6 @@ int32_t cam_context_prepare_dev_to_hw(struct cam_context *ctx,
 				"[%s][%d] : Moving req[%llu] from free_list to pending_list",
 				ctx->dev_name, ctx->ctx_id, req->request_id);
 
-		for (j = 0; j < req->num_in_map_entries; j++) {
-			rc = cam_sync_check_valid(
-				req->in_map_entries[j].sync_id);
-			if (rc) {
-				spin_lock(&ctx->lock);
-				list_del_init(&req->list);
-				spin_unlock(&ctx->lock);
-				CAM_ERR(CAM_CTXT,
-					"invalid in map sync object %d",
-					req->in_map_entries[j].sync_id);
-				goto put_ref;
-			}
-		}
-
 		for (j = 0; j < req->num_in_map_entries; j++) {
 			cam_context_getref(ctx);
 			rc = cam_sync_register_callback(
@@ -493,8 +472,7 @@ int32_t cam_context_prepare_dev_to_hw(struct cam_context *ctx,
 						ctx->dev_name, ctx->ctx_id,
 						req->request_id);
 
-				cam_context_putref(ctx);
-				goto put_ref;
+				goto put_ctx_ref;
 			}
 			CAM_DBG(CAM_CTXT, "register in fence cb: %d ret = %d",
 				req->in_map_entries[j].sync_id, rc);
@@ -502,6 +480,9 @@ int32_t cam_context_prepare_dev_to_hw(struct cam_context *ctx,
 	}
 
 	return rc;
+put_ctx_ref:
+	for (; j >= 0; j--)
+		cam_context_putref(ctx);
 put_ref:
 	for (--i; i >= 0; i--) {
 		if (cam_sync_put_obj_ref(req->out_map_entries[i].sync_id))
@@ -562,7 +543,6 @@ int32_t cam_context_acquire_dev_to_hw(struct cam_context *ctx,
 	param.event_cb = ctx->irq_cb_intf;
 	param.num_acq = cmd->num_resources;
 	param.acquire_info = cmd->resource_hdl;
-	param.session_hdl = cmd->session_handle;
 
 	/* call HW manager to reserve the resource */
 	rc = ctx->hw_mgr_intf->hw_acquire(ctx->hw_mgr_intf->hw_mgr_priv,
@@ -1066,130 +1046,3 @@ int32_t cam_context_dump_hw_acq_info(struct cam_context *ctx)
 end:
 	return rc;
 }
-
-static int cam_context_dump_context(struct cam_context *ctx,
-	struct cam_hw_dump_args *dump_args)
-{
-	int                             rc;
-	int                             i;
-	size_t                          buf_len;
-	size_t                          remain_len;
-	uint8_t                        *dst;
-	uint64_t                       *addr, *start;
-	uint32_t                        min_len;
-	uintptr_t                       cpu_addr;
-	struct cam_ctx_request         *req;
-	struct cam_context_dump_header *hdr;
-
-	if (!ctx || !dump_args) {
-		CAM_ERR(CAM_CORE, "Invalid parameters %pK %pK",
-			ctx, dump_args);
-		return -EINVAL;
-	}
-
-	spin_lock_bh(&ctx->lock);
-	if (list_empty(&ctx->active_req_list)) {
-		CAM_ERR(CAM_CTXT, "[%s][%d] no active request",
-			ctx->dev_name, ctx->ctx_id);
-		spin_unlock_bh(&ctx->lock);
-		return -EIO;
-	}
-	req = list_first_entry(&ctx->active_req_list,
-		struct cam_ctx_request, list);
-	spin_unlock_bh(&ctx->lock);
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&cpu_addr, &buf_len);
-	if (rc) {
-		CAM_ERR(CAM_CTXT, "Invalid hdl %u rc %d",
-			dump_args->buf_handle, rc);
-		return rc;
-	}
-	if (dump_args->offset >= buf_len) {
-		CAM_WARN(CAM_CTXT, "dump buffer overshoot offset %zu len %zu",
-			dump_args->offset, buf_len);
-		return -ENOSPC;
-	}
-
-	remain_len = buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_context_dump_header) +
-		    (CAM_CTXT_DUMP_NUM_WORDS + req->num_in_map_entries +
-		    (req->num_out_map_entries * 2)) * sizeof(uint64_t);
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_CTXT, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-	dst = (uint8_t *)cpu_addr + dump_args->offset;
-	hdr = (struct cam_context_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_CTXT_DUMP_TAG_MAX_LEN,
-		"%s_CTXT_DUMP:", ctx->dev_name);
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst + sizeof(struct cam_context_dump_header));
-	start = addr;
-	*addr++ = ctx->ctx_id;
-	*addr++ = refcount_read(&(ctx->refcount.refcount));
-	*addr++ = ctx->last_flush_req;
-	*addr++ = ctx->state;
-	*addr++ = req->num_out_map_entries;
-	for (i = 0; i < req->num_out_map_entries; i++) {
-		*addr++ = req->out_map_entries[i].resource_handle;
-		*addr++ = req->out_map_entries[i].sync_id;
-	}
-	*addr++ = req->num_in_map_entries;
-	for (i = 0; i < req->num_in_map_entries; i++)
-		*addr++ = req->in_map_entries[i].sync_id;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_context_dump_header);
-	return rc;
-}
-
-int32_t cam_context_dump_dev_to_hw(struct cam_context *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int                     rc = 0;
-	struct cam_hw_dump_args dump_args;
-
-	if (!ctx || !cmd) {
-		CAM_ERR(CAM_CTXT, "Invalid input params %pK %pK", ctx, cmd);
-		return -EINVAL;
-	}
-	if (!ctx->hw_mgr_intf) {
-		CAM_ERR(CAM_CTXT, "[%s][%d] HW interface is not ready",
-			ctx->dev_name, ctx->ctx_id);
-		return -EFAULT;
-	}
-	memset(&dump_args, 0, sizeof(dump_args));
-	if (ctx->hw_mgr_intf->hw_dump) {
-		dump_args.ctxt_to_hw_map = ctx->ctxt_to_hw_map;
-		dump_args.buf_handle = cmd->buf_handle;
-		dump_args.offset = cmd->offset;
-		dump_args.request_id = cmd->issue_req_id;
-		dump_args.error_type = cmd->error_type;
-		rc  = ctx->hw_mgr_intf->hw_dump(
-			ctx->hw_mgr_intf->hw_mgr_priv,
-			&dump_args);
-		if (rc) {
-			CAM_ERR(CAM_CTXT, "[%s][%d] handle[%u] failed",
-			    ctx->dev_name, ctx->ctx_id, dump_args.buf_handle);
-			return rc;
-		}
-		/* Offset will change if the issue request id is found with
-		 * the hw and has been lying with it beyond threshold time.
-		 * If offset does not change, do not dump the context
-		 * information as the current context has no problem with
-		 * the provided request id.
-		 */
-		if (dump_args.offset > cmd->offset) {
-			cam_context_dump_context(ctx, &dump_args);
-			CAM_INFO(CAM_CTXT, "[%s] ctx: %d Filled Length %u",
-				 ctx->dev_name, ctx->ctx_id,
-				 dump_args.offset - cmd->offset);
-			cmd->offset  = dump_args.offset;
-		}
-	} else {
-		CAM_DBG(CAM_CTXT, "%s hw dump not registered", ctx->dev_name);
-	}
-	return rc;
-}
diff --git a/techpack/camera/drivers/cam_core/cam_context_utils.h b/techpack/camera/drivers/cam_core/cam_context_utils.h
index 79dec3142e8a..087fdbf36544 100644
--- a/techpack/camera/drivers/cam_core/cam_context_utils.h
+++ b/techpack/camera/drivers/cam_core/cam_context_utils.h
@@ -30,6 +30,5 @@ int32_t cam_context_dump_pf_info_to_hw(struct cam_context *ctx,
 	struct cam_packet *packet, unsigned long iova, uint32_t buf_info,
 	bool *mem_found);
 int32_t cam_context_dump_hw_acq_info(struct cam_context *ctx);
-int32_t cam_context_dump_dev_to_hw(struct cam_context *ctx,
-	struct cam_dump_req_cmd *cmd);
+
 #endif /* _CAM_CONTEXT_UTILS_H_ */
diff --git a/techpack/camera/drivers/cam_core/cam_hw_mgr_intf.h b/techpack/camera/drivers/cam_core/cam_hw_mgr_intf.h
index 2a3abdda3a3a..fe074734f389 100644
--- a/techpack/camera/drivers/cam_core/cam_hw_mgr_intf.h
+++ b/techpack/camera/drivers/cam_core/cam_hw_mgr_intf.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_HW_MGR_INTF_H_
@@ -71,13 +70,11 @@ struct cam_hw_update_entry {
  *
  * @resrouce_handle:       Resource port id for the buffer
  * @sync_id:               Sync id
- * @image_buf_addr:        Image buffer address array
  *
  */
 struct cam_hw_fence_map_entry {
 	uint32_t           resource_handle;
 	int32_t            sync_id;
-	int32_t            image_buf_addr[CAM_PACKET_MAX_PLANES];
 };
 
 /**
@@ -102,12 +99,8 @@ struct cam_hw_done_event_data {
  * @context_data:          Context data pointer for the callback function
  * @event_cb:              Callback function array
  * @num_acq:               Total number of acquire in the payload
- * @session_hdl:           Session Handle
  * @acquire_info:          Acquired resource array pointer
  * @ctxt_to_hw_map:        HW context (returned)
- * @custom_enabled:        ctx has custom enabled
- * @use_frame_header_ts:   Use frame header for qtimer ts
- * @support_consumed_addr: The platform has last consumed addr register
  * @acquired_hw_id:        Acquired hardware mask
  * @acquired_hw_path:      Acquired path mask for an input
  *                         if input splits into multiple paths,
@@ -119,13 +112,9 @@ struct cam_hw_acquire_args {
 	void                        *context_data;
 	cam_hw_event_cb_func         event_cb;
 	uint32_t                     num_acq;
-	uint32_t                     session_hdl;
 	uint32_t                     acquire_info_size;
 	uintptr_t                    acquire_info;
 	void                        *ctxt_to_hw_map;
-	bool                         custom_enabled;
-	bool                         use_frame_header_ts;
-	bool                         support_consumed_addr;
 
 	uint32_t    acquired_hw_id[CAM_MAX_ACQ_RES];
 	uint32_t    acquired_hw_path[CAM_MAX_ACQ_RES][CAM_MAX_HW_SPLIT];
@@ -238,16 +227,14 @@ struct cam_hw_stream_setttings {
 /**
  * struct cam_hw_config_args - Payload for config command
  *
- * @ctxt_to_hw_map:            HW context from the acquire
- * @num_hw_update_entries:     Number of hardware update entries
- * @hw_update_entries:         Hardware update list
- * @out_map_entries:           Out map info
- * @num_out_map_entries:       Number of out map entries
- * @priv:                      Private pointer
- * @request_id:                Request ID
- * @reapply:                   True if reapplying after bubble
- * @cdm_reset_before_apply:    True is need to reset CDM before re-apply bubble
- *                             request
+ * @ctxt_to_hw_map:        HW context from the acquire
+ * @num_hw_update_entries: Number of hardware update entries
+ * @hw_update_entries:     Hardware update list
+ * @out_map_entries:       Out map info
+ * @num_out_map_entries:   Number of out map entries
+ * @priv:                  Private pointer
+ * @request_id:            Request ID
+ * @reapply                True if reapplying after bubble
  *
  */
 struct cam_hw_config_args {
@@ -260,7 +247,6 @@ struct cam_hw_config_args {
 	uint64_t                        request_id;
 	bool                            init_packet;
 	bool                            reapply;
-	bool                            cdm_reset_before_apply;
 };
 
 /**
@@ -314,23 +300,6 @@ struct cam_hw_reset_args {
 	void                           *ctxt_to_hw_map;
 };
 
-/**
- * struct cam_hw_dump_args - Dump arguments
- *
- * @request_id:            request_id
- * @offset:                Buffer offset. This is updated by the drivers.
- * @buf_handle:            Buffer handle
- * @error_type:            Error type, to be used to extend dump information
- * @ctxt_to_hw_map:        HW context from the acquire
- */
-struct cam_hw_dump_args {
-	uint64_t          request_id;
-	size_t            offset;
-	uint32_t          buf_handle;
-	uint32_t          error_type;
-	void             *ctxt_to_hw_map;
-};
-
 /* enum cam_hw_mgr_command - Hardware manager command type */
 enum cam_hw_mgr_command {
 	CAM_HW_MGR_CMD_INTERNAL,
@@ -386,7 +355,6 @@ struct cam_hw_cmd_args {
  * @hw_close:                  Function pointer for HW deinit
  * @hw_flush:                  Function pointer for HW flush
  * @hw_reset:                  Function pointer for HW reset
- * @hw_dump:                   Function pointer for HW dump
  *
  */
 struct cam_hw_mgr_intf {
@@ -408,7 +376,6 @@ struct cam_hw_mgr_intf {
 	int (*hw_close)(void *hw_priv, void *hw_close_args);
 	int (*hw_flush)(void *hw_priv, void *hw_flush_args);
 	int (*hw_reset)(void *hw_priv, void *hw_reset_args);
-	int (*hw_dump)(void *hw_priv, void *hw_dump_args);
 };
 
 #endif /* _CAM_HW_MGR_INTF_H_ */
diff --git a/techpack/camera/drivers/cam_core/cam_node.c b/techpack/camera/drivers/cam_core/cam_node.c
index 672ae35b6226..4fefa2f35db3 100644
--- a/techpack/camera/drivers/cam_core/cam_node.c
+++ b/techpack/camera/drivers/cam_core/cam_node.c
@@ -435,39 +435,6 @@ static int __cam_node_handle_release_dev(struct cam_node *node,
 	return rc;
 }
 
-static int __cam_node_handle_dump_dev(struct cam_node *node,
-	struct cam_dump_req_cmd *dump)
-{
-	int                 rc;
-	struct cam_context *ctx = NULL;
-
-	if (!dump)
-		return -EINVAL;
-
-	if (dump->dev_handle <= 0) {
-		CAM_ERR(CAM_CORE, "Invalid device handle for context");
-		return -EINVAL;
-	}
-
-	if (dump->session_handle <= 0) {
-		CAM_ERR(CAM_CORE, "Invalid session handle for context");
-		return -EINVAL;
-	}
-
-	ctx = (struct cam_context *)cam_get_device_priv(dump->dev_handle);
-	if (!ctx) {
-		CAM_ERR(CAM_CORE, "Can not get context for handle %d",
-			dump->dev_handle);
-		return -EINVAL;
-	}
-
-	rc = cam_context_handle_dump_dev(ctx, dump);
-	if (rc)
-		CAM_ERR(CAM_CORE, "Dump failure for node %s", node->name);
-
-	return rc;
-}
-
 static int __cam_node_handle_release_hw_v1(struct cam_node *node,
 	struct cam_release_hw_cmd_v1 *release)
 {
@@ -608,25 +575,6 @@ static int __cam_node_crm_process_evt(
 	return cam_context_handle_crm_process_evt(ctx, evt_data);
 }
 
-static int __cam_node_crm_dump_req(struct cam_req_mgr_dump_info *dump)
-{
-	struct cam_context *ctx = NULL;
-
-	if (!dump) {
-		CAM_ERR(CAM_CORE, "Invalid dump request payload");
-		return -EINVAL;
-	}
-
-	ctx = (struct cam_context *) cam_get_device_priv(dump->dev_hdl);
-	if (!ctx) {
-		CAM_ERR(CAM_CORE, "Can not get context for handle %d",
-			dump->dev_hdl);
-		return -EINVAL;
-	}
-
-	return cam_context_handle_crm_dump_req(ctx, dump);
-}
-
 int cam_node_deinit(struct cam_node *node)
 {
 	if (node)
@@ -682,7 +630,6 @@ int cam_node_init(struct cam_node *node, struct cam_hw_mgr_intf *hw_mgr_intf,
 	node->crm_node_intf.link_setup = __cam_node_crm_link_setup;
 	node->crm_node_intf.flush_req = __cam_node_crm_flush_req;
 	node->crm_node_intf.process_evt = __cam_node_crm_process_evt;
-	node->crm_node_intf.dump_req = __cam_node_crm_dump_req;
 
 	mutex_init(&node->list_mutex);
 	INIT_LIST_HEAD(&node->free_ctx_list);
@@ -930,30 +877,6 @@ int cam_node_handle_ioctl(struct cam_node *node, struct cam_control *cmd)
 		}
 		break;
 	}
-	case CAM_DUMP_REQ: {
-		struct cam_dump_req_cmd dump;
-
-		if (copy_from_user(&dump, u64_to_user_ptr(cmd->handle),
-			sizeof(dump))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = __cam_node_handle_dump_dev(node, &dump);
-		if (rc) {
-			CAM_ERR(CAM_CORE,
-			    "Dump device %s failed(rc = %d) ",
-			    node->name, rc);
-			break;
-		}
-		if (copy_to_user(u64_to_user_ptr(cmd->handle),
-			&dump, sizeof(dump))) {
-			CAM_ERR(CAM_CORE,
-			    "Dump device %s copy_to_user fail",
-			    node->name);
-			rc = -EFAULT;
-		}
-		break;
-	}
 	default:
 		CAM_ERR(CAM_CORE, "Unknown op code %d", cmd->op_code);
 		rc = -EINVAL;
diff --git a/techpack/camera/drivers/cam_core/cam_subdev.c b/techpack/camera/drivers/cam_core/cam_subdev.c
index 15b5fd84bbc4..1a81a4d59e99 100644
--- a/techpack/camera/drivers/cam_core/cam_subdev.c
+++ b/techpack/camera/drivers/cam_core/cam_subdev.c
@@ -53,10 +53,8 @@ static long cam_subdev_ioctl(struct v4l2_subdev *sd, unsigned int cmd,
 
 	switch (cmd) {
 	case VIDIOC_CAM_CONTROL:
-		cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
 		rc = cam_node_handle_ioctl(node,
 			(struct cam_control *) arg);
-		cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
 		break;
 	default:
 		CAM_ERR(CAM_CORE, "Invalid command %d for %s", cmd,
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_hw.c b/techpack/camera/drivers/cam_cpas/cam_cpas_hw.c
index 8a51413f67e0..1272eccb4b7a 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_hw.c
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_hw.c
@@ -62,11 +62,9 @@ static int cam_cpas_util_vote_bus_client_level(
 		return -EINVAL;
 	}
 
-	if (level >= CAM_MAX_VOTE) {
-		CAM_ERR(CAM_CPAS,
-			"Invalid votelevel=%d,usecases=%d,Bus client=[%d][%s]",
-			level, bus_client->num_usecases,
-			bus_client->client_id, bus_client->name);
+	if (level >= bus_client->num_usecases) {
+		CAM_ERR(CAM_CPAS, "Invalid vote level=%d, usecases=%d", level,
+			bus_client->num_usecases);
 		return -EINVAL;
 	}
 
@@ -83,7 +81,7 @@ static int cam_cpas_util_vote_bus_client_level(
 
 static int cam_cpas_util_vote_bus_client_bw(
 	struct cam_cpas_bus_client *bus_client, uint64_t ab, uint64_t ib,
-	bool camnoc_bw, uint64_t *applied_ab, uint64_t *applied_ib)
+	bool camnoc_bw)
 {
 	struct msm_bus_paths *path;
 	struct msm_bus_scale_pdata *pdata;
@@ -146,10 +144,6 @@ static int cam_cpas_util_vote_bus_client_bw(
 	CAM_DBG(CAM_CPAS, "Bus client=[%d][%s] :ab[%llu] ib[%llu], index[%d]",
 		bus_client->client_id, bus_client->name, ab, ib, idx);
 	msm_bus_scale_client_update_request(bus_client->client_id, idx);
-	if (applied_ab)
-		*applied_ab = ab;
-	if (applied_ib)
-		*applied_ib = ib;
 
 	return 0;
 }
@@ -225,8 +219,7 @@ static int cam_cpas_util_unregister_bus_client(
 		return -EINVAL;
 
 	if (bus_client->dyn_vote)
-		cam_cpas_util_vote_bus_client_bw(bus_client, 0, 0, false,
-		NULL, NULL);
+		cam_cpas_util_vote_bus_client_bw(bus_client, 0, 0, false);
 	else
 		cam_cpas_util_vote_bus_client_level(bus_client, 0);
 
@@ -249,12 +242,6 @@ static int cam_cpas_util_axi_cleanup(struct cam_cpas *cpas_core,
 		return -EINVAL;
 	}
 
-	if (cpas_core->num_camnoc_axi_ports > CAM_CPAS_MAX_AXI_PORTS) {
-		CAM_ERR(CAM_CPAS, "Invalid num_camnoc_axi_ports: %d",
-			cpas_core->num_camnoc_axi_ports);
-		return -EINVAL;
-	}
-
 	for (i = 0; i < cpas_core->num_axi_ports; i++) {
 		cam_cpas_util_unregister_bus_client(
 			&cpas_core->axi_port[i].bus_client);
@@ -262,13 +249,6 @@ static int cam_cpas_util_axi_cleanup(struct cam_cpas *cpas_core,
 		cpas_core->axi_port[i].axi_port_node = NULL;
 	}
 
-	for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-		cam_cpas_util_unregister_bus_client(
-			&cpas_core->camnoc_axi_port[i].bus_client);
-		of_node_put(cpas_core->camnoc_axi_port[i].axi_port_node);
-		cpas_core->camnoc_axi_port[i].axi_port_node = NULL;
-	}
-
 	return 0;
 }
 
@@ -277,7 +257,6 @@ static int cam_cpas_util_axi_setup(struct cam_cpas *cpas_core,
 {
 	int i = 0, rc = 0;
 	struct device_node *axi_port_mnoc_node = NULL;
-	struct device_node *axi_port_camnoc_node = NULL;
 
 	if (cpas_core->num_axi_ports > CAM_CPAS_MAX_AXI_PORTS) {
 		CAM_ERR(CAM_CPAS, "Invalid num_axi_ports: %d",
@@ -292,15 +271,6 @@ static int cam_cpas_util_axi_setup(struct cam_cpas *cpas_core,
 		if (rc)
 			goto bus_register_fail;
 	}
-	for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-		axi_port_camnoc_node =
-			cpas_core->camnoc_axi_port[i].axi_port_node;
-		rc = cam_cpas_util_register_bus_client(soc_info,
-			axi_port_camnoc_node,
-			&cpas_core->camnoc_axi_port[i].bus_client);
-		if (rc)
-			goto bus_register_fail;
-	}
 
 	return 0;
 bus_register_fail:
@@ -314,7 +284,6 @@ static int cam_cpas_util_vote_default_ahb_axi(struct cam_hw_info *cpas_hw,
 	int rc, i = 0;
 	struct cam_cpas *cpas_core = (struct cam_cpas *)cpas_hw->core_info;
 	uint64_t ab_bw, ib_bw;
-	uint64_t applied_ab_bw = 0, applied_ib_bw = 0;
 
 	rc = cam_cpas_util_vote_bus_client_level(&cpas_core->ahb_bus_client,
 		(enable == true) ? CAM_SVS_VOTE : CAM_SUSPEND_VOTE);
@@ -335,15 +304,13 @@ static int cam_cpas_util_vote_default_ahb_axi(struct cam_hw_info *cpas_hw,
 	for (i = 0; i < cpas_core->num_axi_ports; i++) {
 		rc = cam_cpas_util_vote_bus_client_bw(
 			&cpas_core->axi_port[i].bus_client,
-			ab_bw, ib_bw, false, &applied_ab_bw, &applied_ib_bw);
+			ab_bw, ib_bw, false);
 		if (rc) {
 			CAM_ERR(CAM_CPAS,
 				"Failed in mnoc vote, enable=%d, rc=%d",
 				enable, rc);
 			goto remove_ahb_vote;
 		}
-		cpas_core->axi_port[i].applied_ab_bw = applied_ab_bw;
-		cpas_core->axi_port[i].applied_ib_bw = applied_ib_bw;
 	}
 
 	return 0;
@@ -478,13 +445,6 @@ static int cam_cpas_util_set_camnoc_axi_clk_rate(
 		do_div(intermediate_result, 100);
 		required_camnoc_bw += intermediate_result;
 
-		if (cpas_core->streamon_clients && (required_camnoc_bw == 0)) {
-			CAM_DBG(CAM_CPAS,
-				"Set min vote if streamon_clients is non-zero : streamon_clients=%d",
-				cpas_core->streamon_clients);
-			required_camnoc_bw = CAM_CPAS_DEFAULT_AXI_BW;
-		}
-
 		if ((required_camnoc_bw > 0) &&
 			(required_camnoc_bw <
 			soc_private->camnoc_axi_min_ib_bw))
@@ -509,8 +469,6 @@ static int cam_cpas_util_set_camnoc_axi_clk_rate(
 				CAM_ERR(CAM_CPAS,
 				"Failed in setting camnoc axi clk %llu %lld %d",
 				required_camnoc_bw, clk_rate, rc);
-
-			cpas_core->applied_camnoc_axi_rate = clk_rate;
 		}
 	}
 
@@ -650,113 +608,6 @@ static int cam_cpas_axi_consolidate_path_votes(
 	return rc;
 }
 
-static int cam_cpas_update_axi_vote_bw(
-	struct cam_hw_info *cpas_hw,
-	struct cam_cpas_tree_node *cpas_tree_node,
-	bool   *mnoc_axi_port_updated,
-	bool   *camnoc_axi_port_updated)
-{
-	struct cam_cpas *cpas_core = (struct cam_cpas *) cpas_hw->core_info;
-	struct cam_cpas_private_soc *soc_private =
-		(struct cam_cpas_private_soc *) cpas_hw->soc_info.soc_private;
-	int idx;
-
-	if (cpas_tree_node->axi_port_idx >= CAM_CPAS_MAX_AXI_PORTS) {
-		CAM_ERR(CAM_CPAS, "Invalid axi_port_idx: %d",
-			cpas_tree_node->axi_port_idx);
-		return -EINVAL;
-	}
-
-	cpas_core->axi_port[cpas_tree_node->axi_port_idx].ab_bw =
-		cpas_tree_node->mnoc_ab_bw;
-	cpas_core->axi_port[cpas_tree_node->axi_port_idx].ib_bw =
-		cpas_tree_node->mnoc_ib_bw;
-	mnoc_axi_port_updated[cpas_tree_node->axi_port_idx] = true;
-
-	if (soc_private->control_camnoc_axi_clk)
-		return 0;
-
-	if (cpas_tree_node->camnoc_axi_port_idx >= CAM_CPAS_MAX_AXI_PORTS) {
-		CAM_ERR(CAM_CPAS, "Invalid camnoc_axi_port_idx: %d",
-			cpas_tree_node->camnoc_axi_port_idx);
-		return -EINVAL;
-	}
-
-	idx = cpas_tree_node->camnoc_axi_port_idx;
-	cpas_core->camnoc_axi_port[idx].camnoc_bw = cpas_tree_node->camnoc_bw;
-	camnoc_axi_port_updated[idx] = true;
-	return 0;
-}
-
-static int cam_cpas_camnoc_set_vote_axi_clk_rate(
-	struct cam_hw_info *cpas_hw,
-	bool   *camnoc_axi_port_updated)
-{
-	struct cam_cpas *cpas_core = (struct cam_cpas *) cpas_hw->core_info;
-	struct cam_cpas_private_soc *soc_private =
-		(struct cam_cpas_private_soc *) cpas_hw->soc_info.soc_private;
-	int i;
-	int rc = 0;
-	struct cam_cpas_axi_port *camnoc_axi_port = NULL;
-	uint64_t camnoc_bw;
-	uint64_t applied_ab = 0, applied_ib = 0;
-
-	if (soc_private->control_camnoc_axi_clk) {
-		rc = cam_cpas_util_set_camnoc_axi_clk_rate(cpas_hw);
-		if (rc)
-			CAM_ERR(CAM_CPAS,
-				"Failed in setting axi clk rate rc=%d", rc);
-		return rc;
-	}
-
-	/* Below code is executed if we just vote and do not set the clk rate
-	 * for camnoc
-	 */
-
-	if (cpas_core->num_camnoc_axi_ports > CAM_CPAS_MAX_AXI_PORTS) {
-		CAM_ERR(CAM_CPAS, "Invalid num_camnoc_axi_ports: %d",
-			cpas_core->num_camnoc_axi_ports);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-		if (camnoc_axi_port_updated[i])
-			camnoc_axi_port = &cpas_core->camnoc_axi_port[i];
-		else
-			continue;
-
-		CAM_DBG(CAM_PERF, "Port[%s] : camnoc_bw=%lld",
-			camnoc_axi_port->axi_port_name,
-			camnoc_axi_port->camnoc_bw);
-
-		if (camnoc_axi_port->camnoc_bw)
-			camnoc_bw = camnoc_axi_port->camnoc_bw;
-		else if (camnoc_axi_port->additional_bw)
-			camnoc_bw = camnoc_axi_port->additional_bw;
-		else if (cpas_core->streamon_clients)
-			camnoc_bw = CAM_CPAS_DEFAULT_AXI_BW;
-		else
-			camnoc_bw = 0;
-
-		rc = cam_cpas_util_vote_bus_client_bw(
-			&camnoc_axi_port->bus_client,
-			0, camnoc_bw, true, &applied_ab, &applied_ib);
-
-		CAM_DBG(CAM_CPAS,
-			"camnoc vote camnoc_bw[%llu] rc=%d %s",
-			camnoc_bw, rc, camnoc_axi_port->axi_port_name);
-		if (rc) {
-			CAM_ERR(CAM_CPAS,
-				"Failed in camnoc vote camnoc_bw[%llu] rc=%d",
-				camnoc_bw, rc);
-			break;
-		}
-		camnoc_axi_port->applied_ab_bw = applied_ab;
-		camnoc_axi_port->applied_ib_bw = applied_ib;
-	}
-	return rc;
-}
-
 static int cam_cpas_util_apply_client_axi_vote(
 	struct cam_hw_info *cpas_hw,
 	struct cam_cpas_client *cpas_client,
@@ -764,18 +615,16 @@ static int cam_cpas_util_apply_client_axi_vote(
 {
 	struct cam_cpas *cpas_core = (struct cam_cpas *) cpas_hw->core_info;
 	struct cam_axi_vote *con_axi_vote = NULL;
-	struct cam_cpas_axi_port *mnoc_axi_port = NULL;
+	struct cam_cpas_axi_port *axi_port = NULL;
 	struct cam_cpas_tree_node *curr_tree_node = NULL;
 	struct cam_cpas_tree_node *par_tree_node = NULL;
 	uint32_t transac_type;
 	uint32_t path_data_type;
-	bool mnoc_axi_port_updated[CAM_CPAS_MAX_AXI_PORTS] = {false};
-	bool camnoc_axi_port_updated[CAM_CPAS_MAX_AXI_PORTS] = {false};
+	bool axi_port_updated[CAM_CPAS_MAX_AXI_PORTS] = {false};
 	uint64_t mnoc_ab_bw = 0, mnoc_ib_bw = 0,
 		curr_camnoc_old = 0, curr_mnoc_ab_old = 0, curr_mnoc_ib_old = 0,
 		par_camnoc_old = 0, par_mnoc_ab_old = 0, par_mnoc_ib_old = 0;
 	int rc = 0, i = 0;
-	uint64_t applied_ab = 0, applied_ib = 0;
 
 	mutex_lock(&cpas_core->tree_lock);
 	if (!cpas_client->tree_node_valid) {
@@ -794,22 +643,8 @@ static int cam_cpas_util_apply_client_axi_vote(
 				cpas_core->axi_port[i].additional_bw -=
 					CAM_CPAS_DEFAULT_AXI_BW;
 			}
-			mnoc_axi_port_updated[i] = true;
+			axi_port_updated[i] = true;
 		}
-
-		for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-			if (axi_vote->axi_path[0].camnoc_bw) {
-				/* start case */
-				cpas_core->camnoc_axi_port[i].additional_bw +=
-					CAM_CPAS_DEFAULT_AXI_BW;
-			} else {
-				/* stop case */
-				cpas_core->camnoc_axi_port[i].additional_bw -=
-					CAM_CPAS_DEFAULT_AXI_BW;
-			}
-			camnoc_axi_port_updated[i] = true;
-		}
-
 		goto vote_start_clients;
 	}
 
@@ -898,15 +733,15 @@ static int cam_cpas_util_apply_client_axi_vote(
 					rc = -EINVAL;
 					goto unlock_tree;
 				}
-				rc = cam_cpas_update_axi_vote_bw(cpas_hw,
-					par_tree_node,
-					mnoc_axi_port_updated,
-					camnoc_axi_port_updated);
-				if (rc) {
-					CAM_ERR(CAM_CPAS,
-						"Update Vote failed");
-					goto unlock_tree;
-				}
+
+				cpas_core->axi_port
+				[par_tree_node->axi_port_idx].ab_bw =
+				par_tree_node->mnoc_ab_bw;
+				cpas_core->axi_port
+				[par_tree_node->axi_port_idx].ib_bw =
+				par_tree_node->mnoc_ib_bw;
+				axi_port_updated[par_tree_node->axi_port_idx] =
+					true;
 			}
 
 			curr_tree_node = par_tree_node;
@@ -924,81 +759,27 @@ static int cam_cpas_util_apply_client_axi_vote(
 
 vote_start_clients:
 	for (i = 0; i < cpas_core->num_axi_ports; i++) {
-		if (mnoc_axi_port_updated[i])
-			mnoc_axi_port = &cpas_core->axi_port[i];
+		if (axi_port_updated[i])
+			axi_port = &cpas_core->axi_port[i];
 		else
 			continue;
 
-		CAM_DBG(CAM_PERF,
-			"Port[%s] : ab=%lld ib=%lld additional=%lld, streamon_clients=%d",
-			mnoc_axi_port->axi_port_name, mnoc_axi_port->ab_bw,
-			mnoc_axi_port->ib_bw, mnoc_axi_port->additional_bw,
-			cpas_core->streamon_clients);
-
-		if (mnoc_axi_port->ab_bw)
-			mnoc_ab_bw = mnoc_axi_port->ab_bw;
-		else if (mnoc_axi_port->additional_bw)
-			mnoc_ab_bw = mnoc_axi_port->additional_bw;
-		else if (cpas_core->streamon_clients)
-			mnoc_ab_bw = CAM_CPAS_DEFAULT_AXI_BW;
-		else
-			mnoc_ab_bw = 0;
+		CAM_DBG(CAM_PERF, "Port[%s] : ab=%lld ib=%lld additional=%lld",
+			axi_port->axi_port_name, axi_port->ab_bw,
+			axi_port->ib_bw, axi_port->additional_bw);
 
-		if (cpas_core->axi_port[i].ib_bw_voting_needed)
-			mnoc_ib_bw = mnoc_axi_port->ib_bw;
+		if (axi_port->ab_bw)
+			mnoc_ab_bw = axi_port->ab_bw;
 		else
-			mnoc_ib_bw = 0;
+			mnoc_ab_bw = axi_port->additional_bw;
 
-		rc = cam_cpas_util_vote_bus_client_bw(
-			&mnoc_axi_port->bus_client,
-			mnoc_ab_bw, mnoc_ib_bw, false, &applied_ab,
-			&applied_ib);
-		if (rc) {
-			CAM_ERR(CAM_CPAS,
-				"Failed in mnoc vote ab[%llu] ib[%llu] rc=%d",
-				mnoc_ab_bw, mnoc_ib_bw, rc);
-			goto unlock_tree;
-		}
-		mnoc_axi_port->applied_ab_bw = applied_ab;
-		mnoc_axi_port->applied_ib_bw = applied_ib;
-	}
-	rc = cam_cpas_camnoc_set_vote_axi_clk_rate(
-		cpas_hw, camnoc_axi_port_updated);
-	if (rc)
-		CAM_ERR(CAM_CPAS, "Failed in setting axi clk rate rc=%d", rc);
-
-unlock_tree:
-	mutex_unlock(&cpas_core->tree_lock);
-	return rc;
-}
-
-static int cam_cpas_util_apply_default_axi_vote(
-	struct cam_hw_info *cpas_hw, bool enable)
-{
-	struct cam_cpas *cpas_core = (struct cam_cpas *) cpas_hw->core_info;
-	struct cam_cpas_axi_port *axi_port = NULL;
-	uint64_t mnoc_ab_bw = 0, mnoc_ib_bw = 0;
-	uint64_t camnoc_ab_bw = 0, camnoc_ib_bw = 0;
-	int rc = 0, i = 0;
-
-	mutex_lock(&cpas_core->tree_lock);
-	for (i = 0; i < cpas_core->num_axi_ports; i++) {
-		if (!cpas_core->axi_port[i].ab_bw ||
-			!cpas_core->axi_port[i].ib_bw)
-			axi_port = &cpas_core->axi_port[i];
-		else
-			continue;
-
-		if (enable)
-			mnoc_ib_bw = CAM_CPAS_DEFAULT_AXI_BW;
+		if (cpas_core->axi_port[i].ib_bw_voting_needed)
+			mnoc_ib_bw = axi_port->ib_bw;
 		else
 			mnoc_ib_bw = 0;
 
-		CAM_DBG(CAM_CPAS, "Port=[%s] :ab[%llu] ib[%llu]",
-			axi_port->axi_port_name, mnoc_ab_bw, mnoc_ib_bw);
-
 		rc = cam_cpas_util_vote_bus_client_bw(&axi_port->bus_client,
-			mnoc_ab_bw, mnoc_ib_bw, false, NULL, NULL);
+			mnoc_ab_bw, mnoc_ib_bw, false);
 		if (rc) {
 			CAM_ERR(CAM_CPAS,
 				"Failed in mnoc vote ab[%llu] ib[%llu] rc=%d",
@@ -1007,30 +788,10 @@ static int cam_cpas_util_apply_default_axi_vote(
 		}
 	}
 
-	for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-		if (!cpas_core->camnoc_axi_port[i].ab_bw ||
-			!cpas_core->camnoc_axi_port[i].ib_bw)
-			axi_port = &cpas_core->camnoc_axi_port[i];
-		else
-			continue;
-
-		if (enable)
-			camnoc_ib_bw = CAM_CPAS_DEFAULT_AXI_BW;
-		else
-			camnoc_ib_bw = 0;
-
-		CAM_DBG(CAM_CPAS, "Port=[%s] :ab[%llu] ib[%llu]",
-			axi_port->axi_port_name, camnoc_ab_bw, camnoc_ib_bw);
+	rc = cam_cpas_util_set_camnoc_axi_clk_rate(cpas_hw);
+	if (rc)
+		CAM_ERR(CAM_CPAS, "Failed in setting axi clk rate rc=%d", rc);
 
-		rc = cam_cpas_util_vote_bus_client_bw(&axi_port->bus_client,
-			camnoc_ab_bw, camnoc_ib_bw, false, NULL, NULL);
-		if (rc) {
-			CAM_ERR(CAM_CPAS,
-				"Failed in camnoc vote ab[%llu] ib[%llu] rc=%d",
-				camnoc_ab_bw, camnoc_ib_bw, rc);
-			goto unlock_tree;
-		}
-	}
 unlock_tree:
 	mutex_unlock(&cpas_core->tree_lock);
 	return rc;
@@ -1301,10 +1062,9 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 	struct cam_cpas_hw_cmd_start *cmd_hw_start;
 	struct cam_cpas_client *cpas_client;
 	struct cam_ahb_vote *ahb_vote;
-	struct cam_ahb_vote remove_ahb;
 	struct cam_axi_vote axi_vote = {0};
 	enum cam_vote_level applied_level = CAM_SVS_VOTE;
-	int rc, ret = 0, i = 0;
+	int rc, i = 0;
 	struct cam_cpas_private_soc *soc_private = NULL;
 	bool invalid_start = true;
 
@@ -1363,15 +1123,15 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 		CAM_ERR(CAM_CPAS, "client=[%d] is not registered",
 			client_indx);
 		rc = -EPERM;
-		goto error;
+		goto done;
 	}
 
 	if (CAM_CPAS_CLIENT_STARTED(cpas_core, client_indx)) {
 		CAM_ERR(CAM_CPAS, "client=[%d][%s][%d] is in start state",
 			client_indx, cpas_client->data.identifier,
 			cpas_client->data.cell_index);
-		rc = -EPERM;
-		goto error;
+		rc = -EALREADY;
+		goto done;
 	}
 
 	CAM_DBG(CAM_CPAS,
@@ -1382,7 +1142,7 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 	rc = cam_cpas_util_apply_client_ahb_vote(cpas_hw, cpas_client,
 		ahb_vote, &applied_level);
 	if (rc)
-		goto error;
+		goto done;
 
 	cam_cpas_dump_axi_vote_info(cpas_client, "CPAS Start Vote",
 		&axi_vote);
@@ -1403,7 +1163,7 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 	if (rc) {
 		CAM_ERR(CAM_CPAS, "Unable to create or translate paths rc: %d",
 			rc);
-		goto remove_ahb_vote;
+		goto done;
 	}
 
 	cam_cpas_dump_axi_vote_info(cpas_client, "CPAS Start Translated Vote",
@@ -1412,20 +1172,16 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 	rc = cam_cpas_util_apply_client_axi_vote(cpas_hw,
 		cpas_client, &axi_vote);
 	if (rc)
-		goto remove_ahb_vote;
+		goto done;
 
 	if (cpas_core->streamon_clients == 0) {
-		rc = cam_cpas_util_apply_default_axi_vote(cpas_hw, true);
-		if (rc)
-			goto remove_ahb_vote;
-
 		atomic_set(&cpas_core->irq_count, 1);
 		rc = cam_cpas_soc_enable_resources(&cpas_hw->soc_info,
 			applied_level);
 		if (rc) {
 			atomic_set(&cpas_core->irq_count, 0);
 			CAM_ERR(CAM_CPAS, "enable_resorce failed, rc=%d", rc);
-			goto remove_axi_vote;
+			goto done;
 		}
 
 		if (cpas_core->internal_ops.power_on) {
@@ -1437,7 +1193,7 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 				CAM_ERR(CAM_CPAS,
 					"failed in power_on settings rc=%d",
 					rc);
-				goto remove_axi_vote;
+				goto done;
 			}
 		}
 		CAM_DBG(CAM_CPAS, "irq_count=%d\n",
@@ -1451,35 +1207,7 @@ static int cam_cpas_hw_start(void *hw_priv, void *start_args,
 	CAM_DBG(CAM_CPAS, "client=[%d][%s][%d] streamon_clients=%d",
 		client_indx, cpas_client->data.identifier,
 		cpas_client->data.cell_index, cpas_core->streamon_clients);
-
-	mutex_unlock(&cpas_core->client_mutex[client_indx]);
-	mutex_unlock(&cpas_hw->hw_mutex);
-	return rc;
-
-remove_axi_vote:
-	memset(&axi_vote, 0x0, sizeof(struct cam_axi_vote));
-	ret = cam_cpas_util_create_vote_all_paths(cpas_client, &axi_vote);
-	if (ret)
-		CAM_ERR(CAM_CPAS, "Unable to create per path votes ret: %d",
-			ret);
-
-	cam_cpas_dump_axi_vote_info(cpas_client, "CPAS Start fail Vote",
-		&axi_vote);
-
-	ret = cam_cpas_util_apply_client_axi_vote(cpas_hw,
-		cpas_client, &axi_vote);
-	if (ret)
-		CAM_ERR(CAM_CPAS, "Unable to remove axi votes ret: %d", ret);
-
-remove_ahb_vote:
-	remove_ahb.type = CAM_VOTE_ABSOLUTE;
-	remove_ahb.vote.level = CAM_SUSPEND_VOTE;
-	ret = cam_cpas_util_apply_client_ahb_vote(cpas_hw, cpas_client,
-		&remove_ahb, NULL);
-	if (ret)
-		CAM_ERR(CAM_CPAS, "Removing AHB vote failed, ret: %d", ret);
-
-error:
+done:
 	mutex_unlock(&cpas_core->client_mutex[client_indx]);
 	mutex_unlock(&cpas_hw->hw_mutex);
 	return rc;
@@ -1599,11 +1327,6 @@ static int cam_cpas_hw_stop(void *hw_priv, void *stop_args,
 
 	rc = cam_cpas_util_apply_client_axi_vote(cpas_hw,
 		cpas_client, &axi_vote);
-	if (rc)
-		goto done;
-
-	if (cpas_core->streamon_clients == 0)
-		rc = cam_cpas_util_apply_default_axi_vote(cpas_hw, false);
 done:
 	mutex_unlock(&cpas_core->client_mutex[client_indx]);
 	mutex_unlock(&cpas_hw->hw_mutex);
@@ -1781,46 +1504,6 @@ static int cam_cpas_hw_get_hw_info(void *hw_priv,
 	return 0;
 }
 
-static int cam_cpas_log_vote(struct cam_hw_info *cpas_hw)
-{
-	struct cam_cpas *cpas_core = (struct cam_cpas *) cpas_hw->core_info;
-	struct cam_cpas_private_soc *soc_private =
-		(struct cam_cpas_private_soc *) cpas_hw->soc_info.soc_private;
-	int rc = 0;
-	uint32_t i;
-
-	for (i = 0; i < cpas_core->num_axi_ports; i++) {
-		CAM_INFO(CAM_CPAS,
-			"[%s] ab_bw[%lld] ib_bw[%lld] additional_bw[%lld] applied_ab[%lld] applied_ib[%lld]",
-			cpas_core->axi_port[i].axi_port_name,
-			cpas_core->axi_port[i].ab_bw,
-			cpas_core->axi_port[i].ib_bw,
-			cpas_core->axi_port[i].additional_bw,
-			cpas_core->axi_port[i].applied_ab_bw,
-			cpas_core->axi_port[i].applied_ib_bw);
-	}
-
-	if (soc_private->control_camnoc_axi_clk) {
-		CAM_INFO(CAM_CPAS, "applied camnoc axi clk[%lld]",
-			cpas_core->applied_camnoc_axi_rate);
-	} else {
-		for (i = 0; i < cpas_core->num_camnoc_axi_ports; i++) {
-			CAM_INFO(CAM_CPAS,
-				"[%s] ab_bw[%lld] ib_bw[%lld] additional_bw[%lld] applied_ab[%lld] applied_ib[%lld]",
-				cpas_core->camnoc_axi_port[i].axi_port_name,
-				cpas_core->camnoc_axi_port[i].ab_bw,
-				cpas_core->camnoc_axi_port[i].ib_bw,
-				cpas_core->camnoc_axi_port[i].additional_bw,
-				cpas_core->camnoc_axi_port[i].applied_ab_bw,
-				cpas_core->camnoc_axi_port[i].applied_ib_bw);
-		}
-	}
-
-	CAM_INFO(CAM_CPAS, "ahb client curr vote level[%d]",
-		cpas_core->ahb_bus_client.curr_vote_level);
-
-	return rc;
-}
 
 static int cam_cpas_hw_process_cmd(void *hw_priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
@@ -1924,10 +1607,6 @@ static int cam_cpas_hw_process_cmd(void *hw_priv,
 			cmd_axi_vote->client_handle, cmd_axi_vote->axi_vote);
 		break;
 	}
-	case CAM_CPAS_HW_CMD_LOG_VOTE: {
-		rc = cam_cpas_log_vote(hw_priv);
-		break;
-	}
 	default:
 		CAM_ERR(CAM_CPAS, "CPAS HW command not valid =%d", cmd_type);
 		break;
@@ -2181,10 +1860,10 @@ int cam_cpas_hw_probe(struct platform_device *pdev,
 	cam_cpas_util_unregister_bus_client(&cpas_core->ahb_bus_client);
 client_cleanup:
 	cam_cpas_util_client_cleanup(cpas_hw);
-	cam_cpas_node_tree_cleanup(cpas_core, cpas_hw->soc_info.soc_private);
 deinit_platform_res:
 	cam_cpas_soc_deinit_resources(&cpas_hw->soc_info);
 release_workq:
+	cam_cpas_node_tree_cleanup(cpas_core, cpas_hw->soc_info.soc_private);
 	flush_workqueue(cpas_core->work_queue);
 	destroy_workqueue(cpas_core->work_queue);
 release_mem:
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_hw.h b/techpack/camera/drivers/cam_cpas/cam_cpas_hw.h
index acad4ba44b17..b3c01b3ee737 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_hw.h
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_hw.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CPAS_HW_H_
@@ -153,10 +153,7 @@ struct cam_cpas_bus_client {
  * @axi_port_node: Node representing AXI Port info in device tree
  * @ab_bw: AB bw value for this port
  * @ib_bw: IB bw value for this port
- * @camnoc_bw: CAMNOC bw value for this port
  * @additional_bw: Additional bandwidth to cover non-hw cpas clients
- * @applied_ab_bw: applied ab bw for this port
- * @applied_ib_bw: applied ib bw for this port
  */
 struct cam_cpas_axi_port {
 	const char *axi_port_name;
@@ -165,10 +162,7 @@ struct cam_cpas_axi_port {
 	struct device_node *axi_port_node;
 	uint64_t ab_bw;
 	uint64_t ib_bw;
-	uint64_t camnoc_bw;
 	uint64_t additional_bw;
-	uint64_t applied_ab_bw;
-	uint64_t applied_ib_bw;
 };
 
 /**
@@ -180,20 +174,17 @@ struct cam_cpas_axi_port {
  * @tree_lock: Mutex lock for accessing CPAS node tree
  * @num_clients: Total number of clients that CPAS supports
  * @num_axi_ports: Total number of axi ports found in device tree
- * @num_camnoc_axi_ports: Total number of camnoc axi ports found in device tree
  * @registered_clients: Number of Clients registered currently
  * @streamon_clients: Number of Clients that are in start state currently
  * @regbase_index: Register base indices for CPAS register base IDs
  * @ahb_bus_client: AHB Bus client info
  * @axi_port: AXI port info for a specific axi index
- * @camnoc_axi_port: CAMNOC AXI port info for a specific camnoc axi index
  * @internal_ops: CPAS HW internal ops
  * @work_queue: Work queue handle
  * @irq_count: atomic irq count
  * @irq_count_wq: wait variable to ensure all irq's are handled
  * @dentry: debugfs file entry
  * @ahb_bus_scaling_disable: ahb scaling based on src clk corner for bus
- * @applied_camnoc_axi_rate: applied camnoc axi clock rate
  */
 struct cam_cpas {
 	struct cam_cpas_hw_caps hw_caps;
@@ -202,20 +193,17 @@ struct cam_cpas {
 	struct mutex tree_lock;
 	uint32_t num_clients;
 	uint32_t num_axi_ports;
-	uint32_t num_camnoc_axi_ports;
 	uint32_t registered_clients;
 	uint32_t streamon_clients;
 	int32_t regbase_index[CAM_CPAS_REG_MAX];
 	struct cam_cpas_bus_client ahb_bus_client;
 	struct cam_cpas_axi_port axi_port[CAM_CPAS_MAX_AXI_PORTS];
-	struct cam_cpas_axi_port camnoc_axi_port[CAM_CPAS_MAX_AXI_PORTS];
 	struct cam_cpas_internal_ops internal_ops;
 	struct workqueue_struct *work_queue;
 	atomic_t irq_count;
 	wait_queue_head_t irq_count_wq;
 	struct dentry *dentry;
 	bool ahb_bus_scaling_disable;
-	uint64_t applied_camnoc_axi_rate;
 };
 
 int cam_camsstop_get_internal_ops(struct cam_cpas_internal_ops *internal_ops);
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_hw_intf.h b/techpack/camera/drivers/cam_cpas/cam_cpas_hw_intf.h
index 3f644363062c..0926e6e3d8d1 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_hw_intf.h
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CPAS_HW_INTF_H_
@@ -38,7 +38,6 @@ enum cam_cpas_hw_cmd_process {
 	CAM_CPAS_HW_CMD_REG_READ,
 	CAM_CPAS_HW_CMD_AHB_VOTE,
 	CAM_CPAS_HW_CMD_AXI_VOTE,
-	CAM_CPAS_HW_CMD_LOG_VOTE,
 	CAM_CPAS_HW_CMD_INVALID,
 };
 
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_intf.c b/techpack/camera/drivers/cam_cpas/cam_cpas_intf.c
index bdb81b8f13ec..a1d8b4026059 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_intf.c
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_intf.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/of.h>
@@ -17,7 +17,6 @@
 #include "cam_subdev.h"
 #include "cam_cpas_hw_intf.h"
 #include "cam_cpas_soc.h"
-#include "cam_cpas_api.h"
 
 #define CAM_CPAS_DEV_NAME    "cam-cpas"
 #define CAM_CPAS_INTF_INITIALIZED() (g_cpas_intf && g_cpas_intf->probe_done)
@@ -158,25 +157,6 @@ int cam_cpas_get_cpas_hw_version(uint32_t *hw_version)
 	return 0;
 }
 
-int cam_cpas_get_camnoc_fifo_fill_level_info(
-	uint32_t cpas_version,
-	uint32_t client_handle)
-{
-	int rc = 0;
-
-	if (!CAM_CPAS_INTF_INITIALIZED()) {
-		CAM_ERR(CAM_CPAS, "cpas intf not initialized");
-		return -ENODEV;
-	}
-
-	rc = cam_cpas_hw_get_camnoc_fill_level_info(cpas_version,
-		client_handle);
-	if (rc)
-		CAM_ERR(CAM_CPAS, "Failed to dump fifo reg rc %d", rc);
-
-	return rc;
-}
-
 int cam_cpas_get_hw_info(uint32_t *camera_family,
 	struct cam_hw_version *camera_version,
 	struct cam_hw_version *cpas_version,
@@ -412,30 +392,6 @@ int cam_cpas_start(uint32_t client_handle,
 }
 EXPORT_SYMBOL(cam_cpas_start);
 
-void cam_cpas_log_votes(void)
-{
-	uint32_t dummy_args;
-	int rc;
-
-	if (!CAM_CPAS_INTF_INITIALIZED()) {
-		CAM_ERR(CAM_CPAS, "cpas intf not initialized");
-		return;
-	}
-
-	if (g_cpas_intf->hw_intf->hw_ops.process_cmd) {
-		rc = g_cpas_intf->hw_intf->hw_ops.process_cmd(
-			g_cpas_intf->hw_intf->hw_priv,
-			CAM_CPAS_HW_CMD_LOG_VOTE, &dummy_args,
-			sizeof(dummy_args));
-		if (rc)
-			CAM_ERR(CAM_CPAS, "Failed in process_cmd, rc=%d", rc);
-	} else {
-		CAM_ERR(CAM_CPAS, "Invalid process_cmd ops");
-	}
-
-}
-EXPORT_SYMBOL(cam_cpas_log_votes);
-
 int cam_cpas_unregister_client(uint32_t client_handle)
 {
 	int rc;
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_soc.c b/techpack/camera/drivers/cam_cpas/cam_cpas_soc.c
index 3b4e4fb25275..c86753dd24d9 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_soc.c
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_soc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/device.h>
@@ -134,47 +134,6 @@ static int cam_cpas_util_path_type_to_idx(uint32_t *path_data_type)
 	return 0;
 }
 
-static int cam_cpas_update_camnoc_node(struct cam_cpas *cpas_core,
-	struct device_node *curr_node,
-	struct cam_cpas_tree_node *cpas_node_ptr,
-	int *camnoc_idx)
-
-{
-	struct device_node *camnoc_node;
-	int rc;
-
-	camnoc_node = of_find_node_by_name(curr_node,
-			"qcom,axi-port-camnoc");
-	if (camnoc_node) {
-
-		if (*camnoc_idx >=
-			CAM_CPAS_MAX_AXI_PORTS) {
-			CAM_ERR(CAM_CPAS, "CAMNOC axi index overshoot %d",
-				*camnoc_idx);
-			return -EINVAL;
-		}
-
-		cpas_core->camnoc_axi_port[*camnoc_idx]
-			.axi_port_node = camnoc_node;
-		rc = of_property_read_string(
-			curr_node,
-			"qcom,axi-port-name",
-			&cpas_core->camnoc_axi_port[*camnoc_idx]
-			.axi_port_name);
-
-		if (rc) {
-			CAM_ERR(CAM_CPAS,
-				"fail to read camnoc-port-name rc=%d",
-				rc);
-			return rc;
-		}
-		cpas_node_ptr->camnoc_axi_port_idx = *camnoc_idx;
-		cpas_core->num_camnoc_axi_ports++;
-		(*camnoc_idx)++;
-	}
-	return 0;
-}
-
 static int cam_cpas_parse_node_tree(struct cam_cpas *cpas_core,
 	struct device_node *of_node, struct cam_cpas_private_soc *soc_private)
 {
@@ -183,7 +142,7 @@ static int cam_cpas_parse_node_tree(struct cam_cpas *cpas_core,
 	struct device_node *curr_node;
 	struct device_node *parent_node;
 	struct device_node *mnoc_node;
-	int mnoc_idx = 0, camnoc_idx = 0;
+	int mnoc_idx = 0;
 	uint32_t path_idx;
 	bool camnoc_max_needed = false;
 	struct cam_cpas_tree_node *curr_node_ptr = NULL;
@@ -289,17 +248,6 @@ static int cam_cpas_parse_node_tree(struct cam_cpas *cpas_core,
 				cpas_core->num_axi_ports++;
 			}
 
-			if (!soc_private->control_camnoc_axi_clk) {
-				rc = cam_cpas_update_camnoc_node(
-					cpas_core, curr_node, curr_node_ptr,
-					&camnoc_idx);
-				if (rc) {
-					CAM_ERR(CAM_CPAS,
-						"Parse Camnoc port fail");
-					return rc;
-				}
-			}
-
 			rc = of_property_read_string(curr_node,
 				"client-name", &client_name);
 			if (!rc) {
diff --git a/techpack/camera/drivers/cam_cpas/cam_cpas_soc.h b/techpack/camera/drivers/cam_cpas/cam_cpas_soc.h
index 503efc20e8b8..fea9c3c97593 100644
--- a/techpack/camera/drivers/cam_cpas/cam_cpas_soc.h
+++ b/techpack/camera/drivers/cam_cpas/cam_cpas_soc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CPAS_SOC_H_
@@ -30,7 +30,6 @@ struct cam_cpas_vdd_ahb_mapping {
  * @cell_idx: Index to identify node from device tree and its parent
  * @level_idx: Index to identify at what level the node is present
  * @axi_port_idx: Index to identify which axi port to vote the consolidated bw
- * @camnoc_axi_port_idx: Index to find which axi port to vote consolidated bw
  * @path_data_type: Traffic type info from device tree (ife-vid, ife-disp etc)
  * @path_trans_type: Transaction type info from device tree (rd, wr)
  * @merge_type: Traffic merge type (calculation info) from device tree
@@ -54,7 +53,6 @@ struct cam_cpas_tree_node {
 	uint32_t cell_idx;
 	uint32_t level_idx;
 	int axi_port_idx;
-	int camnoc_axi_port_idx;
 	const char *node_name;
 	uint32_t path_data_type;
 	uint32_t path_trans_type;
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.c b/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.c
index 47a4cc64059e..1f52e1993a5c 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.c
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/delay.h>
@@ -16,7 +16,6 @@
 #include "cam_cpas_soc.h"
 #include "cpastop100.h"
 #include "cpastop_v150_100.h"
-#include "cpastop_v170_200.h"
 #include "cpastop_v170_110.h"
 #include "cpastop_v175_100.h"
 #include "cpastop_v175_101.h"
@@ -38,110 +37,6 @@ static const char * const camnoc_salve_err_code[] = {
 	"Unknown Error",             /* unknown err code */
 };
 
-static const uint32_t cam_cpas_hw_version_map
-	[CAM_CPAS_CAMERA_VERSION_ID_MAX][CAM_CPAS_VERSION_ID_MAX] = {
-	/* for camera_150 */
-	{
-		CAM_CPAS_TITAN_150_V100,
-		0,
-		0,
-		0,
-		0,
-		0,
-	},
-	/* for camera_170 */
-	{
-		CAM_CPAS_TITAN_170_V100,
-		0,
-		CAM_CPAS_TITAN_170_V110,
-		CAM_CPAS_TITAN_170_V120,
-		0,
-		CAM_CPAS_TITAN_170_V200,
-	},
-	/* for camera_175 */
-	{
-		CAM_CPAS_TITAN_175_V100,
-		CAM_CPAS_TITAN_175_V101,
-		0,
-		CAM_CPAS_TITAN_175_V120,
-		CAM_CPAS_TITAN_175_V130,
-		0,
-	},
-	/* for camera_480 */
-	{
-		CAM_CPAS_TITAN_480_V100,
-		0,
-		0,
-		0,
-		0,
-		0,
-	},
-};
-
-static int cam_cpas_translate_camera_cpas_version_id(
-	uint32_t cam_version,
-	uint32_t cpas_version,
-	uint32_t *cam_version_id,
-	uint32_t *cpas_version_id)
-{
-
-	switch (cam_version) {
-
-	case CAM_CPAS_CAMERA_VERSION_150:
-		*cam_version_id = CAM_CPAS_CAMERA_VERSION_ID_150;
-		break;
-
-	case CAM_CPAS_CAMERA_VERSION_170:
-		*cam_version_id = CAM_CPAS_CAMERA_VERSION_ID_170;
-		break;
-
-	case CAM_CPAS_CAMERA_VERSION_175:
-		*cam_version_id = CAM_CPAS_CAMERA_VERSION_ID_175;
-		break;
-
-	case CAM_CPAS_CAMERA_VERSION_480:
-		*cam_version_id = CAM_CPAS_CAMERA_VERSION_ID_480;
-		break;
-
-	default:
-		CAM_ERR(CAM_CPAS, "Invalid cam version %u",
-			cam_version);
-		return -EINVAL;
-	}
-
-	switch (cpas_version) {
-
-	case CAM_CPAS_VERSION_100:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_100;
-		break;
-
-	case CAM_CPAS_VERSION_101:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_101;
-		break;
-	case CAM_CPAS_VERSION_110:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_110;
-		break;
-
-	case CAM_CPAS_VERSION_120:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_120;
-		break;
-
-	case CAM_CPAS_VERSION_130:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_130;
-		break;
-
-	case CAM_CPAS_VERSION_200:
-		*cpas_version_id = CAM_CPAS_VERSION_ID_200;
-		break;
-
-	default:
-		CAM_ERR(CAM_CPAS, "Invalid cpas version %u",
-			cpas_version);
-		return -EINVAL;
-	}
-	return 0;
-}
-
 static int cam_cpastop_get_hw_info(struct cam_hw_info *cpas_hw,
 	struct cam_cpas_hw_caps *hw_caps)
 {
@@ -149,30 +44,27 @@ static int cam_cpastop_get_hw_info(struct cam_hw_info *cpas_hw,
 	struct cam_hw_soc_info *soc_info = &cpas_hw->soc_info;
 	int32_t reg_indx = cpas_core->regbase_index[CAM_CPAS_REG_CPASTOP];
 	uint32_t reg_value;
-	uint32_t cam_version, cpas_version;
-	uint32_t cam_version_id, cpas_version_id;
-	int rc;
 
 	if (reg_indx == -1)
 		return -EINVAL;
 
 	hw_caps->camera_family = CAM_FAMILY_CPAS_SS;
 
-	cam_version = cam_io_r_mb(soc_info->reg_map[reg_indx].mem_base + 0x0);
+	reg_value = cam_io_r_mb(soc_info->reg_map[reg_indx].mem_base + 0x0);
 	hw_caps->camera_version.major =
-		CAM_BITS_MASK_SHIFT(cam_version, 0xff0000, 0x10);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xff0000, 0x10);
 	hw_caps->camera_version.minor =
-		CAM_BITS_MASK_SHIFT(cam_version, 0xff00, 0x8);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xff00, 0x8);
 	hw_caps->camera_version.incr =
-		CAM_BITS_MASK_SHIFT(cam_version, 0xff, 0x0);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xff, 0x0);
 
-	cpas_version = cam_io_r_mb(soc_info->reg_map[reg_indx].mem_base + 0x4);
+	reg_value = cam_io_r_mb(soc_info->reg_map[reg_indx].mem_base + 0x4);
 	hw_caps->cpas_version.major =
-		CAM_BITS_MASK_SHIFT(cpas_version, 0xf0000000, 0x1c);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xf0000000, 0x1c);
 	hw_caps->cpas_version.minor =
-		CAM_BITS_MASK_SHIFT(cpas_version, 0xfff0000, 0x10);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xfff0000, 0x10);
 	hw_caps->cpas_version.incr =
-		CAM_BITS_MASK_SHIFT(cpas_version, 0xffff, 0x0);
+		CAM_BITS_MASK_SHIFT(reg_value, 0xffff, 0x0);
 
 	reg_value = cam_io_r_mb(soc_info->reg_map[reg_indx].mem_base + 0x8);
 	hw_caps->camera_capability = reg_value;
@@ -184,15 +76,53 @@ static int cam_cpastop_get_hw_info(struct cam_hw_info *cpas_hw,
 		hw_caps->cpas_version.incr, hw_caps->camera_capability);
 
 	soc_info->hw_version = CAM_CPAS_TITAN_NONE;
-	rc  = cam_cpas_translate_camera_cpas_version_id(cam_version,
-		cpas_version, &cam_version_id, &cpas_version_id);
-	if (rc) {
-		CAM_ERR(CAM_CPAS, "Invalid Version, Camera: 0x%x CPAS: 0x%x",
-			cam_version, cpas_version);
-		return -EINVAL;
+
+	if ((hw_caps->camera_version.major == 1) &&
+		(hw_caps->camera_version.minor == 7) &&
+		(hw_caps->camera_version.incr == 0)) {
+		if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 0) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_170_V100;
+		else if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 1) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_170_V110;
+		else if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 2) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_170_V120;
+	} else if ((hw_caps->camera_version.major == 1) &&
+		(hw_caps->camera_version.minor == 7) &&
+		(hw_caps->camera_version.incr == 5)) {
+		if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 0) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_175_V100;
+		else if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 0) &&
+			(hw_caps->cpas_version.incr == 1))
+			soc_info->hw_version = CAM_CPAS_TITAN_175_V101;
+		else if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 2) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_175_V120;
+		else if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 3) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_175_V130;
+	} else if ((hw_caps->camera_version.major == 1) &&
+		(hw_caps->camera_version.minor == 5) &&
+		(hw_caps->camera_version.incr == 0)) {
+		if ((hw_caps->cpas_version.major == 1) &&
+			(hw_caps->cpas_version.minor == 0) &&
+			(hw_caps->cpas_version.incr == 0))
+			soc_info->hw_version = CAM_CPAS_TITAN_150_V100;
+	} else if ((hw_caps->camera_version.major == 4) &&
+		(hw_caps->camera_version.minor == 8) &&
+		(hw_caps->camera_version.incr == 0)) {
+		soc_info->hw_version = CAM_CPAS_TITAN_480_V100;
 	}
-	soc_info->hw_version =
-		cam_cpas_hw_version_map[cam_version_id][cpas_version_id];
 
 	CAM_DBG(CAM_CPAS, "CPAS HW VERSION %x", soc_info->hw_version);
 
@@ -676,9 +606,6 @@ static int cam_cpastop_init_hw_version(struct cam_hw_info *cpas_hw,
 	case CAM_CPAS_TITAN_170_V110:
 		camnoc_info = &cam170_cpas110_camnoc_info;
 		break;
-	case CAM_CPAS_TITAN_170_V200:
-		camnoc_info = &cam170_cpas200_camnoc_info;
-		break;
 	case CAM_CPAS_TITAN_175_V100:
 		camnoc_info = &cam175_cpas100_camnoc_info;
 		break;
@@ -709,97 +636,6 @@ static int cam_cpastop_init_hw_version(struct cam_hw_info *cpas_hw,
 	return 0;
 }
 
-int cam_cpas_hw_get_camnoc_fill_level_info(
-	uint32_t cpas_version,
-	uint32_t client_handle)
-{
-	struct cam_camnoc_fifo_lvl_info *camnoc_reg_info;
-	uint32_t val;
-
-	if (!camnoc_info->fill_lvl_register)
-		return -EFAULT;
-
-	camnoc_reg_info = camnoc_info->fill_lvl_register;
-
-	switch (cpas_version) {
-	case CAM_CPAS_TITAN_175_V120:
-	case CAM_CPAS_TITAN_175_V130:
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC,
-			camnoc_reg_info->IFE0_nRDI_maxwr_offset,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "IFE0_nRDI_MAXWR_LOW offset 0x%x val 0x%x",
-			camnoc_reg_info->IFE0_nRDI_maxwr_offset,
-			val);
-
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC,
-			camnoc_reg_info->IFE1_nRDI_maxwr_offset,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "IFE1_nRDI_MAXWR_LOW offset 0x%x val 0x%x",
-			camnoc_reg_info->IFE1_nRDI_maxwr_offset,
-			val);
-
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC,
-			camnoc_reg_info->IFE0123_RDI_maxwr_offset,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "IFE0_nRDI_MAXWR_LOW offset 0x%x val 0x%x",
-			camnoc_reg_info->IFE0123_RDI_maxwr_offset,
-			val);
-		break;
-	case CAM_CPAS_TITAN_480_V100:
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC, camnoc_reg_info->ife_linear,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "ife_linear offset 0x%x val 0x%x",
-			camnoc_reg_info->ife_linear,
-			val);
-
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC, camnoc_reg_info->ife_rdi_wr,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "ife_rdi_wr offset 0x%x val 0x%x",
-			camnoc_reg_info->ife_rdi_wr,
-			val);
-
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC, camnoc_reg_info->ife_ubwc_stats,
-			true, &val);
-		CAM_INFO(CAM_CPAS, "ife_ubwc_stats offset 0x%x val 0x%x",
-			camnoc_reg_info->ife_ubwc_stats,
-			val);
-
-		break;
-	case CAM_CPAS_TITAN_150_V100:
-	case CAM_CPAS_TITAN_170_V100:
-	case CAM_CPAS_TITAN_170_V110:
-	case CAM_CPAS_TITAN_170_V120:
-	case CAM_CPAS_TITAN_170_V200:
-	case CAM_CPAS_TITAN_175_V100:
-	case CAM_CPAS_TITAN_175_V101:
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC, camnoc_reg_info->IFE02_MAXWR_LOW,
-			true, &val);
-		CAM_INFO(CAM_ISP, "IFE02_MAXWR_LOW offset 0x%x val 0x%x",
-			camnoc_reg_info->IFE02_MAXWR_LOW,
-			val);
-
-		cam_cpas_reg_read(client_handle,
-			CAM_CPAS_REG_CAMNOC, camnoc_reg_info->IFE13_MAXWR_LOW,
-			true, &val);
-		CAM_INFO(CAM_ISP, "IFE13_MAXWR_LOW offset 0x%x val 0x%x",
-			camnoc_reg_info->IFE13_MAXWR_LOW,
-			val);
-		break;
-	default:
-		CAM_ERR(CAM_CPAS, "Camera version not supported %d",
-			cpas_version);
-		break;
-	}
-	return 0;
-}
-
 int cam_cpastop_get_internal_ops(struct cam_cpas_internal_ops *internal_ops)
 {
 	if (!internal_ops) {
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.h b/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.h
index 627e29faaa1b..a4d44a3feff6 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cam_cpastop_hw.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CPASTOP_HW_H_
@@ -20,18 +20,12 @@
  * @CAM_CAMNOC_HW_IRQ_IFE_UBWC_STATS_ENCODE_ERROR: Triggered if any error
  *                                                 detected in the IFE UBWC-
  *                                                 Stats encoder instance
- * @CAM_CAMNOC_HW_IRQ_IFE01_UBWC_ENCODE_ERROR  : Triggered if any error
- *                                               detected in the IFE1 UBWC
- *                                               encoder instance
  * @CAM_CAMNOC_HW_IRQ_IFE02_UBWC_ENCODE_ERROR  : Triggered if any error
  *                                               detected in the IFE0 UBWC
  *                                               encoder instance
  * @CAM_CAMNOC_HW_IRQ_IFE13_UBWC_ENCODE_ERROR  : Triggered if any error
  *                                               detected in the IFE1 or IFE3
  *                                               UBWC encoder instance
- * @CAM_CAMNOC_HW_IRQ_IFE23_UBWC_ENCODE_ERROR  : Triggered if any error
- *                                               detected in the IFE2 or IFE3
- *                                               UBWC encoder instance
  * @CAM_CAMNOC_HW_IRQ_IPE1_BPS_UBWC_DECODE_ERROR: Triggered if any error
  *                                                detected in the IPE1/BPS read
  *                                                path decoder instance
@@ -60,14 +54,10 @@ enum cam_camnoc_hw_irq_type {
 		CAM_CAMNOC_IRQ_SLAVE_ERROR,
 	CAM_CAMNOC_HW_IRQ_IFE_UBWC_STATS_ENCODE_ERROR =
 		CAM_CAMNOC_IRQ_IFE_UBWC_STATS_ENCODE_ERROR,
-	CAM_CAMNOC_HW_IRQ_IFE01_UBWC_ENCODE_ERROR =
-		CAM_CAMNOC_IRQ_IFE01_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_HW_IRQ_IFE02_UBWC_ENCODE_ERROR =
 		CAM_CAMNOC_IRQ_IFE02_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_HW_IRQ_IFE13_UBWC_ENCODE_ERROR =
 		CAM_CAMNOC_IRQ_IFE13_UBWC_ENCODE_ERROR,
-	CAM_CAMNOC_HW_IRQ_IFE23_UBWC_ENCODE_ERROR =
-		CAM_CAMNOC_IRQ_IFE23_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_HW_IRQ_IFE0_UBWC_ENCODE_ERROR =
 		CAM_CAMNOC_IRQ_IFE0_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_HW_IRQ_IFE1_WRITE_UBWC_ENCODE_ERROR =
@@ -119,10 +109,8 @@ enum cam_camnoc_hw_irq_type {
  */
 enum cam_camnoc_port_type {
 	CAM_CAMNOC_CDM,
-	CAM_CAMNOC_IFE01,
 	CAM_CAMNOC_IFE02,
 	CAM_CAMNOC_IFE13,
-	CAM_CAMNOC_IFE23,
 	CAM_CAMNOC_IFE_LINEAR,
 	CAM_CAMNOC_IFE_UBWC_STATS,
 	CAM_CAMNOC_IFE_RDI_WR,
@@ -256,28 +244,6 @@ struct cam_camnoc_err_logger_info {
 	uint32_t errlog3_high;
 };
 
-/**
- * struct cam_camnoc_fifo_lvl_info : Struct for fifo fill level registers
- * @IFE0_nRDI_maxwr_offset: Register offset for fill level for IFE0
- * @IFE1_nRDI_maxwr_offset: Register offset for fill level for IFE1
- * @IFE0123_RDI_maxwr_low_offset: Register offset for RDI
- * @ife_linear: Register offset for ife linear
- * @ife_rdi_wr: Register offset for rdi wr
- * @ife_ubwc_stats: Register offset for ubwc stats
- * @IFE02_MAXWR_LOW: Register offset for IFE02
- * @IFE13_MAXWR_LOW: Register offset for IFE13
- */
-struct cam_camnoc_fifo_lvl_info {
-	uint32_t IFE0_nRDI_maxwr_offset;
-	uint32_t IFE1_nRDI_maxwr_offset;
-	uint32_t IFE0123_RDI_maxwr_offset;
-	uint32_t ife_linear;
-	uint32_t ife_rdi_wr;
-	uint32_t ife_ubwc_stats;
-	uint32_t IFE02_MAXWR_LOW;
-	uint32_t IFE13_MAXWR_LOW;
-};
-
 /**
  * struct cam_camnoc_info : Overall CAMNOC settings info
  *
@@ -288,7 +254,6 @@ struct cam_camnoc_fifo_lvl_info {
  * @irq_err_size: Array size of IRQ Error settings
  * @err_logger: Pointer to CAMNOC IRQ Error logger read registers
  * @errata_wa_list: HW Errata workaround info
- * @fill_level_register: Fill level registers
  *
  */
 struct cam_camnoc_info {
@@ -299,7 +264,6 @@ struct cam_camnoc_info {
 	int irq_err_size;
 	struct cam_camnoc_err_logger_info *err_logger;
 	struct cam_cpas_hw_errata_wa_list *errata_wa_list;
-	struct cam_camnoc_fifo_lvl_info *fill_lvl_register;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v150_100.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v150_100.h
index edad15043dda..df9711e74379 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v150_100.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v150_100.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V150_100_H_
@@ -515,11 +515,6 @@ static struct cam_cpas_hw_errata_wa_list cam150_cpas100_errata_wa_list = {
 	},
 };
 
-struct cam_camnoc_fifo_lvl_info cam150_cpas100_camnoc_fifo_info = {
-	.IFE02_MAXWR_LOW = 0x420,
-	.IFE13_MAXWR_LOW = 0x820,
-};
-
 static struct cam_camnoc_info cam150_cpas100_camnoc_info = {
 	.specific = &cam_cpas_v150_100_camnoc_specific[0],
 	.specific_size = sizeof(cam_cpas_v150_100_camnoc_specific) /
@@ -530,7 +525,6 @@ static struct cam_camnoc_info cam150_cpas100_camnoc_info = {
 		sizeof(cam_cpas_v150_100_irq_err[0]),
 	.err_logger = &cam150_cpas100_err_logger_offsets,
 	.errata_wa_list = &cam150_cpas100_errata_wa_list,
-	.fill_lvl_register = &cam150_cpas100_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V150_100_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v170_110.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v170_110.h
index fc986f598e33..788f571a3a13 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v170_110.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v170_110.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V170_110_H_
@@ -523,11 +523,6 @@ static struct cam_cpas_hw_errata_wa_list cam170_cpas110_errata_wa_list = {
 	},
 };
 
-struct cam_camnoc_fifo_lvl_info cam170_cpas110_camnoc_fifo_info = {
-	.IFE02_MAXWR_LOW = 0x420,
-	.IFE13_MAXWR_LOW = 0x820,
-};
-
 static struct cam_camnoc_info cam170_cpas110_camnoc_info = {
 	.specific = &cam_cpas110_camnoc_specific[0],
 	.specific_size = sizeof(cam_cpas110_camnoc_specific) /
@@ -538,7 +533,6 @@ static struct cam_camnoc_info cam170_cpas110_camnoc_info = {
 		sizeof(cam_cpas110_irq_err[0]),
 	.err_logger = &cam170_cpas110_err_logger_offsets,
 	.errata_wa_list = &cam170_cpas110_errata_wa_list,
-	.fill_lvl_register = &cam170_cpas110_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V170_110_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_100.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_100.h
index ab20db01cd18..aae26b5a9178 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_100.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_100.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V175_100_H_
@@ -543,11 +543,6 @@ static struct cam_cpas_hw_errata_wa_list cam175_cpas100_errata_wa_list = {
 	},
 };
 
-struct cam_camnoc_fifo_lvl_info cam175_cpas100_camnoc_fifo_info = {
-	.IFE02_MAXWR_LOW = 0x420,
-	.IFE13_MAXWR_LOW = 0x820,
-};
-
 static struct cam_camnoc_info cam175_cpas100_camnoc_info = {
 	.specific = &cam_cpas_v175_100_camnoc_specific[0],
 	.specific_size = sizeof(cam_cpas_v175_100_camnoc_specific) /
@@ -558,7 +553,6 @@ static struct cam_camnoc_info cam175_cpas100_camnoc_info = {
 		sizeof(cam_cpas_v175_100_irq_err[0]),
 	.err_logger = &cam175_cpas100_err_logger_offsets,
 	.errata_wa_list = &cam175_cpas100_errata_wa_list,
-	.fill_lvl_register = &cam175_cpas100_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V175_100_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_101.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_101.h
index 12ed226008e6..7ec9bec36fd1 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_101.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_101.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V175_101_H_
@@ -543,11 +543,6 @@ static struct cam_cpas_hw_errata_wa_list cam175_cpas101_errata_wa_list = {
 	},
 };
 
-struct cam_camnoc_fifo_lvl_info cam175_cpas101_camnoc_fifo_info = {
-	.IFE02_MAXWR_LOW = 0x420,
-	.IFE13_MAXWR_LOW = 0x820,
-};
-
 static struct cam_camnoc_info cam175_cpas101_camnoc_info = {
 	.specific = &cam_cpas_v175_101_camnoc_specific[0],
 	.specific_size = sizeof(cam_cpas_v175_101_camnoc_specific) /
@@ -558,7 +553,6 @@ static struct cam_camnoc_info cam175_cpas101_camnoc_info = {
 		sizeof(cam_cpas_v175_101_irq_err[0]),
 	.err_logger = &cam175_cpas101_err_logger_offsets,
 	.errata_wa_list = &cam175_cpas101_errata_wa_list,
-	.fill_lvl_register = &cam175_cpas101_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V175_101_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_120.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_120.h
index 83e5fb415472..5844c38ae52c 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_120.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_120.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V175_120_H_
@@ -747,12 +747,6 @@ static struct cam_cpas_hw_errata_wa_list cam175_cpas120_errata_wa_list = {
 	},
 };
 
-static struct cam_camnoc_fifo_lvl_info cam175_cpas120_camnoc_fifo_info = {
-	.IFE0_nRDI_maxwr_offset = 0x3A20,
-	.IFE1_nRDI_maxwr_offset = 0x5420,
-	.IFE0123_RDI_maxwr_offset = 0x3620,
-};
-
 static struct cam_camnoc_info cam175_cpas120_camnoc_info = {
 	.specific = &cam_cpas_v175_120_camnoc_specific[0],
 	.specific_size =  ARRAY_SIZE(cam_cpas_v175_120_camnoc_specific),
@@ -761,7 +755,6 @@ static struct cam_camnoc_info cam175_cpas120_camnoc_info = {
 	.irq_err_size = ARRAY_SIZE(cam_cpas_v175_120_irq_err),
 	.err_logger = &cam175_cpas120_err_logger_offsets,
 	.errata_wa_list = &cam175_cpas120_errata_wa_list,
-	.fill_lvl_register = &cam175_cpas120_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V175_120_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_130.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_130.h
index f7acca0f039f..769e77fc3d6b 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_130.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v175_130.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V175_130_H_
@@ -760,12 +760,6 @@ static struct cam_cpas_hw_errata_wa_list cam175_cpas130_errata_wa_list = {
 	},
 };
 
-static struct cam_camnoc_fifo_lvl_info cam175_cpas130_camnoc_fifo_info = {
-	.IFE0_nRDI_maxwr_offset = 0x3A20,
-	.IFE1_nRDI_maxwr_offset = 0x5420,
-	.IFE0123_RDI_maxwr_offset = 0x3620,
-};
-
 static struct cam_camnoc_info cam175_cpas130_camnoc_info = {
 	.specific = &cam_cpas_v175_130_camnoc_specific[0],
 	.specific_size =  ARRAY_SIZE(cam_cpas_v175_130_camnoc_specific),
@@ -774,7 +768,6 @@ static struct cam_camnoc_info cam175_cpas130_camnoc_info = {
 	.irq_err_size = ARRAY_SIZE(cam_cpas_v175_130_irq_err),
 	.err_logger = &cam175_cpas130_err_logger_offsets,
 	.errata_wa_list = &cam175_cpas130_errata_wa_list,
-	.fill_lvl_register = &cam175_cpas130_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V175_130_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v480_100.h b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v480_100.h
index 49b1e8fb63a1..0d46e0ddcc20 100644
--- a/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v480_100.h
+++ b/techpack/camera/drivers/cam_cpas/cpas_top/cpastop_v480_100.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CPASTOP_V480_100_H_
@@ -698,12 +698,6 @@ static struct cam_cpas_hw_errata_wa_list cam480_cpas100_errata_wa_list = {
 	},
 };
 
-struct cam_camnoc_fifo_lvl_info cam480_cpas100_camnoc_fifo_info = {
-	.ife_linear = 0xA20,
-	.ife_rdi_wr = 0x1420,
-	.ife_ubwc_stats = 0x1A20,
-};
-
 static struct cam_camnoc_info cam480_cpas100_camnoc_info = {
 	.specific = &cam_cpas_v480_100_camnoc_specific[0],
 	.specific_size = ARRAY_SIZE(cam_cpas_v480_100_camnoc_specific),
@@ -712,7 +706,6 @@ static struct cam_camnoc_info cam480_cpas100_camnoc_info = {
 	.irq_err_size = ARRAY_SIZE(cam_cpas_v480_100_irq_err),
 	.err_logger = &cam480_cpas100_err_logger_offsets,
 	.errata_wa_list = &cam480_cpas100_errata_wa_list,
-	.fill_lvl_register = &cam480_cpas100_camnoc_fifo_info,
 };
 
 #endif /* _CPASTOP_V480_100_H_ */
diff --git a/techpack/camera/drivers/cam_cpas/include/cam_cpas_api.h b/techpack/camera/drivers/cam_cpas/include/cam_cpas_api.h
index 9256d9624768..7c551dfcf8a5 100644
--- a/techpack/camera/drivers/cam_cpas/include/cam_cpas_api.h
+++ b/techpack/camera/drivers/cam_cpas/include/cam_cpas_api.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CPAS_API_H_
@@ -32,58 +32,6 @@ enum cam_cpas_reg_base {
 	CAM_CPAS_REG_MAX
 };
 
-/**
- * enum cam_cpas_camera_version Enum for Titan Camera Versions
- */
-enum cam_cpas_camera_version {
-	CAM_CPAS_CAMERA_VERSION_NONE = 0,
-	CAM_CPAS_CAMERA_VERSION_150  = 0x00010500,
-	CAM_CPAS_CAMERA_VERSION_170  = 0x00010700,
-	CAM_CPAS_CAMERA_VERSION_175  = 0x00010705,
-	CAM_CPAS_CAMERA_VERSION_480  = 0x00040800,
-	CAM_CPAS_CAMERA_VERSION_MAX
-};
-
-/**
- * enum cam_cpas_version Enum for Titan CPAS Versions
- */
-enum cam_cpas_version {
-	CAM_CPAS_VERSION_NONE = 0,
-	CAM_CPAS_VERSION_100  = 0x10000000,
-	CAM_CPAS_VERSION_101  = 0x10000001,
-	CAM_CPAS_VERSION_110  = 0x10010000,
-	CAM_CPAS_VERSION_120  = 0x10020000,
-	CAM_CPAS_VERSION_130  = 0x10030000,
-	CAM_CPAS_VERSION_200  = 0x20000000,
-	CAM_CPAS_VERSION_MAX
-};
-
-/**
- * enum cam_cpas_camera_version_map_id Enum for camera version map id
- * This enum is mapped with cam_cpas_camera_version
- */
-enum cam_cpas_camera_version_map_id {
-	CAM_CPAS_CAMERA_VERSION_ID_150  = 0x0,
-	CAM_CPAS_CAMERA_VERSION_ID_170  = 0x1,
-	CAM_CPAS_CAMERA_VERSION_ID_175  = 0x2,
-	CAM_CPAS_CAMERA_VERSION_ID_480  = 0x3,
-	CAM_CPAS_CAMERA_VERSION_ID_MAX
-};
-
-/**
- * enum cam_cpas_version_map_id Enum for cpas version map id
- * This enum is mapped with cam_cpas_version
- */
-enum cam_cpas_version_map_id {
-	CAM_CPAS_VERSION_ID_100  = 0x0,
-	CAM_CPAS_VERSION_ID_101  = 0x1,
-	CAM_CPAS_VERSION_ID_110  = 0x2,
-	CAM_CPAS_VERSION_ID_120  = 0x3,
-	CAM_CPAS_VERSION_ID_130  = 0x4,
-	CAM_CPAS_VERSION_ID_200  = 0x5,
-	CAM_CPAS_VERSION_ID_MAX
-};
-
 /**
  * enum cam_cpas_hw_version - Enum for Titan CPAS HW Versions
  */
@@ -93,7 +41,6 @@ enum cam_cpas_hw_version {
 	CAM_CPAS_TITAN_170_V100 = 0x170100,
 	CAM_CPAS_TITAN_170_V110 = 0x170110,
 	CAM_CPAS_TITAN_170_V120 = 0x170120,
-	CAM_CPAS_TITAN_170_V200 = 0x170200,
 	CAM_CPAS_TITAN_175_V100 = 0x175100,
 	CAM_CPAS_TITAN_175_V101 = 0x175101,
 	CAM_CPAS_TITAN_175_V120 = 0x175120,
@@ -113,16 +60,11 @@ enum cam_cpas_hw_version {
  * @CAM_CAMNOC_IRQ_IFE_UBWC_STATS_ENCODE_ERROR: Triggered if any error detected
  *                                              in the IFE UBWC-Stats encoder
  *                                              instance
- * @CAM_CAMNOC_IRQ_IFE01_UBWC_ENCODE_ERROR  : Triggered if any error detected
- *                                            in the IFE1 UBWC encoder instance
  * @CAM_CAMNOC_IRQ_IFE02_UBWC_ENCODE_ERROR  : Triggered if any error detected
  *                                            in the IFE0 UBWC encoder instance
  * @CAM_CAMNOC_IRQ_IFE13_UBWC_ENCODE_ERROR  : Triggered if any error detected
  *                                            in the IFE1 or IFE3 UBWC encoder
  *                                            instance
- * @CAM_CAMNOC_IRQ_IFE23_UBWC_ENCODE_ERROR  : Triggered if any error detected
- *                                            in the IFE2 or IFE3 UBWC encoder
- *                                            instance
  * @CAM_CAMNOC_IRQ_IFE0_UBWC_ENCODE_ERROR   : Triggered if any error detected
  *                                            in the IFE0 UBWC encoder instance
  * @CAM_CAMNOC_IRQ_IFE1_WR_UBWC_ENCODE_ERROR  : Triggered if any error detected
@@ -146,10 +88,8 @@ enum cam_cpas_hw_version {
 enum cam_camnoc_irq_type {
 	CAM_CAMNOC_IRQ_SLAVE_ERROR,
 	CAM_CAMNOC_IRQ_IFE_UBWC_STATS_ENCODE_ERROR,
-	CAM_CAMNOC_IRQ_IFE01_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_IRQ_IFE02_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_IRQ_IFE13_UBWC_ENCODE_ERROR,
-	CAM_CAMNOC_IRQ_IFE23_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_IRQ_IFE0_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_IRQ_IFE1_WRITE_UBWC_ENCODE_ERROR,
 	CAM_CAMNOC_IRQ_IPE1_BPS_UBWC_DECODE_ERROR,
@@ -585,21 +525,6 @@ int cam_cpas_get_hw_info(
 int cam_cpas_get_cpas_hw_version(
 	uint32_t				 *hw_version);
 
-/**
- * cam_cpas_get_camnoc_fifo_fill_level_info()
- *
- * @brief: API to get camera camnoc hw version
- *
- * @cpas_version: hw version
- * @client_handle: cpas client handle
- *
- * @return 0 on success.
- *
- */
-int cam_cpas_get_camnoc_fifo_fill_level_info(
-	uint32_t                               cpas_version,
-	uint32_t                               client_handle);
-
 /**
  * cam_cpas_is_feature_supported()
  *
@@ -639,30 +564,5 @@ const char *cam_cpas_axi_util_path_type_to_string(
 const char *cam_cpas_axi_util_trans_type_to_string(
 	uint32_t path_data_type);
 
-/**
- * cam_cpas_log_votes()
- *
- * @brief: API to print the all bw votes of axi client. It also print the
- *     applied camnoc axi clock vote value and ahb vote value
- *
- * @return 0 on success.
- *
- */
-void cam_cpas_log_votes(void);
-
-/**
- * cam_cpas_hw_get_camnoc_fill_level_info()
- *
- * @brief: API to get camnoc info
- *
- * @cpas_version: cpas hw version
- * @client_handle: cpas client handle
- *
- * @return 0 on success.
- *
- */
-int cam_cpas_hw_get_camnoc_fill_level_info(
-	uint32_t cpas_version,
-	uint32_t client_handle);
 
 #endif /* _CAM_CPAS_API_H_ */
diff --git a/techpack/camera/drivers/cam_cust/cam_custom_context.c b/techpack/camera/drivers/cam_cust/cam_custom_context.c
index 25e092841cef..7f38392a7d57 100644
--- a/techpack/camera/drivers/cam_cust/cam_custom_context.c
+++ b/techpack/camera/drivers/cam_cust/cam_custom_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/debugfs.h>
@@ -19,15 +19,11 @@
 #include "cam_custom_context.h"
 #include "cam_common_util.h"
 
-static const char custom_dev_name[] = "cam-custom";
+static const char custom_dev_name[] = "custom hw";
 
 static int __cam_custom_ctx_handle_irq_in_activated(
 	void *context, uint32_t evt_id, void *evt_data);
 
-static int __cam_custom_ctx_start_dev_in_ready(
-	struct cam_context *ctx, struct cam_start_stop_dev_cmd *cmd);
-
-
 static int __cam_custom_ctx_enqueue_request_in_order(
 	struct cam_context *ctx, struct cam_ctx_request *req)
 {
@@ -135,104 +131,22 @@ static int __cam_custom_ctx_flush_req(struct cam_context *ctx,
 	return 0;
 }
 
-static int __cam_custom_ctx_unlink_in_acquired(struct cam_context *ctx,
-	struct cam_req_mgr_core_dev_link_setup *unlink)
-{
-	ctx->link_hdl = -1;
-	ctx->ctx_crm_intf = NULL;
-
-	return 0;
-}
-
-static int __cam_custom_ctx_unlink_in_ready(struct cam_context *ctx,
-	struct cam_req_mgr_core_dev_link_setup *unlink)
-{
-	ctx->link_hdl = -1;
-	ctx->ctx_crm_intf = NULL;
-	ctx->state = CAM_CTX_ACQUIRED;
-
-	return 0;
-}
-
-static int __cam_custom_ctx_get_dev_info_in_acquired(struct cam_context *ctx,
-	struct cam_req_mgr_device_info *dev_info)
-{
-	dev_info->dev_hdl = ctx->dev_hdl;
-	strlcpy(dev_info->name, CAM_CUSTOM_DEV_NAME, sizeof(dev_info->name));
-	dev_info->dev_id = CAM_REQ_MGR_DEVICE_CUSTOM_HW;
-	dev_info->p_delay = 1;
-	dev_info->trigger = CAM_TRIGGER_POINT_SOF;
-
-	return 0;
-}
-
 static int __cam_custom_ctx_flush_req_in_top_state(
 	struct cam_context *ctx,
 	struct cam_req_mgr_flush_request *flush_req)
 {
 	int rc = 0;
-	struct cam_custom_context      *custom_ctx;
-	struct cam_hw_reset_args        reset_args;
-	struct cam_hw_stop_args         stop_args;
-	struct cam_custom_stop_args     custom_stop;
-
-	custom_ctx =
-		(struct cam_custom_context *) ctx->ctx_priv;
-
-	CAM_DBG(CAM_CUSTOM, "Flushing pending list");
-	spin_lock_bh(&ctx->lock);
-	__cam_custom_ctx_flush_req(ctx, &ctx->pending_req_list, flush_req);
-	spin_unlock_bh(&ctx->lock);
 
 	if (flush_req->type == CAM_REQ_MGR_FLUSH_TYPE_ALL) {
-		if (ctx->state <= CAM_CTX_READY) {
-			ctx->state = CAM_CTX_ACQUIRED;
-			goto end;
-		}
-
-		spin_lock_bh(&ctx->lock);
-		ctx->state = CAM_CTX_FLUSHED;
-		spin_unlock_bh(&ctx->lock);
-
 		CAM_INFO(CAM_CUSTOM, "Last request id to flush is %lld",
 			flush_req->req_id);
 		ctx->last_flush_req = flush_req->req_id;
-
-		/* stop hw first */
-		if (ctx->hw_mgr_intf->hw_stop) {
-			custom_stop.stop_only = true;
-			stop_args.ctxt_to_hw_map = ctx->ctxt_to_hw_map;
-			stop_args.args = (void *) &custom_stop;
-			rc = ctx->hw_mgr_intf->hw_stop(
-				ctx->hw_mgr_intf->hw_mgr_priv, &stop_args);
-			if (rc)
-				CAM_ERR(CAM_CUSTOM,
-					"HW stop failed in flush rc %d", rc);
-		}
-
-		spin_lock_bh(&ctx->lock);
-		if (!list_empty(&ctx->wait_req_list))
-			__cam_custom_ctx_flush_req(ctx, &ctx->wait_req_list,
-			flush_req);
-
-		if (!list_empty(&ctx->active_req_list))
-			__cam_custom_ctx_flush_req(ctx, &ctx->active_req_list,
-			flush_req);
-
-		custom_ctx->active_req_cnt = 0;
-		spin_unlock_bh(&ctx->lock);
-
-		reset_args.ctxt_to_hw_map = custom_ctx->hw_ctx;
-		rc = ctx->hw_mgr_intf->hw_reset(ctx->hw_mgr_intf->hw_mgr_priv,
-			&reset_args);
-		if (rc)
-			CAM_ERR(CAM_CUSTOM,
-				"Reset HW failed in flush rc %d", rc);
-
-		custom_ctx->init_received = false;
 	}
 
-end:
+	spin_lock_bh(&ctx->lock);
+	rc = __cam_custom_ctx_flush_req(ctx, &ctx->pending_req_list, flush_req);
+	spin_unlock_bh(&ctx->lock);
+
 	return rc;
 }
 
@@ -256,27 +170,34 @@ static int __cam_custom_ctx_flush_req_in_ready(
 	return rc;
 }
 
+static int __cam_custom_ctx_unlink_in_ready(struct cam_context *ctx,
+	struct cam_req_mgr_core_dev_link_setup *unlink)
+{
+	ctx->link_hdl = -1;
+	ctx->ctx_crm_intf = NULL;
+	ctx->state = CAM_CTX_ACQUIRED;
+
+	return 0;
+}
+
 static int __cam_custom_stop_dev_core(
 	struct cam_context *ctx, struct cam_start_stop_dev_cmd *stop_cmd)
 {
 	int rc = 0;
 	uint32_t i;
 	struct cam_custom_context          *ctx_custom =
-		(struct cam_custom_context *)   ctx->ctx_priv;
-	struct cam_ctx_request             *req;
-	struct cam_custom_dev_ctx_req      *req_custom;
-	struct cam_hw_stop_args             stop;
-	struct cam_custom_stop_args         custom_stop;
-
-	if ((ctx->state != CAM_CTX_FLUSHED) && (ctx_custom->hw_ctx) &&
-		(ctx->hw_mgr_intf->hw_stop)) {
-		custom_stop.stop_only = false;
+		(struct cam_custom_context *) ctx->ctx_priv;
+	struct cam_ctx_request          *req;
+	struct cam_custom_dev_ctx_req       *req_custom;
+	struct cam_hw_stop_args          stop;
+
+	if (ctx_custom->hw_ctx) {
 		stop.ctxt_to_hw_map = ctx_custom->hw_ctx;
-		stop.args = (void *) &custom_stop;
-		rc = ctx->hw_mgr_intf->hw_stop(ctx->hw_mgr_intf->hw_mgr_priv,
+
+		stop.args = NULL;
+		if (ctx->hw_mgr_intf->hw_stop)
+			ctx->hw_mgr_intf->hw_stop(ctx->hw_mgr_intf->hw_mgr_priv,
 			&stop);
-		if (rc)
-			CAM_ERR(CAM_CUSTOM, "HW stop failed rc %d", rc);
 	}
 
 	while (!list_empty(&ctx->pending_req_list)) {
@@ -354,67 +275,6 @@ static int __cam_custom_stop_dev_in_activated(struct cam_context *ctx,
 	return 0;
 }
 
-static int __cam_custom_ctx_release_hw_in_top_state(
-	struct cam_context *ctx, void *cmd)
-{
-	int rc = 0;
-	struct cam_hw_release_args        rel_arg;
-	struct cam_req_mgr_flush_request  flush_req;
-	struct cam_custom_context        *custom_ctx =
-		(struct cam_custom_context *) ctx->ctx_priv;
-
-	if (custom_ctx->hw_ctx) {
-		rel_arg.ctxt_to_hw_map = custom_ctx->hw_ctx;
-		rc = ctx->hw_mgr_intf->hw_release(ctx->hw_mgr_intf->hw_mgr_priv,
-			&rel_arg);
-		custom_ctx->hw_ctx = NULL;
-		if (rc)
-			CAM_ERR(CAM_CUSTOM,
-				"Failed to release HW for ctx:%u", ctx->ctx_id);
-	} else {
-		CAM_ERR(CAM_CUSTOM, "No HW resources acquired for this ctx");
-	}
-
-	ctx->last_flush_req = 0;
-	custom_ctx->frame_id = 0;
-	custom_ctx->active_req_cnt = 0;
-	custom_ctx->hw_acquired = false;
-	custom_ctx->init_received = false;
-
-	/* check for active requests as well */
-	flush_req.type = CAM_REQ_MGR_FLUSH_TYPE_ALL;
-	flush_req.link_hdl = ctx->link_hdl;
-	flush_req.dev_hdl = ctx->dev_hdl;
-
-	CAM_DBG(CAM_CUSTOM, "try to flush pending list");
-	spin_lock_bh(&ctx->lock);
-	rc = __cam_custom_ctx_flush_req(ctx, &ctx->pending_req_list,
-		&flush_req);
-	spin_unlock_bh(&ctx->lock);
-	ctx->state = CAM_CTX_ACQUIRED;
-
-	CAM_DBG(CAM_CUSTOM, "Release HW success[%u] next state %d",
-		ctx->ctx_id, ctx->state);
-
-	return rc;
-}
-
-static int __cam_custom_ctx_release_hw_in_activated_state(
-	struct cam_context *ctx, void *cmd)
-{
-	int rc = 0;
-
-	rc = __cam_custom_stop_dev_in_activated(ctx, NULL);
-	if (rc)
-		CAM_ERR(CAM_CUSTOM, "Stop device failed rc=%d", rc);
-
-	rc = __cam_custom_ctx_release_hw_in_top_state(ctx, cmd);
-	if (rc)
-		CAM_ERR(CAM_CUSTOM, "Release hw failed rc=%d", rc);
-
-	return rc;
-}
-
 static int __cam_custom_release_dev_in_acquired(struct cam_context *ctx,
 	struct cam_release_dev_cmd *cmd)
 {
@@ -423,16 +283,14 @@ static int __cam_custom_release_dev_in_acquired(struct cam_context *ctx,
 		(struct cam_custom_context *) ctx->ctx_priv;
 	struct cam_req_mgr_flush_request flush_req;
 
-	if (cmd && ctx_custom->hw_ctx) {
-		CAM_ERR(CAM_CUSTOM, "releasing hw");
-		__cam_custom_ctx_release_hw_in_top_state(ctx, NULL);
-	}
+	rc = cam_context_release_dev_to_hw(ctx, cmd);
+	if (rc)
+		CAM_ERR(CAM_CUSTOM, "Unable to release device");
 
 	ctx->ctx_crm_intf = NULL;
 	ctx->last_flush_req = 0;
 	ctx_custom->frame_id = 0;
 	ctx_custom->active_req_cnt = 0;
-	ctx_custom->hw_acquired = false;
 	ctx_custom->init_received = false;
 
 	if (!list_empty(&ctx->active_req_list))
@@ -523,128 +381,33 @@ static int __cam_custom_ctx_apply_req_in_activated_state(
 	return rc;
 }
 
-static int __cam_custom_ctx_acquire_hw_v1(
-	struct cam_context *ctx, void *args)
+static int __cam_custom_ctx_acquire_dev_in_available(struct cam_context *ctx,
+	struct cam_acquire_dev_cmd *cmd)
 {
-	int rc = 0;
-	struct cam_acquire_hw_cmd_v1 *cmd =
-		(struct cam_acquire_hw_cmd_v1 *)args;
-	struct cam_hw_acquire_args         param;
-	struct cam_custom_context         *ctx_custom =
-		(struct cam_custom_context *)  ctx->ctx_priv;
-	struct cam_custom_acquire_hw_info *acquire_hw_info = NULL;
-
-	if (!ctx->hw_mgr_intf) {
-		CAM_ERR(CAM_CUSTOM, "HW interface is not ready");
-		rc = -EFAULT;
-		goto end;
-	}
-
-	CAM_DBG(CAM_CUSTOM,
-		"session_hdl 0x%x, hdl type %d, res %lld",
-		cmd->session_handle, cmd->handle_type, cmd->resource_hdl);
-
-	if (cmd->handle_type != 1)  {
-		CAM_ERR(CAM_CUSTOM, "Only user pointer is supported");
-		rc = -EINVAL;
-		goto end;
-	}
+	int rc;
+	struct cam_custom_context *custom_ctx;
 
-	if (cmd->data_size < sizeof(*acquire_hw_info)) {
-		CAM_ERR(CAM_CUSTOM, "data_size is not a valid value");
-		goto end;
-	}
+	custom_ctx = (struct cam_custom_context *) ctx->ctx_priv;
 
-	acquire_hw_info = kzalloc(cmd->data_size, GFP_KERNEL);
-	if (!acquire_hw_info) {
+	if (cmd->num_resources > CAM_CUSTOM_DEV_CTX_RES_MAX) {
+		CAM_ERR(CAM_CUSTOM, "Too much resources in the acquire");
 		rc = -ENOMEM;
-		goto end;
-	}
-
-	CAM_DBG(CAM_CUSTOM, "start copy resources from user");
-
-	if (copy_from_user(acquire_hw_info, (void __user *)cmd->resource_hdl,
-		cmd->data_size)) {
-		rc = -EFAULT;
-		goto free_res;
-	}
-
-	memset(&param, 0, sizeof(param));
-	param.context_data = ctx;
-	param.event_cb = ctx->irq_cb_intf;
-	param.acquire_info_size = cmd->data_size;
-	param.acquire_info = (uint64_t) acquire_hw_info;
-
-	/* call HW manager to reserve the resource */
-	rc = ctx->hw_mgr_intf->hw_acquire(ctx->hw_mgr_intf->hw_mgr_priv,
-		&param);
-	if (rc != 0) {
-		CAM_ERR(CAM_CUSTOM, "Acquire HW failed");
-		goto free_res;
-	}
-
-	ctx_custom->hw_ctx = param.ctxt_to_hw_map;
-	ctx_custom->hw_acquired = true;
-	ctx->ctxt_to_hw_map = param.ctxt_to_hw_map;
-
-	CAM_DBG(CAM_CUSTOM,
-		"Acquire HW success on session_hdl 0x%xs for ctx_id %u",
-		ctx->session_hdl, ctx->ctx_id);
-
-	kfree(acquire_hw_info);
-	return rc;
-
-free_res:
-	kfree(acquire_hw_info);
-end:
-	return rc;
-}
-
-static int __cam_custom_ctx_acquire_dev_in_available(
-	struct cam_context *ctx, struct cam_acquire_dev_cmd *cmd)
-{
-	int rc = 0;
-	struct cam_create_dev_hdl  req_hdl_param;
-
-	if (!ctx->hw_mgr_intf) {
-		CAM_ERR(CAM_CUSTOM, "HW interface is not ready");
-		rc = -EFAULT;
 		return rc;
 	}
 
-	CAM_DBG(CAM_CUSTOM,
-		"session_hdl 0x%x, num_resources %d, hdl type %d, res %lld",
-		cmd->session_handle, cmd->num_resources,
-		cmd->handle_type, cmd->resource_hdl);
-
-	if (cmd->num_resources != CAM_API_COMPAT_CONSTANT) {
-		CAM_ERR(CAM_CUSTOM, "Invalid num_resources 0x%x",
-			cmd->num_resources);
-		return -EINVAL;
-	}
-
-	req_hdl_param.session_hdl = cmd->session_handle;
-	req_hdl_param.v4l2_sub_dev_flag = 0;
-	req_hdl_param.media_entity_flag = 0;
-	req_hdl_param.ops = ctx->crm_ctx_intf;
-	req_hdl_param.priv = ctx;
-
-	CAM_DBG(CAM_CUSTOM, "get device handle from bridge");
-	ctx->dev_hdl = cam_create_device_hdl(&req_hdl_param);
-	if (ctx->dev_hdl <= 0) {
-		rc = -EFAULT;
-		CAM_ERR(CAM_CUSTOM, "Can not create device handle");
+	if (cmd->handle_type != 1)	{
+		CAM_ERR(CAM_CUSTOM, "Only user pointer is supported");
+		rc = -EINVAL;
 		return rc;
 	}
 
-	cmd->dev_handle = ctx->dev_hdl;
-	ctx->session_hdl = cmd->session_handle;
-	ctx->state = CAM_CTX_ACQUIRED;
-
-	CAM_DBG(CAM_CUSTOM,
-		"Acquire dev success on session_hdl 0x%x for ctx %u",
-		cmd->session_handle, ctx->ctx_id);
+	rc = cam_context_acquire_dev_to_hw(ctx, cmd);
+	if (!rc) {
+		ctx->state = CAM_CTX_ACQUIRED;
+		custom_ctx->hw_ctx = ctx->ctxt_to_hw_map;
+	}
 
+	CAM_DBG(CAM_CUSTOM, "Acquire done %d", ctx->ctx_id);
 	return rc;
 }
 
@@ -831,9 +594,7 @@ static int __cam_custom_ctx_config_dev(struct cam_context *ctx,
 			CAM_ERR(CAM_CUSTOM, "Recevied INIT pkt in wrong state");
 		}
 	} else {
-		if ((ctx->state != CAM_CTX_FLUSHED) &&
-			(ctx->state >= CAM_CTX_READY) &&
-			(ctx->ctx_crm_intf->add_req)) {
+		if (ctx->state >= CAM_CTX_READY && ctx->ctx_crm_intf->add_req) {
 			add_req.link_hdl = ctx->link_hdl;
 			add_req.dev_hdl  = ctx->dev_hdl;
 			add_req.req_id   = req->request_id;
@@ -877,55 +638,10 @@ static int __cam_custom_ctx_config_dev(struct cam_context *ctx,
 
 }
 
-static int __cam_custom_ctx_config_dev_in_flushed(struct cam_context *ctx,
-	struct cam_config_dev_cmd *cmd)
-{
-	int rc = 0;
-	struct cam_start_stop_dev_cmd start_cmd;
-	struct cam_custom_context *custom_ctx =
-		(struct cam_custom_context *) ctx->ctx_priv;
-
-	if (!custom_ctx->hw_acquired) {
-		CAM_ERR(CAM_CUSTOM, "HW is not acquired, reject packet");
-		rc = -EINVAL;
-		goto end;
-	}
-
-	rc = __cam_custom_ctx_config_dev(ctx, cmd);
-	if (rc)
-		goto end;
-
-	if (!custom_ctx->init_received) {
-		CAM_WARN(CAM_CUSTOM,
-			"Received update packet in flushed state, skip start");
-		goto end;
-	}
-
-	start_cmd.dev_handle = cmd->dev_handle;
-	start_cmd.session_handle = cmd->session_handle;
-	rc = __cam_custom_ctx_start_dev_in_ready(ctx, &start_cmd);
-	if (rc)
-		CAM_ERR(CAM_CUSTOM,
-			"Failed to re-start HW after flush rc: %d", rc);
-	else
-		CAM_INFO(CAM_CUSTOM,
-			"Received init after flush. Re-start HW complete.");
-
-end:
-	return rc;
-}
-
 static int __cam_custom_ctx_config_dev_in_acquired(struct cam_context *ctx,
 	struct cam_config_dev_cmd *cmd)
 {
 	int rc = 0;
-	struct cam_custom_context        *ctx_custom =
-		(struct cam_custom_context *) ctx->ctx_priv;
-
-	if (!ctx_custom->hw_acquired) {
-		CAM_ERR(CAM_CUSTOM, "HW not acquired, reject config packet");
-		return -EAGAIN;
-	}
 
 	rc = __cam_custom_ctx_config_dev(ctx, cmd);
 
@@ -954,11 +670,32 @@ static int __cam_custom_ctx_link_in_acquired(struct cam_context *ctx,
 	return 0;
 }
 
+static int __cam_custom_ctx_unlink_in_acquired(struct cam_context *ctx,
+	struct cam_req_mgr_core_dev_link_setup *unlink)
+{
+	ctx->link_hdl = -1;
+	ctx->ctx_crm_intf = NULL;
+
+	return 0;
+}
+
+static int __cam_custom_ctx_get_dev_info_in_acquired(struct cam_context *ctx,
+	struct cam_req_mgr_device_info *dev_info)
+{
+	dev_info->dev_hdl = ctx->dev_hdl;
+	strlcpy(dev_info->name, CAM_CUSTOM_DEV_NAME, sizeof(dev_info->name));
+	dev_info->dev_id = CAM_REQ_MGR_DEVICE_CUSTOM_HW;
+	dev_info->p_delay = 1;
+	dev_info->trigger = CAM_TRIGGER_POINT_SOF;
+
+	return 0;
+}
+
 static int __cam_custom_ctx_start_dev_in_ready(struct cam_context *ctx,
 	struct cam_start_stop_dev_cmd *cmd)
 {
 	int rc = 0;
-	struct cam_custom_start_args     custom_start;
+	struct cam_hw_config_args        hw_config;
 	struct cam_ctx_request          *req;
 	struct cam_custom_dev_ctx_req   *req_custom;
 	struct cam_custom_context       *ctx_custom =
@@ -987,20 +724,16 @@ static int __cam_custom_ctx_start_dev_in_ready(struct cam_context *ctx,
 		goto end;
 	}
 
-	custom_start.hw_config.ctxt_to_hw_map = ctx_custom->hw_ctx;
-	custom_start.hw_config.request_id = req->request_id;
-	custom_start.hw_config.hw_update_entries = req_custom->cfg;
-	custom_start.hw_config.num_hw_update_entries = req_custom->num_cfg;
-	custom_start.hw_config.priv  = &req_custom->hw_update_data;
-	custom_start.hw_config.init_packet = 1;
-	if (ctx->state == CAM_CTX_FLUSHED)
-		custom_start.start_only = true;
-	else
-		custom_start.start_only = false;
+	hw_config.ctxt_to_hw_map = ctx_custom->hw_ctx;
+	hw_config.request_id = req->request_id;
+	hw_config.hw_update_entries = req_custom->cfg;
+	hw_config.num_hw_update_entries = req_custom->num_cfg;
+	hw_config.priv  = &req_custom->hw_update_data;
+	hw_config.init_packet = 1;
 
 	ctx->state = CAM_CTX_ACTIVATED;
 	rc = ctx->hw_mgr_intf->hw_start(ctx->hw_mgr_intf->hw_mgr_priv,
-		&custom_start);
+		&hw_config);
 	if (rc) {
 		/* HW failure. User need to clean up the resource */
 		CAM_ERR(CAM_CUSTOM, "Start HW failed");
@@ -1093,27 +826,6 @@ static int __cam_custom_ctx_handle_irq_in_activated(void *context,
 	return rc;
 }
 
-static int __cam_custom_ctx_acquire_hw_in_acquired(
-	struct cam_context *ctx, void *args)
-{
-	int rc = -EINVAL;
-	uint32_t api_version;
-
-	if (!ctx || !args) {
-		CAM_ERR(CAM_CUSTOM, "Invalid input pointer");
-		return rc;
-	}
-
-	api_version = *((uint32_t *)args);
-	if (api_version == 1)
-		rc = __cam_custom_ctx_acquire_hw_v1(ctx, args);
-	else
-		CAM_ERR(CAM_CUSTOM, "Unsupported api version %d",
-			api_version);
-
-	return rc;
-}
-
 /* top state machine */
 static struct cam_ctx_ops
 	cam_custom_dev_ctx_top_state_machine[CAM_CTX_STATE_MAX] = {
@@ -1135,10 +847,8 @@ static struct cam_ctx_ops
 	/* Acquired */
 	{
 		.ioctl_ops = {
-			.acquire_hw = __cam_custom_ctx_acquire_hw_in_acquired,
 			.release_dev = __cam_custom_release_dev_in_acquired,
 			.config_dev = __cam_custom_ctx_config_dev_in_acquired,
-			.release_hw = __cam_custom_ctx_release_hw_in_top_state,
 		},
 		.crm_ops = {
 			.link = __cam_custom_ctx_link_in_acquired,
@@ -1156,7 +866,6 @@ static struct cam_ctx_ops
 			.start_dev = __cam_custom_ctx_start_dev_in_ready,
 			.release_dev = __cam_custom_release_dev_in_acquired,
 			.config_dev = __cam_custom_ctx_config_dev,
-			.release_hw = __cam_custom_ctx_release_hw_in_top_state,
 		},
 		.crm_ops = {
 			.unlink = __cam_custom_ctx_unlink_in_ready,
@@ -1166,20 +875,7 @@ static struct cam_ctx_ops
 		.pagefault_ops = NULL,
 	},
 	/* Flushed */
-	{
-		.ioctl_ops = {
-			.stop_dev = __cam_custom_stop_dev_in_activated,
-			.release_dev =
-				__cam_custom_ctx_release_dev_in_activated,
-			.config_dev = __cam_custom_ctx_config_dev_in_flushed,
-			.release_hw =
-				__cam_custom_ctx_release_hw_in_activated_state,
-		},
-		.crm_ops = {
-			.unlink = __cam_custom_ctx_unlink_in_ready,
-		},
-		.irq_ops = NULL,
-	},
+	{},
 	/* Activated */
 	{
 		.ioctl_ops = {
@@ -1187,8 +883,6 @@ static struct cam_ctx_ops
 			.release_dev =
 				__cam_custom_ctx_release_dev_in_activated,
 			.config_dev = __cam_custom_ctx_config_dev,
-			.release_hw =
-				__cam_custom_ctx_release_hw_in_activated_state,
 		},
 		.crm_ops = {
 			.unlink = __cam_custom_ctx_unlink_in_activated,
diff --git a/techpack/camera/drivers/cam_cust/cam_custom_context.h b/techpack/camera/drivers/cam_cust/cam_custom_context.h
index 27268b20c526..91acf1e5ee80 100644
--- a/techpack/camera/drivers/cam_cust/cam_custom_context.h
+++ b/techpack/camera/drivers/cam_cust/cam_custom_context.h
@@ -67,7 +67,6 @@ struct cam_custom_dev_ctx_req {
  *                   custom HW will invoke CRM cb at those event.
  * @active_req_cnt: Counter for the active request
  * @frame_id: Frame id tracking for the custom context
- * @hw_acquired: Flag to indicate if HW is acquired for this context
  * @req_base: common request structure
  * @req_custom: custom request structure
  *
@@ -81,7 +80,6 @@ struct cam_custom_context {
 	uint32_t                      subscribe_event;
 	uint32_t                      active_req_cnt;
 	int64_t                       frame_id;
-	bool                          hw_acquired;
 	struct cam_ctx_request        req_base[CAM_CTX_REQ_MAX];
 	struct cam_custom_dev_ctx_req req_custom[CAM_CTX_REQ_MAX];
 };
diff --git a/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_csid/cam_custom_csid480.h b/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_csid/cam_custom_csid480.h
index da98ebf104c7..a55bb002ffc2 100644
--- a/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_csid/cam_custom_csid480.h
+++ b/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_csid/cam_custom_csid480.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CUSTOM_CSID_480_H_
@@ -56,7 +56,7 @@ static struct cam_ife_csid_udi_reg_offset
 	.csid_udi_byte_cntr_pong_addr             = 0x2e4,
 	/* configurations */
 	.ccif_violation_en                        = 1,
-	.overflow_ctrl_en                         = 0,
+	.overflow_ctrl_en                         = 1,
 };
 
 static struct cam_ife_csid_udi_reg_offset
@@ -105,7 +105,7 @@ static struct cam_ife_csid_udi_reg_offset
 	.csid_udi_byte_cntr_pong_addr             = 0x3e4,
 	/* configurations */
 	.ccif_violation_en                        = 1,
-	.overflow_ctrl_en                         = 0,
+	.overflow_ctrl_en                         = 1,
 };
 
 static struct cam_ife_csid_udi_reg_offset
@@ -155,7 +155,7 @@ static struct cam_ife_csid_udi_reg_offset
 	.csid_udi_byte_cntr_pong_addr             = 0x4e4,
 	/* configurations */
 	.ccif_violation_en                        = 1,
-	.overflow_ctrl_en                         = 0,
+	.overflow_ctrl_en                         = 1,
 };
 
 static struct cam_ife_csid_csi2_rx_reg_offset
diff --git a/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_hw_mgr.c b/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_hw_mgr.c
index 2fed429ad13a..1db06bb3ab1f 100644
--- a/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_hw_mgr.c
+++ b/techpack/camera/drivers/cam_cust/cam_custom_hw_mgr/cam_custom_hw_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -220,7 +220,6 @@ static int cam_custom_hw_mgr_stop_hw_res(
 static int cam_custom_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 {
 	int                               rc        = 0;
-	struct cam_custom_stop_args      *custom_args;
 	struct cam_hw_stop_args          *stop_args = stop_hw_args;
 	struct cam_custom_hw_mgr_res     *hw_mgr_res;
 	struct cam_custom_hw_mgr_ctx     *ctx;
@@ -230,7 +229,6 @@ static int cam_custom_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 		return -EINVAL;
 	}
 
-	custom_args = (struct cam_custom_stop_args *)stop_args->args;
 	ctx = (struct cam_custom_hw_mgr_ctx *)
 		stop_args->ctxt_to_hw_map;
 
@@ -263,9 +261,6 @@ static int cam_custom_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 
 	/* stop custom hw here */
 
-	if (custom_args->stop_only)
-		goto end;
-
 	/* Deinit custom cid here */
 	list_for_each_entry(hw_mgr_res,
 		&ctx->res_list_custom_cid, list) {
@@ -287,7 +282,6 @@ static int cam_custom_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 
 	/* deinit custom rsrc */
 
-end:
 	return rc;
 }
 
@@ -363,19 +357,13 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 	struct cam_hw_stop_args                  stop_args;
 	struct cam_custom_hw_mgr_res            *hw_mgr_res;
 	struct cam_custom_hw_mgr_ctx            *ctx;
-	struct cam_custom_stop_args              custom_stop_args;
-	struct cam_custom_start_args            *custom_args;
 
 	if (!hw_mgr_priv || !start_hw_args) {
 		CAM_ERR(CAM_CUSTOM, "Invalid arguments");
 		return -EINVAL;
 	}
 
-	custom_args =
-		(struct cam_custom_start_args *)start_hw_args;
-
-	hw_config = (struct cam_hw_config_args *)
-		&custom_args->hw_config;
+	hw_config = (struct cam_hw_config_args *)start_hw_args;
 
 	ctx = (struct cam_custom_hw_mgr_ctx *)
 		hw_config->ctxt_to_hw_map;
@@ -387,15 +375,12 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 	CAM_DBG(CAM_CUSTOM, "Enter... ctx id:%d",
 		ctx->ctx_index);
 
-	if (custom_args->start_only)
-		goto start_only;
-
 	/* Init custom cid */
 	list_for_each_entry(hw_mgr_res,
 		&ctx->res_list_custom_cid, list) {
 		rc = cam_custom_hw_mgr_init_hw_res(hw_mgr_res);
 		if (rc) {
-			CAM_ERR(CAM_CUSTOM, "Can not INIT CID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not INIT CID(id :%d)",
 				hw_mgr_res->res_id);
 			goto deinit_hw;
 		}
@@ -406,7 +391,7 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 		&ctx->res_list_custom_csid, list) {
 		rc = cam_custom_hw_mgr_init_hw_res(hw_mgr_res);
 		if (rc) {
-			CAM_ERR(CAM_CUSTOM, "Can not INIT CSID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not INIT CSID(id :%d)",
 				hw_mgr_res->res_id);
 			goto deinit_hw;
 		}
@@ -417,8 +402,6 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 
 	/* Apply init config */
 
-start_only:
-
 	/* Start custom HW first */
 	if (rc < 0)
 		goto err;
@@ -428,7 +411,7 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 		&ctx->res_list_custom_csid, list) {
 		rc = cam_custom_hw_mgr_start_hw_res(hw_mgr_res);
 		if (rc) {
-			CAM_ERR(CAM_CUSTOM, "Can not START CSID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not START CSID(id :%d)",
 				hw_mgr_res->res_id);
 			goto err;
 		}
@@ -439,7 +422,7 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 		&ctx->res_list_custom_cid, list) {
 		rc = cam_custom_hw_mgr_start_hw_res(hw_mgr_res);
 		if (rc) {
-			CAM_ERR(CAM_CUSTOM, "Can not START CID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not START CID(id :%d)",
 				hw_mgr_res->res_id);
 			goto err;
 		}
@@ -449,8 +432,6 @@ static int cam_custom_mgr_start_hw(void *hw_mgr_priv,
 	return 0;
 
 err:
-	custom_stop_args.stop_only = false;
-	stop_args.args = (void *) &custom_stop_args;
 	stop_args.ctxt_to_hw_map = hw_config->ctxt_to_hw_map;
 	cam_custom_mgr_stop_hw(hw_mgr_priv, &stop_args);
 deinit_hw:
@@ -779,7 +760,7 @@ static int cam_custom_hw_mgr_release_hw_for_ctx(
 		&custom_ctx->res_list_custom_cid, list) {
 		rc = cam_custom_hw_mgr_free_hw_res(hw_mgr_res);
 		if (rc)
-			CAM_ERR(CAM_CUSTOM, "Can not release CID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not release CID(id :%d)",
 				hw_mgr_res->res_id);
 		cam_custom_hw_mgr_put_res(
 			&custom_ctx->free_res_list, &hw_mgr_res);
@@ -790,7 +771,7 @@ static int cam_custom_hw_mgr_release_hw_for_ctx(
 		&custom_ctx->res_list_custom_csid, list) {
 		rc = cam_custom_hw_mgr_free_hw_res(hw_mgr_res);
 		if (rc)
-			CAM_ERR(CAM_CUSTOM, "Can not release CSID(id :%d)",
+			CAM_ERR(CAM_ISP, "Can not release CSID(id :%d)",
 				hw_mgr_res->res_id);
 		cam_custom_hw_mgr_put_res(
 			&custom_ctx->free_res_list, &hw_mgr_res);
@@ -830,82 +811,41 @@ static int cam_custom_mgr_release_hw(void *hw_mgr_priv,
 	return rc;
 }
 
-static int cam_custom_hw_mgr_acquire_get_unified_dev_str(
-	struct cam_custom_acquire_hw_info *acquire_hw_info,
-	uint32_t *input_size,
-	struct cam_isp_in_port_generic_info **gen_port_info)
+static void cam_custom_hw_mgr_acquire_get_unified_dev_str(
+	struct cam_custom_in_port_info *in,
+	struct cam_isp_in_port_generic_info *gen_port_info)
 {
-	int32_t rc = 0, i;
-	uint32_t in_port_length = 0;
-	struct cam_custom_in_port_info *in = NULL;
-	struct cam_isp_in_port_generic_info *port_info = NULL;
-
-	in = (struct cam_custom_in_port_info *)
-		((uint8_t *)&acquire_hw_info->data +
-		 acquire_hw_info->input_info_offset + *input_size);
-
-	in_port_length = sizeof(struct cam_custom_in_port_info) +
-		(in->num_out_res - 1) *
-		sizeof(struct cam_custom_out_port_info);
-
-	*input_size += in_port_length;
-
-	if ((*input_size) > acquire_hw_info->input_info_size) {
-		CAM_ERR(CAM_CUSTOM, "Input is not proper");
-		rc = -EINVAL;
-		return rc;
-	}
-
-	port_info = kzalloc(
-		sizeof(struct cam_isp_in_port_generic_info), GFP_KERNEL);
-
-	if (!port_info)
-		return -ENOMEM;
+	int i;
 
-	port_info->res_type        =  in->res_type +
+	gen_port_info->res_type        =  in->res_type +
 		CAM_ISP_IFE_IN_RES_BASE - CAM_CUSTOM_IN_RES_BASE;
-	port_info->lane_type       =  in->lane_type;
-	port_info->lane_num        =  in->lane_num;
-	port_info->lane_cfg        =  in->lane_cfg;
-	port_info->vc[0]           =  in->vc[0];
-	port_info->dt[0]           =  in->dt[0];
-	port_info->num_valid_vc_dt =  in->num_valid_vc_dt;
-	port_info->format          =  in->format;
-	port_info->test_pattern    =  in->test_pattern;
-	port_info->usage_type      =  in->usage_type;
-	port_info->left_start      =  in->left_start;
-	port_info->left_stop       =  in->left_stop;
-	port_info->left_width      =  in->left_width;
-	port_info->right_start     =  in->right_start;
-	port_info->right_stop      =  in->right_stop;
-	port_info->right_width     =  in->right_width;
-	port_info->line_start      =  in->line_start;
-	port_info->line_stop       =  in->line_stop;
-	port_info->height          =  in->height;
-	port_info->pixel_clk       =  in->pixel_clk;
-	port_info->cust_node       =  1;
-	port_info->num_out_res     =  in->num_out_res;
-	port_info->num_bytes_out   =  in->num_bytes_out;
-
-	port_info->data = kcalloc(in->num_out_res,
-		sizeof(struct cam_isp_out_port_generic_info),
-		GFP_KERNEL);
-	if (port_info->data == NULL) {
-		rc = -ENOMEM;
-		goto release_port_mem;
-	}
+	gen_port_info->lane_type       =  in->lane_type;
+	gen_port_info->lane_num        =  in->lane_num;
+	gen_port_info->lane_cfg        =  in->lane_cfg;
+	gen_port_info->vc[0]           =  in->vc[0];
+	gen_port_info->dt[0]           =  in->dt[0];
+	gen_port_info->num_valid_vc_dt =  in->num_valid_vc_dt;
+	gen_port_info->format          =  in->format;
+	gen_port_info->test_pattern    =  in->test_pattern;
+	gen_port_info->usage_type      =  in->usage_type;
+	gen_port_info->left_start      =  in->left_start;
+	gen_port_info->left_stop       =  in->left_stop;
+	gen_port_info->left_width      =  in->left_width;
+	gen_port_info->right_start     =  in->right_start;
+	gen_port_info->right_stop      =  in->right_stop;
+	gen_port_info->right_width     =  in->right_width;
+	gen_port_info->line_start      =  in->line_start;
+	gen_port_info->line_stop       =  in->line_stop;
+	gen_port_info->height          =  in->height;
+	gen_port_info->pixel_clk       =  in->pixel_clk;
+	gen_port_info->cust_node       =  1;
+	gen_port_info->num_out_res     =  in->num_out_res;
+	gen_port_info->num_bytes_out   =  in->num_bytes_out;
 
 	for (i = 0; i < in->num_out_res; i++) {
-		port_info->data[i].res_type     = in->data[i].res_type;
-		port_info->data[i].format       = in->data[i].format;
+		gen_port_info->data[i].res_type     = in->data[i].res_type;
+		gen_port_info->data[i].format       = in->data[i].format;
 	}
-
-	*gen_port_info = port_info;
-	return 0;
-
-release_port_mem:
-	kfree(port_info);
-	return rc;
 }
 
 static int cam_custom_mgr_acquire_hw_for_ctx(
@@ -956,16 +896,18 @@ static int cam_custom_mgr_acquire_hw(
 	void *hw_mgr_priv,
 	void *acquire_hw_args)
 {
-	int rc = -1, i;
-	uint32_t                             input_size = 0;
+	int rc = -1;
+	int32_t i;
+	uint32_t                             in_port_length;
 	struct cam_custom_hw_mgr_ctx        *custom_ctx;
 	struct cam_custom_hw_mgr            *custom_hw_mgr;
-	struct cam_custom_acquire_hw_info   *acquire_hw_info = NULL;
-	struct cam_isp_in_port_generic_info *gen_port_info = NULL;
 	struct cam_hw_acquire_args          *acquire_args =
-		(struct cam_hw_acquire_args *)acquire_hw_args;
+		(struct cam_hw_acquire_args *)  acquire_hw_args;
+	struct cam_custom_in_port_info      *in_port_info;
+	struct cam_custom_resource          *custom_rsrc;
+	struct cam_isp_in_port_generic_info *gen_port_info = NULL;
 
-	if (!hw_mgr_priv || !acquire_args) {
+	if (!hw_mgr_priv || !acquire_args || (acquire_args->num_acq <= 0)) {
 		CAM_ERR(CAM_CUSTOM, "Invalid params");
 		return -EINVAL;
 	}
@@ -981,47 +923,127 @@ static int cam_custom_mgr_acquire_hw(
 	}
 	mutex_unlock(&g_custom_hw_mgr.ctx_mutex);
 
+	/* Handle Acquire Here */
 	custom_ctx->hw_mgr = custom_hw_mgr;
 	custom_ctx->cb_priv = acquire_args->context_data;
 	custom_ctx->event_cb = acquire_args->event_cb;
 
-	acquire_hw_info =
-		(struct cam_custom_acquire_hw_info *)acquire_args->acquire_info;
+	custom_rsrc = kcalloc(acquire_args->num_acq,
+		sizeof(*custom_rsrc), GFP_KERNEL);
+	if (!custom_rsrc) {
+		rc = -ENOMEM;
+		goto free_ctx;
+	}
+
+	CAM_DBG(CAM_CUSTOM, "start copy %d resources from user",
+		acquire_args->num_acq);
+
+	if (copy_from_user(custom_rsrc,
+		(void __user *)acquire_args->acquire_info,
+		((sizeof(*custom_rsrc)) * acquire_args->num_acq))) {
+		rc = -EFAULT;
+		goto free_ctx;
+	}
+
+	for (i = 0; i < acquire_args->num_acq; i++) {
+		if (custom_rsrc[i].resource_id != CAM_CUSTOM_RES_ID_PORT)
+			continue;
 
-	for (i = 0; i < acquire_hw_info->num_inputs; i++) {
-		rc = cam_custom_hw_mgr_acquire_get_unified_dev_str(
-			acquire_hw_info, &input_size, &gen_port_info);
+		CAM_DBG(CAM_CUSTOM, "acquire no = %d total = %d", i,
+			acquire_args->num_acq);
 
-		if (rc < 0) {
-			CAM_ERR(CAM_CUSTOM, "Failed in parsing: %d", rc);
+		CAM_DBG(CAM_CUSTOM,
+			"start copy from user handle %lld with len = %d",
+			custom_rsrc[i].res_hdl,
+			custom_rsrc[i].length);
+
+		in_port_length = sizeof(struct cam_custom_in_port_info);
+		if (in_port_length > custom_rsrc[i].length) {
+			CAM_ERR(CAM_CUSTOM, "buffer size is not enough");
+			rc = -EINVAL;
 			goto free_res;
 		}
 
-		CAM_DBG(CAM_CUSTOM, "in_res_type %x", gen_port_info->res_type);
-		rc = cam_custom_mgr_acquire_hw_for_ctx(custom_ctx,
-			gen_port_info, &acquire_args->acquired_hw_id[i],
-			acquire_args->acquired_hw_path[i]);
-		if (rc) {
-			CAM_ERR(CAM_CUSTOM, "can not acquire resource");
-			goto free_mem;
-		}
+		in_port_info = memdup_user(
+			u64_to_user_ptr(custom_rsrc[i].res_hdl),
+			custom_rsrc[i].length);
+
+		if (!IS_ERR(in_port_info)) {
+			if (in_port_info->num_out_res >
+				CAM_CUSTOM_HW_OUT_RES_MAX) {
+				CAM_ERR(CAM_CUSTOM, "too many output res %d",
+					in_port_info->num_out_res);
+				rc = -EINVAL;
+				kfree(in_port_info);
+				goto free_res;
+			}
+
+			in_port_length =
+				sizeof(struct cam_custom_in_port_info) +
+				(in_port_info->num_out_res - 1) *
+				sizeof(struct cam_custom_out_port_info);
+
+			if (in_port_length > custom_rsrc[i].length) {
+				CAM_ERR(CAM_CUSTOM,
+					"buffer size is not enough");
+				rc = -EINVAL;
+				kfree(in_port_info);
+				goto free_res;
+			}
+
+			gen_port_info = kzalloc(
+				sizeof(struct cam_isp_in_port_generic_info),
+				GFP_KERNEL);
+			if (gen_port_info == NULL) {
+				rc = -ENOMEM;
+				goto free_res;
+			}
+
+			gen_port_info->data = kcalloc(
+				sizeof(struct cam_isp_out_port_generic_info),
+				in_port_info->num_out_res, GFP_KERNEL);
+			if (gen_port_info->data == NULL) {
+				kfree(gen_port_info);
+				gen_port_info = NULL;
+				rc = -ENOMEM;
+				goto free_res;
+			}
+
+			cam_custom_hw_mgr_acquire_get_unified_dev_str(
+				in_port_info, gen_port_info);
 
-		kfree(gen_port_info->data);
-		kfree(gen_port_info);
-		gen_port_info = NULL;
+			rc = cam_custom_mgr_acquire_hw_for_ctx(custom_ctx,
+				gen_port_info, &acquire_args->acquired_hw_id[i],
+				acquire_args->acquired_hw_path[i]);
+
+			kfree(in_port_info);
+			if (gen_port_info != NULL) {
+				kfree(gen_port_info->data);
+				kfree(gen_port_info);
+				gen_port_info = NULL;
+			}
+
+			if (rc) {
+				CAM_ERR(CAM_CUSTOM, "can not acquire resource");
+				goto free_res;
+			}
+	} else {
+		CAM_ERR(CAM_CUSTOM,
+			"Copy from user failed with in_port = %pK",
+			in_port_info);
+			rc = -EFAULT;
+			goto free_res;
+		}
 	}
 
 	custom_ctx->ctx_in_use = 1;
 	acquire_args->ctxt_to_hw_map = custom_ctx;
-	cam_custom_hw_mgr_put_ctx(&custom_hw_mgr->used_ctx_list, &custom_ctx);
 	CAM_DBG(CAM_CUSTOM, "Exit...(success)");
 	return 0;
 
-free_mem:
-	kfree(gen_port_info->data);
-	kfree(gen_port_info);
 free_res:
 	cam_custom_hw_mgr_release_hw_for_ctx(custom_ctx);
+free_ctx:
 	cam_custom_hw_mgr_put_ctx(&custom_hw_mgr->free_ctx_list, &custom_ctx);
 err:
 	CAM_DBG(CAM_CUSTOM, "Exit...(rc=%d)", rc);
@@ -1132,81 +1154,6 @@ static int cam_custom_mgr_prepare_hw_update(void *hw_mgr_priv,
 	return 0;
 }
 
-static int cam_custom_hw_mgr_reset_csid_res(
-	struct cam_custom_hw_mgr_res *hw_mgr_res)
-{
-	int rc = -1;
-	struct cam_csid_reset_cfg_args  csid_reset_args;
-	struct cam_isp_resource_node *custom_rsrc_node = NULL;
-	struct cam_hw_intf *hw_intf = NULL;
-
-	custom_rsrc_node =
-		(struct cam_isp_resource_node *)hw_mgr_res->rsrc_node;
-	if (!custom_rsrc_node) {
-		CAM_ERR(CAM_CUSTOM, "Invalid args");
-		return -EINVAL;
-	}
-
-	csid_reset_args.reset_type = CAM_IFE_CSID_RESET_PATH;
-	csid_reset_args.node_res = custom_rsrc_node;
-	hw_intf = custom_rsrc_node->hw_intf;
-	if (hw_intf->hw_ops.reset) {
-		CAM_DBG(CAM_CUSTOM, "RESET HW for res_id:%u",
-			hw_mgr_res->res_id);
-		rc = hw_intf->hw_ops.reset(hw_intf->hw_priv,
-			&csid_reset_args,
-			sizeof(struct cam_csid_reset_cfg_args));
-		if (rc)
-			goto err;
-	}
-
-	return 0;
-
-err:
-	CAM_ERR(CAM_CUSTOM,
-		"RESET HW failed for res_id:%u",
-		hw_mgr_res->res_id);
-	return rc;
-}
-
-static int cam_custom_hw_mgr_reset(
-	void *hw_mgr_priv, void *hw_reset_args)
-{
-	struct cam_hw_reset_args         *reset_args =
-		hw_reset_args;
-	struct cam_custom_hw_mgr_ctx     *ctx;
-	struct cam_custom_hw_mgr_res     *hw_mgr_res;
-	int                               rc = 0;
-
-	if (!hw_mgr_priv || !hw_reset_args) {
-		CAM_ERR(CAM_CUSTOM, "Invalid arguments");
-		return -EINVAL;
-	}
-
-	ctx = (struct cam_custom_hw_mgr_ctx *)
-		reset_args->ctxt_to_hw_map;
-	if (!ctx || !ctx->ctx_in_use) {
-		CAM_ERR(CAM_CUSTOM, "Invalid context is used");
-		return -EPERM;
-	}
-
-	CAM_DBG(CAM_CUSTOM, "Reset SBI CSID and SBI core");
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_custom_csid, list) {
-		rc = cam_custom_hw_mgr_reset_csid_res(hw_mgr_res);
-		if (rc) {
-			CAM_ERR(CAM_CUSTOM,
-				"Failed to reset CSID:%d rc: %d",
-				hw_mgr_res->res_id, rc);
-			goto end;
-		}
-	}
-
-	/* Reset SBI HW */
-
-end:
-	return rc;
-}
-
 static int cam_custom_mgr_config_hw(void *hw_mgr_priv,
 	void *hw_config_args)
 {
@@ -1373,7 +1320,6 @@ int cam_custom_hw_mgr_init(struct device_node *of_node,
 	hw_mgr_intf->hw_release = cam_custom_mgr_release_hw;
 	hw_mgr_intf->hw_prepare_update = cam_custom_mgr_prepare_hw_update;
 	hw_mgr_intf->hw_config = cam_custom_mgr_config_hw;
-	hw_mgr_intf->hw_reset = cam_custom_hw_mgr_reset;
 
 	if (iommu_hdl)
 		*iommu_hdl = g_custom_hw_mgr.img_iommu_hdl;
diff --git a/techpack/camera/drivers/cam_fd/cam_fd_context.c b/techpack/camera/drivers/cam_fd/cam_fd_context.c
index 99887d30242d..7c03761ee03a 100644
--- a/techpack/camera/drivers/cam_fd/cam_fd_context.c
+++ b/techpack/camera/drivers/cam_fd/cam_fd_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -117,19 +117,6 @@ static int __cam_fd_ctx_release_dev_in_activated(struct cam_context *ctx,
 	return rc;
 }
 
-static int __cam_fd_ctx_dump_dev_in_activated(
-	struct cam_context *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int rc;
-
-	rc = cam_context_dump_dev_to_hw(ctx, cmd);
-	if (rc)
-		CAM_ERR(CAM_FD, "Failed to dump device, rc=%d", rc);
-
-	return rc;
-}
-
 static int __cam_fd_ctx_flush_dev_in_activated(struct cam_context *ctx,
 	struct cam_flush_dev_cmd *cmd)
 {
@@ -137,7 +124,7 @@ static int __cam_fd_ctx_flush_dev_in_activated(struct cam_context *ctx,
 
 	rc = cam_context_flush_dev_to_hw(ctx, cmd);
 	if (rc)
-		CAM_ERR(CAM_ICP, "Failed to flush device, rc=%d", rc);
+		CAM_ERR(CAM_FD, "Failed to flush device, rc=%d", rc);
 
 	return rc;
 }
@@ -211,7 +198,6 @@ static struct cam_ctx_ops
 			.release_dev = __cam_fd_ctx_release_dev_in_activated,
 			.config_dev = __cam_fd_ctx_config_dev_in_activated,
 			.flush_dev = __cam_fd_ctx_flush_dev_in_activated,
-			.dump_dev = __cam_fd_ctx_dump_dev_in_activated,
 		},
 		.crm_ops = {},
 		.irq_ops = __cam_fd_ctx_handle_irq_in_activated,
diff --git a/techpack/camera/drivers/cam_fd/cam_fd_dev.c b/techpack/camera/drivers/cam_fd/cam_fd_dev.c
index e68ba141fee4..c92cea8fc9e9 100644
--- a/techpack/camera/drivers/cam_fd/cam_fd_dev.c
+++ b/techpack/camera/drivers/cam_fd/cam_fd_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/device.h>
@@ -43,11 +43,8 @@ static int cam_fd_dev_open(struct v4l2_subdev *sd,
 {
 	struct cam_fd_dev *fd_dev = &g_fd_dev;
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
-
 	if (!fd_dev->probe_done) {
 		CAM_ERR(CAM_FD, "FD Dev not initialized, fd_dev=%pK", fd_dev);
-		cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
 		return -ENODEV;
 	}
 
@@ -56,8 +53,6 @@ static int cam_fd_dev_open(struct v4l2_subdev *sd,
 	CAM_DBG(CAM_FD, "FD Subdev open count %d", fd_dev->open_cnt);
 	mutex_unlock(&fd_dev->lock);
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
-
 	return 0;
 }
 
@@ -73,22 +68,16 @@ static int cam_fd_dev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&fd_dev->lock);
-	if (fd_dev->open_cnt <= 0) {
-		mutex_unlock(&fd_dev->lock);
-		return -EINVAL;
-	}
 	fd_dev->open_cnt--;
 	CAM_DBG(CAM_FD, "FD Subdev open count %d", fd_dev->open_cnt);
+	mutex_unlock(&fd_dev->lock);
 
 	if (!node) {
 		CAM_ERR(CAM_FD, "Node ptr is NULL");
-		mutex_unlock(&fd_dev->lock);
 		return -EINVAL;
 	}
 
-	if (fd_dev->open_cnt == 0)
-		cam_node_shutdown(node);
-	mutex_unlock(&fd_dev->lock);
+	cam_node_shutdown(node);
 
 	return 0;
 }
@@ -142,7 +131,6 @@ static int cam_fd_dev_probe(struct platform_device *pdev)
 
 	mutex_init(&g_fd_dev.lock);
 	g_fd_dev.probe_done = true;
-	g_fd_dev.open_cnt = 0;
 
 	CAM_DBG(CAM_FD, "Camera FD probe complete");
 
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.c b/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.c
index ba83d4db92a9..2f43f8ebf21d 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.c
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -240,15 +240,6 @@ static int cam_fd_mgr_util_release_device(struct cam_fd_hw_mgr *hw_mgr,
 
 	mutex_lock(&hw_mgr->hw_mgr_mutex);
 	hw_device->num_ctxts--;
-
-	if (!hw_device->num_ctxts) {
-		mutex_lock(&hw_device->lock);
-		hw_device->ready_to_process = true;
-		hw_device->req_id = -1;
-		hw_device->cur_hw_ctx = NULL;
-		mutex_unlock(&hw_device->lock);
-	}
-
 	mutex_unlock(&hw_mgr->hw_mgr_mutex);
 
 	hw_ctx->device_index = -1;
@@ -286,11 +277,6 @@ static int cam_fd_mgr_util_select_device(struct cam_fd_hw_mgr *hw_mgr,
 			(!fd_acquire_args->get_raw_results ||
 			hw_device->hw_caps.raw_results_available)) {
 			CAM_DBG(CAM_FD, "Found dedicated HW Index=%d", i);
-			mutex_lock(&hw_device->lock);
-			hw_device->ready_to_process = true;
-			hw_device->req_id = -1;
-			hw_device->cur_hw_ctx = NULL;
-			mutex_unlock(&hw_device->lock);
 			hw_device->num_ctxts++;
 			break;
 		}
@@ -308,9 +294,7 @@ static int cam_fd_mgr_util_select_device(struct cam_fd_hw_mgr *hw_mgr,
 				(!fd_acquire_args->get_raw_results ||
 				hw_device->hw_caps.raw_results_available)) {
 				hw_device->num_ctxts++;
-				CAM_DBG(CAM_FD,
-					"Found sharing HW Index=%d, num_ctxts=%d",
-					i, hw_device->num_ctxts);
+				CAM_DBG(CAM_FD, "Found sharing HW Index=%d", i);
 				break;
 			}
 		}
@@ -862,22 +846,15 @@ static int cam_fd_mgr_util_submit_frame(void *priv, void *data)
 
 	mutex_lock(&hw_device->lock);
 	if (hw_device->ready_to_process == false) {
-		if (hw_mgr->num_pending_frames > 6) {
-			CAM_WARN(CAM_FD,
-				"Device busy for longer time with cur_hw_ctx=%pK, ReqId=%lld",
-				hw_device->cur_hw_ctx, hw_device->req_id);
-		}
 		mutex_unlock(&hw_device->lock);
 		mutex_unlock(&hw_mgr->frame_req_mutex);
+		CAM_DBG(CAM_FD, "FrameSubmit : Frame[%lld] HW is busy", frame_req->request_id);
 		return -EBUSY;
 	}
 
 	trace_cam_submit_to_hw("FD", frame_req->request_id);
 
 	list_del_init(&frame_req->list);
-	hw_mgr->num_pending_frames--;
-	frame_req->submit_timestamp = ktime_get();
-	list_add_tail(&frame_req->list, &hw_mgr->frame_processing_list);
 
 	if (hw_device->hw_intf->hw_ops.start) {
 		start_args.hw_ctx = hw_ctx;
@@ -892,14 +869,12 @@ static int cam_fd_mgr_util_submit_frame(void *priv, void *data)
 			sizeof(start_args));
 		if (rc) {
 			CAM_ERR(CAM_FD, "Failed in HW Start %d", rc);
-			list_del_init(&frame_req->list);
 			mutex_unlock(&hw_device->lock);
 			mutex_unlock(&hw_mgr->frame_req_mutex);
 			goto put_req_into_free_list;
 		}
 	} else {
 		CAM_ERR(CAM_FD, "Invalid hw_ops.start");
-		list_del_init(&frame_req->list);
 		mutex_unlock(&hw_device->lock);
 		mutex_unlock(&hw_mgr->frame_req_mutex);
 		rc = -EPERM;
@@ -909,10 +884,13 @@ static int cam_fd_mgr_util_submit_frame(void *priv, void *data)
 	hw_device->ready_to_process = false;
 	hw_device->cur_hw_ctx = hw_ctx;
 	hw_device->req_id = frame_req->request_id;
+	list_add_tail(&frame_req->list, &hw_mgr->frame_processing_list);
+
 	mutex_unlock(&hw_device->lock);
 	mutex_unlock(&hw_mgr->frame_req_mutex);
 
 	return rc;
+
 put_req_into_free_list:
 	cam_fd_mgr_util_put_frame_req(&hw_mgr->frame_free_list, &frame_req);
 
@@ -1250,9 +1228,9 @@ static int cam_fd_mgr_hw_start(void *hw_mgr_priv, void *mgr_start_args)
 	struct cam_fd_hw_mgr_ctx *hw_ctx;
 	struct cam_fd_device *hw_device;
 	struct cam_fd_hw_init_args hw_init_args;
-	struct cam_hw_info *fd_hw;
-	struct cam_fd_core *fd_core;
 
+    struct cam_hw_info *fd_hw;
+	struct cam_fd_core *fd_core;
 	if (!hw_mgr_priv || !hw_mgr_start_args) {
 		CAM_ERR(CAM_FD, "Invalid arguments %pK %pK",
 			hw_mgr_priv, hw_mgr_start_args);
@@ -1274,32 +1252,24 @@ static int cam_fd_mgr_hw_start(void *hw_mgr_priv, void *mgr_start_args)
 		return rc;
 	}
 
-	fd_hw = (struct cam_hw_info *)hw_device->hw_intf->hw_priv;
-	fd_core = (struct cam_fd_core *)fd_hw->core_info;
+	hw_device->ready_to_process = true;
 
-	if (hw_device->hw_intf->hw_ops.init) {
+    fd_hw = (struct cam_hw_info *)hw_device->hw_intf->hw_priv;
+	fd_core = (struct cam_fd_core *)fd_hw->core_info;
+    if (hw_device->hw_intf->hw_ops.init) {
 		hw_init_args.hw_ctx = hw_ctx;
 		hw_init_args.ctx_hw_private = hw_ctx->ctx_hw_private;
-		hw_init_args.is_hw_reset = false;
-		if (fd_core->hw_static_info->enable_errata_wa.skip_reset)
-			hw_init_args.reset_required = false;
-		else
-			hw_init_args.reset_required = true;
-		rc = hw_device->hw_intf->hw_ops.init(
-			hw_device->hw_intf->hw_priv, &hw_init_args,
-			sizeof(hw_init_args));
-		if (rc) {
+        if (fd_core->hw_static_info->enable_errata_wa.skip_reset)
+            hw_init_args.reset_required = false;
+        else
+            hw_init_args.reset_required = true;
+        rc = hw_device->hw_intf->hw_ops.init(
+                hw_device->hw_intf->hw_priv, &hw_init_args,
+                sizeof(hw_init_args));
+        if (rc) {
 			CAM_ERR(CAM_FD, "Failed in HW Init %d", rc);
 			return rc;
 		}
-
-		if (hw_init_args.is_hw_reset) {
-			mutex_lock(&hw_device->lock);
-			hw_device->ready_to_process = true;
-			hw_device->req_id = -1;
-			hw_device->cur_hw_ctx = NULL;
-			mutex_unlock(&hw_device->lock);
-		}
 	} else {
 		CAM_ERR(CAM_FD, "Invalid init function");
 		return -EINVAL;
@@ -1347,7 +1317,6 @@ static int cam_fd_mgr_hw_flush_req(void *hw_mgr_priv,
 			if (frame_req->request_id != flush_req->request_id)
 				continue;
 
-			hw_mgr->num_pending_frames--;
 			list_del_init(&frame_req->list);
 			break;
 		}
@@ -1360,7 +1329,6 @@ static int cam_fd_mgr_hw_flush_req(void *hw_mgr_priv,
 			if (frame_req->request_id != flush_req->request_id)
 				continue;
 
-			hw_mgr->num_pending_frames--;
 			list_del_init(&frame_req->list);
 			break;
 		}
@@ -1437,13 +1405,13 @@ static int cam_fd_mgr_hw_flush_ctx(void *hw_mgr_priv,
 		return rc;
 	}
 
+
 	mutex_lock(&hw_mgr->frame_req_mutex);
 	list_for_each_entry_safe(frame_req, req_temp,
 		&hw_mgr->frame_pending_list_high, list) {
 		if (frame_req->hw_ctx != hw_ctx)
 			continue;
 
-		hw_mgr->num_pending_frames--;
 		list_del_init(&frame_req->list);
 	}
 
@@ -1452,7 +1420,6 @@ static int cam_fd_mgr_hw_flush_ctx(void *hw_mgr_priv,
 		if (frame_req->hw_ctx != hw_ctx)
 			continue;
 
-		hw_mgr->num_pending_frames--;
 		list_del_init(&frame_req->list);
 	}
 
@@ -1462,6 +1429,7 @@ static int cam_fd_mgr_hw_flush_ctx(void *hw_mgr_priv,
 			continue;
 
 		list_del_init(&frame_req->list);
+		CAM_DBG(CAM_FD, "Request deleted from frame processing list");
 		mutex_lock(&hw_device->lock);
 		if ((hw_device->ready_to_process == true) ||
 			(hw_device->cur_hw_ctx != hw_ctx))
@@ -1533,137 +1501,6 @@ static int cam_fd_mgr_hw_flush(void *hw_mgr_priv,
 	return rc;
 }
 
-static int cam_fd_mgr_hw_dump(
-	void *hw_mgr_priv,
-	void *hw_dump_args)
-{
-	int                              rc;
-	uint8_t                         *dst;
-	ktime_t                          cur_time;
-	size_t                           remain_len;
-	uint32_t                         min_len;
-	uint64_t                         diff;
-	uint64_t                        *addr, *start;
-	struct timespec64                cur_ts;
-	struct timespec64                req_ts;
-	struct cam_fd_hw_mgr            *hw_mgr;
-	struct cam_hw_dump_args         *dump_args;
-	struct cam_fd_hw_mgr_ctx        *hw_ctx;
-	struct cam_fd_device            *hw_device;
-	struct cam_fd_hw_dump_args       fd_dump_args;
-	struct cam_fd_hw_dump_header    *hdr;
-	struct cam_fd_mgr_frame_request *frame_req, *req_temp;
-
-	hw_mgr = (struct cam_fd_hw_mgr *)hw_mgr_priv;
-	dump_args = (struct cam_hw_dump_args *)hw_dump_args;
-	if (!hw_mgr || !dump_args) {
-		CAM_ERR(CAM_FD, "Invalid args %pK %pK",
-			hw_mgr, dump_args);
-		return -EINVAL;
-	}
-
-	hw_ctx = (struct cam_fd_hw_mgr_ctx *)dump_args->ctxt_to_hw_map;
-
-	if (!hw_ctx) {
-		CAM_ERR(CAM_FD, "Invalid ctx");
-		return -EINVAL;
-	}
-
-	rc = cam_fd_mgr_util_get_device(hw_mgr, hw_ctx, &hw_device);
-
-	if (rc) {
-		CAM_ERR(CAM_FD, "Error in getting device %d", rc);
-		return rc;
-	}
-
-	list_for_each_entry_safe(frame_req, req_temp,
-		&hw_mgr->frame_processing_list, list) {
-		if (frame_req->request_id == dump_args->request_id)
-			goto hw_dump;
-	}
-
-	CAM_DBG(CAM_FD, "fd dump cannot find req %llu",
-		dump_args->request_id);
-	return rc;
-hw_dump:
-	cur_time = ktime_get();
-	diff = ktime_us_delta(cur_time, frame_req->submit_timestamp);
-	cur_ts = ktime_to_timespec64(cur_time);
-	req_ts = ktime_to_timespec64(frame_req->submit_timestamp);
-	if (diff < CAM_FD_RESPONSE_TIME_THRESHOLD) {
-		CAM_INFO(CAM_FD, "No Error req %lld %ld:%06ld %ld:%06ld",
-			dump_args->request_id,
-			req_ts.tv_sec,
-			req_ts.tv_nsec/NSEC_PER_USEC,
-			cur_ts.tv_sec,
-			cur_ts.tv_nsec/NSEC_PER_USEC);
-		return 0;
-	}
-	CAM_INFO(CAM_FD, "Error req %lld %ld:%06ld %ld:%06ld",
-		dump_args->request_id,
-		req_ts.tv_sec,
-		req_ts.tv_nsec/NSEC_PER_USEC,
-		cur_ts.tv_sec,
-		cur_ts.tv_nsec/NSEC_PER_USEC);
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&fd_dump_args.cpu_addr, &fd_dump_args.buf_len);
-	if (rc) {
-		CAM_ERR(CAM_FD, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		return rc;
-	}
-	if (fd_dump_args.buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_FD, "dump offset overshoot len %zu offset %zu",
-			fd_dump_args.buf_len, dump_args->offset);
-		return -ENOSPC;
-	}
-	remain_len = fd_dump_args.buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_fd_hw_dump_header) +
-		(CAM_FD_HW_DUMP_NUM_WORDS * sizeof(uint64_t));
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_FD, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)fd_dump_args.cpu_addr + dump_args->offset;
-	hdr = (struct cam_fd_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_FD_HW_DUMP_TAG_MAX_LEN,
-		"FD_REQ:");
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst + sizeof(struct cam_fd_hw_dump_header));
-	start = addr;
-	*addr++ = frame_req->request_id;
-	*addr++ = req_ts.tv_sec;
-	*addr++ = req_ts.tv_nsec/NSEC_PER_USEC;
-	*addr++ = cur_ts.tv_sec;
-	*addr++ = cur_ts.tv_nsec/NSEC_PER_USEC;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_fd_hw_dump_header);
-
-	fd_dump_args.request_id = dump_args->request_id;
-	fd_dump_args.offset = dump_args->offset;
-	if (hw_device->hw_intf->hw_ops.process_cmd) {
-		rc = hw_device->hw_intf->hw_ops.process_cmd(
-			hw_device->hw_intf->hw_priv,
-			CAM_FD_HW_CMD_HW_DUMP,
-			&fd_dump_args,
-			sizeof(struct
-			cam_fd_hw_dump_args));
-		if (rc) {
-			CAM_ERR(CAM_FD, "Hw Dump cmd fails req %lld rc %d",
-				frame_req->request_id, rc);
-			return rc;
-		}
-	}
-	CAM_DBG(CAM_FD, "Offset before %zu after %zu",
-		dump_args->offset, fd_dump_args.offset);
-	dump_args->offset = fd_dump_args.offset;
-	return rc;
-}
-
 static int cam_fd_mgr_hw_stop(void *hw_mgr_priv, void *mgr_stop_args)
 {
 	struct cam_fd_hw_mgr *hw_mgr = (struct cam_fd_hw_mgr *)hw_mgr_priv;
@@ -1697,6 +1534,8 @@ static int cam_fd_mgr_hw_stop(void *hw_mgr_priv, void *mgr_stop_args)
 	CAM_DBG(CAM_FD, "FD Device ready_to_process = %d",
 		hw_device->ready_to_process);
 
+	hw_device->ready_to_process = true;
+
 	if (hw_device->hw_intf->hw_ops.deinit) {
 		hw_deinit_args.hw_ctx = hw_ctx;
 		hw_deinit_args.ctx_hw_private = hw_ctx->ctx_hw_private;
@@ -1834,7 +1673,6 @@ static int cam_fd_mgr_hw_config(void *hw_mgr_priv, void *hw_config_args)
 	struct cam_fd_mgr_frame_request *frame_req;
 	int rc;
 	int i;
-	uint64_t req_id;
 
 	if (!hw_mgr || !config) {
 		CAM_ERR(CAM_FD, "Invalid arguments %pK %pK", hw_mgr, config);
@@ -1853,7 +1691,6 @@ static int cam_fd_mgr_hw_config(void *hw_mgr_priv, void *hw_config_args)
 	}
 
 	frame_req = config->priv;
-	req_id = frame_req->request_id;
 
 	trace_cam_apply_req("FD", frame_req->request_id);
 	CAM_DBG(CAM_FD, "FrameHWConfig : Frame[%lld]", frame_req->request_id);
@@ -1883,13 +1720,6 @@ static int cam_fd_mgr_hw_config(void *hw_mgr_priv, void *hw_config_args)
 		goto put_free_list;
 	}
 
-	mutex_lock(&g_fd_hw_mgr.frame_req_mutex);
-	hw_mgr->num_pending_frames++;
-	CAM_DBG(CAM_FD,
-		"Adding ctx[%pK] Req[%llu] : Total number of pending frames %d",
-		hw_ctx, req_id, hw_mgr->num_pending_frames);
-	mutex_unlock(&g_fd_hw_mgr.frame_req_mutex);
-
 	rc = cam_fd_mgr_util_schedule_frame_worker_task(hw_mgr);
 	if (rc) {
 		CAM_ERR(CAM_FD, "Worker task scheduling failed %d", rc);
@@ -1909,10 +1739,6 @@ static int cam_fd_mgr_hw_config(void *hw_mgr_priv, void *hw_config_args)
 		cam_fd_mgr_util_get_frame_req(
 			&hw_mgr->frame_pending_list_normal, &frame_req);
 	}
-
-	mutex_lock(&g_fd_hw_mgr.frame_req_mutex);
-	hw_mgr->num_pending_frames--;
-	mutex_unlock(&g_fd_hw_mgr.frame_req_mutex);
 put_free_list:
 	cam_fd_mgr_util_put_frame_req(&hw_mgr->frame_free_list,
 		&frame_req);
@@ -1936,11 +1762,6 @@ int cam_fd_hw_mgr_deinit(struct device_node *of_node)
 	return 0;
 }
 
-static void cam_req_mgr_process_workq_cam_fd_worker(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 int cam_fd_hw_mgr_init(struct device_node *of_node,
 	struct cam_hw_mgr_intf *hw_mgr_intf)
 {
@@ -1988,8 +1809,6 @@ int cam_fd_hw_mgr_init(struct device_node *of_node,
 		hw_device->valid = true;
 		hw_device->hw_intf = hw_intf;
 		hw_device->ready_to_process = true;
-		hw_device->req_id = -1;
-		hw_device->cur_hw_ctx = NULL;
 
 		if (hw_device->hw_intf->hw_ops.process_cmd) {
 			struct cam_fd_hw_cmd_set_irq_cb irq_cb_args;
@@ -2042,7 +1861,6 @@ int cam_fd_hw_mgr_init(struct device_node *of_node,
 	g_fd_hw_mgr.device_iommu.secure = -1;
 	g_fd_hw_mgr.cdm_iommu.non_secure = -1;
 	g_fd_hw_mgr.cdm_iommu.secure = -1;
-	g_fd_hw_mgr.num_pending_frames = 0;
 
 	rc = cam_smmu_get_handle("fd",
 		&g_fd_hw_mgr.device_iommu.non_secure);
@@ -2086,8 +1904,7 @@ int cam_fd_hw_mgr_init(struct device_node *of_node,
 	}
 
 	rc = cam_req_mgr_workq_create("cam_fd_worker", CAM_FD_WORKQ_NUM_TASK,
-		&g_fd_hw_mgr.work, CRM_WORKQ_USAGE_IRQ, 0, true,
-		cam_req_mgr_process_workq_cam_fd_worker);
+		&g_fd_hw_mgr.work, CRM_WORKQ_USAGE_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_FD, "Unable to create a worker, rc=%d", rc);
 		goto detach_smmu;
@@ -2126,7 +1943,6 @@ int cam_fd_hw_mgr_init(struct device_node *of_node,
 	hw_mgr_intf->hw_write = NULL;
 	hw_mgr_intf->hw_close = NULL;
 	hw_mgr_intf->hw_flush = cam_fd_mgr_hw_flush;
-	hw_mgr_intf->hw_dump = cam_fd_mgr_hw_dump;
 
 	return rc;
 
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.h b/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.h
index 53daf2185203..49bc5bbc1b07 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.h
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/cam_fd_hw_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_FD_HW_MGR_H_
@@ -21,12 +21,6 @@
 #define CAM_FD_HW_MAX            1
 #define CAM_FD_WORKQ_NUM_TASK    10
 
-/*
- * Response time threshold in ms beyond which a request is not expected to be
- * with FD hw
- */
-#define CAM_FD_RESPONSE_TIME_THRESHOLD   100000
-
 struct cam_fd_hw_mgr;
 
 /**
@@ -106,7 +100,6 @@ struct cam_fd_device {
  * @hw_update_entries     : HW update entries corresponding to this request
  *                          which needs to be submitted to HW through CDM
  * @num_hw_update_entries : Number of HW update entries
- * @submit_timestamp      : Time stamp for submit req with hw
  */
 struct cam_fd_mgr_frame_request {
 	struct list_head               list;
@@ -115,7 +108,6 @@ struct cam_fd_mgr_frame_request {
 	struct cam_fd_hw_req_private   hw_req_private;
 	struct cam_hw_update_entry     hw_update_entries[CAM_FD_MAX_HW_ENTRIES];
 	uint32_t                       num_hw_update_entries;
-	ktime_t                        submit_timestamp;
 };
 
 /**
@@ -159,8 +151,6 @@ struct cam_fd_mgr_work_data {
  * @work                      : Worker handle
  * @work_data                 : Worker data
  * @fd_caps                   : FD driver capabilities
- * @num_pending_frames        : Number of total frames pending for processing
- *                              across contexts
  */
 struct cam_fd_hw_mgr {
 	struct list_head                   free_ctx_list;
@@ -184,7 +174,6 @@ struct cam_fd_hw_mgr {
 	struct cam_req_mgr_core_workq     *work;
 	struct cam_fd_mgr_work_data        work_data[CAM_FD_WORKQ_NUM_TASK];
 	struct cam_fd_query_cap_cmd        fd_caps;
-	uint32_t                           num_pending_frames;
 };
 
 #endif /* _CAM_FD_HW_MGR_H_ */
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.c b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.c
index 7ff03e806a55..b6084eeec52b 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.c
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_fd_hw_core.h"
@@ -516,80 +516,6 @@ static int cam_fd_hw_util_processcmd_frame_done(struct cam_hw_info *fd_hw,
 	return 0;
 }
 
-static int cam_fd_hw_util_processcmd_hw_dump(
-	struct cam_hw_info *fd_hw,
-	void               *args)
-{
-	int                            i, j;
-	uint8_t                       *dst;
-	uint32_t                      *addr, *start;
-	uint32_t                       num_reg, min_len;
-	uint64_t                       remain_len;
-	struct cam_hw_soc_info        *soc_info;
-	struct cam_fd_hw_dump_header  *hdr;
-	struct cam_fd_hw_dump_args    *dump_args;
-
-	if (!fd_hw || !args) {
-		CAM_ERR(CAM_FD, "Invalid args %pK %pK",
-			fd_hw, args);
-		return -EINVAL;
-	}
-
-	mutex_lock(&fd_hw->hw_mutex);
-
-	if (fd_hw->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_INFO(CAM_FD, "power off state");
-		mutex_unlock(&fd_hw->hw_mutex);
-		return 0;
-	}
-
-	dump_args = (struct cam_fd_hw_dump_args *)args;
-	soc_info = &fd_hw->soc_info;
-
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_FD, "dump offset overshoot len %zu offset %zu",
-			dump_args->buf_len, dump_args->offset);
-		mutex_unlock(&fd_hw->hw_mutex);
-		return -ENOSPC;
-	}
-
-	remain_len = dump_args->buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_fd_hw_dump_header) +
-		    soc_info->reg_map[0].size + sizeof(uint32_t);
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_FD, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		mutex_unlock(&fd_hw->hw_mutex);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_fd_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_FD_HW_DUMP_TAG_MAX_LEN,
-		"FD_REG:");
-	hdr->word_size = sizeof(uint32_t);
-	addr = (uint32_t *)(dst + sizeof(struct cam_fd_hw_dump_header));
-	start = addr;
-	*addr++ = soc_info->index;
-
-	for (j = 0; j < soc_info->num_reg_map; j++) {
-		num_reg = soc_info->reg_map[j].size/4;
-		for (i = 0; i < num_reg; i++) {
-			*addr++ = soc_info->mem_block[j]->start + i*4;
-			*addr++ = cam_io_r(soc_info->reg_map[j].mem_base +
-				(i*4));
-		}
-	}
-
-	mutex_unlock(&fd_hw->hw_mutex);
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_fd_hw_dump_header);
-	CAM_DBG(CAM_FD, "%zu", dump_args->offset);
-	return 0;
-}
-
 irqreturn_t cam_fd_hw_irq(int irq_num, void *data)
 {
 	struct cam_hw_info *fd_hw = (struct cam_hw_info *)data;
@@ -747,15 +673,13 @@ int cam_fd_hw_init(void *hw_priv, void *init_hw_args, uint32_t arg_size)
 	fd_core->core_state = CAM_FD_CORE_STATE_IDLE;
 	spin_unlock_irqrestore(&fd_core->spin_lock, flags);
 
-	if (init_args->reset_required) {
-		rc = cam_fd_hw_reset(hw_priv, NULL, 0);
-		if (rc) {
-			CAM_ERR(CAM_FD, "Reset Failed, rc=%d", rc);
-			goto disable_soc;
-		}
-
-		init_args->is_hw_reset = true;
-	}
+    if (init_args->reset_required){
+        rc = cam_fd_hw_reset(hw_priv, NULL, 0);
+        if (rc) {
+            CAM_ERR(CAM_FD, "Reset Failed, rc=%d", rc);
+            goto disable_soc;
+        }
+    }
 
 	cam_fd_hw_util_enable_power_on_settings(fd_hw);
 
@@ -1234,11 +1158,6 @@ int cam_fd_hw_process_cmd(void *hw_priv, uint32_t cmd_type,
 			cmd_frame_results);
 		break;
 	}
-	case CAM_FD_HW_CMD_HW_DUMP: {
-		rc = cam_fd_hw_util_processcmd_hw_dump(fd_hw,
-			cmd_args);
-		break;
-	}
 	default:
 		break;
 	}
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.h b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.h
index 22bcdf6fc733..75e4263517fe 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.h
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_core.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_FD_HW_CORE_H_
@@ -135,13 +135,12 @@ struct cam_fd_wrapper_regs {
  * @ro_mode_enable_always   : Whether to enable ro mode always
  * @ro_mode_results_invalid : Whether results written directly into output
  *                            memory by HW are valid or not
- * @skip_reset              : Whether to skip reset during init
  */
 struct cam_fd_hw_errata_wa {
 	bool   single_irq_only;
 	bool   ro_mode_enable_always;
 	bool   ro_mode_results_invalid;
-	bool   skip_reset;
+    bool   skip_reset;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_dev.c b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_dev.c
index 7a42379512be..ddf7c60140c2 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_dev.c
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/platform_device.h>
@@ -110,8 +110,8 @@ static int cam_fd_hw_dev_probe(struct platform_device *pdev)
 
 	memset(&init_args, 0x0, sizeof(init_args));
 	memset(&deinit_args, 0x0, sizeof(deinit_args));
-	init_args.reset_required = true;
-	rc = cam_fd_hw_init(fd_hw, &init_args, sizeof(init_args));
+    init_args.reset_required = true;
+    rc = cam_fd_hw_init(fd_hw, &init_args, sizeof(init_args));
 	if (rc) {
 		CAM_ERR(CAM_FD, "Failed to hw init, rc=%d", rc);
 		goto deinit_platform_res;
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_intf.h b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_intf.h
index 82d18ccf85dd..ede4cfded0bc 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_intf.h
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_FD_HW_INTF_H_
@@ -24,8 +24,6 @@
 
 #define CAM_FD_MAX_IO_BUFFERS        5
 #define CAM_FD_MAX_HW_ENTRIES        5
-#define CAM_FD_HW_DUMP_TAG_MAX_LEN   32
-#define CAM_FD_HW_DUMP_NUM_WORDS     5
 
 /**
  * enum cam_fd_hw_type - Enum for FD HW type
@@ -83,14 +81,12 @@ enum cam_fd_hw_irq_type {
  * @CAM_FD_HW_CMD_UPDATE_SOC        : Command to process soc update
  * @CAM_FD_HW_CMD_REGISTER_CALLBACK : Command to set hw mgr callback
  * @CAM_FD_HW_CMD_MAX               : Indicates max cmd
- * @CAM_FD_HW_CMD_HW_DUMP           : Command to dump fd hw information
  */
 enum cam_fd_hw_cmd_type {
 	CAM_FD_HW_CMD_PRESTART,
 	CAM_FD_HW_CMD_FRAME_DONE,
 	CAM_FD_HW_CMD_UPDATE_SOC,
 	CAM_FD_HW_CMD_REGISTER_CALLBACK,
-	CAM_FD_HW_CMD_HW_DUMP,
 	CAM_FD_HW_CMD_MAX,
 };
 
@@ -163,13 +159,11 @@ struct cam_fd_hw_release_args {
  * @hw_ctx         : HW context for which init is requested
  * @ctx_hw_private : HW layer's private information specific to this hw context
  * @reset_required : Indicates if the reset is required during init or not
- * @is_hw_reset    : Output from hw layer, whether hw is reset on this init
  */
 struct cam_fd_hw_init_args {
 	void    *hw_ctx;
 	void    *ctx_hw_private;
-	bool     reset_required;
-	bool     is_hw_reset;
+    bool     reset_required;
 };
 
 /**
@@ -287,32 +281,4 @@ struct cam_fd_hw_cmd_set_irq_cb {
 	void *data;
 };
 
-/**
- * struct cam_fd_hw_dump_args : Args for dump request
- *
- * @request_id   : Issue request id
- * @offset       : offset of the buffer
- * @buf_len      : Length of target buffer
- * @cpu_addr     : start address of the target buffer
- */
-struct cam_fd_hw_dump_args {
-	uint64_t  request_id;
-	size_t    offset;
-	size_t    buf_len;
-	uintptr_t cpu_addr;
-};
-
-/**
- * struct cam_fd_hw_dump_header : fd hw dump header
- *
- * @tag       : fd hw dump header tag
- * @size      : Size of data
- * @word_size : size of each word
- */
-struct cam_fd_hw_dump_header {
-	uint8_t  tag[CAM_FD_HW_DUMP_TAG_MAX_LEN];
-	uint64_t size;
-	uint32_t word_size;
-};
-
 #endif /* _CAM_FD_HW_INTF_H_ */
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_soc.c b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_soc.c
index c3d5a68c6910..a5a327094e25 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_soc.c
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_soc.c
@@ -71,6 +71,39 @@ static int cam_fd_hw_soc_util_setup_regbase_indices(
 	return 0;
 }
 
+static int cam_fd_soc_set_clk_flags(struct cam_hw_soc_info *soc_info)
+{
+	int i, rc = 0;
+
+	if (soc_info->num_clk > CAM_SOC_MAX_CLK) {
+		CAM_ERR(CAM_FD, "Invalid num clk %d", soc_info->num_clk);
+		return -EINVAL;
+	}
+
+	/* set memcore and mem periphery logic flags to 0 */
+	for (i = 0; i < soc_info->num_clk; i++) {
+		if ((strcmp(soc_info->clk_name[i], "fd_core_clk") == 0) ||
+			(strcmp(soc_info->clk_name[i], "fd_core_uar_clk") ==
+			0)) {
+			rc = cam_soc_util_set_clk_flags(soc_info, i,
+				CLKFLAG_NORETAIN_MEM);
+			if (rc)
+				CAM_ERR(CAM_FD,
+					"Failed in NORETAIN_MEM i=%d, rc=%d",
+					i, rc);
+
+			cam_soc_util_set_clk_flags(soc_info, i,
+				CLKFLAG_NORETAIN_PERIPH);
+			if (rc)
+				CAM_ERR(CAM_FD,
+					"Failed in NORETAIN_PERIPH i=%d, rc=%d",
+					i, rc);
+		}
+	}
+
+	return rc;
+}
+
 void cam_fd_soc_register_write(struct cam_hw_soc_info *soc_info,
 	enum cam_fd_reg_base reg_base, uint32_t reg_offset, uint32_t reg_value)
 {
@@ -102,6 +135,7 @@ uint32_t cam_fd_soc_register_read(struct cam_hw_soc_info *soc_info,
 	return reg_value;
 }
 
+
 int cam_fd_soc_enable_resources(struct cam_hw_soc_info *soc_info)
 {
 	struct cam_fd_soc_private *soc_private = soc_info->soc_private;
@@ -195,6 +229,12 @@ int cam_fd_soc_init_resources(struct cam_hw_soc_info *soc_info,
 		return rc;
 	}
 
+	rc = cam_fd_soc_set_clk_flags(soc_info);
+	if (rc) {
+		CAM_ERR(CAM_FD, "failed in set_clk_flags rc=%d", rc);
+		goto release_res;
+	}
+
 	soc_private = kzalloc(sizeof(struct cam_fd_soc_private), GFP_KERNEL);
 	if (!soc_private) {
 		rc = -ENOMEM;
diff --git a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_v501.h b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_v501.h
index d8b78d6e4414..a9438bd3c898 100644
--- a/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_v501.h
+++ b/techpack/camera/drivers/cam_fd/fd_hw_mgr/fd_hw/cam_fd_hw_v501.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_FD_HW_V501_H_
@@ -50,7 +50,7 @@ static struct cam_fd_hw_static_info cam_fd_wrapper200_core501_info = {
 		.single_irq_only         = true,
 		.ro_mode_enable_always   = true,
 		.ro_mode_results_invalid = true,
-		.skip_reset              = true,
+        .skip_reset              = true,
 	},
 	.irq_mask = CAM_FD_IRQ_TO_MASK(CAM_FD_IRQ_FRAME_DONE) |
 		CAM_FD_IRQ_TO_MASK(CAM_FD_IRQ_HALT_DONE) |
diff --git a/techpack/camera/drivers/cam_icp/cam_icp_context.c b/techpack/camera/drivers/cam_icp/cam_icp_context.c
index 6a9f57b65f68..180ea7152a76 100644
--- a/techpack/camera/drivers/cam_icp/cam_icp_context.c
+++ b/techpack/camera/drivers/cam_icp/cam_icp_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/debugfs.h>
@@ -107,19 +107,6 @@ static int __cam_icp_start_dev_in_acquired(struct cam_context *ctx,
 	return rc;
 }
 
-static int __cam_icp_dump_dev_in_ready(
-	struct cam_context      *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int rc;
-
-	rc = cam_context_dump_dev_to_hw(ctx, cmd);
-	if (rc)
-		CAM_ERR(CAM_ICP, "Failed to dump device");
-
-	return rc;
-}
-
 static int __cam_icp_flush_dev_in_ready(struct cam_context *ctx,
 	struct cam_flush_dev_cmd *cmd)
 {
@@ -243,7 +230,6 @@ static struct cam_ctx_ops
 			.start_dev = __cam_icp_start_dev_in_acquired,
 			.config_dev = __cam_icp_config_dev_in_ready,
 			.flush_dev = __cam_icp_flush_dev_in_ready,
-			.dump_dev = __cam_icp_dump_dev_in_ready,
 		},
 		.crm_ops = {},
 		.irq_ops = __cam_icp_handle_buf_done_in_ready,
@@ -256,7 +242,6 @@ static struct cam_ctx_ops
 			.release_dev = __cam_icp_release_dev_in_ready,
 			.config_dev = __cam_icp_config_dev_in_ready,
 			.flush_dev = __cam_icp_flush_dev_in_ready,
-			.dump_dev = __cam_icp_dump_dev_in_ready,
 		},
 		.crm_ops = {},
 		.irq_ops = __cam_icp_handle_buf_done_in_ready,
diff --git a/techpack/camera/drivers/cam_icp/cam_icp_subdev.c b/techpack/camera/drivers/cam_icp/cam_icp_subdev.c
index 128b171f8659..bdb2ed5f900b 100644
--- a/techpack/camera/drivers/cam_icp/cam_icp_subdev.c
+++ b/techpack/camera/drivers/cam_icp/cam_icp_subdev.c
@@ -75,8 +75,6 @@ static int cam_icp_subdev_open(struct v4l2_subdev *sd,
 	struct cam_node *node = v4l2_get_subdevdata(sd);
 	int rc = 0;
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
-
 	mutex_lock(&g_icp_dev.icp_lock);
 	if (g_icp_dev.open_cnt >= 1) {
 		CAM_ERR(CAM_ICP, "ICP subdev is already opened");
@@ -99,7 +97,6 @@ static int cam_icp_subdev_open(struct v4l2_subdev *sd,
 	g_icp_dev.open_cnt++;
 end:
 	mutex_unlock(&g_icp_dev.icp_lock);
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
 	return rc;
 }
 
diff --git a/techpack/camera/drivers/cam_icp/fw_inc/hfi_intf.h b/techpack/camera/drivers/cam_icp/fw_inc/hfi_intf.h
index d804ff7bde44..afd42d23b9fb 100644
--- a/techpack/camera/drivers/cam_icp/fw_inc/hfi_intf.h
+++ b/techpack/camera/drivers/cam_icp/fw_inc/hfi_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2019, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _HFI_INTF_H_
@@ -146,10 +146,9 @@ int hfi_cmd_ubwc_config_ext(uint32_t *ubwc_ipe_cfg,
 /**
  * hfi_cmd_ubwc_config() - UBWC configuration to firmware
  *                         for older targets
- * @ubwc_cfg:           UBWC configuration parameters
- * @disable_ubwc_comp:  Disable UBWC compression
+ * @ubwc_cfg: UBWC configuration parameters
  */
-int hfi_cmd_ubwc_config(uint32_t *ubwc_cfg, bool disable_ubwc_comp);
+int hfi_cmd_ubwc_config(uint32_t *ubwc_cfg);
 
 /**
  * cam_hfi_resume() - function to resume
diff --git a/techpack/camera/drivers/cam_icp/fw_inc/hfi_sys_defs.h b/techpack/camera/drivers/cam_icp/fw_inc/hfi_sys_defs.h
index a197503e7413..905b85a53633 100644
--- a/techpack/camera/drivers/cam_icp/fw_inc/hfi_sys_defs.h
+++ b/techpack/camera/drivers/cam_icp/fw_inc/hfi_sys_defs.h
@@ -36,7 +36,6 @@
 #define HFI_ERR_SYS_UNSUPPORT_CMD       (HFI_COMMON_BASE + 0x4)
 #define HFI_ERR_SYS_CMDFAILED           (HFI_COMMON_BASE + 0x5)
 #define HFI_ERR_SYS_CMDSIZE             (HFI_COMMON_BASE + 0x6)
-#define HFI_ERR_SYS_RESET_FAILURE       (HFI_COMMON_BASE + 0x7)
 
 /* System Level Event types */
 #define HFI_EVENT_SYS_ERROR             (HFI_COMMON_BASE + 0x1)
@@ -83,12 +82,6 @@
 #define CAMERAICP_EHWVIOLATION         11
 #define CAMERAICP_ECDMERROR            12
 
-/* HFI Specific errors. */
-#define CAMERAICP_HFI_ERR_COMMAND_SIZE 1000
-#define CAMERAICP_HFI_ERR_MESSAGE_SIZE 1001
-#define CAMERAICP_HFI_QUEUE_EMPTY      1002
-#define CAMERAICP_HFI_QUEUE_FULL       1003
-
 /* Core level commands */
 /* IPE/BPS core Commands */
 #define HFI_CMD_IPE_BPS_COMMON_START \
diff --git a/techpack/camera/drivers/cam_icp/hfi.c b/techpack/camera/drivers/cam_icp/hfi.c
index 7cf22f23dd2b..89a95aca62e1 100644
--- a/techpack/camera/drivers/cam_icp/hfi.c
+++ b/techpack/camera/drivers/cam_icp/hfi.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2019, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/io.h>
@@ -269,7 +269,7 @@ int hfi_read_message(uint32_t *pmsg, uint8_t q_id,
 	return rc;
 }
 
-int hfi_cmd_ubwc_config(uint32_t *ubwc_cfg, bool disable_ubwc_comp)
+int hfi_cmd_ubwc_config(uint32_t *ubwc_cfg)
 {
 	uint8_t *prop;
 	struct hfi_cmd_prop *dbg_prop;
@@ -292,11 +292,6 @@ int hfi_cmd_ubwc_config(uint32_t *ubwc_cfg, bool disable_ubwc_comp)
 	dbg_prop->num_prop = 1;
 	dbg_prop->prop_data[0] = HFI_PROP_SYS_UBWC_CFG;
 	dbg_prop->prop_data[1] = ubwc_cfg[0];
-	if (disable_ubwc_comp) {
-		ubwc_cfg[1] &= ~CAM_ICP_UBWC_COMP_EN;
-		CAM_DBG(CAM_ICP, "UBWC comp force disable, val= 0x%x",
-			ubwc_cfg[1]);
-	}
 	dbg_prop->prop_data[2] = ubwc_cfg[1];
 
 	hfi_write_cmd(prop);
diff --git a/techpack/camera/drivers/cam_icp/icp_hw/a5_hw/a5_core.c b/techpack/camera/drivers/cam_icp/icp_hw/a5_hw/a5_core.c
index 4a6d1cec0e73..e4cb645b7af0 100644
--- a/techpack/camera/drivers/cam_icp/icp_hw/a5_hw/a5_core.c
+++ b/techpack/camera/drivers/cam_icp/icp_hw/a5_hw/a5_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -235,53 +235,6 @@ static int32_t cam_a5_download_fw(void *device_priv)
 	return rc;
 }
 
-static int cam_a5_fw_dump(
-	struct cam_icp_hw_dump_args    *dump_args,
-	struct cam_a5_device_core_info *core_info)
-{
-	u8                         *dest;
-	u8                         *src;
-	uint64_t                    size_required;
-	struct cam_icp_dump_header *hdr;
-
-	if (!core_info || !dump_args) {
-		CAM_ERR(CAM_ICP, "invalid params %pK %pK",
-		    core_info, dump_args);
-		return -EINVAL;
-	}
-	if (!core_info->fw_kva_addr || !dump_args->cpu_addr) {
-		CAM_ERR(CAM_ICP, "invalid params %pK, 0x%zx",
-		    core_info->fw_kva_addr, dump_args->cpu_addr);
-		return -EINVAL;
-	}
-
-	size_required = core_info->fw_buf_len +
-		sizeof(struct cam_icp_dump_header);
-
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_ICP, "Dump offset overshoot len %zu offset %zu",
-			dump_args->buf_len, dump_args->offset);
-		return -ENOSPC;
-	}
-
-	if ((dump_args->buf_len - dump_args->offset) < size_required) {
-		CAM_WARN(CAM_ICP, "Dump buffer exhaust required %llu len %llu",
-			size_required, core_info->fw_buf_len);
-		return -ENOSPC;
-	}
-
-	dest = (u8 *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_icp_dump_header *)dest;
-	scnprintf(hdr->tag, CAM_ICP_DUMP_TAG_MAX_LEN, "ICP_FW:");
-	hdr->word_size = sizeof(u8);
-	hdr->size = core_info->fw_buf_len;
-	src = (u8 *)core_info->fw_kva_addr;
-	dest = (u8 *)dest + sizeof(struct cam_icp_dump_header);
-	memcpy_fromio(dest, src, core_info->fw_buf_len);
-	dump_args->offset += hdr->size + sizeof(struct cam_icp_dump_header);
-	return 0;
-}
-
 int cam_a5_init_hw(void *device_priv,
 	void *init_hw_args, uint32_t arg_size)
 {
@@ -535,7 +488,6 @@ int cam_a5_process_cmd(void *device_priv, uint32_t cmd_type,
 		break;
 	case CAM_ICP_A5_CMD_UBWC_CFG: {
 		struct a5_ubwc_cfg_ext *ubwc_cfg_ext = NULL;
-		uint32_t *disable_ubwc_comp;
 
 		a5_soc = soc_info->soc_private;
 		if (!a5_soc) {
@@ -543,13 +495,6 @@ int cam_a5_process_cmd(void *device_priv, uint32_t cmd_type,
 			return -EINVAL;
 		}
 
-		if (!cmd_args) {
-			CAM_ERR(CAM_ICP, "Invalid args");
-			return -EINVAL;
-		}
-
-		disable_ubwc_comp = (uint32_t *)cmd_args;
-
 		if (a5_soc->ubwc_config_ext) {
 			/* Invoke kernel API to determine DDR type */
 			ddr_type = of_fdt_get_ddrtype();
@@ -566,24 +511,10 @@ int cam_a5_process_cmd(void *device_priv, uint32_t cmd_type,
 				ubwc_cfg_ext->ubwc_bps_fetch_cfg[index];
 			ubwc_bps_cfg[1] =
 				ubwc_cfg_ext->ubwc_bps_write_cfg[index];
-
-			if (*disable_ubwc_comp) {
-				ubwc_ipe_cfg[1] &= ~CAM_ICP_UBWC_COMP_EN;
-				ubwc_bps_cfg[1] &= ~CAM_ICP_UBWC_COMP_EN;
-				CAM_DBG(CAM_ISP,
-					"UBWC comp force disable, ubwc_ipe_cfg:  0x%x, ubwc_bps_cfg: 0x%x",
-					ubwc_ipe_cfg[1], ubwc_bps_cfg[1]);
-			}
-
 			rc = hfi_cmd_ubwc_config_ext(&ubwc_ipe_cfg[0],
 					&ubwc_bps_cfg[0]);
 		} else {
-			if (*disable_ubwc_comp)
-				rc = hfi_cmd_ubwc_config(
-					a5_soc->uconfig.ubwc_cfg, true);
-			else
-				rc = hfi_cmd_ubwc_config(
-					a5_soc->uconfig.ubwc_cfg, false);
+			rc = hfi_cmd_ubwc_config(a5_soc->uconfig.ubwc_cfg);
 		}
 
 		break;
@@ -612,12 +543,6 @@ int cam_a5_process_cmd(void *device_priv, uint32_t cmd_type,
 			core_info->cpas_handle, &ahb_vote);
 		break;
 	}
-	case CAM_ICP_A5_CMD_HW_DUMP: {
-		struct cam_icp_hw_dump_args *dump_args = cmd_args;
-
-		rc = cam_a5_fw_dump(dump_args, core_info);
-		break;
-	}
 	default:
 		break;
 	}
diff --git a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c
index 40bb64848b39..09a3fd1d2d81 100644
--- a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c
+++ b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/uaccess.h>
@@ -19,7 +19,6 @@
 #include <media/cam_defs.h>
 #include <media/cam_icp.h>
 #include <media/cam_cpas.h>
-#include <media/cam_req_mgr.h>
 
 #include "cam_sync_api.h"
 #include "cam_packet_util.h"
@@ -45,7 +44,6 @@
 #include "cam_trace.h"
 #include "cam_cpas_api.h"
 #include "cam_common_util.h"
-#include "cam_req_mgr_dev.h"
 
 #define ICP_WORKQ_TASK_CMD_TYPE 1
 #define ICP_WORKQ_TASK_MSG_TYPE 2
@@ -109,7 +107,6 @@ static int cam_icp_send_ubwc_cfg(struct cam_icp_hw_mgr *hw_mgr)
 {
 	struct cam_hw_intf *a5_dev_intf = NULL;
 	int rc;
-	uint32_t disable_ubwc_comp = 0;
 
 	a5_dev_intf = hw_mgr->a5_dev_intf;
 	if (!a5_dev_intf) {
@@ -117,12 +114,9 @@ static int cam_icp_send_ubwc_cfg(struct cam_icp_hw_mgr *hw_mgr)
 		return -EINVAL;
 	}
 
-	disable_ubwc_comp = hw_mgr->disable_ubwc_comp;
-
 	rc = a5_dev_intf->hw_ops.process_cmd(
 		a5_dev_intf->hw_priv,
-		CAM_ICP_A5_CMD_UBWC_CFG, (void *)&disable_ubwc_comp,
-		sizeof(disable_ubwc_comp));
+		CAM_ICP_A5_CMD_UBWC_CFG, NULL, 0);
 	if (rc)
 		CAM_ERR(CAM_ICP, "CAM_ICP_A5_CMD_UBWC_CFG is failed");
 
@@ -421,48 +415,73 @@ static int32_t cam_icp_deinit_idle_clk(void *priv, void *data)
 	return rc;
 }
 
-static int cam_icp_remove_ctx_bw(struct cam_icp_hw_mgr *hw_mgr,
-	struct cam_icp_hw_ctx_data *ctx_data)
+static int32_t cam_icp_ctx_timer(void *priv, void *data)
 {
-	int rc = 0;
-	struct cam_hw_intf *dev_intf = NULL;
+	struct clk_work_data *task_data = (struct clk_work_data *)data;
+	struct cam_icp_hw_ctx_data *ctx_data =
+		(struct cam_icp_hw_ctx_data *)task_data->data;
+	struct cam_icp_hw_mgr *hw_mgr = &icp_hw_mgr;
 	uint32_t id;
 	uint64_t temp;
+	struct cam_hw_intf *ipe0_dev_intf = NULL;
+	struct cam_hw_intf *ipe1_dev_intf = NULL;
+	struct cam_hw_intf *bps_dev_intf = NULL;
+	struct cam_hw_intf *dev_intf = NULL;
 	struct cam_icp_clk_info *clk_info;
 	struct cam_icp_cpas_vote clk_update;
 	int i = 0;
 	int device_share_ratio = 1;
 	uint64_t total_ab_bw = 0;
 
-	if (!ctx_data->icp_dev_acquire_info) {
-		CAM_WARN(CAM_ICP, "NULL acquire info");
+	if (!ctx_data) {
+		CAM_ERR(CAM_ICP, "ctx_data is NULL, failed to update clk");
 		return -EINVAL;
 	}
 
-	if ((!hw_mgr->ipe0_dev_intf) || (!hw_mgr->bps_dev_intf)) {
-		CAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");
-		return -EINVAL;
+	mutex_lock(&ctx_data->ctx_mutex);
+	if ((ctx_data->state != CAM_ICP_CTX_STATE_ACQUIRED) ||
+		(ctx_data->watch_dog_reset_counter == 0)) {
+		CAM_DBG(CAM_PERF, "state %d, counter=%d",
+			ctx_data->state, ctx_data->watch_dog_reset_counter);
+		mutex_unlock(&ctx_data->ctx_mutex);
+		return 0;
+	}
+
+	if (cam_icp_frame_pending(ctx_data)) {
+		cam_icp_ctx_timer_reset(ctx_data);
+		mutex_unlock(&ctx_data->ctx_mutex);
+		return -EBUSY;
 	}
 
 	CAM_DBG(CAM_PERF,
-		"ctx_id = %d ubw = %lld cbw = %lld curr_fc = %u bc = %u",
+		"E :ctx_id = %d ubw = %lld cbw = %lld curr_fc = %u bc = %u",
 		ctx_data->ctx_id,
 		ctx_data->clk_info.uncompressed_bw,
 		ctx_data->clk_info.compressed_bw,
 		ctx_data->clk_info.curr_fc, ctx_data->clk_info.base_clk);
 
-	if (!ctx_data->clk_info.bw_included) {
-		CAM_DBG(CAM_PERF, "ctx_id = %d BW vote already removed",
-			ctx_data->ctx_id);
-		return 0;
+	ipe0_dev_intf = hw_mgr->ipe0_dev_intf;
+	ipe1_dev_intf = hw_mgr->ipe1_dev_intf;
+	bps_dev_intf = hw_mgr->bps_dev_intf;
+
+	if ((!ipe0_dev_intf) || (!bps_dev_intf)) {
+		CAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");
+		mutex_unlock(&ctx_data->ctx_mutex);
+		return -EINVAL;
+	}
+
+	if (!ctx_data->icp_dev_acquire_info) {
+		CAM_WARN(CAM_ICP, "NULL acquire info");
+		mutex_unlock(&ctx_data->ctx_mutex);
+		return -EINVAL;
 	}
 
 	if (ctx_data->icp_dev_acquire_info->dev_type == CAM_ICP_RES_TYPE_BPS) {
-		dev_intf = hw_mgr->bps_dev_intf;
+		dev_intf = bps_dev_intf;
 		clk_info = &hw_mgr->clk_info[ICP_CLK_HW_BPS];
 		id = CAM_ICP_BPS_CMD_VOTE_CPAS;
 	} else {
-		dev_intf = hw_mgr->ipe0_dev_intf;
+		dev_intf = ipe0_dev_intf;
 		clk_info = &hw_mgr->clk_info[ICP_CLK_HW_IPE];
 		id = CAM_ICP_IPE_CMD_VOTE_CPAS;
 	}
@@ -473,7 +492,7 @@ static int cam_icp_remove_ctx_bw(struct cam_icp_hw_mgr *hw_mgr,
 	 * to vote on each device
 	 */
 	if ((ctx_data->icp_dev_acquire_info->dev_type !=
-		CAM_ICP_RES_TYPE_BPS) && (hw_mgr->ipe1_dev_intf))
+		CAM_ICP_RES_TYPE_BPS) && (ipe1_dev_intf))
 		device_share_ratio = 2;
 
 	if (ctx_data->bw_config_version == CAM_ICP_BW_CONFIG_V1) {
@@ -530,20 +549,23 @@ static int cam_icp_remove_ctx_bw(struct cam_icp_hw_mgr *hw_mgr,
 				 * votes only.
 				 */
 				path_index =
-				ctx_data->clk_info.axi_path[i].transac_type -
-				CAM_AXI_TRANSACTION_READ;
+					ctx_data->clk_info.axi_path[i]
+					.transac_type -
+					CAM_AXI_TRANSACTION_READ;
 			} else {
 				path_index =
-				ctx_data->clk_info.axi_path[i].path_data_type -
-				CAM_AXI_PATH_DATA_IPE_START_OFFSET;
+					ctx_data->clk_info.axi_path[i]
+					.path_data_type -
+					CAM_AXI_PATH_DATA_IPE_START_OFFSET;
 			}
 
 			if (path_index >= CAM_ICP_MAX_PER_PATH_VOTES) {
 				CAM_WARN(CAM_PERF,
-				"Invalid path %d, start offset=%d, max=%d",
-				ctx_data->clk_info.axi_path[i].path_data_type,
-				CAM_AXI_PATH_DATA_IPE_START_OFFSET,
-				CAM_ICP_MAX_PER_PATH_VOTES);
+					"Invalid path %d, start offset=%d, max=%d",
+					ctx_data->clk_info.axi_path[i]
+					.path_data_type,
+					CAM_AXI_PATH_DATA_IPE_START_OFFSET,
+					CAM_ICP_MAX_PER_PATH_VOTES);
 				continue;
 			}
 
@@ -560,30 +582,6 @@ static int cam_icp_remove_ctx_bw(struct cam_icp_hw_mgr *hw_mgr,
 
 			total_ab_bw +=
 				clk_info->axi_path[path_index].mnoc_ab_bw;
-
-			CAM_DBG(CAM_PERF,
-				"Removing ctx bw from path_type: %s, transac_type: %s, camnoc_bw = %lld mnoc_ab_bw = %lld, mnoc_ib_bw = %lld, device: %s",
-				cam_cpas_axi_util_path_type_to_string(
-				ctx_data->clk_info.axi_path[i].path_data_type),
-				cam_cpas_axi_util_trans_type_to_string(
-				ctx_data->clk_info.axi_path[i].transac_type),
-				ctx_data->clk_info.axi_path[i].camnoc_bw,
-				ctx_data->clk_info.axi_path[i].mnoc_ab_bw,
-				ctx_data->clk_info.axi_path[i].mnoc_ib_bw,
-				cam_icp_dev_type_to_name(
-				ctx_data->icp_dev_acquire_info->dev_type));
-
-			CAM_DBG(CAM_PERF,
-				"Final HW bw for path_type: %s, transac_type: %s, camnoc_bw = %lld mnoc_ab_bw = %lld, mnoc_ib_bw = %lld, device: %s",
-				cam_cpas_axi_util_path_type_to_string(
-				clk_info->axi_path[i].path_data_type),
-				cam_cpas_axi_util_trans_type_to_string(
-				clk_info->axi_path[i].transac_type),
-				clk_info->axi_path[i].camnoc_bw,
-				clk_info->axi_path[i].mnoc_ab_bw,
-				clk_info->axi_path[i].mnoc_ib_bw,
-				cam_icp_dev_type_to_name(
-				ctx_data->icp_dev_acquire_info->dev_type));
 		}
 
 		memset(&ctx_data->clk_info.axi_path[0], 0,
@@ -630,76 +628,22 @@ static int cam_icp_remove_ctx_bw(struct cam_icp_hw_mgr *hw_mgr,
 		clk_update.ahb_vote_valid = false;
 	}
 
-	rc = dev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,
+	dev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,
 		&clk_update, sizeof(clk_update));
-	if (rc)
-		CAM_ERR(CAM_PERF, "Failed in updating cpas vote, rc=%d", rc);
 
 	/*
 	 * Vote half bandwidth each on both devices.
 	 * Total bw at mnoc - CPAS will take care of adding up.
 	 * camnoc clk calculate is more accurate this way.
 	 */
-	if ((!rc) && (hw_mgr->ipe1_dev_intf) &&
-		(ctx_data->icp_dev_acquire_info->dev_type !=
-		CAM_ICP_RES_TYPE_BPS)) {
-		dev_intf = hw_mgr->ipe1_dev_intf;
-		rc = dev_intf->hw_ops.process_cmd(dev_intf->hw_priv,
-			id, &clk_update, sizeof(clk_update));
-		if (rc)
-			CAM_ERR(CAM_PERF,
-				"Failed in updating cpas vote for ipe 2, rc=%d",
-				rc);
-	}
-
-	ctx_data->clk_info.bw_included = false;
+	if ((ctx_data->icp_dev_acquire_info->dev_type !=
+		CAM_ICP_RES_TYPE_BPS) && (ipe1_dev_intf))
+		ipe1_dev_intf->hw_ops.process_cmd(ipe1_dev_intf->hw_priv, id,
+		&clk_update, sizeof(clk_update));
 
 	CAM_DBG(CAM_PERF, "X :ctx_id = %d curr_fc = %u bc = %u",
 		ctx_data->ctx_id, ctx_data->clk_info.curr_fc,
 		ctx_data->clk_info.base_clk);
-
-	return rc;
-
-}
-
-
-static int32_t cam_icp_ctx_timer(void *priv, void *data)
-{
-	struct clk_work_data *task_data = (struct clk_work_data *)data;
-	struct cam_icp_hw_ctx_data *ctx_data =
-		(struct cam_icp_hw_ctx_data *)task_data->data;
-
-	if (!ctx_data) {
-		CAM_ERR(CAM_ICP, "ctx_data is NULL, failed to update clk");
-		return -EINVAL;
-	}
-
-	mutex_lock(&ctx_data->ctx_mutex);
-
-	CAM_DBG(CAM_PERF,
-		"ctx_id = %d ubw = %lld cbw = %lld curr_fc = %u bc = %u",
-		ctx_data->ctx_id,
-		ctx_data->clk_info.uncompressed_bw,
-		ctx_data->clk_info.compressed_bw,
-		ctx_data->clk_info.curr_fc,
-		ctx_data->clk_info.base_clk);
-
-	if ((ctx_data->state != CAM_ICP_CTX_STATE_ACQUIRED) ||
-		(ctx_data->watch_dog_reset_counter == 0)) {
-		CAM_DBG(CAM_PERF, "state %d, counter=%d",
-			ctx_data->state, ctx_data->watch_dog_reset_counter);
-		mutex_unlock(&ctx_data->ctx_mutex);
-		return 0;
-	}
-
-	if (cam_icp_frame_pending(ctx_data)) {
-		cam_icp_ctx_timer_reset(ctx_data);
-		mutex_unlock(&ctx_data->ctx_mutex);
-		return -EBUSY;
-	}
-
-	cam_icp_remove_ctx_bw(&icp_hw_mgr, ctx_data);
-
 	mutex_unlock(&ctx_data->ctx_mutex);
 
 	return 0;
@@ -1240,8 +1184,6 @@ static bool cam_icp_update_bw_v2(struct cam_icp_hw_mgr *hw_mgr,
 			hw_mgr_clk_info->axi_path[path_index].mnoc_ab_bw);
 	}
 
-	ctx_data->clk_info.bw_included = true;
-
 	if (hw_mgr_clk_info->num_paths < ctx_data->clk_info.num_paths)
 		hw_mgr_clk_info->num_paths = ctx_data->clk_info.num_paths;
 
@@ -1308,8 +1250,6 @@ static bool cam_icp_update_bw(struct cam_icp_hw_mgr *hw_mgr,
 		}
 	}
 
-	ctx_data->clk_info.bw_included = true;
-
 	return true;
 }
 
@@ -1492,7 +1432,6 @@ static int cam_icp_update_clk_rate(struct cam_icp_hw_mgr *hw_mgr,
 static int cam_icp_update_cpas_vote(struct cam_icp_hw_mgr *hw_mgr,
 	struct cam_icp_hw_ctx_data *ctx_data)
 {
-	int rc = 0;
 	uint32_t id;
 	uint64_t temp;
 	int i = 0;
@@ -1590,10 +1529,8 @@ static int cam_icp_update_cpas_vote(struct cam_icp_hw_mgr *hw_mgr,
 	}
 
 	clk_update.axi_vote_valid = true;
-	rc = dev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,
+	dev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,
 		&clk_update, sizeof(clk_update));
-	if (rc)
-		CAM_ERR(CAM_PERF, "Failed in updating cpas vote, rc=%d", rc);
 
 	/*
 	 * Vote half bandwidth each on both devices.
@@ -1601,16 +1538,11 @@ static int cam_icp_update_cpas_vote(struct cam_icp_hw_mgr *hw_mgr,
 	 * camnoc clk calculate is more accurate this way.
 	 */
 	if ((ctx_data->icp_dev_acquire_info->dev_type !=
-		CAM_ICP_RES_TYPE_BPS) && (ipe1_dev_intf)) {
-		rc = ipe1_dev_intf->hw_ops.process_cmd(ipe1_dev_intf->hw_priv,
-			id, &clk_update, sizeof(clk_update));
-		if (rc)
-			CAM_ERR(CAM_PERF,
-				"Failed in updating cpas vote for ipe 2, rc=%d",
-				rc);
-	}
+		CAM_ICP_RES_TYPE_BPS) && (ipe1_dev_intf))
+		ipe1_dev_intf->hw_ops.process_cmd(ipe1_dev_intf->hw_priv, id,
+		&clk_update, sizeof(clk_update));
 
-	return rc;
+	return 0;
 }
 
 static int cam_icp_mgr_ipe_bps_clk_update(struct cam_icp_hw_mgr *hw_mgr,
@@ -1745,7 +1677,6 @@ static int cam_icp_mgr_ipe_bps_power_collapse(struct cam_icp_hw_mgr *hw_mgr,
 			bps_dev_intf->hw_ops.deinit
 				(bps_dev_intf->hw_priv, NULL, 0);
 			hw_mgr->bps_clk_state = false;
-			hw_mgr->clk_info[ICP_CLK_HW_BPS].curr_clk = 0;
 		}
 	} else {
 		CAM_DBG(CAM_PERF, "ipe ctx cnt %d", hw_mgr->ipe_ctxt_cnt);
@@ -1781,7 +1712,6 @@ static int cam_icp_mgr_ipe_bps_power_collapse(struct cam_icp_hw_mgr *hw_mgr,
 		}
 
 		hw_mgr->ipe_clk_state = false;
-		hw_mgr->clk_info[ICP_CLK_HW_IPE].curr_clk = 0;
 	}
 
 end:
@@ -1960,17 +1890,6 @@ static int cam_icp_hw_mgr_create_debugfs_entry(void)
 		goto err;
 	}
 
-	if (!debugfs_create_bool("disable_ubwc_comp",
-		0644,
-		icp_hw_mgr.dentry,
-		&icp_hw_mgr.disable_ubwc_comp)) {
-		CAM_ERR(CAM_ICP, "failed to create disable_ubwc_comp");
-		rc = -ENOMEM;
-		goto err;
-	}
-
-	/* Set default hang dump lvl */
-	icp_hw_mgr.a5_fw_dump_lvl = HFI_FW_DUMP_ON_FAILURE;
 	return rc;
 err:
 	debugfs_remove_recursive(icp_hw_mgr.dentry);
@@ -2036,70 +1955,6 @@ static int cam_icp_mgr_cleanup_ctx(struct cam_icp_hw_ctx_data *ctx_data)
 	return 0;
 }
 
-static const char *cam_icp_error_handle_id_to_type(
-	uint32_t error_handle)
-{
-	const char *name = NULL;
-
-	switch (error_handle) {
-	case CAMERAICP_SUCCESS:
-		name = "SUCCESS";
-		break;
-	case CAMERAICP_EFAILED:
-		name = "EFAILED";
-		break;
-	case CAMERAICP_ENOMEMORY:
-		name = "ENOMEMORY";
-		break;
-	case CAMERAICP_EBADSTATE:
-		name = "EBADSTATE";
-		break;
-	case CAMERAICP_EBADPARM:
-		name = "EBADPARM";
-		break;
-	case CAMERAICP_EBADITEM:
-		name = "EBADITEM";
-		break;
-	case CAMERAICP_EINVALIDFORMAT:
-		name = "EINVALIDFORMAT";
-		break;
-	case CAMERAICP_EUNSUPPORTED:
-		name = "EUNSUPPORTED";
-		break;
-	case CAMERAICP_EOUTOFBOUND:
-		name = "EOUTOFBOUND";
-		break;
-	case CAMERAICP_ETIMEDOUT:
-		name = "ETIMEDOUT";
-		break;
-	case CAMERAICP_EABORTED:
-		name = "EABORTED";
-		break;
-	case CAMERAICP_EHWVIOLATION:
-		name = "EHWVIOLATION";
-		break;
-	case CAMERAICP_ECDMERROR:
-		name = "ECDMERROR";
-		break;
-	case CAMERAICP_HFI_ERR_COMMAND_SIZE:
-		name = "HFI_ERR_COMMAND_SIZE";
-		break;
-	case CAMERAICP_HFI_ERR_MESSAGE_SIZE:
-		name = "HFI_ERR_MESSAGE_SIZE";
-		break;
-	case CAMERAICP_HFI_QUEUE_EMPTY:
-		name = "HFI_QUEUE_EMPTY";
-		break;
-	case CAMERAICP_HFI_QUEUE_FULL:
-		name = "HFI_QUEUE_FULL";
-		break;
-	default:
-		name = NULL;
-		break;
-	}
-	return name;
-}
-
 static int cam_icp_mgr_handle_frame_process(uint32_t *msg_ptr, int flag)
 {
 	int i;
@@ -2159,10 +2014,8 @@ static int cam_icp_mgr_handle_frame_process(uint32_t *msg_ptr, int flag)
 				ctx_data->icp_dev_acquire_info->dev_type);
 		else
 			CAM_ERR(CAM_ICP,
-				"Done with error: %u err_type= [%s] on ctx_id %d dev %d for req %llu",
+				"Done with error: %u on ctx_id %d dev %d for req %llu",
 				ioconfig_ack->err_type,
-				cam_icp_error_handle_id_to_type(
-				ioconfig_ack->err_type),
 				ctx_data->ctx_id,
 				ctx_data->icp_dev_acquire_info->dev_type,
 				request_id);
@@ -2235,13 +2088,8 @@ static int cam_icp_mgr_process_msg_config_io(uint32_t *msg_ptr)
 		ipe_config_ack =
 			(struct hfi_msg_ipe_config *)(ioconfig_ack->msg_data);
 		if (ipe_config_ack->rc) {
-			CAM_ERR(CAM_ICP, "rc = %d failed with\n"
-				"err_no = [%u] err_type = [%s]",
-				ipe_config_ack->rc,
-				ioconfig_ack->err_type,
-				cam_icp_error_handle_id_to_type(
-				ioconfig_ack->err_type));
-
+			CAM_ERR(CAM_ICP, "rc = %d err = %u",
+				ipe_config_ack->rc, ioconfig_ack->err_type);
 			return -EIO;
 		}
 		ctx_data = (struct cam_icp_hw_ctx_data *)
@@ -2406,13 +2254,9 @@ static int cam_icp_mgr_process_direct_ack_msg(uint32_t *msg_ptr)
 			(struct cam_icp_hw_ctx_data *)ioconfig_ack->user_data1;
 		if (ctx_data->state != CAM_ICP_CTX_STATE_FREE)
 			complete(&ctx_data->wait_complete);
-		CAM_DBG(CAM_ICP, "received IPE/BPS\n"
-			"MAP ACK:ctx_state =%d\n"
-			"failed with err_no = [%u] err_type = [%s]",
-			ctx_data->state,
-			ioconfig_ack->err_type,
-			cam_icp_error_handle_id_to_type(
-			ioconfig_ack->err_type));
+		CAM_DBG(CAM_ICP,
+			"received IPE/BPS MAP ACK:ctx_state =%d err_status =%u",
+			ctx_data->state, ioconfig_ack->err_type);
 		break;
 	case HFI_IPEBPS_CMD_OPCODE_MEM_UNMAP:
 		ioconfig_ack = (struct hfi_msg_ipebps_async_ack *)msg_ptr;
@@ -2421,12 +2265,8 @@ static int cam_icp_mgr_process_direct_ack_msg(uint32_t *msg_ptr)
 		if (ctx_data->state != CAM_ICP_CTX_STATE_FREE)
 			complete(&ctx_data->wait_complete);
 		CAM_DBG(CAM_ICP,
-			"received IPE/BPS UNMAP ACK:ctx_state =%d\n"
-			"failed with err_no = [%u] err_type = [%s]",
-			ctx_data->state,
-			ioconfig_ack->err_type,
-			cam_icp_error_handle_id_to_type(
-			ioconfig_ack->err_type));
+			"received IPE/BPS UNMAP ACK:ctx_state =%d err_status =%u",
+			ctx_data->state, ioconfig_ack->err_type);
 		break;
 	default:
 		CAM_ERR(CAM_ICP, "Invalid opcode : %u",
@@ -2504,9 +2344,7 @@ static int cam_icp_mgr_process_fatal_error(
 	struct cam_icp_hw_mgr *hw_mgr, uint32_t *msg_ptr)
 {
 	struct hfi_msg_event_notify *event_notify;
-	int rc = 0, i = 0;
-	struct cam_req_mgr_message req_msg;
-	struct cam_acquire_dev_cmd *acq_cmd;
+	int rc = 0;
 
 	CAM_DBG(CAM_ICP, "Enter");
 
@@ -2523,35 +2361,6 @@ static int cam_icp_mgr_process_fatal_error(
 
 	if (event_notify->event_id == HFI_EVENT_SYS_ERROR) {
 		CAM_INFO(CAM_ICP, "received HFI_EVENT_SYS_ERROR");
-		if (event_notify->event_data1 == HFI_ERR_SYS_FATAL) {
-			CAM_ERR(CAM_ICP, "received HFI_ERR_SYS_FATAL");
-			BUG();
-		} else if (event_notify->event_data1 ==
-			HFI_ERR_SYS_RESET_FAILURE) {
-			for (i = 0; i < CAM_ICP_CTX_MAX; i++) {
-				if (hw_mgr->ctx_data[i].state !=
-					CAM_CTX_ACQUIRED)
-					continue;
-
-				acq_cmd = &hw_mgr->ctx_data[i].acquire_dev_cmd;
-				CAM_INFO(CAM_ICP,
-					"Sending Full Recovery on sess %x",
-					acq_cmd->session_handle);
-
-				req_msg.session_hdl =
-					acq_cmd->session_handle;
-				req_msg.u.err_msg.device_hdl = -1;
-				req_msg.u.err_msg.link_hdl = -1;
-				req_msg.u.err_msg.request_id = 0;
-				req_msg.u.err_msg.resource_size = 0x0;
-				req_msg.u.err_msg.error_type =
-					CAM_REQ_MGR_ERROR_TYPE_FULL_RECOVERY;
-				cam_req_mgr_notify_message(&req_msg,
-					V4L_EVENT_CAM_REQ_MGR_ERROR,
-					V4L_EVENT_CAM_REQ_MGR_EVENT);
-				break;
-			}
-		}
 		rc = cam_icp_mgr_trigger_recovery(hw_mgr);
 		cam_icp_mgr_process_dbg_buf(icp_hw_mgr.a5_dbg_lvl);
 	}
@@ -3450,7 +3259,6 @@ static int cam_icp_mgr_release_ctx(struct cam_icp_hw_mgr *hw_mgr, int ctx_id)
 	}
 
 	mutex_lock(&hw_mgr->ctx_data[ctx_id].ctx_mutex);
-	cam_icp_remove_ctx_bw(hw_mgr, &hw_mgr->ctx_data[ctx_id]);
 	if (hw_mgr->ctx_data[ctx_id].state !=
 		CAM_ICP_CTX_STATE_ACQUIRED) {
 		mutex_unlock(&hw_mgr->ctx_data[ctx_id].ctx_mutex);
@@ -4089,7 +3897,6 @@ static int cam_icp_mgr_config_hw(void *hw_mgr_priv, void *config_hw_args)
 
 	cam_icp_mgr_ipe_bps_clk_update(hw_mgr, ctx_data, idx);
 	ctx_data->hfi_frame_process.fw_process_flag[idx] = true;
-	ctx_data->hfi_frame_process.submit_timestamp[idx] = ktime_get();
 
 	CAM_DBG(CAM_ICP, "req_id %llu, io config %llu", req_id,
 		frame_info->io_config);
@@ -4104,8 +3911,8 @@ static int cam_icp_mgr_config_hw(void *hw_mgr_priv, void *config_hw_args)
 
 	if (req_id <= ctx_data->last_flush_req)
 		CAM_WARN(CAM_ICP,
-			"Anomaly submitting flushed req %llu [last_flush %llu] in ctx %u",
-			req_id, ctx_data->last_flush_req, ctx_data->ctx_id);
+			"Anomaly detected submitting flushed req %llu in ctx %u",
+			req_id, ctx_data->ctx_id);
 
 	rc = cam_icp_mgr_enqueue_config(hw_mgr, config_args);
 	if (rc)
@@ -4850,8 +4657,6 @@ static void cam_icp_mgr_print_io_bufs(struct cam_packet *packet,
 
 		}
 	}
-	cam_packet_dump_patch_info(packet, icp_hw_mgr.iommu_hdl,
-		icp_hw_mgr.iommu_sec_hdl);
 }
 
 static int cam_icp_mgr_config_stream_settings(
@@ -5198,115 +5003,6 @@ static int cam_icp_mgr_enqueue_abort(
 	return 0;
 }
 
-static int cam_icp_mgr_hw_dump(void *hw_priv, void *hw_dump_args)
-{
-	int                              rc;
-	int                              i;
-	size_t                           remain_len;
-	uint8_t                         *dst;
-	uint32_t                         min_len;
-	uint64_t                         diff;
-	uint64_t                        *addr, *start;
-	struct timespec64                cur_ts;
-	struct timespec64                req_ts;
-	ktime_t                          cur_time;
-	struct cam_hw_intf              *a5_dev_intf;
-	struct cam_icp_hw_mgr           *hw_mgr;
-	struct cam_hw_dump_args         *dump_args;
-	struct cam_icp_hw_ctx_data      *ctx_data;
-	struct cam_icp_dump_header      *hdr;
-	struct cam_icp_hw_dump_args      icp_dump_args;
-	struct hfi_frame_process_info   *frm_process;
-
-	if ((!hw_priv) || (!hw_dump_args)) {
-		CAM_ERR(CAM_ICP, "Invalid params %pK %pK",
-			hw_priv, hw_dump_args);
-		return -EINVAL;
-	}
-
-	dump_args = (struct cam_hw_dump_args *)hw_dump_args;
-	hw_mgr = hw_priv;
-	ctx_data = dump_args->ctxt_to_hw_map;
-	CAM_DBG(CAM_ICP, "Req %lld", dump_args->request_id);
-	frm_process = &ctx_data->hfi_frame_process;
-	for (i = 0; i < CAM_FRAME_CMD_MAX; i++) {
-		if ((frm_process->request_id[i] ==
-			dump_args->request_id) &&
-			frm_process->fw_process_flag[i])
-			goto hw_dump;
-	}
-	return 0;
-hw_dump:
-	cur_time = ktime_get();
-	diff = ktime_us_delta(cur_time, frm_process->submit_timestamp[i]);
-	cur_ts = ktime_to_timespec64(cur_time);
-	req_ts = ktime_to_timespec64(frm_process->submit_timestamp[i]);
-
-	if (diff < CAM_ICP_CTX_RESPONSE_TIME_THRESHOLD) {
-		CAM_INFO(CAM_ICP, "No Error req %lld %ld:%06ld %ld:%06ld",
-			dump_args->request_id,
-			req_ts.tv_sec,
-			req_ts.tv_nsec/NSEC_PER_USEC,
-			cur_ts.tv_sec,
-			cur_ts.tv_nsec/NSEC_PER_USEC);
-		return 0;
-	}
-
-	CAM_INFO(CAM_ICP, "Error req %lld %ld:%06ld %ld:%06ld",
-		dump_args->request_id,
-		req_ts.tv_sec,
-		req_ts.tv_nsec/NSEC_PER_USEC,
-		cur_ts.tv_sec,
-		cur_ts.tv_nsec/NSEC_PER_USEC);
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&icp_dump_args.cpu_addr, &icp_dump_args.buf_len);
-	if (rc) {
-		CAM_ERR(CAM_ICP, "Invalid addr %u rc %d",
-			dump_args->buf_handle, rc);
-		return rc;
-	}
-	if (icp_dump_args.buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_ICP, "dump buffer overshoot len %zu offset %zu",
-			icp_dump_args.buf_len, dump_args->offset);
-		return -ENOSPC;
-	}
-
-	remain_len = icp_dump_args.buf_len - dump_args->offset;
-	min_len = sizeof(struct cam_icp_dump_header) +
-			(CAM_ICP_DUMP_NUM_WORDS * sizeof(uint64_t));
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_ICP, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)icp_dump_args.cpu_addr + dump_args->offset;
-	hdr = (struct cam_icp_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_ICP_DUMP_TAG_MAX_LEN, "ICP_REQ:");
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst + sizeof(struct cam_icp_dump_header));
-	start = addr;
-	*addr++ = frm_process->request_id[i];
-	*addr++ = req_ts.tv_sec;
-	*addr++ = req_ts.tv_nsec/NSEC_PER_USEC;
-	*addr++ = cur_ts.tv_sec;
-	*addr++ = cur_ts.tv_nsec/NSEC_PER_USEC;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += (hdr->size + sizeof(struct cam_icp_dump_header));
-	/* Dumping the fw image*/
-	icp_dump_args.offset = dump_args->offset;
-	a5_dev_intf = hw_mgr->a5_dev_intf;
-	rc = a5_dev_intf->hw_ops.process_cmd(
-		a5_dev_intf->hw_priv,
-		CAM_ICP_A5_CMD_HW_DUMP, &icp_dump_args,
-		sizeof(struct cam_icp_hw_dump_args));
-	CAM_DBG(CAM_ICP, "Offset before %zu after %zu",
-		dump_args->offset, icp_dump_args.offset);
-	dump_args->offset = icp_dump_args.offset;
-	return rc;
-}
-
 static int cam_icp_mgr_hw_flush(void *hw_priv, void *hw_flush_args)
 {
 	struct cam_hw_flush_args *flush_args = hw_flush_args;
@@ -5645,7 +5341,6 @@ static int cam_icp_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 	}
 	ctx_data = &hw_mgr->ctx_data[ctx_id];
 	ctx_data->ctx_id = ctx_id;
-	ctx_data->acquire_dev_cmd.session_handle = args->session_hdl;
 
 	mutex_lock(&ctx_data->ctx_mutex);
 	rc = cam_icp_get_acquire_info(hw_mgr, args, ctx_data);
@@ -5987,45 +5682,28 @@ static int cam_icp_mgr_init_devs(struct device_node *of_node)
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_icp_command_queue(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
-static void cam_req_mgr_process_workq_icp_message_queue(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
-static void cam_req_mgr_process_workq_icp_timer_queue(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 static int cam_icp_mgr_create_wq(void)
 {
 	int rc;
 	int i;
 
 	rc = cam_req_mgr_workq_create("icp_command_queue", ICP_WORKQ_NUM_TASK,
-		&icp_hw_mgr.cmd_work, CRM_WORKQ_USAGE_NON_IRQ, 0, false,
-		cam_req_mgr_process_workq_icp_command_queue);
+		&icp_hw_mgr.cmd_work, CRM_WORKQ_USAGE_NON_IRQ,
+		0);
 	if (rc) {
 		CAM_ERR(CAM_ICP, "unable to create a command worker");
 		goto cmd_work_failed;
 	}
 
 	rc = cam_req_mgr_workq_create("icp_message_queue", ICP_WORKQ_NUM_TASK,
-		&icp_hw_mgr.msg_work, CRM_WORKQ_USAGE_IRQ, 0, false,
-		cam_req_mgr_process_workq_icp_message_queue);
+		&icp_hw_mgr.msg_work, CRM_WORKQ_USAGE_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_ICP, "unable to create a message worker");
 		goto msg_work_failed;
 	}
 
 	rc = cam_req_mgr_workq_create("icp_timer_queue", ICP_WORKQ_NUM_TASK,
-		&icp_hw_mgr.timer_work, CRM_WORKQ_USAGE_IRQ, 0, false,
-		cam_req_mgr_process_workq_icp_timer_queue);
+		&icp_hw_mgr.timer_work, CRM_WORKQ_USAGE_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_ICP, "unable to create a timer worker");
 		goto timer_work_failed;
@@ -6137,7 +5815,6 @@ int cam_icp_hw_mgr_init(struct device_node *of_node, uint64_t *hw_mgr_hdl,
 	hw_mgr_intf->hw_close = cam_icp_mgr_hw_close_u;
 	hw_mgr_intf->hw_flush = cam_icp_mgr_hw_flush;
 	hw_mgr_intf->hw_cmd = cam_icp_mgr_cmd;
-	hw_mgr_intf->hw_dump = cam_icp_mgr_hw_dump;
 
 	icp_hw_mgr.secure_mode = CAM_SECURE_MODE_NON_SECURE;
 	mutex_init(&icp_hw_mgr.hw_mgr_mutex);
diff --git a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.h b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.h
index a2d62754c847..8cab9a80cd30 100644
--- a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.h
+++ b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_ICP_HW_MGR_H
@@ -67,12 +67,6 @@
 /* Current appliacble vote paths, based on number of UAPI definitions */
 #define CAM_ICP_MAX_PER_PATH_VOTES 6
 
-/*
- * Response time threshold in ms beyond which a request is not expected
- * to be with ICP hw
- */
-#define CAM_ICP_CTX_RESPONSE_TIME_THRESHOLD   300000
-
 /**
  * struct icp_hfi_mem_info
  * @qtbl: Memory info of queue table
@@ -177,7 +171,6 @@ struct cam_icp_clk_bw_req_internal_v2 {
  * @clk_info: Clock information for a request
  * @clk_info_v2: Clock info for AXI bw voting v2
  * @frame_info: information needed to process request
- * @submit_timestamp: Submit timestamp to hw
  */
 struct hfi_frame_process_info {
 	struct hfi_cmd_ipebps_async hfi_frame_cmd[CAM_FRAME_CMD_MAX];
@@ -193,7 +186,6 @@ struct hfi_frame_process_info {
 	struct cam_icp_clk_bw_request clk_info[CAM_FRAME_CMD_MAX];
 	struct cam_icp_clk_bw_req_internal_v2 clk_info_v2[CAM_FRAME_CMD_MAX];
 	struct icp_frame_info frame_info[CAM_FRAME_CMD_MAX];
-	ktime_t submit_timestamp[CAM_FRAME_CMD_MAX];
 };
 
 /**
@@ -207,7 +199,6 @@ struct hfi_frame_process_info {
  * @clk_rate: Supported clock rates for the context
  * @num_paths: Number of valid AXI paths
  * @axi_path: ctx based per path bw vote
- * @bw_included: Whether bw of this context is included in overal voting
  */
 struct cam_ctx_clk_info {
 	uint32_t curr_fc;
@@ -219,7 +210,6 @@ struct cam_ctx_clk_info {
 	int32_t clk_rate[CAM_MAX_VOTE];
 	uint32_t num_paths;
 	struct cam_axi_per_path_bw_vote axi_path[CAM_ICP_MAX_PER_PATH_VOTES];
-	bool bw_included;
 };
 /**
  * struct cam_icp_hw_ctx_data
@@ -352,7 +342,6 @@ struct cam_icp_clk_info {
  * @bps_dev_intf: Device interface for BPS
  * @ipe_clk_state: IPE clock state flag
  * @bps_clk_state: BPS clock state flag
- * @disable_ubwc_comp: Disable UBWC compression
  * @recovery: Flag to validate if in previous session FW
  *            reported a fatal error or wdt. If set FW is
  *            re-downloaded for new camera session.
@@ -402,7 +391,6 @@ struct cam_icp_hw_mgr {
 	struct cam_hw_intf *bps_dev_intf;
 	bool ipe_clk_state;
 	bool bps_clk_state;
-	bool disable_ubwc_comp;
 	atomic_t recovery;
 };
 
diff --git a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/include/cam_a5_hw_intf.h b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/include/cam_a5_hw_intf.h
index c3fefdc09ba9..af80a2eac15d 100644
--- a/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/include/cam_a5_hw_intf.h
+++ b/techpack/camera/drivers/cam_icp/icp_hw/icp_hw_mgr/include/cam_a5_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_A5_HW_INTF_H
@@ -27,7 +27,6 @@ enum cam_icp_a5_cmd_type {
 	CAM_ICP_A5_CMD_UBWC_CFG,
 	CAM_ICP_A5_CMD_PC_PREP,
 	CAM_ICP_A5_CMD_CLK_UPDATE,
-	CAM_ICP_A5_CMD_HW_DUMP,
 	CAM_ICP_A5_CMD_MAX,
 };
 
diff --git a/techpack/camera/drivers/cam_icp/icp_hw/include/cam_icp_hw_mgr_intf.h b/techpack/camera/drivers/cam_icp/icp_hw/include/cam_icp_hw_mgr_intf.h
index 6a1b9c57c193..2d349348bf7c 100644
--- a/techpack/camera/drivers/cam_icp/icp_hw/include/cam_icp_hw_mgr_intf.h
+++ b/techpack/camera/drivers/cam_icp/icp_hw/include/cam_icp_hw_mgr_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_ICP_HW_MGR_INTF_H
@@ -16,12 +16,10 @@
 
 #define CAM_ICP_A5_BW_BYTES_VOTE 40000000
 
-#define CAM_ICP_CTX_MAX          54
+#define CAM_ICP_CTX_MAX          65
 
 #define CPAS_IPE1_BIT            0x2000
 
-#define CAM_ICP_UBWC_COMP_EN     BIT(1)
-
 #define CAM_IPE_DEFAULT_AXI_PATH    CAM_AXI_PATH_DATA_IPE_WR_VID
 #define CAM_IPE_DEFAULT_AXI_TRANSAC CAM_AXI_TRANSACTION_WRITE
 #define CAM_BPS_DEFAULT_AXI_PATH    CAM_AXI_PATH_DATA_ALL
@@ -29,9 +27,6 @@
 #define CAM_ICP_DEFAULT_AXI_PATH    CAM_AXI_PATH_DATA_ALL
 #define CAM_ICP_DEFAULT_AXI_TRANSAC CAM_AXI_TRANSACTION_READ
 
-#define CAM_ICP_DUMP_TAG_MAX_LEN 32
-#define CAM_ICP_DUMP_NUM_WORDS   5
-
 int cam_icp_hw_mgr_init(struct device_node *of_node,
 	uint64_t *hw_mgr_hdl, int *iommu_hdl);
 
@@ -49,28 +44,4 @@ struct cam_icp_cpas_vote {
 	uint32_t axi_vote_valid;
 };
 
-/**
- * struct cam_icp_hw_dump_args
- * @cpu_addr: kernel vaddr
- * @buf_len:  buffer length
- * @offset:   offset
- */
-struct cam_icp_hw_dump_args {
-	uintptr_t  cpu_addr;
-	size_t     buf_len;
-	size_t     offset;
-};
-
-/**
- * struct cam_icp_dump_header
- * @tag:        tag of the packet
- * @size:       size of data in packet
- * @word_size:  size of each word in packet
- */
-struct cam_icp_dump_header {
-	uint8_t    tag[CAM_ICP_DUMP_TAG_MAX_LEN];
-	uint64_t   size;
-	int32_t    word_size;
-};
-
 #endif /* CAM_ICP_HW_MGR_INTF_H */
diff --git a/techpack/camera/drivers/cam_isp/cam_isp_context.c b/techpack/camera/drivers/cam_isp/cam_isp_context.c
index d890af0ba824..6433389c4ba4 100644
--- a/techpack/camera/drivers/cam_isp/cam_isp_context.c
+++ b/techpack/camera/drivers/cam_isp/cam_isp_context.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/debugfs.h>
@@ -25,9 +24,9 @@ static const char isp_dev_name[] = "cam-isp";
 
 static struct cam_isp_ctx_debug isp_ctx_debug;
 
-#define INC_HEAD(head, max_entries, ret) \
+#define INC_STATE_MONITOR_HEAD(head, ret) \
 	div_u64_rem(atomic64_add_return(1, head),\
-	max_entries, (ret))
+	CAM_ISP_CTX_STATE_MONITOR_MAX_ENTRIES, (ret))
 
 static int cam_isp_context_dump_active_request(void *data, unsigned long iova,
 	uint32_t buf_info);
@@ -35,150 +34,6 @@ static int cam_isp_context_dump_active_request(void *data, unsigned long iova,
 static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 	struct cam_start_stop_dev_cmd *cmd);
 
-static const char *__cam_isp_evt_val_to_type(
-	uint32_t evt_id)
-{
-	switch (evt_id) {
-	case CAM_ISP_CTX_EVENT_SUBMIT:
-		return "SUBMIT";
-	case CAM_ISP_CTX_EVENT_APPLY:
-		return "APPLY";
-	case CAM_ISP_CTX_EVENT_EPOCH:
-		return "EPOCH";
-	case CAM_ISP_CTX_EVENT_RUP:
-		return "RUP";
-	case CAM_ISP_CTX_EVENT_BUFDONE:
-		return "BUFDONE";
-	default:
-		return "CAM_ISP_EVENT_INVALID";
-	}
-}
-
-static void __cam_isp_ctx_update_event_record(
-	struct cam_isp_context *ctx_isp,
-	enum cam_isp_ctx_event  event,
-	struct cam_ctx_request *req)
-{
-	int                      iterator = 0;
-	ktime_t                  cur_time;
-	struct cam_isp_ctx_req  *req_isp;
-
-	if (!ctx_isp) {
-		CAM_ERR(CAM_ISP, "Invalid Args");
-		return;
-	}
-	switch (event) {
-	case CAM_ISP_CTX_EVENT_EPOCH:
-	case CAM_ISP_CTX_EVENT_RUP:
-	case CAM_ISP_CTX_EVENT_BUFDONE:
-		break;
-	case CAM_ISP_CTX_EVENT_SUBMIT:
-	case CAM_ISP_CTX_EVENT_APPLY:
-		if (!req) {
-			CAM_ERR(CAM_ISP, "Invalid arg for event %d", event);
-			return;
-		}
-		break;
-	default:
-		break;
-	}
-
-	INC_HEAD(&ctx_isp->event_record_head[event],
-		CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES, &iterator);
-	cur_time = ktime_get();
-	if (req) {
-		req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-		ctx_isp->event_record[event][iterator].req_id =
-			req->request_id;
-		req_isp->event_timestamp[event] = cur_time;
-	} else {
-		ctx_isp->event_record[event][iterator].req_id = 0;
-	}
-	ctx_isp->event_record[event][iterator].timestamp  = cur_time;
-}
-
-static int __cam_isp_ctx_dump_event_record(
-	struct cam_isp_context *ctx_isp,
-	uintptr_t               cpu_addr,
-	size_t                  buf_len,
-	size_t                 *offset)
-{
-	int                                  i, j;
-	int                                  index;
-	size_t                               remain_len;
-	uint8_t                             *dst;
-	uint32_t                             oldest_entry, num_entries;
-	uint32_t                             min_len;
-	uint64_t                            *addr, *start;
-	uint64_t                             state_head;
-	struct timespec64                    ts;
-	struct cam_isp_context_dump_header  *hdr;
-	struct cam_isp_context_event_record *record;
-
-	if (!cpu_addr || !buf_len || !offset || !ctx_isp) {
-		CAM_ERR(CAM_ISP, "Invalid args %pK %zu %pK %pK",
-			cpu_addr, buf_len, offset, ctx_isp);
-		return -EINVAL;
-	}
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++) {
-		state_head = atomic64_read(&ctx_isp->event_record_head[i]);
-
-		if (state_head == -1) {
-			return 0;
-		} else if (state_head < CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES) {
-			num_entries = state_head + 1;
-			oldest_entry = 0;
-		} else {
-			num_entries = CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES;
-			div_u64_rem(state_head + 1,
-				CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES,
-				&oldest_entry);
-		}
-		index = oldest_entry;
-
-		if (buf_len <= *offset) {
-			CAM_WARN(CAM_ISP,
-				"Dump buffer overshoot len %zu offset %zu",
-				buf_len, *offset);
-			return -ENOSPC;
-		}
-
-		min_len = sizeof(struct cam_isp_context_dump_header) +
-			((num_entries * CAM_ISP_CTX_DUMP_EVENT_NUM_WORDS) *
-			sizeof(uint64_t));
-		remain_len = buf_len - *offset;
-
-		if (remain_len < min_len) {
-			CAM_WARN(CAM_ISP,
-				"Dump buffer exhaust remain %zu min %u",
-				remain_len, min_len);
-			return -ENOSPC;
-		}
-		dst = (uint8_t *)cpu_addr + *offset;
-		hdr = (struct cam_isp_context_dump_header *)dst;
-		scnprintf(hdr->tag,
-			CAM_ISP_CONTEXT_DUMP_TAG_MAX_LEN, "ISP_EVT_%s:",
-			__cam_isp_evt_val_to_type(i));
-		hdr->word_size = sizeof(uint64_t);
-		addr = (uint64_t *)(dst +
-			sizeof(struct cam_isp_context_dump_header));
-		start = addr;
-		for (j = 0; j <  num_entries; j++) {
-			record  = &ctx_isp->event_record[i][index];
-			ts      = ktime_to_timespec64(record->timestamp);
-			*addr++ = record->req_id;
-			*addr++ = ts.tv_sec;
-			*addr++ = ts.tv_nsec/NSEC_PER_USEC;
-			index = (index + 1) %
-				CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES;
-		}
-		hdr->size = hdr->word_size * (addr - start);
-		*offset += hdr->size +
-			sizeof(struct cam_isp_context_dump_header);
-	}
-	return 0;
-}
-
 static void __cam_isp_ctx_update_state_monitor_array(
 	struct cam_isp_context *ctx_isp,
 	enum cam_isp_state_change_trigger trigger_type,
@@ -186,8 +41,7 @@ static void __cam_isp_ctx_update_state_monitor_array(
 {
 	int iterator;
 
-	INC_HEAD(&ctx_isp->state_monitor_head,
-		CAM_ISP_CTX_STATE_MONITOR_MAX_ENTRIES, &iterator);
+	INC_STATE_MONITOR_HEAD(&ctx_isp->state_monitor_head, &iterator);
 
 	ctx_isp->cam_isp_ctx_state_monitor[iterator].curr_state =
 		ctx_isp->substate_activated;
@@ -308,19 +162,13 @@ static int cam_isp_context_info_dump(void *context,
 	return 0;
 }
 
-static int cam_isp_ctx_dump_req(
-	struct cam_isp_ctx_req  *req_isp,
-	uintptr_t                cpu_addr,
-	size_t                   buf_len,
-	size_t                  *offset,
-	bool                     dump_to_buff)
+static void cam_isp_ctx_dump_req(struct cam_isp_ctx_req *req_isp)
 {
 	int i = 0, rc = 0;
 	size_t len = 0;
 	uint32_t *buf_addr;
 	uint32_t *buf_start, *buf_end;
 	size_t   remain_len = 0;
-	struct cam_cdm_cmd_buf_dump_info dump_info;
 
 	for (i = 0; i < req_isp->num_cfg; i++) {
 		rc = cam_packet_util_get_cmd_mem_addr(
@@ -334,7 +182,7 @@ static int cam_isp_ctx_dump_req(
 				CAM_ERR(CAM_ISP,
 					"Invalid offset exp %u actual %u",
 					req_isp->cfg[i].offset, (uint32_t)len);
-				return rc;
+				return;
 			}
 			remain_len = len - req_isp->cfg[i].offset;
 
@@ -344,33 +192,16 @@ static int cam_isp_ctx_dump_req(
 					"Invalid len exp %u remain_len %u",
 					req_isp->cfg[i].len,
 					(uint32_t)remain_len);
-				return rc;
+				return;
 			}
 
 			buf_start = (uint32_t *)((uint8_t *) buf_addr +
 				req_isp->cfg[i].offset);
 			buf_end = (uint32_t *)((uint8_t *) buf_start +
 				req_isp->cfg[i].len - 1);
-			if (dump_to_buff) {
-				if (!cpu_addr || !offset || !buf_len) {
-					CAM_ERR(CAM_ISP, "Invalid args");
-					break;
-				}
-				dump_info.src_start = buf_start;
-				dump_info.src_end =   buf_end;
-				dump_info.dst_start = cpu_addr;
-				dump_info.dst_offset = *offset;
-				dump_info.dst_max_size = buf_len;
-				rc = cam_cdm_util_dump_cmd_bufs_v2(&dump_info);
-				*offset = dump_info.dst_offset;
-				if (rc)
-					return rc;
-			} else {
-				cam_cdm_util_dump_cmd_buf(buf_start, buf_end);
-			}
+			cam_cdm_util_dump_cmd_buf(buf_start, buf_end);
 		}
 	}
-	return rc;
 }
 
 static int __cam_isp_ctx_enqueue_request_in_order(
@@ -379,7 +210,6 @@ static int __cam_isp_ctx_enqueue_request_in_order(
 	struct cam_ctx_request           *req_current;
 	struct cam_ctx_request           *req_prev;
 	struct list_head                  temp_list;
-	struct cam_isp_context           *ctx_isp;
 
 	INIT_LIST_HEAD(&temp_list);
 	spin_lock_bh(&ctx->lock);
@@ -410,9 +240,6 @@ static int __cam_isp_ctx_enqueue_request_in_order(
 			}
 		}
 	}
-	ctx_isp = (struct cam_isp_context *) ctx->ctx_priv;
-	__cam_isp_ctx_update_event_record(ctx_isp,
-		CAM_ISP_CTX_EVENT_SUBMIT, req);
 	spin_unlock_bh(&ctx->lock);
 	return 0;
 }
@@ -421,12 +248,9 @@ static int __cam_isp_ctx_enqueue_init_request(
 	struct cam_context *ctx, struct cam_ctx_request *req)
 {
 	int rc = 0;
-	struct cam_ctx_request                *req_old;
-	struct cam_isp_ctx_req                *req_isp_old;
-	struct cam_isp_ctx_req                *req_isp_new;
-	struct cam_isp_prepare_hw_update_data *hw_update_data;
-	struct cam_isp_prepare_hw_update_data *req_update_old;
-	struct cam_isp_prepare_hw_update_data *req_update_new;
+	struct cam_ctx_request           *req_old;
+	struct cam_isp_ctx_req           *req_isp_old;
+	struct cam_isp_ctx_req           *req_isp_new;
 
 	spin_lock_bh(&ctx->lock);
 	if (list_empty(&ctx->pending_req_list)) {
@@ -478,24 +302,6 @@ static int __cam_isp_ctx_enqueue_init_request(
 			memcpy(&req_old->pf_data, &req->pf_data,
 				sizeof(struct cam_hw_mgr_dump_pf_data));
 
-			/* Update frame header params for EPCR */
-			hw_update_data = &req_isp_new->hw_update_data;
-			req_isp_old->hw_update_data.frame_header_res_id =
-				req_isp_new->hw_update_data.frame_header_res_id;
-			req_isp_old->hw_update_data.frame_header_cpu_addr =
-				hw_update_data->frame_header_cpu_addr;
-
-			if (req_isp_new->hw_update_data.num_reg_dump_buf) {
-				req_update_new = &req_isp_new->hw_update_data;
-				req_update_old = &req_isp_old->hw_update_data;
-				memcpy(&req_update_old->reg_dump_buf_desc,
-					&req_update_new->reg_dump_buf_desc,
-					sizeof(struct cam_cmd_buf_desc) *
-					req_update_new->num_reg_dump_buf);
-				req_update_old->num_reg_dump_buf =
-					req_update_new->num_reg_dump_buf;
-			}
-
 			req_old->request_id = req->request_id;
 
 			list_add_tail(&req->list, &ctx->free_req_list);
@@ -619,12 +425,11 @@ static void __cam_isp_ctx_send_sof_boot_timestamp(
 	req_msg.u.frame_msg.timestamp = ctx_isp->boot_timestamp;
 	req_msg.u.frame_msg.link_hdl = ctx_isp->base->link_hdl;
 	req_msg.u.frame_msg.sof_status = sof_event_status;
-	req_msg.u.frame_msg.frame_id_meta = ctx_isp->frame_id_meta;
 
 	CAM_DBG(CAM_ISP,
-		"request id:%lld frame number:%lld boot time stamp:0x%llx status:%u",
+		"request id:%lld frame number:%lld boot time stamp:0x%llx",
 		 request_id, ctx_isp->frame_id,
-		 ctx_isp->boot_timestamp, sof_event_status);
+		 ctx_isp->boot_timestamp);
 
 	if (cam_req_mgr_notify_message(&req_msg,
 		V4L_EVENT_CAM_REQ_MGR_SOF_BOOT_TS,
@@ -634,41 +439,6 @@ static void __cam_isp_ctx_send_sof_boot_timestamp(
 			request_id);
 }
 
-static void __cam_isp_ctx_send_sof_timestamp_frame_header(
-	struct cam_isp_context *ctx_isp, uint32_t *frame_header_cpu_addr,
-	uint64_t request_id, uint32_t sof_event_status)
-{
-	uint32_t *time32 = NULL;
-	uint64_t timestamp = 0;
-	struct cam_req_mgr_message   req_msg;
-
-	time32 = frame_header_cpu_addr;
-	timestamp = (uint64_t) time32[1];
-	timestamp = timestamp << 24;
-	timestamp |= (uint64_t)(time32[0] >> 8);
-	timestamp = mul_u64_u32_div(timestamp,
-			CAM_IFE_QTIMER_MUL_FACTOR,
-			CAM_IFE_QTIMER_DIV_FACTOR);
-
-	ctx_isp->sof_timestamp_val = timestamp;
-	req_msg.session_hdl = ctx_isp->base->session_hdl;
-	req_msg.u.frame_msg.frame_id = ctx_isp->frame_id;
-	req_msg.u.frame_msg.request_id = request_id;
-	req_msg.u.frame_msg.timestamp = ctx_isp->sof_timestamp_val;
-	req_msg.u.frame_msg.link_hdl = ctx_isp->base->link_hdl;
-	req_msg.u.frame_msg.sof_status = sof_event_status;
-
-	CAM_DBG(CAM_ISP,
-		"request id:%lld frame number:%lld SOF time stamp:0x%llx status:%u",
-		 request_id, ctx_isp->frame_id,
-		ctx_isp->sof_timestamp_val, sof_event_status);
-
-	if (cam_req_mgr_notify_message(&req_msg,
-		V4L_EVENT_CAM_REQ_MGR_SOF, V4L_EVENT_CAM_REQ_MGR_EVENT))
-		CAM_ERR(CAM_ISP,
-			"Error in notifying the sof time for req id:%lld",
-			request_id);
-}
 
 static void __cam_isp_ctx_send_sof_timestamp(
 	struct cam_isp_context *ctx_isp, uint64_t request_id,
@@ -676,22 +446,18 @@ static void __cam_isp_ctx_send_sof_timestamp(
 {
 	struct cam_req_mgr_message   req_msg;
 
-	if ((ctx_isp->use_frame_header_ts) && (request_id) &&
-		(sof_event_status == CAM_REQ_MGR_SOF_EVENT_SUCCESS))
-		goto end;
-
 	req_msg.session_hdl = ctx_isp->base->session_hdl;
 	req_msg.u.frame_msg.frame_id = ctx_isp->frame_id;
 	req_msg.u.frame_msg.request_id = request_id;
 	req_msg.u.frame_msg.timestamp = ctx_isp->sof_timestamp_val;
 	req_msg.u.frame_msg.link_hdl = ctx_isp->base->link_hdl;
 	req_msg.u.frame_msg.sof_status = sof_event_status;
-	req_msg.u.frame_msg.frame_id_meta = ctx_isp->frame_id_meta;
 
 	CAM_DBG(CAM_ISP,
-		"request id:%lld frame number:%lld SOF time stamp:0x%llx status:%u",
+		"request id:%lld frame number:%lld SOF time stamp:0x%llx",
 		 request_id, ctx_isp->frame_id,
-		ctx_isp->sof_timestamp_val, sof_event_status);
+		ctx_isp->sof_timestamp_val);
+	CAM_DBG(CAM_ISP, "sof status:%d", sof_event_status);
 
 	if (cam_req_mgr_notify_message(&req_msg,
 		V4L_EVENT_CAM_REQ_MGR_SOF, V4L_EVENT_CAM_REQ_MGR_EVENT))
@@ -699,9 +465,9 @@ static void __cam_isp_ctx_send_sof_timestamp(
 			"Error in notifying the sof time for req id:%lld",
 			request_id);
 
-end:
 	__cam_isp_ctx_send_sof_boot_timestamp(ctx_isp,
 		request_id, sof_event_status);
+
 }
 
 static void __cam_isp_ctx_handle_buf_done_fail_log(
@@ -724,11 +490,6 @@ static void __cam_isp_ctx_handle_buf_done_fail_log(
 		"Resource Handles that fail to generate buf_done in prev frame");
 	for (i = 0; i < req_isp->num_fence_map_out; i++) {
 		if (req_isp->fence_map_out[i].sync_id != -1) {
-			trace_cam_log_event("Buf_done Congestion",
-				__cam_isp_resource_handle_id_to_type(
-				req_isp->fence_map_out[i].resource_handle),
-				request_id, req_isp->fence_map_out[i].sync_id);
-
 			CAM_WARN(CAM_ISP,
 			"Resource_Handle: [%s][0x%x] Sync_ID: [0x%x]",
 			__cam_isp_resource_handle_id_to_type(
@@ -739,70 +500,6 @@ static void __cam_isp_ctx_handle_buf_done_fail_log(
 	}
 }
 
-static int __cam_isp_ctx_handle_buf_done_for_req_list(
-	struct cam_isp_context *ctx_isp,
-	struct cam_ctx_request *req)
-{
-	int rc = 0, i;
-	uint64_t buf_done_req_id;
-	struct cam_isp_ctx_req *req_isp;
-	struct cam_context *ctx = ctx_isp->base;
-
-	req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-	ctx_isp->active_req_cnt--;
-	buf_done_req_id = req->request_id;
-
-	if (req_isp->bubble_detected && req_isp->bubble_report) {
-		req_isp->num_acked = 0;
-		req_isp->bubble_detected = false;
-		list_del_init(&req->list);
-		atomic_set(&ctx_isp->process_bubble, 0);
-
-		if (buf_done_req_id <= ctx->last_flush_req) {
-			for (i = 0; i < req_isp->num_fence_map_out; i++)
-				rc = cam_sync_signal(
-					req_isp->fence_map_out[i].sync_id,
-					CAM_SYNC_STATE_SIGNALED_ERROR);
-
-			list_add_tail(&req->list, &ctx->free_req_list);
-			CAM_DBG(CAM_REQ,
-				"Move active request %lld to free list(cnt = %d) [flushed], ctx %u",
-				buf_done_req_id, ctx_isp->active_req_cnt,
-				ctx->ctx_id);
-		} else {
-			list_add(&req->list, &ctx->pending_req_list);
-			CAM_DBG(CAM_REQ,
-				"Move active request %lld to pending list(cnt = %d) [bubble recovery], ctx %u",
-				req->request_id, ctx_isp->active_req_cnt,
-				ctx->ctx_id);
-		}
-	} else {
-		if (!ctx_isp->use_frame_header_ts) {
-			if (ctx_isp->reported_req_id < buf_done_req_id) {
-				ctx_isp->reported_req_id = buf_done_req_id;
-				__cam_isp_ctx_send_sof_timestamp(ctx_isp,
-					buf_done_req_id,
-					CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-			}
-		}
-		list_del_init(&req->list);
-		list_add_tail(&req->list, &ctx->free_req_list);
-		req_isp->reapply = false;
-
-		CAM_DBG(CAM_REQ,
-			"Move active request %lld to free list(cnt = %d) [all fences done], ctx %u",
-			buf_done_req_id, ctx_isp->active_req_cnt, ctx->ctx_id);
-		ctx_isp->req_info.last_bufdone_req_id = req->request_id;
-	}
-
-	__cam_isp_ctx_update_state_monitor_array(ctx_isp,
-		CAM_ISP_STATE_CHANGE_TRIGGER_DONE, buf_done_req_id);
-
-	__cam_isp_ctx_update_event_record(ctx_isp,
-		CAM_ISP_CTX_EVENT_BUFDONE, req);
-	return rc;
-}
-
 static int __cam_isp_ctx_handle_buf_done_for_request(
 	struct cam_isp_context *ctx_isp,
 	struct cam_ctx_request  *req,
@@ -812,8 +509,9 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 {
 	int rc = 0;
 	int i, j;
-	struct cam_isp_ctx_req *req_isp;
+	struct cam_isp_ctx_req  *req_isp;
 	struct cam_context *ctx = ctx_isp->base;
+	uint64_t buf_done_req_id;
 
 	trace_cam_buf_done("ISP", ctx, req);
 
@@ -822,8 +520,10 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 	CAM_DBG(CAM_ISP, "Enter with bubble_state %d, req_bubble_detected %d",
 		bubble_state, req_isp->bubble_detected);
 
-	done_next_req->num_handles = 0;
-	done_next_req->timestamp = done->timestamp;
+	if (done_next_req) {
+		done_next_req->num_handles = 0;
+		done_next_req->timestamp = done->timestamp;
+	}
 
 	for (i = 0; i < done->num_handles; i++) {
 		for (j = 0; j < req_isp->num_fence_map_out; j++) {
@@ -833,21 +533,10 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 		}
 
 		if (j == req_isp->num_fence_map_out) {
-			/*
-			 * If not found in current request, it could be
-			 * belonging to next request, this can happen if
-			 * IRQ delay happens. It is only valid when the
-			 * platform doesn't have last consumed address.
-			 */
-			CAM_WARN(CAM_ISP,
-				"BUF_DONE for res %s not found in Req %lld ",
-				__cam_isp_resource_handle_id_to_type(
-				done->resource_handle[i]),
-				req->request_id);
-
-			done_next_req->resource_handle
-				[done_next_req->num_handles++] =
-				done->resource_handle[i];
+			CAM_ERR(CAM_ISP,
+				"Can not find matching lane handle 0x%x!",
+				done->resource_handle[i]);
+			rc = -EINVAL;
 			continue;
 		}
 
@@ -857,14 +546,13 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 				req->request_id, i, j,
 				__cam_isp_resource_handle_id_to_type(
 				done->resource_handle[i]));
-			trace_cam_log_event("Duplicate BufDone",
-				__cam_isp_resource_handle_id_to_type(
-				done->resource_handle[i]),
-				req->request_id, ctx->ctx_id);
 
-			done_next_req->resource_handle
-				[done_next_req->num_handles++] =
-				done->resource_handle[i];
+			if (done_next_req) {
+				done_next_req->resource_handle
+					[done_next_req->num_handles++] =
+					done->resource_handle[i];
+			}
+
 			continue;
 		}
 
@@ -915,14 +603,6 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 			req_isp->num_acked++;
 			req_isp->fence_map_out[j].sync_id = -1;
 		}
-
-		if ((ctx_isp->use_frame_header_ts) &&
-			(req_isp->hw_update_data.frame_header_res_id ==
-			req_isp->fence_map_out[j].resource_handle))
-			__cam_isp_ctx_send_sof_timestamp_frame_header(
-				ctx_isp,
-				req_isp->hw_update_data.frame_header_cpu_addr,
-				req->request_id, CAM_REQ_MGR_SOF_EVENT_SUCCESS);
 	}
 
 	if (req_isp->num_acked > req_isp->num_fence_map_out) {
@@ -937,151 +617,63 @@ static int __cam_isp_ctx_handle_buf_done_for_request(
 	if (req_isp->num_acked != req_isp->num_fence_map_out)
 		return rc;
 
-	rc = __cam_isp_ctx_handle_buf_done_for_req_list(ctx_isp, req);
-	return rc;
-}
-
-static int __cam_isp_ctx_handle_buf_done_for_request_verify_addr(
-	struct cam_isp_context *ctx_isp,
-	struct cam_ctx_request  *req,
-	struct cam_isp_hw_done_event_data *done,
-	uint32_t bubble_state,
-	bool verify_consumed_addr)
-{
-	int rc = 0;
-	int i, j;
-	struct cam_isp_ctx_req *req_isp;
-	struct cam_context *ctx = ctx_isp->base;
-	const char *handle_type;
-
-	trace_cam_buf_done("ISP", ctx, req);
-
-	req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-
-	CAM_DBG(CAM_ISP, "Enter with bubble_state %d, req_bubble_detected %d",
-		bubble_state, req_isp->bubble_detected);
-
-	for (i = 0; i < done->num_handles; i++) {
-		for (j = 0; j < req_isp->num_fence_map_out; j++) {
-			if (verify_consumed_addr &&
-				(done->last_consumed_addr[i] !=
-				 req_isp->fence_map_out[j].image_buf_addr[0]))
-				continue;
-
-			if (done->resource_handle[i] ==
-				req_isp->fence_map_out[j].resource_handle)
-				break;
-		}
-
-		if (j == req_isp->num_fence_map_out) {
-			/*
-			 * If not found in current request, it could be
-			 * belonging to next request, this can happen if
-			 * IRQ delay happens. It is only valid when the
-			 * platform doesn't have last consumed address.
-			 */
-			CAM_DBG(CAM_ISP,
-				"BUF_DONE for res %s not found in Req %lld ",
-				__cam_isp_resource_handle_id_to_type(
-				done->resource_handle[i]),
-				req->request_id);
-			continue;
-		}
-
-		if (req_isp->fence_map_out[j].sync_id == -1) {
-			handle_type =
-				__cam_isp_resource_handle_id_to_type(
-				req_isp->fence_map_out[i].resource_handle);
-
-			CAM_WARN(CAM_ISP,
-				"Duplicate BUF_DONE for req %lld : i=%d, j=%d, res=%s",
-				req->request_id, i, j, handle_type);
+	ctx_isp->active_req_cnt--;
+	buf_done_req_id = req->request_id;
 
-			trace_cam_log_event("Duplicate BufDone",
-				handle_type, req->request_id, ctx->ctx_id);
-			continue;
-		}
+	if (req_isp->bubble_detected && req_isp->bubble_report) {
+		req_isp->num_acked = 0;
+		req_isp->bubble_detected = false;
+		list_del_init(&req->list);
+		atomic_set(&ctx_isp->process_bubble, 0);
 
-		if (!req_isp->bubble_detected) {
-			CAM_DBG(CAM_ISP,
-				"Sync with success: req %lld res 0x%x fd 0x%x, ctx %u",
-				req->request_id,
-				req_isp->fence_map_out[j].resource_handle,
-				req_isp->fence_map_out[j].sync_id,
-				ctx->ctx_id);
+		if (buf_done_req_id <= ctx->last_flush_req) {
+			for (i = 0; i < req_isp->num_fence_map_out; i++)
+				cam_sync_signal(
+					req_isp->fence_map_out[i].sync_id,
+					CAM_SYNC_STATE_SIGNALED_ERROR);
 
-			rc = cam_sync_signal(req_isp->fence_map_out[j].sync_id,
-				CAM_SYNC_STATE_SIGNALED_SUCCESS);
-			if (rc)
-				CAM_DBG(CAM_ISP, "Sync failed with rc = %d",
-					 rc);
-		} else if (!req_isp->bubble_report) {
-			CAM_ERR(CAM_ISP,
-				"Sync with failure: req %lld res 0x%x fd 0x%x, ctx %u",
-				req->request_id,
-				req_isp->fence_map_out[j].resource_handle,
-				req_isp->fence_map_out[j].sync_id,
+			list_add_tail(&req->list, &ctx->free_req_list);
+			CAM_DBG(CAM_REQ,
+				"Move active request %lld to free list(cnt = %d) [flushed], ctx %u",
+				buf_done_req_id, ctx_isp->active_req_cnt,
 				ctx->ctx_id);
-
-			rc = cam_sync_signal(req_isp->fence_map_out[j].sync_id,
-				CAM_SYNC_STATE_SIGNALED_ERROR);
-			if (rc)
-				CAM_ERR(CAM_ISP, "Sync failed with rc = %d",
-					rc);
 		} else {
-			/*
-			 * Ignore the buffer done if bubble detect is on
-			 * Increment the ack number here, and queue the
-			 * request back to pending list whenever all the
-			 * buffers are done.
-			 */
-			req_isp->num_acked++;
-			CAM_DBG(CAM_ISP,
-				"buf done with bubble state %d recovery %d",
-				bubble_state, req_isp->bubble_report);
-			continue;
+			list_add(&req->list, &ctx->pending_req_list);
+			ctx_isp->bubble_frame_cnt = 0;
+			CAM_DBG(CAM_REQ,
+				"Move active request %lld to pending list(cnt = %d) [bubble recovery], ctx %u",
+				req->request_id, ctx_isp->active_req_cnt,
+				ctx->ctx_id);
 		}
-
-		CAM_DBG(CAM_ISP, "req %lld, reset sync id 0x%x ctx %u",
-			req->request_id,
-			req_isp->fence_map_out[j].sync_id, ctx->ctx_id);
-		if (!rc) {
-			req_isp->num_acked++;
-			req_isp->fence_map_out[j].sync_id = -1;
+	} else {
+		if (ctx_isp->reported_req_id < buf_done_req_id) {
+			ctx_isp->reported_req_id = buf_done_req_id;
+			__cam_isp_ctx_send_sof_timestamp(ctx_isp,
+				buf_done_req_id, CAM_REQ_MGR_SOF_EVENT_SUCCESS);
 		}
+		list_del_init(&req->list);
+		list_add_tail(&req->list, &ctx->free_req_list);
+		req_isp->reapply = false;
 
-		if ((ctx_isp->use_frame_header_ts) &&
-			(req_isp->hw_update_data.frame_header_res_id ==
-			req_isp->fence_map_out[j].resource_handle))
-			__cam_isp_ctx_send_sof_timestamp_frame_header(
-				ctx_isp,
-				req_isp->hw_update_data.frame_header_cpu_addr,
-				req->request_id, CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-	}
-
-	if (req_isp->num_acked > req_isp->num_fence_map_out) {
-		/* Should not happen */
-		CAM_ERR(CAM_ISP,
-			"WARNING: req_id %lld num_acked %d > map_out %d, ctx %u",
-			req->request_id, req_isp->num_acked,
-			req_isp->num_fence_map_out, ctx->ctx_id);
-		WARN_ON(req_isp->num_acked > req_isp->num_fence_map_out);
+		CAM_DBG(CAM_REQ,
+			"Move active request %lld to free list(cnt = %d) [all fences done], ctx %u",
+			buf_done_req_id, ctx_isp->active_req_cnt, ctx->ctx_id);
+		ctx_isp->req_info.last_bufdone_req_id = req->request_id;
 	}
 
-	if (req_isp->num_acked != req_isp->num_fence_map_out)
-		return rc;
+	__cam_isp_ctx_update_state_monitor_array(ctx_isp,
+		CAM_ISP_STATE_CHANGE_TRIGGER_DONE, buf_done_req_id);
 
-	rc = __cam_isp_ctx_handle_buf_done_for_req_list(ctx_isp, req);
 	return rc;
 }
 
-static int __cam_isp_ctx_handle_buf_done(
+static int __cam_isp_ctx_handle_buf_done_in_activated_state(
 	struct cam_isp_context *ctx_isp,
 	struct cam_isp_hw_done_event_data *done,
 	uint32_t bubble_state)
 {
 	int rc = 0;
-	struct cam_ctx_request *req;
+	struct cam_ctx_request  *req;
 	struct cam_context *ctx = ctx_isp->base;
 	struct cam_isp_hw_done_event_data done_next_req;
 
@@ -1139,240 +731,6 @@ static int __cam_isp_ctx_handle_buf_done(
 	return rc;
 }
 
-static void __cam_isp_ctx_buf_done_match_req(
-	struct cam_ctx_request *req,
-	struct cam_isp_hw_done_event_data *done,
-	bool *irq_delay_detected)
-{
-	int i, j;
-	uint32_t match_count = 0;
-	struct cam_isp_ctx_req *req_isp;
-
-	req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-
-	for (i = 0; i < done->num_handles; i++) {
-		for (j = 0; j < req_isp->num_fence_map_out; j++) {
-			if ((done->resource_handle[i] ==
-				 req_isp->fence_map_out[j].resource_handle) &&
-				(done->last_consumed_addr[i] ==
-				 req_isp->fence_map_out[j].image_buf_addr[0])) {
-				match_count++;
-				break;
-			}
-		}
-	}
-
-	if (match_count > 0)
-		*irq_delay_detected = true;
-	else
-		*irq_delay_detected = false;
-
-	CAM_DBG(CAM_ISP,
-		"buf done num handles %d match count %d for next req:%lld",
-		done->num_handles, match_count, req->request_id);
-	CAM_DBG(CAM_ISP,
-		"irq_delay_detected %d", *irq_delay_detected);
-}
-
-static int __cam_isp_ctx_handle_buf_done_verify_addr(
-	struct cam_isp_context *ctx_isp,
-	struct cam_isp_hw_done_event_data *done,
-	uint32_t bubble_state)
-{
-	int rc = 0;
-	bool irq_delay_detected = false;
-	struct cam_ctx_request *req;
-	struct cam_ctx_request *next_req = NULL;
-	struct cam_context *ctx = ctx_isp->base;
-
-	if (list_empty(&ctx->active_req_list)) {
-		CAM_DBG(CAM_ISP, "Buf done with no active request");
-		return 0;
-	}
-
-	req = list_first_entry(&ctx->active_req_list,
-			struct cam_ctx_request, list);
-
-	if (ctx_isp->active_req_cnt > 1) {
-		next_req = list_last_entry(
-			&ctx->active_req_list,
-			struct cam_ctx_request, list);
-
-		if (next_req->request_id != req->request_id)
-			__cam_isp_ctx_buf_done_match_req(next_req, done,
-				&irq_delay_detected);
-		else
-			CAM_WARN(CAM_ISP,
-				"Req %lld only active request, spurious buf_done rxd",
-				req->request_id);
-	}
-
-	/*
-	 * If irq delay isn't detected, then we need to verify
-	 * the consumed address for current req, otherwise, we
-	 * can't verify the consumed address.
-	 */
-	rc = __cam_isp_ctx_handle_buf_done_for_request_verify_addr(
-		ctx_isp, req, done, bubble_state,
-		!irq_delay_detected);
-
-	/*
-	 * Verify the consumed address for next req all the time,
-	 * since the reported buf done event may belong to current
-	 * req, then we can't signal this event for next req.
-	 */
-	if (!rc && irq_delay_detected)
-		rc = __cam_isp_ctx_handle_buf_done_for_request_verify_addr(
-			ctx_isp, next_req, done,
-			bubble_state, true);
-
-	return rc;
-}
-
-static int __cam_isp_ctx_handle_buf_done_in_activated_state(
-	struct cam_isp_context *ctx_isp,
-	struct cam_isp_hw_done_event_data *done,
-	uint32_t bubble_state)
-{
-	int rc = 0;
-
-	if (ctx_isp->support_consumed_addr)
-		rc = __cam_isp_ctx_handle_buf_done_verify_addr(
-			ctx_isp, done, bubble_state);
-	else
-		rc = __cam_isp_ctx_handle_buf_done(
-			ctx_isp, done, bubble_state);
-
-	return rc;
-}
-
-static int __cam_isp_ctx_apply_req_offline(
-	void *priv, void *data)
-{
-	int rc = 0;
-	struct cam_context *ctx = NULL;
-	struct cam_isp_context *ctx_isp = priv;
-	struct cam_ctx_request *req;
-	struct cam_isp_ctx_req *req_isp;
-	struct cam_hw_config_args cfg;
-
-	if (!ctx_isp) {
-		CAM_ERR(CAM_ISP, "Invalid ctx_isp:%pK", ctx);
-		rc = -EINVAL;
-		goto end;
-	}
-	ctx = ctx_isp->base;
-
-	if (list_empty(&ctx->pending_req_list)) {
-		CAM_DBG(CAM_ISP, "No pending requests to apply");
-		rc = -EFAULT;
-		goto end;
-	}
-
-	if (ctx->state != CAM_CTX_ACTIVATED)
-		goto end;
-
-	if (ctx_isp->active_req_cnt >= 2)
-		goto end;
-
-	spin_lock_bh(&ctx->lock);
-	req = list_first_entry(&ctx->pending_req_list, struct cam_ctx_request,
-		list);
-	spin_unlock_bh(&ctx->lock);
-
-	CAM_DBG(CAM_REQ, "Apply request %lld in substate %d ctx %u",
-		req->request_id, ctx_isp->substate_activated, ctx->ctx_id);
-	req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-
-	memset(&cfg, 0, sizeof(cfg));
-
-	cfg.ctxt_to_hw_map = ctx_isp->hw_ctx;
-	cfg.request_id = req->request_id;
-	cfg.hw_update_entries = req_isp->cfg;
-	cfg.num_hw_update_entries = req_isp->num_cfg;
-	cfg.priv  = &req_isp->hw_update_data;
-	cfg.init_packet = 0;
-
-	rc = ctx->hw_mgr_intf->hw_config(ctx->hw_mgr_intf->hw_mgr_priv, &cfg);
-	if (rc) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "Can not apply the configuration");
-	} else {
-		spin_lock_bh(&ctx->lock);
-
-		atomic_set(&ctx_isp->rxd_epoch, 0);
-
-		ctx_isp->substate_activated = CAM_ISP_CTX_ACTIVATED_APPLIED;
-		ctx_isp->last_applied_req_id = req->request_id;
-
-		list_del_init(&req->list);
-		list_add_tail(&req->list, &ctx->wait_req_list);
-
-		spin_unlock_bh(&ctx->lock);
-
-		CAM_DBG(CAM_ISP, "New substate state %d, applied req %lld",
-			CAM_ISP_CTX_ACTIVATED_APPLIED,
-			ctx_isp->last_applied_req_id);
-
-		__cam_isp_ctx_update_state_monitor_array(ctx_isp,
-			CAM_ISP_STATE_CHANGE_TRIGGER_APPLIED,
-			req->request_id);
-	}
-end:
-	return rc;
-}
-
-static int __cam_isp_ctx_schedule_apply_req_offline(
-	struct cam_isp_context *ctx_isp)
-{
-	int rc = 0;
-	struct crm_workq_task *task;
-
-	task = cam_req_mgr_workq_get_task(ctx_isp->workq);
-	if (!task) {
-		CAM_ERR(CAM_ISP, "No task for worker");
-		return -ENOMEM;
-	}
-
-	task->process_cb = __cam_isp_ctx_apply_req_offline;
-	rc = cam_req_mgr_workq_enqueue_task(task, ctx_isp, CRM_TASK_PRIORITY_0);
-	if (rc)
-		CAM_ERR(CAM_ISP, "Failed to schedule task rc:%d", rc);
-
-	return rc;
-}
-
-static int __cam_isp_ctx_offline_epoch_in_activated_state(
-	struct cam_isp_context *ctx_isp, void *evt_data)
-{
-	struct cam_context *ctx = ctx_isp->base;
-	struct cam_ctx_request *req, *req_temp;
-	uint64_t request_id = 0;
-
-	atomic_set(&ctx_isp->rxd_epoch, 1);
-
-	CAM_DBG(CAM_ISP, "SOF frame %lld ctx %u", ctx_isp->frame_id,
-		ctx->ctx_id);
-
-	list_for_each_entry_safe(req, req_temp, &ctx->active_req_list, list) {
-		if (req->request_id > ctx_isp->reported_req_id) {
-			request_id = req->request_id;
-			ctx_isp->reported_req_id = request_id;
-			break;
-		}
-	}
-
-	__cam_isp_ctx_schedule_apply_req_offline(ctx_isp);
-
-	__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
-		CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-
-	__cam_isp_ctx_update_state_monitor_array(ctx_isp,
-		CAM_ISP_STATE_CHANGE_TRIGGER_EPOCH,
-		request_id);
-
-	return 0;
-}
-
 static int __cam_isp_ctx_reg_upd_in_epoch_bubble_state(
 	struct cam_isp_context *ctx_isp, void *evt_data)
 {
@@ -1414,8 +772,6 @@ static int __cam_isp_ctx_reg_upd_in_applied_state(
 		CAM_DBG(CAM_REQ,
 			"move request %lld to active list(cnt = %d), ctx %u",
 			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
-		__cam_isp_ctx_update_event_record(ctx_isp,
-			CAM_ISP_CTX_EVENT_RUP, req);
 	} else {
 		/* no io config, so the request is completed. */
 		list_add_tail(&req->list, &ctx->free_req_list);
@@ -1444,24 +800,11 @@ static int __cam_isp_ctx_notify_sof_in_activated_state(
 	struct cam_isp_context *ctx_isp, void *evt_data)
 {
 	int rc = 0;
-	uint64_t  request_id  = 0;
 	struct cam_req_mgr_trigger_notify  notify;
 	struct cam_context *ctx = ctx_isp->base;
 	struct cam_ctx_request  *req;
 	struct cam_isp_ctx_req  *req_isp;
-	struct cam_hw_cmd_args   hw_cmd_args;
-	struct cam_isp_hw_cmd_args  isp_hw_cmd_args;
-	uint64_t last_cdm_done_req = 0;
-
-	struct cam_isp_hw_epoch_event_data *epoch_done_event_data =
-			(struct cam_isp_hw_epoch_event_data *)evt_data;
-
-	if (!evt_data) {
-		CAM_ERR(CAM_ISP, "invalid event data");
-		return -EINVAL;
-	}
-
-	ctx_isp->frame_id_meta = epoch_done_event_data->frame_id_meta;
+	uint64_t  request_id  = 0;
 
 	/*
 	 * notify reqmgr with sof signal. Note, due to scheduling delay
@@ -1481,84 +824,33 @@ static int __cam_isp_ctx_notify_sof_in_activated_state(
 			return rc;
 		}
 
-		if (ctx_isp->last_sof_timestamp ==
-			ctx_isp->sof_timestamp_val) {
-			CAM_DBG(CAM_ISP,
-				"Tasklet delay detected! Bubble frame check skipped, sof_timestamp: %lld",
-				ctx_isp->sof_timestamp_val);
-			goto notify_only;
-		}
-
 		req = list_first_entry(&ctx->active_req_list,
 			struct cam_ctx_request, list);
 		req_isp = (struct cam_isp_ctx_req *) req->req_priv;
 
 		if (ctx_isp->bubble_frame_cnt >= 1 &&
 			req_isp->bubble_detected) {
-			hw_cmd_args.ctxt_to_hw_map = ctx_isp->hw_ctx;
-			hw_cmd_args.cmd_type = CAM_HW_MGR_CMD_INTERNAL;
-			isp_hw_cmd_args.cmd_type =
-				CAM_ISP_HW_MGR_GET_LAST_CDM_DONE;
-			hw_cmd_args.u.internal_args = (void *)&isp_hw_cmd_args;
-			rc = ctx->hw_mgr_intf->hw_cmd(
-				ctx->hw_mgr_intf->hw_mgr_priv,
-				&hw_cmd_args);
-			if (rc) {
-				CAM_ERR(CAM_ISP,
-				"HW command failed to get last CDM done");
-				return rc;
-			}
-
-			last_cdm_done_req = isp_hw_cmd_args.u.last_cdm_done;
-			CAM_DBG(CAM_ISP, "last_cdm_done req: %d",
-				last_cdm_done_req);
-
-			if (last_cdm_done_req >= req->request_id) {
-				CAM_INFO_RATE_LIMIT(CAM_ISP,
-					"CDM callback detected for req: %lld, possible buf_done delay, waiting for buf_done",
-					req->request_id);
-				ctx_isp->bubble_frame_cnt = 0;
-			} else {
-				CAM_DBG(CAM_ISP,
-					"CDM callback not happened for req: %lld, possible CDM stuck or workqueue delay",
-					req->request_id);
-				req_isp->num_acked = 0;
-				ctx_isp->bubble_frame_cnt = 0;
-				req_isp->bubble_detected = false;
-				req_isp->cdm_reset_before_apply = true;
-				list_del_init(&req->list);
-				list_add(&req->list, &ctx->pending_req_list);
-				atomic_set(&ctx_isp->process_bubble, 0);
-				ctx_isp->active_req_cnt--;
-				CAM_DBG(CAM_REQ,
-					"Move active req: %lld to pending list(cnt = %d) [bubble re-apply],ctx %u",
-					req->request_id,
-					ctx_isp->active_req_cnt, ctx->ctx_id);
-			}
+			req_isp->num_acked = 0;
+			ctx_isp->bubble_frame_cnt = 0;
+			req_isp->bubble_detected = false;
+			list_del_init(&req->list);
+			list_add(&req->list, &ctx->pending_req_list);
+			atomic_set(&ctx_isp->process_bubble, 0);
+			ctx_isp->active_req_cnt--;
+			CAM_DBG(CAM_REQ,
+				"Move active req: %lld to pending list(cnt = %d) [bubble re-apply], ctx %u",
+				req->request_id,
+				ctx_isp->active_req_cnt, ctx->ctx_id);
 		} else if (req_isp->bubble_detected) {
-			if (ctx_isp->last_sof_timestamp !=
-				ctx_isp->sof_timestamp_val) {
-				ctx_isp->bubble_frame_cnt++;
-				CAM_DBG(CAM_ISP,
-					"Waiting on bufdone bubble req %lld ctx %u frame_cnt %lld link 0x%x",
-					req->request_id, ctx->ctx_id,
-					ctx_isp->bubble_frame_cnt,
-					ctx->link_hdl);
-			} else {
-				CAM_DBG(CAM_ISP,
-					"Possible tasklet delay req %lld ctx %u link 0x%x ts %lld",
-					req->request_id, ctx->ctx_id,
-					ctx->link_hdl,
-					ctx_isp->sof_timestamp_val);
-			}
-		} else
+			ctx_isp->bubble_frame_cnt++;
 			CAM_DBG(CAM_ISP,
-				"Delayed bufdone for req: %lld ctx %u link 0x%x",
-				req->request_id, ctx->ctx_id, ctx->link_hdl);
+				"Waiting on bufdone for bubble req: %lld, since frame_cnt = %lld",
+				req->request_id, ctx_isp->bubble_frame_cnt);
+		} else
+			CAM_DBG(CAM_ISP, "Delayed bufdone for req: %lld",
+				req->request_id);
 	}
 
-notify_only:
-
 	if (ctx->ctx_crm_intf && ctx->ctx_crm_intf->notify_trigger &&
 		ctx_isp->active_req_cnt <= 2) {
 		if (ctx_isp->subscribe_event & CAM_TRIGGER_POINT_SOF) {
@@ -1568,7 +860,6 @@ static int __cam_isp_ctx_notify_sof_in_activated_state(
 			notify.trigger = CAM_TRIGGER_POINT_SOF;
 			notify.req_id = ctx_isp->req_info.last_bufdone_req_id;
 			notify.sof_timestamp_val = ctx_isp->sof_timestamp_val;
-			notify.trigger_id = ctx_isp->trigger_id;
 
 			ctx->ctx_crm_intf->notify_trigger(&notify);
 			CAM_DBG(CAM_ISP, "Notify CRM  SOF frame %lld ctx %u",
@@ -1576,13 +867,9 @@ static int __cam_isp_ctx_notify_sof_in_activated_state(
 		}
 
 		list_for_each_entry(req, &ctx->active_req_list, list) {
-			req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-			if ((!req_isp->bubble_detected) &&
-				(req->request_id > ctx_isp->reported_req_id)) {
+			if (req->request_id > ctx_isp->reported_req_id) {
 				request_id = req->request_id;
 				ctx_isp->reported_req_id = request_id;
-				__cam_isp_ctx_update_event_record(ctx_isp,
-					CAM_ISP_CTX_EVENT_EPOCH, req);
 				break;
 			}
 		}
@@ -1602,7 +889,7 @@ static int __cam_isp_ctx_notify_sof_in_activated_state(
 			ctx->ctx_id);
 		rc = -EFAULT;
 	}
-	ctx_isp->last_sof_timestamp = ctx_isp->sof_timestamp_val;
+
 	return 0;
 }
 
@@ -1732,19 +1019,11 @@ static int __cam_isp_ctx_reg_upd_in_sof(struct cam_isp_context *ctx_isp,
 static int __cam_isp_ctx_epoch_in_applied(struct cam_isp_context *ctx_isp,
 	void *evt_data)
 {
-	uint64_t request_id = 0;
-	struct cam_ctx_request             *req;
-	struct cam_isp_ctx_req             *req_isp;
-	struct cam_context                 *ctx = ctx_isp->base;
-	struct cam_isp_hw_epoch_event_data *epoch_done_event_data =
-		(struct cam_isp_hw_epoch_event_data *)evt_data;
-
-	if (!evt_data) {
-		CAM_ERR(CAM_ISP, "invalid event data");
-		return -EINVAL;
-	}
+	struct cam_ctx_request    *req;
+	struct cam_isp_ctx_req    *req_isp;
+	struct cam_context        *ctx = ctx_isp->base;
+	uint64_t  request_id = 0;
 
-	ctx_isp->frame_id_meta = epoch_done_event_data->frame_id_meta;
 	if (list_empty(&ctx->wait_req_list)) {
 		/*
 		 * If no wait req in epoch, this is an error case.
@@ -1756,8 +1035,7 @@ static int __cam_isp_ctx_epoch_in_applied(struct cam_isp_context *ctx_isp,
 		/* Send SOF event as empty frame*/
 		__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 			CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-		__cam_isp_ctx_update_event_record(ctx_isp,
-			CAM_ISP_CTX_EVENT_EPOCH, NULL);
+
 		goto end;
 	}
 
@@ -1766,7 +1044,6 @@ static int __cam_isp_ctx_epoch_in_applied(struct cam_isp_context *ctx_isp,
 	req_isp = (struct cam_isp_ctx_req *)req->req_priv;
 	req_isp->bubble_detected = true;
 	req_isp->reapply = true;
-	req_isp->cdm_reset_before_apply = false;
 
 	CAM_INFO(CAM_ISP, "ctx:%d Report Bubble flag %d req id:%lld",
 		ctx->ctx_id, req_isp->bubble_report, req->request_id);
@@ -1778,16 +1055,9 @@ static int __cam_isp_ctx_epoch_in_applied(struct cam_isp_context *ctx_isp,
 		notify.dev_hdl = ctx->dev_hdl;
 		notify.req_id = req->request_id;
 		notify.error = CRM_KMD_ERR_BUBBLE;
-		notify.trigger = 0;
-		if (ctx_isp->subscribe_event & CAM_TRIGGER_POINT_SOF)
-			notify.trigger = CAM_TRIGGER_POINT_SOF;
-		notify.frame_id = ctx_isp->frame_id;
-		notify.sof_timestamp_val = ctx_isp->sof_timestamp_val;
 		CAM_WARN(CAM_ISP,
 			"Notify CRM about Bubble req %lld frame %lld, ctx %u",
 			req->request_id, ctx_isp->frame_id, ctx->ctx_id);
-		trace_cam_log_event("Bubble", "Rcvd epoch in applied state",
-			req->request_id, ctx->ctx_id);
 		ctx->ctx_crm_intf->notify_err(&notify);
 		atomic_set(&ctx_isp->process_bubble, 1);
 	} else {
@@ -1804,15 +1074,13 @@ static int __cam_isp_ctx_epoch_in_applied(struct cam_isp_context *ctx_isp,
 	CAM_DBG(CAM_REQ, "move request %lld to active list(cnt = %d), ctx %u",
 		req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
 
-	if ((req->request_id > ctx_isp->reported_req_id)
-		&& !req_isp->bubble_report) {
+	if (req->request_id > ctx_isp->reported_req_id) {
 		request_id = req->request_id;
 		ctx_isp->reported_req_id = request_id;
 	}
 	__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 		CAM_REQ_MGR_SOF_EVENT_ERROR);
-	__cam_isp_ctx_update_event_record(ctx_isp,
-		CAM_ISP_CTX_EVENT_EPOCH, req);
+
 	ctx_isp->substate_activated = CAM_ISP_CTX_ACTIVATED_BUBBLE;
 	CAM_DBG(CAM_ISP, "next Substate[%s]",
 		__cam_isp_ctx_substate_val_to_type(
@@ -1912,19 +1180,10 @@ static int __cam_isp_ctx_buf_done_in_bubble(
 static int __cam_isp_ctx_epoch_in_bubble_applied(
 	struct cam_isp_context *ctx_isp, void *evt_data)
 {
+	struct cam_ctx_request    *req;
+	struct cam_isp_ctx_req    *req_isp;
+	struct cam_context        *ctx = ctx_isp->base;
 	uint64_t  request_id = 0;
-	struct cam_ctx_request             *req;
-	struct cam_isp_ctx_req             *req_isp;
-	struct cam_context                 *ctx = ctx_isp->base;
-	struct cam_isp_hw_epoch_event_data *epoch_done_event_data =
-		(struct cam_isp_hw_epoch_event_data *)evt_data;
-
-	if (!evt_data) {
-		CAM_ERR(CAM_ISP, "invalid event data");
-		return -EINVAL;
-	}
-
-	ctx_isp->frame_id_meta = epoch_done_event_data->frame_id_meta;
 
 	/*
 	 * This means we missed the reg upd ack. So we need to
@@ -1939,8 +1198,6 @@ static int __cam_isp_ctx_epoch_in_bubble_applied(
 		CAM_ERR(CAM_ISP, "ctx:%d No pending request.", ctx->ctx_id);
 		__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 			CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-		__cam_isp_ctx_update_event_record(ctx_isp,
-			CAM_ISP_CTX_EVENT_EPOCH, NULL);
 
 		ctx_isp->substate_activated = CAM_ISP_CTX_ACTIVATED_BUBBLE;
 		goto end;
@@ -1953,7 +1210,6 @@ static int __cam_isp_ctx_epoch_in_bubble_applied(
 	CAM_INFO(CAM_ISP, "Ctx:%d Report Bubble flag %d req id:%lld",
 		ctx->ctx_id, req_isp->bubble_report, req->request_id);
 	req_isp->reapply = true;
-	req_isp->cdm_reset_before_apply = false;
 
 	if (req_isp->bubble_report && ctx->ctx_crm_intf &&
 		ctx->ctx_crm_intf->notify_err) {
@@ -1963,11 +1219,6 @@ static int __cam_isp_ctx_epoch_in_bubble_applied(
 		notify.dev_hdl = ctx->dev_hdl;
 		notify.req_id = req->request_id;
 		notify.error = CRM_KMD_ERR_BUBBLE;
-		notify.trigger = 0;
-		if (ctx_isp->subscribe_event & CAM_TRIGGER_POINT_SOF)
-			notify.trigger = CAM_TRIGGER_POINT_SOF;
-		notify.frame_id = ctx_isp->frame_id;
-		notify.sof_timestamp_val = ctx_isp->sof_timestamp_val;
 		CAM_WARN(CAM_REQ,
 			"Notify CRM about Bubble req_id %llu frame %lld, ctx %u",
 			req->request_id, ctx_isp->frame_id, ctx->ctx_id);
@@ -1993,21 +1244,13 @@ static int __cam_isp_ctx_epoch_in_bubble_applied(
 			ctx_isp->reported_req_id = request_id;
 			__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 			CAM_REQ_MGR_SOF_EVENT_ERROR);
-
-			__cam_isp_ctx_update_event_record(ctx_isp,
-				CAM_ISP_CTX_EVENT_EPOCH, req);
-		} else {
+		} else
 			__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 				CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-			__cam_isp_ctx_update_event_record(ctx_isp,
-				CAM_ISP_CTX_EVENT_EPOCH, NULL);
-		}
-	} else {
+	} else
 		__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 			CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-		__cam_isp_ctx_update_event_record(ctx_isp,
-			CAM_ISP_CTX_EVENT_EPOCH, NULL);
-	}
+
 	ctx_isp->substate_activated = CAM_ISP_CTX_ACTIVATED_BUBBLE;
 	CAM_DBG(CAM_ISP, "next Substate[%s]",
 		__cam_isp_ctx_substate_val_to_type(
@@ -2097,7 +1340,7 @@ static int __cam_isp_ctx_handle_error(struct cam_isp_context *ctx_isp,
 	req_isp = (struct cam_isp_ctx_req *) req_to_dump->req_priv;
 
 	if (error_event_data->enable_req_dump)
-		rc = cam_isp_ctx_dump_req(req_isp, 0, 0, NULL, false);
+		cam_isp_ctx_dump_req(req_isp);
 
 	__cam_isp_ctx_update_state_monitor_array(ctx_isp,
 		CAM_ISP_STATE_CHANGE_TRIGGER_ERROR, req_to_dump->request_id);
@@ -2219,9 +1462,6 @@ static int __cam_isp_ctx_handle_error(struct cam_isp_context *ctx_isp,
 
 	} while (req->request_id < ctx_isp->last_applied_req_id);
 
-	if (ctx_isp->offline_context)
-		goto exit;
-
 	if (ctx->ctx_crm_intf && ctx->ctx_crm_intf->notify_err) {
 		notify.link_hdl = ctx->link_hdl;
 		notify.dev_hdl = ctx->dev_hdl;
@@ -2248,14 +1488,8 @@ static int __cam_isp_ctx_handle_error(struct cam_isp_context *ctx_isp,
 		if (notify.error == CRM_KMD_ERR_FATAL) {
 			req_msg.session_hdl = ctx_isp->base->session_hdl;
 			req_msg.u.err_msg.device_hdl = ctx_isp->base->dev_hdl;
-
-			if (error_type == CAM_ISP_HW_ERROR_CSID_FATAL)
-				req_msg.u.err_msg.error_type =
-					CAM_REQ_MGR_ERROR_TYPE_FULL_RECOVERY;
-			else
-				req_msg.u.err_msg.error_type =
-					CAM_REQ_MGR_ERROR_TYPE_RECOVERY;
-
+			req_msg.u.err_msg.error_type =
+				CAM_REQ_MGR_ERROR_TYPE_RECOVERY;
 			req_msg.u.err_msg.link_hdl = ctx_isp->base->link_hdl;
 			req_msg.u.err_msg.request_id = error_request_id;
 			req_msg.u.err_msg.resource_size = 0x0;
@@ -2278,7 +1512,6 @@ static int __cam_isp_ctx_handle_error(struct cam_isp_context *ctx_isp,
 
 	CAM_DBG(CAM_ISP, "Exit");
 
-exit:
 	return rc;
 }
 
@@ -2662,63 +1895,6 @@ static struct cam_isp_ctx_irq_ops
 	},
 };
 
-static struct cam_isp_ctx_irq_ops
-	cam_isp_ctx_offline_state_machine_irq[CAM_ISP_CTX_ACTIVATED_MAX] = {
-	/* SOF */
-	{
-		.irq_ops = {
-			__cam_isp_ctx_handle_error,
-			NULL,
-			NULL,
-			NULL,
-			NULL,
-			NULL,
-		},
-	},
-	/* APPLIED */
-	{
-		.irq_ops = {
-			__cam_isp_ctx_handle_error,
-			__cam_isp_ctx_sof_in_activated_state,
-			__cam_isp_ctx_reg_upd_in_applied_state,
-			NULL,
-			NULL,
-			__cam_isp_ctx_buf_done_in_applied,
-		},
-	},
-	/* EPOCH */
-	{
-		.irq_ops = {
-			__cam_isp_ctx_handle_error,
-			NULL,
-			NULL,
-			__cam_isp_ctx_offline_epoch_in_activated_state,
-			NULL,
-			__cam_isp_ctx_buf_done_in_epoch,
-		},
-	},
-	/* BUBBLE */
-	{
-	},
-	/* Bubble Applied */
-	{
-	},
-	/* HW ERROR */
-	{
-		.irq_ops = {
-			NULL,
-			__cam_isp_ctx_sof_in_activated_state,
-			__cam_isp_ctx_reg_upd_in_hw_error,
-			NULL,
-			NULL,
-			NULL,
-		},
-	},
-	/* HALT */
-	{
-	},
-};
-
 static int __cam_isp_ctx_apply_req_in_activated_state(
 	struct cam_context *ctx, struct cam_req_mgr_apply_request *apply,
 	enum cam_isp_ctx_activated_substate next_state)
@@ -2754,14 +1930,6 @@ static int __cam_isp_ctx_apply_req_in_activated_state(
 		goto end;
 	}
 
-	if (apply->re_apply)
-		if (apply->request_id <= ctx_isp->last_applied_req_id) {
-			CAM_INFO(CAM_ISP,
-				"Trying to reapply the same request %llu again",
-				apply->request_id);
-			return 0;
-		}
-
 	spin_lock_bh(&ctx->lock);
 	req = list_first_entry(&ctx->pending_req_list, struct cam_ctx_request,
 		list);
@@ -2821,10 +1989,11 @@ static int __cam_isp_ctx_apply_req_in_activated_state(
 	cfg.priv  = &req_isp->hw_update_data;
 	cfg.init_packet = 0;
 	cfg.reapply = req_isp->reapply;
-	cfg.cdm_reset_before_apply = req_isp->cdm_reset_before_apply;
 
 	rc = ctx->hw_mgr_intf->hw_config(ctx->hw_mgr_intf->hw_mgr_priv, &cfg);
-	if (!rc) {
+	if (rc) {
+		CAM_ERR_RATE_LIMIT(CAM_ISP, "Can not apply the configuration");
+	} else {
 		spin_lock_bh(&ctx->lock);
 		ctx_isp->substate_activated = next_state;
 		ctx_isp->last_applied_req_id = apply->request_id;
@@ -2838,24 +2007,6 @@ static int __cam_isp_ctx_apply_req_in_activated_state(
 		__cam_isp_ctx_update_state_monitor_array(ctx_isp,
 			CAM_ISP_STATE_CHANGE_TRIGGER_APPLIED,
 			req->request_id);
-		__cam_isp_ctx_update_event_record(ctx_isp,
-			CAM_ISP_CTX_EVENT_APPLY, req);
-	} else if (rc == -EALREADY) {
-		spin_lock_bh(&ctx->lock);
-		req_isp->bubble_detected = true;
-		req_isp->cdm_reset_before_apply = false;
-		atomic_set(&ctx_isp->process_bubble, 1);
-		list_del_init(&req->list);
-		list_add(&req->list, &ctx->active_req_list);
-		ctx_isp->active_req_cnt++;
-		spin_unlock_bh(&ctx->lock);
-		CAM_DBG(CAM_REQ,
-			"move request %lld to active list(cnt = %d), ctx %u",
-			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
-	} else {
-		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"ctx_id:%d ,Can not apply (req %lld) the configuration, rc %d",
-			ctx->ctx_id, apply->request_id, rc);
 	}
 end:
 	return rc;
@@ -2933,199 +2084,6 @@ static int __cam_isp_ctx_apply_req_in_bubble(
 	return rc;
 }
 
-static int __cam_isp_ctx_dump_req_info(
-	struct cam_context     *ctx,
-	struct cam_ctx_request *req,
-	uintptr_t               cpu_addr,
-	size_t                  buf_len,
-	size_t                 *offset)
-{
-	int                                 i, rc;
-	uint8_t                            *dst;
-	int32_t                            *addr, *start;
-	uint32_t                            min_len;
-	size_t                              remain_len;
-	struct cam_isp_ctx_req             *req_isp;
-	struct cam_isp_context             *ctx_isp;
-	struct cam_isp_context_dump_header *hdr;
-
-	if (!req || !ctx || !offset || !cpu_addr || !buf_len) {
-		CAM_ERR(CAM_ISP, "Invalid parameters %pK %pK %pK %zu",
-			req, ctx, offset, buf_len);
-		return -EINVAL;
-	}
-	req_isp = (struct cam_isp_ctx_req *)req->req_priv;
-	ctx_isp = (struct cam_isp_context *)ctx->ctx_priv;
-
-	if (buf_len <= *offset) {
-		CAM_WARN(CAM_ISP, "Dump buffer overshoot len %zu offset %zu",
-			buf_len, *offset);
-		return -ENOSPC;
-	}
-
-	remain_len = buf_len - *offset;
-	min_len = sizeof(struct cam_isp_context_dump_header) +
-		(CAM_ISP_CTX_DUMP_REQUEST_NUM_WORDS *
-		 req_isp->num_fence_map_out *
-		sizeof(int32_t));
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_ISP, "Dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)cpu_addr + *offset;
-	hdr = (struct cam_isp_context_dump_header *)dst;
-	hdr->word_size = sizeof(int32_t);
-	scnprintf(hdr->tag, CAM_ISP_CONTEXT_DUMP_TAG_MAX_LEN,
-		"ISP_OUT_FENCE:");
-	addr = (int32_t *)(dst + sizeof(struct cam_isp_context_dump_header));
-	start = addr;
-	for (i = 0; i < req_isp->num_fence_map_out; i++) {
-		*addr++ = req_isp->fence_map_out[i].resource_handle;
-		*addr++ = req_isp->fence_map_out[i].sync_id;
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	*offset += hdr->size + sizeof(struct cam_isp_context_dump_header);
-	rc = cam_isp_ctx_dump_req(req_isp, cpu_addr, buf_len,
-		offset, true);
-	return rc;
-}
-
-static int __cam_isp_ctx_dump_in_top_state(
-	struct cam_context           *ctx,
-	struct cam_req_mgr_dump_info *dump_info)
-{
-	int                                 rc = 0;
-	bool                                dump_only_event_record = false;
-	size_t                              buf_len;
-	size_t                              remain_len;
-	uint8_t                            *dst;
-	ktime_t                             cur_time;
-	uint32_t                            min_len;
-	uint64_t                            diff;
-	uint64_t                           *addr, *start;
-	uintptr_t                           cpu_addr;
-	struct timespec64                   ts;
-	struct cam_isp_context             *ctx_isp;
-	struct cam_ctx_request             *req = NULL;
-	struct cam_isp_ctx_req             *req_isp;
-	struct cam_ctx_request             *req_temp;
-	struct cam_hw_dump_args             dump_args;
-	struct cam_isp_context_dump_header *hdr;
-
-	spin_lock_bh(&ctx->lock);
-	list_for_each_entry_safe(req, req_temp,
-		&ctx->active_req_list, list) {
-		if (req->request_id == dump_info->req_id) {
-			CAM_INFO(CAM_ISP, "isp dump active list req: %lld",
-			    dump_info->req_id);
-			goto hw_dump;
-		}
-	}
-	list_for_each_entry_safe(req, req_temp,
-		&ctx->wait_req_list, list) {
-		if (req->request_id == dump_info->req_id) {
-			CAM_INFO(CAM_ISP, "isp dump wait list req: %lld",
-			    dump_info->req_id);
-			goto hw_dump;
-		}
-	}
-	spin_unlock_bh(&ctx->lock);
-	return rc;
-hw_dump:
-	rc  = cam_mem_get_cpu_buf(dump_info->buf_handle,
-		&cpu_addr, &buf_len);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Invalid handle %u rc %d",
-			dump_info->buf_handle, rc);
-		spin_unlock_bh(&ctx->lock);
-		return rc;
-	}
-	if (buf_len <= dump_info->offset) {
-		spin_unlock_bh(&ctx->lock);
-		CAM_WARN(CAM_ISP, "Dump buffer overshoot len %zu offset %zu",
-			buf_len, dump_info->offset);
-		return -ENOSPC;
-	}
-
-	remain_len = buf_len - dump_info->offset;
-	min_len = sizeof(struct cam_isp_context_dump_header) +
-		(CAM_ISP_CTX_DUMP_NUM_WORDS * sizeof(uint64_t));
-
-	if (remain_len < min_len) {
-		spin_unlock_bh(&ctx->lock);
-		CAM_WARN(CAM_ISP, "Dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-
-	ctx_isp = (struct cam_isp_context *) ctx->ctx_priv;
-	req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-	cur_time = ktime_get();
-	diff = ktime_us_delta(cur_time,
-		req_isp->event_timestamp[CAM_ISP_CTX_EVENT_APPLY]);
-	if (diff < CAM_ISP_CTX_RESPONSE_TIME_THRESHOLD) {
-		CAM_INFO(CAM_ISP, "req %lld found no error",
-			req->request_id);
-		dump_only_event_record = true;
-	}
-	dst = (uint8_t *)cpu_addr + dump_info->offset;
-	hdr = (struct cam_isp_context_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_ISP_CONTEXT_DUMP_TAG_MAX_LEN,
-		"ISP_CTX_DUMP:");
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst +
-		sizeof(struct cam_isp_context_dump_header));
-	start = addr;
-	*addr++ = req->request_id;
-	ts      = ktime_to_timespec64(
-		req_isp->event_timestamp[CAM_ISP_CTX_EVENT_APPLY]);
-	*addr++ = ts.tv_sec;
-	*addr++ = ts.tv_nsec/NSEC_PER_USEC;
-	ts      = ktime_to_timespec64(cur_time);
-	*addr++ = ts.tv_sec;
-	*addr++ = ts.tv_nsec/NSEC_PER_USEC;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_info->offset += hdr->size +
-		sizeof(struct cam_isp_context_dump_header);
-
-	rc = __cam_isp_ctx_dump_event_record(ctx_isp, cpu_addr,
-		buf_len, &dump_info->offset);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Dump event fail %lld",
-			req->request_id);
-		spin_unlock_bh(&ctx->lock);
-		return rc;
-	}
-	if (dump_only_event_record) {
-		spin_unlock_bh(&ctx->lock);
-		return rc;
-	}
-	rc = __cam_isp_ctx_dump_req_info(ctx, req, cpu_addr,
-		buf_len, &dump_info->offset);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Dump Req info fail %lld",
-			req->request_id);
-		spin_unlock_bh(&ctx->lock);
-		return rc;
-	}
-	spin_unlock_bh(&ctx->lock);
-
-	if (ctx->hw_mgr_intf->hw_dump) {
-		dump_args.offset = dump_info->offset;
-		dump_args.request_id = dump_info->req_id;
-		dump_args.buf_handle = dump_info->buf_handle;
-		dump_args.ctxt_to_hw_map = ctx_isp->hw_ctx;
-		rc = ctx->hw_mgr_intf->hw_dump(
-			ctx->hw_mgr_intf->hw_mgr_priv,
-			&dump_args);
-		dump_info->offset = dump_args.offset;
-	}
-	return rc;
-}
-
 static int __cam_isp_ctx_flush_req(struct cam_context *ctx,
 	struct list_head *req_list, struct cam_req_mgr_flush_request *flush_req)
 {
@@ -3191,7 +2149,6 @@ static int __cam_isp_ctx_flush_req(struct cam_context *ctx,
 			}
 		}
 		req_isp->reapply = false;
-		req_isp->cdm_reset_before_apply = false;
 		list_del_init(&req->list);
 		list_add_tail(&req->list, &ctx->free_req_list);
 	}
@@ -3293,7 +2250,6 @@ static int __cam_isp_ctx_flush_req_in_top_state(
 end:
 	ctx_isp->bubble_frame_cnt = 0;
 	atomic_set(&ctx_isp->process_bubble, 0);
-	atomic_set(&ctx_isp->rxd_epoch, 0);
 	return rc;
 }
 
@@ -3557,7 +2513,6 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_applied(
 	CAM_INFO(CAM_ISP, "Ctx:%d Report Bubble flag %d req id:%lld",
 		ctx->ctx_id, req_isp->bubble_report, req->request_id);
 	req_isp->reapply = true;
-	req_isp->cdm_reset_before_apply = false;
 
 	if (req_isp->bubble_report && ctx->ctx_crm_intf &&
 		ctx->ctx_crm_intf->notify_err) {
@@ -3567,18 +2522,12 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_applied(
 		notify.dev_hdl = ctx->dev_hdl;
 		notify.req_id = req->request_id;
 		notify.error = CRM_KMD_ERR_BUBBLE;
-		notify.trigger = 0;
-		if (ctx_isp->subscribe_event & CAM_TRIGGER_POINT_SOF)
-			notify.trigger = CAM_TRIGGER_POINT_SOF;
-		notify.frame_id = ctx_isp->frame_id;
-		notify.sof_timestamp_val = ctx_isp->sof_timestamp_val;
 		CAM_WARN(CAM_ISP,
 			"Notify CRM about Bubble req %lld frame %lld ctx %u",
 			req->request_id,
 			ctx_isp->frame_id,
 			ctx->ctx_id);
 		ctx->ctx_crm_intf->notify_err(&notify);
-		atomic_set(&ctx_isp->process_bubble, 1);
 	} else {
 		req_isp->bubble_report = 0;
 	}
@@ -3624,11 +2573,7 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_state(
 	struct cam_req_mgr_trigger_notify      notify;
 	struct cam_isp_hw_sof_event_data      *sof_event_data = evt_data;
 	struct cam_isp_ctx_req                *req_isp;
-	struct cam_hw_cmd_args                 hw_cmd_args;
-	struct cam_isp_hw_cmd_args             isp_hw_cmd_args;
 	uint64_t                               request_id  = 0;
-	uint64_t                               last_cdm_done_req = 0;
-	int                                    rc = 0;
 
 	if (!evt_data) {
 		CAM_ERR(CAM_ISP, "in valid sof event data");
@@ -3640,71 +2585,6 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_state(
 	ctx_isp->boot_timestamp = sof_event_data->boot_time;
 	CAM_DBG(CAM_ISP, "frame id: %lld time stamp:0x%llx",
 		ctx_isp->frame_id, ctx_isp->sof_timestamp_val);
-
-
-	if (atomic_read(&ctx_isp->process_bubble)) {
-		if (list_empty(&ctx->active_req_list)) {
-			CAM_ERR(CAM_ISP, "No available active req in bubble");
-			atomic_set(&ctx_isp->process_bubble, 0);
-			return -EINVAL;
-		}
-
-		if (ctx_isp->last_sof_timestamp ==
-				ctx_isp->sof_timestamp_val) {
-			CAM_DBG(CAM_ISP,
-				"Tasklet delay detected! Bubble frame check skipped, sof_timestamp: %lld, ctx_id: %d",
-				ctx_isp->sof_timestamp_val,
-				ctx->ctx_id);
-			goto end;
-		}
-
-		req = list_first_entry(&ctx->active_req_list,
-				struct cam_ctx_request, list);
-		req_isp = (struct cam_isp_ctx_req *) req->req_priv;
-
-		if (req_isp->bubble_detected) {
-			hw_cmd_args.ctxt_to_hw_map = ctx_isp->hw_ctx;
-			hw_cmd_args.cmd_type = CAM_HW_MGR_CMD_INTERNAL;
-			isp_hw_cmd_args.cmd_type =
-				CAM_ISP_HW_MGR_GET_LAST_CDM_DONE;
-			hw_cmd_args.u.internal_args = (void *)&isp_hw_cmd_args;
-			rc = ctx->hw_mgr_intf->hw_cmd(
-				ctx->hw_mgr_intf->hw_mgr_priv,
-				&hw_cmd_args);
-			if (rc) {
-				CAM_ERR(CAM_ISP,
-				"HW command failed to get last CDM done");
-				return rc;
-			}
-
-			last_cdm_done_req = isp_hw_cmd_args.u.last_cdm_done;
-			CAM_DBG(CAM_ISP, "last_cdm_done req: %d ctx_id: %d",
-				last_cdm_done_req, ctx->ctx_id);
-
-			if (last_cdm_done_req >= req->request_id) {
-				CAM_DBG(CAM_ISP,
-					"CDM callback detected for req: %lld, possible buf_done delay, waiting for buf_done",
-					req->request_id);
-				goto end;
-			} else {
-				CAM_DBG(CAM_ISP,
-					"CDM callback not happened for req: %lld, possible CDM stuck or workqueue delay",
-					req->request_id);
-				req_isp->num_acked = 0;
-				req_isp->bubble_detected = false;
-				req_isp->cdm_reset_before_apply = true;
-				list_del_init(&req->list);
-				list_add(&req->list, &ctx->pending_req_list);
-				atomic_set(&ctx_isp->process_bubble, 0);
-				ctx_isp->active_req_cnt--;
-				CAM_DBG(CAM_REQ,
-					"Move active req: %lld to pending list(cnt = %d) [bubble re-apply],ctx %u",
-					req->request_id,
-					ctx_isp->active_req_cnt, ctx->ctx_id);
-			}
-			goto end;
-		}
-	}
 	/*
 	 * Signal all active requests with error and move the  all the active
 	 * requests to free list
@@ -3726,7 +2606,6 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_state(
 		ctx_isp->active_req_cnt--;
 	}
 
-end:
 	/* notify reqmgr with sof signal */
 	if (ctx->ctx_crm_intf && ctx->ctx_crm_intf->notify_trigger) {
 		notify.link_hdl = ctx->link_hdl;
@@ -3757,14 +2636,13 @@ static int __cam_isp_ctx_rdi_only_sof_in_bubble_state(
 		__cam_isp_ctx_substate_val_to_type(
 		ctx_isp->substate_activated));
 
-	ctx_isp->last_sof_timestamp = ctx_isp->sof_timestamp_val;
 	return 0;
 }
 
 static int __cam_isp_ctx_rdi_only_reg_upd_in_bubble_applied_state(
 	struct cam_isp_context *ctx_isp, void *evt_data)
 {
-	struct cam_ctx_request  *req = NULL;
+	struct cam_ctx_request  *req;
 	struct cam_context      *ctx = ctx_isp->base;
 	struct cam_isp_ctx_req  *req_isp;
 	struct cam_req_mgr_trigger_notify  notify;
@@ -3824,15 +2702,12 @@ static int __cam_isp_ctx_rdi_only_reg_upd_in_bubble_applied_state(
 	CAM_DBG(CAM_ISP, "next Substate[%s]",
 		__cam_isp_ctx_substate_val_to_type(
 		ctx_isp->substate_activated));
-	__cam_isp_ctx_update_event_record(ctx_isp,
-		CAM_ISP_CTX_EVENT_RUP, req);
+
 	return 0;
 error:
 	/* Send SOF event as idle frame*/
 	__cam_isp_ctx_send_sof_timestamp(ctx_isp, request_id,
 		CAM_REQ_MGR_SOF_EVENT_SUCCESS);
-	__cam_isp_ctx_update_event_record(ctx_isp,
-		CAM_ISP_CTX_EVENT_RUP, NULL);
 
 	/*
 	 * There is no request in the pending list, move the sub state machine
@@ -3992,7 +2867,6 @@ static int __cam_isp_ctx_release_hw_in_top_state(struct cam_context *ctx,
 	struct cam_isp_context *ctx_isp =
 		(struct cam_isp_context *) ctx->ctx_priv;
 	struct cam_req_mgr_flush_request flush_req;
-	int i;
 
 	if (ctx_isp->hw_ctx) {
 		rel_arg.ctxt_to_hw_map = ctx_isp->hw_ctx;
@@ -4004,20 +2878,15 @@ static int __cam_isp_ctx_release_hw_in_top_state(struct cam_context *ctx,
 	}
 
 	ctx->last_flush_req = 0;
-	ctx_isp->custom_enabled = false;
-	ctx_isp->use_frame_header_ts = false;
 	ctx_isp->frame_id = 0;
 	ctx_isp->active_req_cnt = 0;
 	ctx_isp->reported_req_id = 0;
 	ctx_isp->hw_acquired = false;
 	ctx_isp->init_received = false;
-	ctx_isp->support_consumed_addr = false;
 	ctx_isp->req_info.last_bufdone_req_id = 0;
 
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
 
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
 	/*
 	 * Ideally, we should never have any active request here.
 	 * But we still add some sanity check code here to help the debug
@@ -4047,7 +2916,6 @@ static int __cam_isp_ctx_release_dev_in_top_state(struct cam_context *ctx,
 	struct cam_release_dev_cmd *cmd)
 {
 	int rc = 0;
-	int i;
 	struct cam_hw_release_args       rel_arg;
 	struct cam_isp_context *ctx_isp =
 		(struct cam_isp_context *) ctx->ctx_priv;
@@ -4079,8 +2947,7 @@ static int __cam_isp_ctx_release_dev_in_top_state(struct cam_context *ctx,
 	ctx_isp->req_info.last_bufdone_req_id = 0;
 
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
+
 	/*
 	 * Ideally, we should never have any active request here.
 	 * But we still add some sanity check code here to help the debug
@@ -4119,9 +2986,6 @@ static int __cam_isp_ctx_config_dev_in_top_state(
 	struct cam_req_mgr_add_request    add_req;
 	struct cam_isp_context           *ctx_isp =
 		(struct cam_isp_context *) ctx->ctx_priv;
-	struct cam_hw_cmd_args           hw_cmd_args;
-	struct cam_isp_hw_cmd_args       isp_hw_cmd_args;
-	uint32_t                         packet_opcode = 0;
 
 	CAM_DBG(CAM_ISP, "get free request object......");
 
@@ -4170,23 +3034,7 @@ static int __cam_isp_ctx_config_dev_in_top_state(
 	CAM_DBG(CAM_ISP, "Packet size 0x%x", packet->header.size);
 	CAM_DBG(CAM_ISP, "packet op %d", packet->header.op_code);
 
-	/* Query the packet opcode */
-	hw_cmd_args.ctxt_to_hw_map = ctx_isp->hw_ctx;
-	hw_cmd_args.cmd_type = CAM_HW_MGR_CMD_INTERNAL;
-	isp_hw_cmd_args.cmd_type = CAM_ISP_HW_MGR_GET_PACKET_OPCODE;
-	isp_hw_cmd_args.cmd_data = (void *)packet;
-	hw_cmd_args.u.internal_args = (void *)&isp_hw_cmd_args;
-	rc = ctx->hw_mgr_intf->hw_cmd(ctx->hw_mgr_intf->hw_mgr_priv,
-		&hw_cmd_args);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "HW command failed");
-		goto free_req;
-	}
-
-	packet_opcode = isp_hw_cmd_args.u.packet_op_code;
-	CAM_DBG(CAM_ISP, "packet op %d", packet_opcode);
-
-	if ((packet_opcode == CAM_ISP_PACKET_UPDATE_DEV)
+	if ((((packet->header.op_code + 1) & 0xF) == CAM_ISP_PACKET_UPDATE_DEV)
 		&& (packet->header.request_id <= ctx->last_flush_req)) {
 		CAM_INFO(CAM_ISP,
 			"request %lld has been flushed, reject packet",
@@ -4223,7 +3071,6 @@ static int __cam_isp_ctx_config_dev_in_top_state(
 	req_isp->num_fence_map_in = cfg.num_in_map_entries;
 	req_isp->num_acked = 0;
 	req_isp->bubble_detected = false;
-	req_isp->cdm_reset_before_apply = false;
 
 	for (i = 0; i < req_isp->num_fence_map_out; i++) {
 		rc = cam_sync_get_obj_ref(req_isp->fence_map_out[i].sync_id);
@@ -4258,11 +3105,8 @@ static int __cam_isp_ctx_config_dev_in_top_state(
 				ctx->state);
 		}
 	} else {
-		if (ctx_isp->offline_context) {
-			__cam_isp_ctx_enqueue_request_in_order(ctx, req);
-		} else if ((ctx->state != CAM_CTX_FLUSHED) &&
-			(ctx->state >= CAM_CTX_READY) &&
-			ctx->ctx_crm_intf->add_req) {
+		if (ctx->state != CAM_CTX_FLUSHED && ctx->state >= CAM_CTX_READY
+			&& ctx->ctx_crm_intf->add_req) {
 			add_req.link_hdl = ctx->link_hdl;
 			add_req.dev_hdl  = ctx->dev_hdl;
 			add_req.req_id   = req->request_id;
@@ -4289,10 +3133,6 @@ static int __cam_isp_ctx_config_dev_in_top_state(
 		"Preprocessing Config req_id %lld successful on ctx %u",
 		req->request_id, ctx->ctx_id);
 
-	if (ctx_isp->offline_context && atomic_read(&ctx_isp->rxd_epoch)) {
-		__cam_isp_ctx_schedule_apply_req_offline(ctx_isp);
-	}
-
 	return rc;
 
 put_ref:
@@ -4313,7 +3153,6 @@ static int __cam_isp_ctx_acquire_dev_in_available(struct cam_context *ctx,
 	struct cam_acquire_dev_cmd *cmd)
 {
 	int rc = 0;
-	int i;
 	struct cam_hw_acquire_args       param;
 	struct cam_isp_resource         *isp_res = NULL;
 	struct cam_create_dev_hdl        req_hdl_param;
@@ -4407,15 +3246,11 @@ static int __cam_isp_ctx_acquire_dev_in_available(struct cam_context *ctx,
 			cam_isp_ctx_rdi_only_activated_state_machine;
 		ctx_isp->rdi_only_context = true;
 	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_FS2) {
-		CAM_DBG(CAM_ISP, "FS2 Session has PIX, RD and RDI");
+		CAM_DBG(CAM_ISP, "FS2 Session has PIX ,RD and RDI");
 		ctx_isp->substate_machine_irq =
 			cam_isp_ctx_fs2_state_machine_irq;
 		ctx_isp->substate_machine =
 			cam_isp_ctx_fs2_state_machine;
-	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_OFFLINE) {
-		CAM_DBG(CAM_ISP, "offline Session has PIX and RD resources");
-		ctx_isp->substate_machine_irq =
-			cam_isp_ctx_offline_state_machine_irq;
 	} else {
 		CAM_DBG(CAM_ISP, "Session has PIX or PIX and RDI resources");
 		ctx_isp->substate_machine_irq =
@@ -4430,8 +3265,6 @@ static int __cam_isp_ctx_acquire_dev_in_available(struct cam_context *ctx,
 	ctx->ctxt_to_hw_map = param.ctxt_to_hw_map;
 
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
 
 	kfree(isp_res);
 	isp_res = NULL;
@@ -4482,7 +3315,6 @@ static int __cam_isp_ctx_acquire_hw_v1(struct cam_context *ctx,
 	void *args)
 {
 	int rc = 0;
-	int i;
 	struct cam_acquire_hw_cmd_v1 *cmd =
 		(struct cam_acquire_hw_cmd_v1 *)args;
 	struct cam_hw_acquire_args       param;
@@ -4569,16 +3401,11 @@ static int __cam_isp_ctx_acquire_hw_v1(struct cam_context *ctx,
 			cam_isp_ctx_rdi_only_activated_state_machine;
 		ctx_isp->rdi_only_context = true;
 	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_FS2) {
-		CAM_DBG(CAM_ISP, "FS2 Session has PIX, RD and RDI");
+		CAM_DBG(CAM_ISP, "FS2 Session has PIX ,RD and RDI");
 		ctx_isp->substate_machine_irq =
 			cam_isp_ctx_fs2_state_machine_irq;
 		ctx_isp->substate_machine =
 			cam_isp_ctx_fs2_state_machine;
-	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_OFFLINE) {
-		CAM_DBG(CAM_ISP, "Offline session has PIX and RD resources");
-		ctx_isp->substate_machine_irq =
-			cam_isp_ctx_offline_state_machine_irq;
-		ctx_isp->substate_machine = NULL;
 	} else {
 		CAM_DBG(CAM_ISP, "Session has PIX or PIX and RDI resources");
 		ctx_isp->substate_machine_irq =
@@ -4593,9 +3420,6 @@ static int __cam_isp_ctx_acquire_hw_v1(struct cam_context *ctx,
 
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
 
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
-
 	trace_cam_context_state("ISP", ctx);
 	CAM_DBG(CAM_ISP,
 		"Acquire success on session_hdl 0x%xs ctx_type %d ctx_id %u",
@@ -4614,11 +3438,6 @@ static int __cam_isp_ctx_acquire_hw_v1(struct cam_context *ctx,
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_offline_ife_worker(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 static int __cam_isp_ctx_acquire_hw_v2(struct cam_context *ctx,
 	void *args)
 {
@@ -4684,14 +3503,6 @@ static int __cam_isp_ctx_acquire_hw_v2(struct cam_context *ctx,
 		goto free_res;
 	}
 
-	/* Set custom flag if applicable
-	 * custom hw is supported only on v2
-	 */
-	ctx_isp->custom_enabled = param.custom_enabled;
-	ctx_isp->use_frame_header_ts = param.use_frame_header_ts;
-	ctx_isp->support_consumed_addr =
-		param.support_consumed_addr;
-
 	/* Query the context has rdi only resource */
 	hw_cmd_args.ctxt_to_hw_map = param.ctxt_to_hw_map;
 	hw_cmd_args.cmd_type = CAM_HW_MGR_CMD_INTERNAL;
@@ -4732,25 +3543,11 @@ static int __cam_isp_ctx_acquire_hw_v2(struct cam_context *ctx,
 			cam_isp_ctx_rdi_only_activated_state_machine;
 		ctx_isp->rdi_only_context = true;
 	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_FS2) {
-		CAM_DBG(CAM_ISP, "FS2 Session has PIX, RD and RDI");
+		CAM_DBG(CAM_ISP, "FS2 Session has PIX ,RD and RDI");
 		ctx_isp->substate_machine_irq =
 			cam_isp_ctx_fs2_state_machine_irq;
 		ctx_isp->substate_machine =
 			cam_isp_ctx_fs2_state_machine;
-	} else if (isp_hw_cmd_args.u.ctx_type == CAM_ISP_CTX_OFFLINE) {
-		CAM_DBG(CAM_ISP, "Offline Session has PIX and RD resources");
-		ctx_isp->substate_machine_irq =
-			cam_isp_ctx_offline_state_machine_irq;
-		ctx_isp->substate_machine = NULL;
-		ctx_isp->offline_context = true;
-
-		rc = cam_req_mgr_workq_create("offline_ife", 20,
-			&ctx_isp->workq, CRM_WORKQ_USAGE_IRQ, 0, false,
-			cam_req_mgr_process_workq_offline_ife_worker);
-		if (rc)
-			CAM_ERR(CAM_ISP,
-				"Failed to create workq for offline IFE rc:%d",
-				rc);
 	} else {
 		CAM_DBG(CAM_ISP, "Session has PIX or PIX and RDI resources");
 		ctx_isp->substate_machine_irq =
@@ -4817,10 +3614,11 @@ static int __cam_isp_ctx_config_dev_in_acquired(struct cam_context *ctx,
 
 	rc = __cam_isp_ctx_config_dev_in_top_state(ctx, cmd);
 
-	if (!rc && ((ctx->link_hdl >= 0) || ctx_isp->offline_context)) {
+	if (!rc && (ctx->link_hdl >= 0)) {
 		ctx->state = CAM_CTX_READY;
 		trace_cam_context_state("ISP", ctx);
 	}
+
 	CAM_DBG(CAM_ISP, "next state %d", ctx->state);
 	return rc;
 }
@@ -4890,7 +3688,6 @@ static int __cam_isp_ctx_link_in_acquired(struct cam_context *ctx,
 	ctx->link_hdl = link->link_hdl;
 	ctx->ctx_crm_intf = link->crm_cb;
 	ctx_isp->subscribe_event = link->subscribe_event;
-	ctx_isp->trigger_id = link->trigger_id;
 
 	/* change state only if we had the init config */
 	if (ctx_isp->init_received) {
@@ -4907,12 +3704,9 @@ static int __cam_isp_ctx_unlink_in_acquired(struct cam_context *ctx,
 	struct cam_req_mgr_core_dev_link_setup *unlink)
 {
 	int rc = 0;
-	struct cam_isp_context *ctx_isp =
-		(struct cam_isp_context *) ctx->ctx_priv;
 
 	ctx->link_hdl = -1;
 	ctx->ctx_crm_intf = NULL;
-	ctx_isp->trigger_id = -1;
 
 	return rc;
 }
@@ -4927,7 +3721,6 @@ static int __cam_isp_ctx_get_dev_info_in_acquired(struct cam_context *ctx,
 	dev_info->dev_id = CAM_REQ_MGR_DEVICE_IFE;
 	dev_info->p_delay = 1;
 	dev_info->trigger = CAM_TRIGGER_POINT_SOF;
-	dev_info->trigger_on = true;
 
 	return rc;
 }
@@ -4936,7 +3729,6 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 	struct cam_start_stop_dev_cmd *cmd)
 {
 	int rc = 0;
-	int i;
 	struct cam_isp_start_args        start_isp;
 	struct cam_ctx_request          *req;
 	struct cam_isp_ctx_req          *req_isp;
@@ -4973,7 +3765,6 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 	start_isp.hw_config.priv  = &req_isp->hw_update_data;
 	start_isp.hw_config.init_packet = 1;
 	start_isp.hw_config.reapply = 0;
-	start_isp.hw_config.cdm_reset_before_apply = false;
 
 	ctx_isp->last_applied_req_id = req->request_id;
 
@@ -4983,7 +3774,6 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 		start_isp.start_only = false;
 
 	atomic_set(&ctx_isp->process_bubble, 0);
-	atomic_set(&ctx_isp->rxd_epoch, 0);
 	ctx_isp->frame_id = 0;
 	ctx_isp->active_req_cnt = 0;
 	ctx_isp->reported_req_id = 0;
@@ -4995,9 +3785,6 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
 
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
-
 	/*
 	 * In case of CSID TPG we might receive SOF and RUP IRQs
 	 * before hw_mgr_intf->hw_start has returned. So move
@@ -5006,24 +3793,11 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 	 */
 	list_del_init(&req->list);
 
-	if (ctx_isp->offline_context && !req_isp->num_fence_map_out) {
-		list_add_tail(&req->list, &ctx->free_req_list);
-		atomic_set(&ctx_isp->rxd_epoch, 1);
-		CAM_DBG(CAM_REQ,
-			"Move pending req: %lld to free list(cnt: %d) offline ctx %u",
-			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
-	} else if (ctx_isp->rdi_only_context || !req_isp->num_fence_map_out) {
+	if (ctx_isp->rdi_only_context || !req_isp->num_fence_map_out) {
 		list_add_tail(&req->list, &ctx->wait_req_list);
-		CAM_DBG(CAM_REQ,
-			"Move pending req: %lld to wait list(cnt: %d) ctx %u",
-			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id);
 	} else {
 		list_add_tail(&req->list, &ctx->active_req_list);
 		ctx_isp->active_req_cnt++;
-		CAM_DBG(CAM_REQ,
-			"Move pending req: %lld to active list(cnt: %d) ctx %u offline %d",
-			req->request_id, ctx_isp->active_req_cnt, ctx->ctx_id,
-			ctx_isp->offline_context);
 	}
 
 	/*
@@ -5041,7 +3815,7 @@ static int __cam_isp_ctx_start_dev_in_ready(struct cam_context *ctx,
 		ctx->state = CAM_CTX_READY;
 		trace_cam_context_state("ISP", ctx);
 		if (rc == -ETIMEDOUT)
-			cam_isp_ctx_dump_req(req_isp, 0, 0, NULL, false);
+			cam_isp_ctx_dump_req(req_isp);
 		list_del_init(&req->list);
 		list_add(&req->list, &ctx->pending_req_list);
 		goto end;
@@ -5168,12 +3942,8 @@ static int __cam_isp_ctx_stop_dev_in_activated_unlock(
 	ctx_isp->last_applied_req_id = 0;
 	ctx_isp->req_info.last_bufdone_req_id = 0;
 	atomic_set(&ctx_isp->process_bubble, 0);
-	atomic_set(&ctx_isp->rxd_epoch, 0);
 	atomic64_set(&ctx_isp->state_monitor_head, -1);
 
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx_isp->event_record_head[i], -1);
-
 	CAM_DBG(CAM_ISP, "Stop device success next state %d on ctx %u",
 		ctx->state, ctx->ctx_id);
 
@@ -5430,7 +4200,6 @@ static struct cam_ctx_ops
 			.unlink = __cam_isp_ctx_unlink_in_acquired,
 			.get_dev_info = __cam_isp_ctx_get_dev_info_in_acquired,
 			.flush_req = __cam_isp_ctx_flush_req_in_top_state,
-			.dump_req = __cam_isp_ctx_dump_in_top_state,
 		},
 		.irq_ops = NULL,
 		.pagefault_ops = cam_isp_context_dump_active_request,
@@ -5447,7 +4216,6 @@ static struct cam_ctx_ops
 		.crm_ops = {
 			.unlink = __cam_isp_ctx_unlink_in_ready,
 			.flush_req = __cam_isp_ctx_flush_req_in_ready,
-			.dump_req = __cam_isp_ctx_dump_in_top_state,
 		},
 		.irq_ops = NULL,
 		.pagefault_ops = cam_isp_context_dump_active_request,
@@ -5482,7 +4250,6 @@ static struct cam_ctx_ops
 			.apply_req = __cam_isp_ctx_apply_req,
 			.flush_req = __cam_isp_ctx_flush_req_in_top_state,
 			.process_evt = __cam_isp_ctx_process_evt,
-			.dump_req = __cam_isp_ctx_dump_in_top_state,
 		},
 		.irq_ops = __cam_isp_ctx_handle_irq_in_activated,
 		.pagefault_ops = cam_isp_context_dump_active_request,
@@ -5630,8 +4397,6 @@ int cam_isp_context_init(struct cam_isp_context *ctx,
 
 	ctx->base = ctx_base;
 	ctx->frame_id = 0;
-	ctx->custom_enabled = false;
-	ctx->use_frame_header_ts = false;
 	ctx->active_req_cnt = 0;
 	ctx->reported_req_id = 0;
 	ctx->req_info.last_bufdone_req_id = 0;
@@ -5666,11 +4431,7 @@ int cam_isp_context_init(struct cam_isp_context *ctx,
 	}
 	atomic64_set(&ctx->state_monitor_head, -1);
 
-	for (i = 0; i < CAM_ISP_CTX_EVENT_MAX; i++)
-		atomic64_set(&ctx->event_record_head[i], -1);
-
 	cam_isp_context_debug_register();
-
 err:
 	return rc;
 }
diff --git a/techpack/camera/drivers/cam_isp/cam_isp_context.h b/techpack/camera/drivers/cam_isp/cam_isp_context.h
index f3e2b3c25f9f..503e46526dee 100644
--- a/techpack/camera/drivers/cam_isp/cam_isp_context.h
+++ b/techpack/camera/drivers/cam_isp/cam_isp_context.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_ISP_CONTEXT_H_
@@ -14,10 +13,6 @@
 
 #include "cam_context.h"
 #include "cam_isp_hw_mgr_intf.h"
-#include "cam_req_mgr_workq.h"
-
-#define CAM_IFE_QTIMER_MUL_FACTOR        10000
-#define CAM_IFE_QTIMER_DIV_FACTOR        192
 
 /*
  * Maximum hw resource - This number is based on the maximum
@@ -37,27 +32,6 @@
  */
 #define CAM_ISP_CTX_STATE_MONITOR_MAX_ENTRIES   40
 
-/*
- * Threshold response time in us beyond which a request is not expected
- * to be with IFE hw
- */
-#define CAM_ISP_CTX_RESPONSE_TIME_THRESHOLD   100000
-
-/* Number of words for dumping isp context */
-#define CAM_ISP_CTX_DUMP_NUM_WORDS  5
-
-/* Number of words for dumping isp context events*/
-#define CAM_ISP_CTX_DUMP_EVENT_NUM_WORDS  3
-
-/* Number of words for dumping request info*/
-#define CAM_ISP_CTX_DUMP_REQUEST_NUM_WORDS  2
-
-/* Maximum entries in event record */
-#define CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES   20
-
-/* Maximum length of tag while dumping */
-#define CAM_ISP_CONTEXT_DUMP_TAG_MAX_LEN 32
-
 /* forward declaration */
 struct cam_isp_context;
 
@@ -80,19 +54,6 @@ enum cam_isp_ctx_activated_substate {
 	CAM_ISP_CTX_ACTIVATED_MAX,
 };
 
-/**
- * enum cam_isp_ctx_event_type - events for a request
- *
- */
-enum cam_isp_ctx_event {
-	CAM_ISP_CTX_EVENT_SUBMIT,
-	CAM_ISP_CTX_EVENT_APPLY,
-	CAM_ISP_CTX_EVENT_EPOCH,
-	CAM_ISP_CTX_EVENT_RUP,
-	CAM_ISP_CTX_EVENT_BUFDONE,
-	CAM_ISP_CTX_EVENT_MAX
-};
-
 /**
  * enum cam_isp_state_change_trigger - Different types of ISP events
  *
@@ -134,23 +95,20 @@ struct cam_isp_ctx_irq_ops {
 /**
  * struct cam_isp_ctx_req - ISP context request object
  *
- * @base:                      Common request object ponter
- * @cfg:                       ISP hardware configuration array
- * @num_cfg:                   Number of ISP hardware configuration entries
- * @fence_map_out:             Output fence mapping array
- * @num_fence_map_out:         Number of the output fence map
- * @fence_map_in:              Input fence mapping array
- * @num_fence_map_in:          Number of input fence map
- * @num_acked:                 Count to track acked entried for output.
- *                             If count equals the number of fence out, it means
- *                             the request has been completed.
- * @bubble_report:             Flag to track if bubble report is active on
- *                             current request
- * @hw_update_data:            HW update data for this request
- * @event_timestamp:           Timestamp for different stage of request
- * @reapply:                   True if reapplying after bubble
- * @cdm_reset_before_apply:    For bubble re-apply when buf done not coming set
- *                             to True
+ * @base:                  Common request object ponter
+ * @cfg:                   ISP hardware configuration array
+ * @num_cfg:               Number of ISP hardware configuration entries
+ * @fence_map_out:         Output fence mapping array
+ * @num_fence_map_out:     Number of the output fence map
+ * @fence_map_in:          Input fence mapping array
+ * @num_fence_map_in:      Number of input fence map
+ * @num_acked:             Count to track acked entried for output.
+ *                         If count equals the number of fence out, it means
+ *                         the request has been completed.
+ * @bubble_report:         Flag to track if bubble report is active on
+ *                         current request
+ * @hw_update_data:        HW update data for this request
+ * @reapply:               True if reapplying after bubble
  *
  */
 struct cam_isp_ctx_req {
@@ -166,11 +124,8 @@ struct cam_isp_ctx_req {
 	uint32_t                              num_acked;
 	int32_t                               bubble_report;
 	struct cam_isp_prepare_hw_update_data hw_update_data;
-	ktime_t                               event_timestamp
-		[CAM_ISP_CTX_EVENT_MAX];
 	bool                                  bubble_detected;
 	bool                                  reapply;
-	bool                                  cdm_reset_before_apply;
 };
 
 /**
@@ -204,28 +159,12 @@ struct cam_isp_context_state_monitor {
 struct cam_isp_context_req_id_info {
 	int64_t                          last_bufdone_req_id;
 };
-
 /**
  *
- * struct cam_isp_context_event_record - Information for last 20 Events
- *  for a request; Submit, Apply, EPOCH, RUP, Buf done.
- *
- * @req_id:    Last applied request id
- * @timestamp: Timestamp for the event
- *
- */
-struct cam_isp_context_event_record {
-	uint64_t                         req_id;
-	ktime_t                          timestamp;
-};
-
-/**
  * struct cam_isp_context   -  ISP context object
  *
  * @base:                      Common context object pointer
  * @frame_id:                  Frame id tracking for the isp context
- * @frame_id_meta:             Frame id read every epoch for the ctx
- *                             meta from the sensor
  * @substate_actiavted:        Current substate for the activated state.
  * @process_bubble:            Atomic variable to check if ctx is still
  *                             processing bubble.
@@ -242,83 +181,46 @@ struct cam_isp_context_event_record {
  * @subscribe_event:           The irq event mask that CRM subscribes to, IFE
  *                             will invoke CRM cb at those event.
  * @last_applied_req_id:       Last applied request id
- * @last_sof_timestamp:        SOF timestamp of the last frame
  * @state_monitor_head:        Write index to the state monitoring array
  * @req_info                   Request id information about last buf done
  * @cam_isp_ctx_state_monitor: State monitoring array
- * @event_record_head:         Write index to the state monitoring array
- * @event_record:              Event record array
  * @rdi_only_context:          Get context type information.
  *                             true, if context is rdi only context
- * @offline_context:           Indicate whether context is for offline IFE
  * @hw_acquired:               Indicate whether HW resources are acquired
  * @init_received:             Indicate whether init config packet is received
  * @split_acquire:             Indicate whether a separate acquire is expected
- * @custom_enabled:            Custom HW enabled for this ctx
- * @use_frame_header_ts:       Use frame header for qtimer ts
- * @support_consumed_addr:     Indicate whether HW has last consumed addr reg
  * @init_timestamp:            Timestamp at which this context is initialized
- * @rxd_epoch:                 Indicate whether epoch has been received. Used to
- *                             decide whether to apply request in offline ctx
- * @workq:                     Worker thread for offline ife
- * @trigger_id:                ID provided by CRM for each ctx on the link
  *
  */
 struct cam_isp_context {
-	struct cam_context              *base;
-
-	int64_t                          frame_id;
-	uint32_t                         frame_id_meta;
-	uint32_t                         substate_activated;
-	atomic_t                         process_bubble;
-	uint32_t                         bubble_frame_cnt;
-	struct cam_ctx_ops              *substate_machine;
-	struct cam_isp_ctx_irq_ops      *substate_machine_irq;
-
-	struct cam_ctx_request           req_base[CAM_CTX_REQ_MAX];
-	struct cam_isp_ctx_req           req_isp[CAM_CTX_REQ_MAX];
-
-	void                            *hw_ctx;
-	uint64_t                         sof_timestamp_val;
-	uint64_t                         boot_timestamp;
-	int32_t                          active_req_cnt;
-	int64_t                          reported_req_id;
-	uint32_t                         subscribe_event;
-	int64_t                          last_applied_req_id;
-	uint64_t                         last_sof_timestamp;
-	atomic64_t                       state_monitor_head;
-	struct cam_isp_context_state_monitor cam_isp_ctx_state_monitor[
+	struct cam_context                   *base;
+
+	int64_t                               frame_id;
+	enum cam_isp_ctx_activated_substate   substate_activated;
+	atomic_t                              process_bubble;
+	uint32_t                              bubble_frame_cnt;
+	struct cam_ctx_ops                   *substate_machine;
+	struct cam_isp_ctx_irq_ops           *substate_machine_irq;
+
+	struct cam_ctx_request                req_base[CAM_CTX_REQ_MAX];
+	struct cam_isp_ctx_req                req_isp[CAM_CTX_REQ_MAX];
+
+	void                                 *hw_ctx;
+	uint64_t                              sof_timestamp_val;
+	uint64_t                              boot_timestamp;
+	int32_t                               active_req_cnt;
+	int64_t                               reported_req_id;
+	uint32_t                              subscribe_event;
+	int64_t                               last_applied_req_id;
+	atomic64_t                            state_monitor_head;
+	struct cam_isp_context_state_monitor  cam_isp_ctx_state_monitor[
 		CAM_ISP_CTX_STATE_MONITOR_MAX_ENTRIES];
 	struct cam_isp_context_req_id_info    req_info;
-	atomic64_t                            event_record_head[
-		CAM_ISP_CTX_EVENT_MAX];
-	struct cam_isp_context_event_record   event_record[
-		CAM_ISP_CTX_EVENT_MAX][CAM_ISP_CTX_EVENT_RECORD_MAX_ENTRIES];
 	bool                                  rdi_only_context;
-	bool                                  offline_context;
 	bool                                  hw_acquired;
 	bool                                  init_received;
 	bool                                  split_acquire;
-	bool                                  custom_enabled;
-	bool                                  use_frame_header_ts;
-	bool                                  support_consumed_addr;
 	unsigned int                          init_timestamp;
-	atomic_t                              rxd_epoch;
-	struct cam_req_mgr_core_workq        *workq;
-	int32_t                               trigger_id;
-};
-
-/**
- * struct cam_isp_context_dump_header - ISP context dump header
- * @tag:       Tag name for the header
- * @word_size: Size of word
- * @size:      Size of data
- *
- */
-struct cam_isp_context_dump_header {
-	uint8_t   tag[CAM_ISP_CONTEXT_DUMP_TAG_MAX_LEN];
-	uint64_t  size;
-	uint32_t  word_size;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_isp/cam_isp_dev.c b/techpack/camera/drivers/cam_isp/cam_isp_dev.c
index 2e28232e91be..9c3f33181ae6 100644
--- a/techpack/camera/drivers/cam_isp/cam_isp_dev.c
+++ b/techpack/camera/drivers/cam_isp/cam_isp_dev.c
@@ -50,14 +50,10 @@ static const struct of_device_id cam_isp_dt_match[] = {
 static int cam_isp_subdev_open(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
-
 	mutex_lock(&g_isp_dev.isp_mutex);
 	g_isp_dev.open_cnt++;
 	mutex_unlock(&g_isp_dev.isp_mutex);
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
-
 	return 0;
 }
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c
index 74e6149c2074..82a557a33ba7 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -26,7 +25,6 @@
 #include "cam_common_util.h"
 
 #define CAM_IFE_HW_ENTRIES_MAX  20
-#define CAM_IFE_HW_CONFIG_WAIT_MAX_TRY  3
 
 #define TZ_SVC_SMMU_PROGRAM 0x15
 #define TZ_SAFE_SYSCALL_ID  0x3
@@ -38,10 +36,7 @@
 	(CAM_ISP_PACKET_META_GENERIC_BLOB_COMMON + 1)
 
 #define CAM_ISP_GENERIC_BLOB_TYPE_MAX               \
-	(CAM_ISP_GENERIC_BLOB_TYPE_CSID_QCFA_CONFIG + 1)
-
-static int cam_ife_hw_mgr_handle_hw_dump_bus_info(
-	void *ctx, void *evt_info);
+	(CAM_ISP_GENERIC_BLOB_TYPE_BW_CONFIG_V2 + 1)
 
 static uint32_t blob_type_hw_cmd_map[CAM_ISP_GENERIC_BLOB_TYPE_MAX] = {
 	CAM_ISP_HW_CMD_GET_HFR_UPDATE,
@@ -139,9 +134,7 @@ static int cam_ife_mgr_regspace_data_cb(uint32_t reg_base_type,
 
 static int cam_ife_mgr_handle_reg_dump(struct cam_ife_hw_mgr_ctx *ctx,
 	struct cam_cmd_buf_desc *reg_dump_buf_desc, uint32_t num_reg_dump_buf,
-	uint32_t meta_type,
-	void *soc_dump_args,
-	bool user_triggered_dump)
+	uint32_t meta_type)
 {
 	int rc = 0, i;
 
@@ -164,9 +157,7 @@ static int cam_ife_mgr_handle_reg_dump(struct cam_ife_hw_mgr_ctx *ctx,
 			rc = cam_soc_util_reg_dump_to_cmd_buf(ctx,
 				&reg_dump_buf_desc[i],
 				ctx->applied_req_id,
-				cam_ife_mgr_regspace_data_cb,
-				soc_dump_args,
-				user_triggered_dump);
+				cam_ife_mgr_regspace_data_cb);
 			if (rc) {
 				CAM_ERR(CAM_ISP,
 					"Reg dump failed at idx: %d, rc: %d req_id: %llu meta type: %u",
@@ -188,7 +179,6 @@ static int cam_ife_notify_safe_lut_scm(bool safe_trigger)
 	if (!rc) {
 		switch (camera_hw_version) {
 		case CAM_CPAS_TITAN_170_V100:
-		case CAM_CPAS_TITAN_170_V200:
 		case CAM_CPAS_TITAN_170_V110:
 		case CAM_CPAS_TITAN_175_V100:
 
@@ -291,7 +281,7 @@ static int cam_ife_hw_mgr_reset_csid_res(
 			rc = hw_intf->hw_ops.reset(hw_intf->hw_priv,
 				&csid_reset_args,
 				sizeof(struct cam_csid_reset_cfg_args));
-			if (rc)
+			if (rc <= 0)
 				goto err;
 		}
 	}
@@ -663,78 +653,25 @@ static const char *cam_ife_hw_mgr_get_src_res_id(
 	}
 }
 
-static void cam_ife_hw_mgr_print_acquire_info(
-	struct cam_ife_hw_mgr_ctx *hw_mgr_ctx, uint32_t num_pix_port,
-	uint32_t num_pd_port, uint32_t num_rdi_port, int acquire_failed)
+static void cam_ife_hw_mgr_dump_src_acq_info(
+	struct cam_ife_hw_mgr_ctx    *hwr_mgr_ctx,
+	uint32_t num_pix_port, uint32_t num_rdi_port)
 {
 	struct cam_ife_hw_mgr_res    *hw_mgr_res = NULL;
 	struct cam_ife_hw_mgr_res    *hw_mgr_res_temp = NULL;
 	struct cam_isp_resource_node *hw_res = NULL;
-	struct cam_hw_intf           *hw_intf = NULL;
-	struct cam_vfe_num_of_acquired_resources num_rsrc;
-	int hw_idx[CAM_ISP_HW_SPLIT_MAX] = {-1, -1};
 	int i = 0;
 
-	hw_mgr_res = list_first_entry(&hw_mgr_ctx->res_list_ife_csid,
-		struct cam_ife_hw_mgr_res, list);
-
-	if (hw_mgr_ctx->is_offline)
-		hw_mgr_res = list_first_entry(&hw_mgr_ctx->res_list_ife_src,
-			struct cam_ife_hw_mgr_res, list);
-
-	for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-		hw_res = hw_mgr_res->hw_res[i];
-		if (hw_res && hw_res->hw_intf)
-			hw_idx[i] = hw_res->hw_intf->hw_idx;
-	}
-
-	if (acquire_failed)
-		goto fail;
-
-	hw_mgr_res = list_first_entry(&hw_mgr_ctx->res_list_ife_src,
-		struct cam_ife_hw_mgr_res, list);
-	for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-		if (!hw_mgr_res->hw_res[i])
-			continue;
-
-		hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-
-		if (hw_intf->hw_ops.process_cmd) {
-			num_rsrc.num_pix_rsrc = num_pix_port;
-			num_rsrc.num_pd_rsrc = num_pd_port;
-			num_rsrc.num_rdi_rsrc = num_rdi_port;
-
-			hw_intf->hw_ops.process_cmd(hw_intf->hw_priv,
-				CAM_ISP_HW_CMD_SET_NUM_OF_ACQUIRED_RESOURCE,
-				&num_rsrc,
-				sizeof(
-				struct cam_vfe_num_of_acquired_resources));
-		}
-	}
-
 	CAM_INFO(CAM_ISP,
-		"Successfully acquire %s IFE[%d %d] with [%u pix] [%u pd] [%u rdi] ports for ctx:%u",
-		(hw_mgr_ctx->is_dual) ? "dual" : "single",
-		hw_idx[CAM_ISP_HW_SPLIT_LEFT], hw_idx[CAM_ISP_HW_SPLIT_RIGHT],
-		num_pix_port, num_pd_port, num_rdi_port, hw_mgr_ctx->ctx_index);
-
-	return;
-
-fail:
-	CAM_ERR(CAM_ISP, "Acquire HW failed for ctx:%u", hw_mgr_ctx->ctx_index);
-	CAM_INFO(CAM_ISP,
-		"Fail to acquire %s IFE[%d %d] with [%u pix] [%u pd] [%u rdi] ports for ctx:%u",
-		(hw_mgr_ctx->is_dual) ? "dual" : "single",
-		hw_idx[CAM_ISP_HW_SPLIT_LEFT], hw_idx[CAM_ISP_HW_SPLIT_RIGHT],
-		num_pix_port, num_pd_port, num_rdi_port, hw_mgr_ctx->ctx_index);
-
+		"Acquired HW for ctx: %u with pix_port: %u rdi_port: %u",
+		hwr_mgr_ctx->ctx_index, num_pix_port, num_rdi_port);
 	list_for_each_entry_safe(hw_mgr_res, hw_mgr_res_temp,
-		&hw_mgr_ctx->res_list_ife_src, list) {
+		&hwr_mgr_ctx->res_list_ife_src, list) {
 		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
 			hw_res = hw_mgr_res->hw_res[i];
 			if (hw_res && hw_res->hw_intf)
 				CAM_INFO(CAM_ISP,
-					"IFE src split_id:%d res_id:%s hw_idx:%u state:%s",
+					"IFE src split_id: %d res_id: %s hw_idx: %u state: %s",
 					i,
 					cam_ife_hw_mgr_get_src_res_id(
 					hw_res->res_id),
@@ -852,47 +789,6 @@ static void cam_ife_hw_mgr_dump_acq_data(
 	}
 }
 
-static int cam_ife_mgr_csid_change_halt_mode(struct list_head  *halt_list,
-	uint32_t  base_idx, enum cam_ife_csid_halt_mode halt_mode)
-{
-	struct cam_ife_hw_mgr_res      *hw_mgr_res;
-	struct cam_isp_resource_node   *isp_res;
-	struct cam_csid_hw_halt_args    halt;
-	struct cam_hw_intf             *hw_intf;
-	uint32_t i;
-	int rc = 0;
-
-	list_for_each_entry(hw_mgr_res, halt_list, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i] ||
-				(hw_mgr_res->hw_res[i]->res_state !=
-				CAM_ISP_RESOURCE_STATE_STREAMING))
-				continue;
-
-			isp_res = hw_mgr_res->hw_res[i];
-			if (isp_res->hw_intf->hw_idx != base_idx)
-				continue;
-
-			if ((isp_res->res_type == CAM_ISP_RESOURCE_PIX_PATH) &&
-				(isp_res->res_id == CAM_IFE_PIX_PATH_RES_IPP)) {
-				hw_intf         = isp_res->hw_intf;
-				halt.node_res   = isp_res;
-				halt.halt_mode  = halt_mode;
-				rc = hw_intf->hw_ops.process_cmd(
-					hw_intf->hw_priv,
-					CAM_ISP_HW_CMD_CSID_CHANGE_HALT_MODE,
-					&halt,
-					sizeof(struct cam_csid_hw_halt_args));
-				if (rc)
-					CAM_ERR(CAM_ISP, "Halt update failed");
-				break;
-			}
-		}
-	}
-
-	return rc;
-}
-
 static int cam_ife_mgr_csid_stop_hw(
 	struct cam_ife_hw_mgr_ctx *ctx, struct list_head  *stop_list,
 		uint32_t  base_idx, uint32_t stop_cmd)
@@ -940,10 +836,6 @@ static int cam_ife_hw_mgr_release_hw_for_ctx(
 	struct cam_ife_hw_mgr_res        *hw_mgr_res;
 	struct cam_ife_hw_mgr_res        *hw_mgr_res_temp;
 
-	/* clean up the callback function */
-	ife_ctx->common.cb_priv = NULL;
-	memset(ife_ctx->common.event_cb, 0, sizeof(ife_ctx->common.event_cb));
-
 	/* ife leaf resource */
 	for (i = 0; i < CAM_IFE_HW_OUT_RES_MAX; i++)
 		cam_ife_hw_mgr_free_hw_res(&ife_ctx->res_list_ife_out[i]);
@@ -980,6 +872,10 @@ static int cam_ife_hw_mgr_release_hw_for_ctx(
 	if (ife_ctx->res_list_ife_in.res_type != CAM_IFE_HW_MGR_RES_UNINIT)
 		cam_ife_hw_mgr_free_hw_res(&ife_ctx->res_list_ife_in);
 
+	/* clean up the callback function */
+	ife_ctx->common.cb_priv = NULL;
+	memset(ife_ctx->common.event_cb, 0, sizeof(ife_ctx->common.event_cb));
+
 	CAM_DBG(CAM_ISP, "release context completed ctx id:%d",
 		ife_ctx->ctx_index);
 
@@ -1096,6 +992,91 @@ static int cam_ife_mgr_process_base_info(
 	return 0;
 }
 
+static int cam_ife_hw_mgr_acquire_res_bus_rd(
+	struct cam_ife_hw_mgr_ctx       *ife_ctx,
+	struct cam_isp_in_port_generic_info *in_port)
+{
+	int rc = -EINVAL;
+	struct cam_vfe_acquire_args               vfe_acquire;
+	struct cam_ife_hw_mgr_res                *ife_in_rd_res;
+	struct cam_hw_intf                       *hw_intf;
+	struct cam_ife_hw_mgr_res                *ife_src_res;
+	int i;
+
+	CAM_DBG(CAM_ISP, "Enter");
+
+	list_for_each_entry(ife_src_res, &ife_ctx->res_list_ife_src, list) {
+		if (ife_src_res->res_id != CAM_ISP_HW_VFE_IN_RD)
+			continue;
+
+		rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list,
+			&ife_in_rd_res);
+		if (rc) {
+			CAM_ERR(CAM_ISP, "No more free hw mgr resource");
+			goto err;
+		}
+		cam_ife_hw_mgr_put_res(&ife_ctx->res_list_ife_in_rd,
+			&ife_in_rd_res);
+
+		vfe_acquire.rsrc_type = CAM_ISP_RESOURCE_VFE_BUS_RD;
+		vfe_acquire.tasklet = ife_ctx->common.tasklet_info;
+		vfe_acquire.vfe_out.cdm_ops = ife_ctx->cdm_ops;
+		vfe_acquire.priv = ife_ctx;
+		vfe_acquire.vfe_out.unique_id = ife_ctx->ctx_index;
+		vfe_acquire.vfe_out.is_dual = ife_src_res->is_dual_vfe;
+		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
+			if (!ife_src_res->hw_res[i])
+				continue;
+
+			hw_intf = ife_src_res->hw_res[i]->hw_intf;
+			if (i == CAM_ISP_HW_SPLIT_LEFT) {
+				vfe_acquire.vfe_out.split_id  =
+					CAM_ISP_HW_SPLIT_LEFT;
+				if (ife_src_res->is_dual_vfe) {
+					/*TBD */
+					vfe_acquire.vfe_out.is_master     = 1;
+					vfe_acquire.vfe_out.dual_slave_core =
+						(hw_intf->hw_idx == 0) ? 1 : 0;
+				} else {
+					vfe_acquire.vfe_out.is_master   = 0;
+					vfe_acquire.vfe_out.dual_slave_core =
+						0;
+				}
+			} else {
+				vfe_acquire.vfe_out.split_id  =
+					CAM_ISP_HW_SPLIT_RIGHT;
+				vfe_acquire.vfe_out.is_master       = 0;
+				vfe_acquire.vfe_out.dual_slave_core =
+					(hw_intf->hw_idx == 0) ? 1 : 0;
+			}
+			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
+				&vfe_acquire,
+				sizeof(struct cam_vfe_acquire_args));
+			if (rc) {
+				CAM_ERR(CAM_ISP,
+					"Can not acquire out resource 0x%x",
+					vfe_acquire.rsrc_type);
+				goto err;
+			}
+
+			ife_in_rd_res->hw_res[i] =
+				vfe_acquire.vfe_out.rsrc_node;
+			CAM_DBG(CAM_ISP, "resource type :0x%x res id:0x%x",
+				ife_in_rd_res->hw_res[i]->res_type,
+				ife_in_rd_res->hw_res[i]->res_id);
+
+		}
+		ife_in_rd_res->is_dual_vfe = in_port->usage_type;
+		ife_in_rd_res->res_type = (enum cam_ife_hw_mgr_res_type)
+			CAM_ISP_RESOURCE_VFE_BUS_RD;
+	}
+
+	return 0;
+err:
+	CAM_DBG(CAM_ISP, "Exit rc(0x%x)", rc);
+	return rc;
+}
+
 static int cam_ife_hw_mgr_acquire_res_ife_out_rdi(
 	struct cam_ife_hw_mgr_ctx       *ife_ctx,
 	struct cam_ife_hw_mgr_res       *ife_src_res,
@@ -1150,8 +1131,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_out_rdi(
 		vfe_acquire.vfe_out.split_id = CAM_ISP_HW_SPLIT_LEFT;
 		vfe_acquire.vfe_out.unique_id = ife_ctx->ctx_index;
 		vfe_acquire.vfe_out.is_dual = 0;
-		vfe_acquire.vfe_out.disable_ubwc_comp =
-			g_ife_hw_mgr.debug_cfg.disable_ubwc_comp;
 		vfe_acquire.event_cb = cam_ife_hw_mgr_event_handler;
 		hw_intf = ife_src_res->hw_res[0]->hw_intf;
 		rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
@@ -1235,8 +1214,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_out_pixel(
 		vfe_acquire.vfe_out.out_port_info =  out_port;
 		vfe_acquire.vfe_out.is_dual       = ife_src_res->is_dual_vfe;
 		vfe_acquire.vfe_out.unique_id     = ife_ctx->ctx_index;
-		vfe_acquire.vfe_out.disable_ubwc_comp =
-			g_ife_hw_mgr.debug_cfg.disable_ubwc_comp;
 		vfe_acquire.event_cb = cam_ife_hw_mgr_event_handler;
 
 		for (j = 0; j < CAM_ISP_HW_SPLIT_MAX; j++) {
@@ -1252,7 +1229,7 @@ static int cam_ife_hw_mgr_acquire_res_ife_out_pixel(
 					/*TBD */
 					vfe_acquire.vfe_out.is_master     = 1;
 					vfe_acquire.vfe_out.dual_slave_core =
-						ife_ctx->slave_hw_idx;
+						(hw_intf->hw_idx == 0) ? 1 : 0;
 				} else {
 					vfe_acquire.vfe_out.is_master   = 0;
 					vfe_acquire.vfe_out.dual_slave_core =
@@ -1263,8 +1240,9 @@ static int cam_ife_hw_mgr_acquire_res_ife_out_pixel(
 					CAM_ISP_HW_SPLIT_RIGHT;
 				vfe_acquire.vfe_out.is_master       = 0;
 				vfe_acquire.vfe_out.dual_slave_core =
-					ife_ctx->master_hw_idx;
+					(hw_intf->hw_idx == 0) ? 1 : 0;
 			}
+
 			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
 				&vfe_acquire,
 				sizeof(struct cam_vfe_acquire_args));
@@ -1341,6 +1319,132 @@ static int cam_ife_hw_mgr_acquire_res_ife_out(
 	return rc;
 }
 
+static int cam_ife_hw_mgr_acquire_res_ife_rd_src(
+	struct cam_ife_hw_mgr_ctx *ife_ctx,
+	struct cam_isp_in_port_generic_info *in_port)
+{
+	int rc                = -1;
+	struct cam_ife_hw_mgr_res                  *csid_res;
+	struct cam_ife_hw_mgr_res                  *ife_src_res;
+	struct cam_vfe_acquire_args                 vfe_acquire;
+	struct cam_hw_intf                         *hw_intf;
+	struct cam_ife_hw_mgr                      *ife_hw_mgr;
+	int vfe_idx = -1, i = 0;
+
+	ife_hw_mgr = ife_ctx->hw_mgr;
+
+	CAM_DBG(CAM_ISP, "Enter");
+	list_for_each_entry(csid_res, &ife_ctx->res_list_ife_csid, list) {
+		if (csid_res->res_id != CAM_IFE_PIX_PATH_RES_RDI_0) {
+			CAM_DBG(CAM_ISP, "not RDI0: %d", csid_res->res_id);
+			continue;
+		}
+
+		rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list,
+			&ife_src_res);
+		if (rc) {
+			CAM_ERR(CAM_ISP, "No more free hw mgr resource");
+			goto err;
+		}
+		cam_ife_hw_mgr_put_res(&ife_ctx->res_list_ife_src,
+			&ife_src_res);
+
+		CAM_DBG(CAM_ISP, "csid_res_id %d", csid_res->res_id);
+		vfe_acquire.rsrc_type = CAM_ISP_RESOURCE_VFE_IN;
+		vfe_acquire.tasklet = ife_ctx->common.tasklet_info;
+		vfe_acquire.vfe_in.cdm_ops = ife_ctx->cdm_ops;
+		vfe_acquire.vfe_in.in_port = in_port;
+		vfe_acquire.vfe_in.res_id = CAM_ISP_HW_VFE_IN_RD;
+		vfe_acquire.vfe_in.sync_mode = CAM_ISP_HW_SYNC_NONE;
+
+		ife_src_res->res_type =
+			(enum cam_ife_hw_mgr_res_type)vfe_acquire.rsrc_type;
+		ife_src_res->res_id = vfe_acquire.vfe_in.res_id;
+		ife_src_res->is_dual_vfe = csid_res->is_dual_vfe;
+
+		hw_intf =
+			ife_hw_mgr->ife_devices[csid_res->hw_res[
+			CAM_ISP_HW_SPLIT_LEFT]->hw_intf->hw_idx];
+
+		vfe_idx = csid_res->hw_res[
+			CAM_ISP_HW_SPLIT_LEFT]->hw_intf->hw_idx;
+
+		/*
+		 * fill in more acquire information as needed
+		 */
+		if (ife_src_res->is_dual_vfe)
+			vfe_acquire.vfe_in.sync_mode = CAM_ISP_HW_SYNC_MASTER;
+
+		rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
+				&vfe_acquire,
+				sizeof(struct cam_vfe_acquire_args));
+		if (rc) {
+			CAM_ERR(CAM_ISP,
+				"Can not acquire IFE HW res %d",
+				csid_res->res_id);
+			goto err;
+		}
+		ife_src_res->hw_res[CAM_ISP_HW_SPLIT_LEFT] =
+			vfe_acquire.vfe_in.rsrc_node;
+		CAM_DBG(CAM_ISP,
+			"acquire success IFE:%d  res type :0x%x res id:0x%x",
+			hw_intf->hw_idx,
+			ife_src_res->hw_res[CAM_ISP_HW_SPLIT_LEFT]->res_type,
+			ife_src_res->hw_res[CAM_ISP_HW_SPLIT_LEFT]->res_id);
+
+		if (!ife_src_res->is_dual_vfe)
+			goto acq;
+
+		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
+			if (i == CAM_ISP_HW_SPLIT_LEFT) {
+				CAM_DBG(CAM_ISP, "vfe_idx %d is acquired",
+					vfe_idx);
+				continue;
+			}
+
+			hw_intf = ife_hw_mgr->ife_devices[i];
+
+			/* fill in more acquire information as needed */
+			if (i == CAM_ISP_HW_SPLIT_RIGHT)
+				vfe_acquire.vfe_in.sync_mode =
+					CAM_ISP_HW_SYNC_SLAVE;
+
+			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
+					&vfe_acquire,
+					sizeof(struct cam_vfe_acquire_args));
+			if (rc) {
+				CAM_ERR(CAM_ISP,
+					"Can not acquire IFE HW res %d",
+					csid_res->res_id);
+				goto err;
+			}
+			ife_src_res->hw_res[i] = vfe_acquire.vfe_in.rsrc_node;
+			CAM_DBG(CAM_ISP,
+				"acquire success IFE:%d  res type :0x%x res id:0x%x",
+				hw_intf->hw_idx,
+				ife_src_res->hw_res[i]->res_type,
+				ife_src_res->hw_res[i]->res_id);
+		}
+acq:
+		/*
+		 * It should be one to one mapping between
+		 * csid resource and ife source resource
+		 */
+		csid_res->child[0] = ife_src_res;
+		ife_src_res->parent = csid_res;
+		csid_res->child[csid_res->num_children++] = ife_src_res;
+		CAM_DBG(CAM_ISP,
+			"csid_res=%d  CSID num_children=%d ife_src_res=%d",
+			csid_res->res_id, csid_res->num_children,
+			ife_src_res->res_id);
+	}
+
+err:
+	/* release resource at the entry function */
+	CAM_DBG(CAM_ISP, "Exit rc %d", rc);
+	return rc;
+}
+
 static int cam_convert_hw_idx_to_ife_hw_num(int hw_idx)
 {
 	uint32_t hw_version, rc = 0;
@@ -1366,20 +1470,6 @@ static int cam_convert_hw_idx_to_ife_hw_num(int hw_idx)
 				return CAM_ISP_IFE1_LITE_HW;
 			else if (hw_idx == 4)
 				return CAM_ISP_IFE2_LITE_HW;
-			else if (hw_idx == 5)
-				return CAM_ISP_IFE3_LITE_HW;
-			else if (hw_idx == 6)
-				return CAM_ISP_IFE4_LITE_HW;
-			break;
-		case CAM_CPAS_TITAN_170_V200:
-			if (hw_idx == 0)
-				return CAM_ISP_IFE0_HW;
-			else if (hw_idx == 1)
-				return CAM_ISP_IFE1_HW;
-			else if (hw_idx == 2)
-				return CAM_ISP_IFE2_HW;
-			else if (hw_idx == 3)
-				return CAM_ISP_IFE0_LITE_HW;
 			break;
 		default:
 			CAM_ERR(CAM_ISP, "Invalid hw_version: 0x%X",
@@ -1460,8 +1550,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_src(
 		vfe_acquire.tasklet = ife_ctx->common.tasklet_info;
 		vfe_acquire.vfe_in.cdm_ops = ife_ctx->cdm_ops;
 		vfe_acquire.vfe_in.in_port = in_port;
-		vfe_acquire.vfe_in.is_fe_enabled = ife_ctx->is_fe_enabled;
-		vfe_acquire.vfe_in.is_offline = ife_ctx->is_offline;
 		vfe_acquire.priv = ife_ctx;
 		vfe_acquire.event_cb = cam_ife_hw_mgr_event_handler;
 
@@ -1479,7 +1567,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_src(
 			else
 				vfe_acquire.vfe_in.sync_mode =
 				CAM_ISP_HW_SYNC_NONE;
-			vfe_acquire.vfe_in.is_dual = csid_res->is_dual_vfe;
 
 			break;
 		case CAM_IFE_PIX_PATH_RES_PPP:
@@ -1520,20 +1607,12 @@ static int cam_ife_hw_mgr_acquire_res_ife_src(
 			hw_intf = ife_hw_mgr->ife_devices[
 				csid_res->hw_res[i]->hw_intf->hw_idx];
 
-			if (i == CAM_ISP_HW_SPLIT_LEFT &&
-				ife_src_res->is_dual_vfe) {
-				vfe_acquire.vfe_in.dual_hw_idx =
-					ife_ctx->slave_hw_idx;
-			}
 			/* fill in more acquire information as needed */
 			/* slave Camif resource, */
 			if (i == CAM_ISP_HW_SPLIT_RIGHT &&
-				ife_src_res->is_dual_vfe) {
+				ife_src_res->is_dual_vfe)
 				vfe_acquire.vfe_in.sync_mode =
 				CAM_ISP_HW_SYNC_SLAVE;
-				vfe_acquire.vfe_in.dual_hw_idx =
-					ife_ctx->master_hw_idx;
-			}
 
 			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
 					&vfe_acquire,
@@ -1580,100 +1659,28 @@ static int cam_ife_hw_mgr_acquire_res_ife_src(
 	return rc;
 }
 
-static int cam_ife_hw_mgr_acquire_csid_hw(
-	struct cam_ife_hw_mgr *ife_hw_mgr,
-	struct cam_csid_hw_reserve_resource_args  *csid_acquire,
-	bool is_start_lower_idx)
+static int cam_ife_mgr_acquire_cid_res(
+	struct cam_ife_hw_mgr_ctx           *ife_ctx,
+	struct cam_isp_in_port_generic_info *in_port,
+	struct cam_ife_hw_mgr_res          **cid_res,
+	enum cam_ife_pix_path_res_id         path_res_id)
 {
-	int i;
 	int rc = -1;
-	struct cam_hw_intf  *hw_intf;
-	struct cam_isp_hw_cmd_query vfe_query;
+	int i, j;
+	struct cam_ife_hw_mgr                *ife_hw_mgr;
+	struct cam_hw_intf                   *hw_intf;
+	struct cam_ife_hw_mgr_res            *cid_res_temp, *cid_res_iterator;
+	struct cam_csid_hw_reserve_resource_args  csid_acquire;
+	uint32_t acquired_cnt = 0;
+	struct cam_isp_out_port_generic_info *out_port = NULL;
 
-	if (!ife_hw_mgr || !csid_acquire) {
-		CAM_ERR(CAM_ISP,
-			"Invalid args ife hw mgr %pK csid_acquire %pK",
-			ife_hw_mgr, csid_acquire);
-		return -EINVAL;
-	}
-
-	if (is_start_lower_idx) {
-		for (i =  0; i < CAM_IFE_CSID_HW_NUM_MAX; i++) {
-			if (!ife_hw_mgr->csid_devices[i])
-				continue;
-
-			if (csid_acquire->in_port->dsp_mode) {
-				vfe_query.query_cmd =
-					CAM_ISP_HW_CMD_QUERY_DSP_MODE;
-				rc = ife_hw_mgr->ife_devices[i]->hw_ops
-					.process_cmd(
-					ife_hw_mgr->ife_devices[i]->hw_priv,
-					CAM_ISP_HW_CMD_QUERY,
-					&vfe_query, sizeof(vfe_query));
-				if (rc)
-					continue;
-			}
-
-			hw_intf = ife_hw_mgr->csid_devices[i];
-			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
-				csid_acquire,
-				sizeof(struct
-					cam_csid_hw_reserve_resource_args));
-			if (!rc)
-				return rc;
-		}
-		return rc;
-	}
-
-	for (i = CAM_IFE_CSID_HW_NUM_MAX - 1; i >= 0; i--) {
-		if (!ife_hw_mgr->csid_devices[i])
-			continue;
-
-		if (csid_acquire->in_port->dsp_mode) {
-			vfe_query.query_cmd =
-				CAM_ISP_HW_CMD_QUERY_DSP_MODE;
-			rc = ife_hw_mgr->ife_devices[i]->hw_ops.process_cmd(
-				ife_hw_mgr->ife_devices[i]->hw_priv,
-				CAM_ISP_HW_CMD_QUERY,
-				&vfe_query, sizeof(vfe_query));
-			if (rc)
-				continue;
-		}
-
-		hw_intf = ife_hw_mgr->csid_devices[i];
-		rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
-			csid_acquire,
-			sizeof(struct
-				cam_csid_hw_reserve_resource_args));
-		if (!rc)
-			return rc;
-	}
-
-	return rc;
-}
-
-static int cam_ife_mgr_acquire_cid_res(
-	struct cam_ife_hw_mgr_ctx           *ife_ctx,
-	struct cam_isp_in_port_generic_info *in_port,
-	struct cam_ife_hw_mgr_res          **cid_res,
-	enum cam_ife_pix_path_res_id         path_res_id)
-{
-	int rc = -1;
-	int i, j;
-	struct cam_ife_hw_mgr                *ife_hw_mgr;
-	struct cam_hw_intf                   *hw_intf;
-	struct cam_ife_hw_mgr_res            *cid_res_temp, *cid_res_iterator;
-	struct cam_csid_hw_reserve_resource_args  csid_acquire;
-	uint32_t acquired_cnt = 0;
-	struct cam_isp_out_port_generic_info *out_port = NULL;
-
-	ife_hw_mgr = ife_ctx->hw_mgr;
-	*cid_res = NULL;
-
-	rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list, cid_res);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "No more free hw mgr resource");
-		goto end;
+	ife_hw_mgr = ife_ctx->hw_mgr;
+	*cid_res = NULL;
+
+	rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list, cid_res);
+	if (rc) {
+		CAM_ERR(CAM_ISP, "No more free hw mgr resource");
+		goto end;
 	}
 
 	cid_res_temp = *cid_res;
@@ -1744,21 +1751,52 @@ static int cam_ife_mgr_acquire_cid_res(
 	}
 
 	/* Acquire Left if not already acquired */
-	/* For dual IFE cases, start acquiring the lower idx first */
-	if (ife_ctx->is_fe_enabled || in_port->usage_type)
-		rc = cam_ife_hw_mgr_acquire_csid_hw(ife_hw_mgr,
-			&csid_acquire, true);
-	else
-		rc = cam_ife_hw_mgr_acquire_csid_hw(ife_hw_mgr,
-			&csid_acquire, false);
+	if (ife_ctx->is_fe_enable) {
+		for (i = 0; i < CAM_IFE_CSID_HW_NUM_MAX; i++) {
+			if (!ife_hw_mgr->csid_devices[i])
+				continue;
 
-	if (rc || !csid_acquire.node_res) {
-		CAM_ERR(CAM_ISP,
-			"Can not acquire ife cid resource for path %d",
-			path_res_id);
-		goto put_res;
+			hw_intf = ife_hw_mgr->csid_devices[i];
+			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
+				&csid_acquire, sizeof(csid_acquire));
+			if (rc)
+				continue;
+			else {
+				cid_res_temp->hw_res[acquired_cnt++] =
+					csid_acquire.node_res;
+				break;
+			}
+		}
+		if (i == CAM_IFE_CSID_HW_NUM_MAX || !csid_acquire.node_res) {
+			CAM_ERR(CAM_ISP,
+				"Can not acquire ife cid resource for path %d",
+				path_res_id);
+			goto put_res;
+		}
+	} else {
+		for (i = CAM_IFE_CSID_HW_NUM_MAX - 1; i >= 0; i--) {
+			if (!ife_hw_mgr->csid_devices[i])
+				continue;
+
+			hw_intf = ife_hw_mgr->csid_devices[i];
+			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
+				&csid_acquire, sizeof(csid_acquire));
+			if (rc)
+				continue;
+			else {
+				cid_res_temp->hw_res[acquired_cnt++] =
+					csid_acquire.node_res;
+				break;
+			}
+		}
+		if (i == -1 || !csid_acquire.node_res) {
+			CAM_ERR(CAM_ISP,
+				"Can not acquire ife cid resource for path %d",
+				path_res_id);
+			goto put_res;
+		}
 	}
-	cid_res_temp->hw_res[acquired_cnt++] = csid_acquire.node_res;
+
 
 acquire_successful:
 	CAM_DBG(CAM_ISP, "CID left acquired success is_dual %d",
@@ -1769,9 +1807,7 @@ static int cam_ife_mgr_acquire_cid_res(
 	cid_res_temp->res_id = csid_acquire.node_res->res_id;
 	cid_res_temp->is_dual_vfe = in_port->usage_type;
 	ife_ctx->is_dual = (bool)in_port->usage_type;
-	if (ife_ctx->is_dual)
-		ife_ctx->master_hw_idx =
-			cid_res_temp->hw_res[0]->hw_intf->hw_idx;
+
 	if (in_port->num_out_res)
 		cid_res_temp->is_secure = out_port->secure_mode;
 
@@ -1808,8 +1844,6 @@ static int cam_ife_mgr_acquire_cid_res(
 			goto end;
 		}
 		cid_res_temp->hw_res[1] = csid_acquire.node_res;
-		ife_ctx->slave_hw_idx =
-			cid_res_temp->hw_res[1]->hw_intf->hw_idx;
 		CAM_DBG(CAM_ISP, "CID right acquired success is_dual %d",
 			in_port->usage_type);
 	}
@@ -1888,8 +1922,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_csid_pxl(
 		csid_acquire.in_port = in_port;
 		csid_acquire.out_port = in_port->data;
 		csid_acquire.node_res = NULL;
-		csid_acquire.event_cb = cam_ife_hw_mgr_event_handler;
-		csid_acquire.priv = ife_ctx;
 		csid_acquire.crop_enable = crop_enable;
 		csid_acquire.drop_enable = false;
 
@@ -2019,8 +2051,6 @@ static int cam_ife_hw_mgr_acquire_res_ife_csid_rdi(
 		csid_acquire.in_port = in_port;
 		csid_acquire.out_port = out_port;
 		csid_acquire.node_res = NULL;
-		csid_acquire.event_cb = cam_ife_hw_mgr_event_handler;
-		csid_acquire.priv = ife_ctx;
 
 		/*
 		 * Enable RDI pixel drop by default. CSID will enable only for
@@ -2086,7 +2116,7 @@ static int cam_ife_hw_mgr_acquire_res_root(
 		ife_ctx->res_list_ife_in.res_id = in_port->res_type;
 		ife_ctx->res_list_ife_in.is_dual_vfe = in_port->usage_type;
 	} else if ((ife_ctx->res_list_ife_in.res_id !=
-		in_port->res_type) && (!ife_ctx->is_fe_enabled))  {
+		in_port->res_type) && (!ife_ctx->is_fe_enable))  {
 		CAM_ERR(CAM_ISP, "No Free resource for this context");
 		goto err;
 	} else {
@@ -2100,36 +2130,18 @@ static int cam_ife_hw_mgr_acquire_res_root(
 
 static int cam_ife_mgr_check_and_update_fe_v0(
 	struct cam_ife_hw_mgr_ctx         *ife_ctx,
-	struct cam_isp_acquire_hw_info    *acquire_hw_info,
-	uint32_t                           acquire_info_size)
+	struct cam_isp_acquire_hw_info    *acquire_hw_info)
 {
 	int i;
 	struct cam_isp_in_port_info       *in_port = NULL;
 	uint32_t                           in_port_length = 0;
 	uint32_t                           total_in_port_length = 0;
 
-	if (acquire_hw_info->input_info_offset >=
-		acquire_hw_info->input_info_size) {
-		CAM_ERR(CAM_ISP,
-			"Invalid size offset 0x%x is greater then size 0x%x",
-			acquire_hw_info->input_info_offset,
-			acquire_hw_info->input_info_size);
-		return -EINVAL;
-	}
-
 	in_port = (struct cam_isp_in_port_info *)
 		((uint8_t *)&acquire_hw_info->data +
 		 acquire_hw_info->input_info_offset);
 	for (i = 0; i < acquire_hw_info->num_inputs; i++) {
 
-		if (((uint8_t *)in_port +
-			sizeof(struct cam_isp_in_port_info)) >
-			((uint8_t *)acquire_hw_info +
-			acquire_info_size)) {
-			CAM_ERR(CAM_ISP, "Invalid size");
-			return -EINVAL;
-		}
-
 		if ((in_port->num_out_res > CAM_IFE_HW_OUT_RES_MAX) ||
 			(in_port->num_out_res <= 0)) {
 			CAM_ERR(CAM_ISP, "Invalid num output res %u",
@@ -2149,50 +2161,32 @@ static int cam_ife_mgr_check_and_update_fe_v0(
 		CAM_DBG(CAM_ISP, "in_port%d res_type %d", i,
 			in_port->res_type);
 		if (in_port->res_type == CAM_ISP_IFE_IN_RES_RD) {
-			ife_ctx->is_fe_enabled = true;
+			ife_ctx->is_fe_enable = true;
 			break;
 		}
 
 		in_port = (struct cam_isp_in_port_info *)((uint8_t *)in_port +
 			in_port_length);
 	}
-	CAM_DBG(CAM_ISP, "is_fe_enabled %d", ife_ctx->is_fe_enabled);
+	CAM_DBG(CAM_ISP, "is_fe_enable %d", ife_ctx->is_fe_enable);
 
 	return 0;
 }
 
 static int cam_ife_mgr_check_and_update_fe_v2(
 	struct cam_ife_hw_mgr_ctx         *ife_ctx,
-	struct cam_isp_acquire_hw_info    *acquire_hw_info,
-	uint32_t                           acquire_info_size)
+	struct cam_isp_acquire_hw_info    *acquire_hw_info)
 {
 	int i;
 	struct cam_isp_in_port_info_v2    *in_port = NULL;
 	uint32_t                           in_port_length = 0;
 	uint32_t                           total_in_port_length = 0;
 
-	if (acquire_hw_info->input_info_offset >=
-		acquire_hw_info->input_info_size) {
-		CAM_ERR(CAM_ISP,
-			"Invalid size offset 0x%x is greater then size 0x%x",
-			acquire_hw_info->input_info_offset,
-			acquire_hw_info->input_info_size);
-		return -EINVAL;
-	}
-
 	in_port = (struct cam_isp_in_port_info_v2 *)
 		((uint8_t *)&acquire_hw_info->data +
 		 acquire_hw_info->input_info_offset);
 	for (i = 0; i < acquire_hw_info->num_inputs; i++) {
 
-		if (((uint8_t *)in_port +
-			sizeof(struct cam_isp_in_port_info)) >
-			((uint8_t *)acquire_hw_info +
-			acquire_info_size)) {
-			CAM_ERR(CAM_ISP, "Invalid size");
-			return -EINVAL;
-		}
-
 		if ((in_port->num_out_res > CAM_IFE_HW_OUT_RES_MAX) ||
 			(in_port->num_out_res <= 0)) {
 			CAM_ERR(CAM_ISP, "Invalid num output res %u",
@@ -2212,25 +2206,21 @@ static int cam_ife_mgr_check_and_update_fe_v2(
 		CAM_DBG(CAM_ISP, "in_port%d res_type %d", i,
 			in_port->res_type);
 		if (in_port->res_type == CAM_ISP_IFE_IN_RES_RD) {
-			ife_ctx->is_fe_enabled = true;
-			if (in_port->offline_mode)
-				ife_ctx->is_offline = true;
+			ife_ctx->is_fe_enable = true;
 			break;
 		}
 
 		in_port = (struct cam_isp_in_port_info_v2 *)
 			((uint8_t *)in_port + in_port_length);
 	}
-	CAM_DBG(CAM_ISP, "is_fe_enabled %d is_offline %d",
-		ife_ctx->is_fe_enabled, ife_ctx->is_offline);
+	CAM_DBG(CAM_ISP, "is_fe_enable %d", ife_ctx->is_fe_enable);
 
 	return 0;
 }
 
 static int cam_ife_mgr_check_and_update_fe(
 	struct cam_ife_hw_mgr_ctx         *ife_ctx,
-	struct cam_isp_acquire_hw_info    *acquire_hw_info,
-	uint32_t                           acquire_info_size)
+	struct cam_isp_acquire_hw_info    *acquire_hw_info)
 {
 	uint32_t major_ver = 0, minor_ver = 0;
 
@@ -2243,10 +2233,10 @@ static int cam_ife_mgr_check_and_update_fe(
 	switch (major_ver) {
 	case 1:
 		return cam_ife_mgr_check_and_update_fe_v0(
-			ife_ctx, acquire_hw_info, acquire_info_size);
+			ife_ctx, acquire_hw_info);
 	case 2:
 		return cam_ife_mgr_check_and_update_fe_v2(
-			ife_ctx, acquire_hw_info, acquire_info_size);
+			ife_ctx, acquire_hw_info);
 		break;
 	default:
 		CAM_ERR(CAM_ISP, "Invalid ver of common info from user");
@@ -2276,21 +2266,22 @@ static int cam_ife_hw_mgr_preprocess_port(
 
 	ife_hw_mgr = ife_ctx->hw_mgr;
 
-	if (in_port->res_type == CAM_ISP_IFE_IN_RES_RD)
+	if (in_port->res_type == CAM_ISP_IFE_IN_RES_RD) {
 		ife_rd_num++;
-
-	for (i = 0; i < in_port->num_out_res; i++) {
-		out_port = &in_port->data[i];
-		if (cam_ife_hw_mgr_is_rdi_res(out_port->res_type))
-			rdi_num++;
-		else if (out_port->res_type == CAM_ISP_IFE_OUT_RES_2PD)
-			ppp_num++;
-		else if (out_port->res_type == CAM_ISP_IFE_OUT_RES_LCR)
-			lcr_num++;
-		else {
-			CAM_DBG(CAM_ISP, "out_res_type %d",
-			out_port->res_type);
-			ipp_num++;
+	} else {
+		for (i = 0; i < in_port->num_out_res; i++) {
+			out_port = &in_port->data[i];
+			if (cam_ife_hw_mgr_is_rdi_res(out_port->res_type))
+				rdi_num++;
+			else if (out_port->res_type == CAM_ISP_IFE_OUT_RES_2PD)
+				ppp_num++;
+			else if (out_port->res_type == CAM_ISP_IFE_OUT_RES_LCR)
+				lcr_num++;
+			else {
+				CAM_DBG(CAM_ISP, "out_res_type %d",
+				out_port->res_type);
+				ipp_num++;
+			}
 		}
 	}
 
@@ -2306,299 +2297,11 @@ static int cam_ife_hw_mgr_preprocess_port(
 	return 0;
 }
 
-static int cam_ife_hw_mgr_acquire_res_ife_bus_rd(
-	struct cam_ife_hw_mgr_ctx                  *ife_ctx,
-	struct cam_isp_in_port_generic_info        *in_port)
-{
-	int                                         rc = -EINVAL, j;
-	int                                         i = CAM_ISP_HW_SPLIT_LEFT;
-	struct cam_vfe_acquire_args                 vfe_acquire;
-	struct cam_ife_hw_mgr_res                  *ife_bus_rd_res;
-	struct cam_hw_intf                         *hw_intf;
-	struct cam_ife_hw_mgr                      *ife_hw_mgr;
-
-	ife_hw_mgr = ife_ctx->hw_mgr;
-
-	rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list, &ife_bus_rd_res);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "No more free hw mgr resource");
-		goto end;
-	}
-
-	vfe_acquire.rsrc_type = CAM_ISP_RESOURCE_VFE_BUS_RD;
-	vfe_acquire.tasklet = ife_ctx->common.tasklet_info;
-	vfe_acquire.priv = ife_ctx;
-	vfe_acquire.event_cb = cam_ife_hw_mgr_event_handler;
-
-	vfe_acquire.vfe_bus_rd.cdm_ops = ife_ctx->cdm_ops;
-	vfe_acquire.vfe_bus_rd.is_dual = (uint32_t)ife_ctx->is_dual;
-	vfe_acquire.vfe_bus_rd.is_offline = ife_ctx->is_offline;
-	vfe_acquire.vfe_bus_rd.res_id = CAM_ISP_HW_VFE_IN_RD;
-	vfe_acquire.vfe_bus_rd.unpacker_fmt = in_port->fe_unpacker_fmt;
-
-	for (j = 0; j < CAM_IFE_HW_NUM_MAX; j++) {
-		if (!ife_hw_mgr->ife_devices[j])
-			continue;
-
-		hw_intf = ife_hw_mgr->ife_devices[j];
-		rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
-			&vfe_acquire, sizeof(struct cam_vfe_acquire_args));
-
-		if (!rc) {
-			ife_bus_rd_res->hw_res[i] =
-				vfe_acquire.vfe_bus_rd.rsrc_node;
-
-			CAM_DBG(CAM_ISP, "Acquired VFE:%d BUS RD for LEFT", j);
-			break;
-		}
-	}
-
-	if (j == CAM_IFE_HW_NUM_MAX || !vfe_acquire.vfe_bus_rd.rsrc_node) {
-		CAM_ERR(CAM_ISP, "Failed to acquire BUS RD for LEFT", i);
-		goto put_res;
-	}
-
-	ife_bus_rd_res->res_type =
-		(enum cam_ife_hw_mgr_res_type)vfe_acquire.rsrc_type;
-	ife_bus_rd_res->res_id = vfe_acquire.vfe_in.res_id;
-	ife_bus_rd_res->is_dual_vfe = (uint32_t)ife_ctx->is_dual;
-	cam_ife_hw_mgr_put_res(&ife_ctx->res_list_ife_in_rd, &ife_bus_rd_res);
-
-	if (ife_ctx->is_dual) {
-		for (j = 0; j < CAM_IFE_HW_NUM_MAX; j++) {
-			if (!ife_hw_mgr->ife_devices[j])
-				continue;
-
-			if (j == ife_bus_rd_res->hw_res[i]->hw_intf->hw_idx)
-				continue;
-
-			hw_intf = ife_hw_mgr->ife_devices[j];
-			rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv,
-				&vfe_acquire,
-				sizeof(struct cam_vfe_acquire_args));
-
-			if (!rc) {
-				ife_bus_rd_res->hw_res[++i] =
-					vfe_acquire.vfe_bus_rd.rsrc_node;
-
-				CAM_DBG(CAM_ISP,
-					"Acquired VFE:%d BUS RD for RIGHT", j);
-				break;
-			}
-		}
-
-		if (j == CAM_IFE_HW_NUM_MAX ||
-			!vfe_acquire.vfe_bus_rd.rsrc_node) {
-			CAM_ERR(CAM_ISP, "Failed to acquire BUS RD for RIGHT");
-			goto end;
-		}
-	}
-
-	return 0;
-
-put_res:
-	cam_ife_hw_mgr_put_res(&ife_ctx->free_res_list, &ife_bus_rd_res);
-
-end:
-	return rc;
-}
-
-static int cam_ife_hw_mgr_acquire_offline_res_ife_camif(
-	struct cam_ife_hw_mgr_ctx                  *ife_ctx,
-	struct cam_isp_in_port_generic_info        *in_port,
-	bool                                        acquire_lcr,
-	uint32_t                                   *acquired_hw_id,
-	uint32_t                                   *acquired_hw_path)
-{
-	int                                         rc = -1;
-	int                                         i = CAM_ISP_HW_SPLIT_LEFT;
-	struct cam_ife_hw_mgr_res                  *ife_src_res;
-	struct cam_ife_hw_mgr_res                  *ife_bus_rd_res;
-	struct cam_vfe_acquire_args                 vfe_acquire;
-	struct cam_hw_intf                         *hw_intf;
-	struct cam_ife_hw_mgr                      *ife_hw_mgr;
-
-	ife_hw_mgr = ife_ctx->hw_mgr;
-
-	ife_bus_rd_res = list_first_entry(&ife_ctx->res_list_ife_in_rd,
-		struct cam_ife_hw_mgr_res, list);
-
-	if (!ife_bus_rd_res) {
-		CAM_ERR(CAM_ISP, "BUS RD resource has not been acquired");
-		rc = -EINVAL;
-		goto end;
-	}
-
-	rc = cam_ife_hw_mgr_get_res(&ife_ctx->free_res_list, &ife_src_res);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "No free resource");
-		goto end;
-	}
-
-	vfe_acquire.rsrc_type = CAM_ISP_RESOURCE_VFE_IN;
-	vfe_acquire.tasklet = ife_ctx->common.tasklet_info;
-	vfe_acquire.priv = ife_ctx;
-	vfe_acquire.event_cb = cam_ife_hw_mgr_event_handler;
-
-	vfe_acquire.vfe_in.cdm_ops = ife_ctx->cdm_ops;
-	vfe_acquire.vfe_in.in_port = in_port;
-	vfe_acquire.vfe_in.is_fe_enabled = ife_ctx->is_fe_enabled;
-	vfe_acquire.vfe_in.is_offline = ife_ctx->is_offline;
-
-	if (!acquire_lcr)
-		vfe_acquire.vfe_in.res_id = CAM_ISP_HW_VFE_IN_CAMIF;
-	else
-		vfe_acquire.vfe_in.res_id = CAM_ISP_HW_VFE_IN_LCR;
-
-	if (ife_ctx->is_dual)
-		vfe_acquire.vfe_in.sync_mode = CAM_ISP_HW_SYNC_MASTER;
-	else
-		vfe_acquire.vfe_in.sync_mode = CAM_ISP_HW_SYNC_NONE;
-
-	hw_intf = ife_hw_mgr->ife_devices[
-		ife_bus_rd_res->hw_res[i]->hw_intf->hw_idx];
-
-	rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv, &vfe_acquire,
-		sizeof(struct cam_vfe_acquire_args));
-
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Failed to acquire CAMIF for LEFT");
-		goto put_res;
-	}
-
-	ife_src_res->hw_res[i] = vfe_acquire.vfe_in.rsrc_node;
-
-	*acquired_hw_id |= cam_convert_hw_idx_to_ife_hw_num(
-		hw_intf->hw_idx);
-
-	acquired_hw_path[i] |= cam_convert_res_id_to_hw_path(
-		ife_src_res->hw_res[i]->res_id);
-
-	CAM_DBG(CAM_ISP, "Acquired VFE:%d CAMIF for LEFT",
-		ife_src_res->hw_res[i]->hw_intf->hw_idx);
-
-	ife_src_res->res_type =
-		(enum cam_ife_hw_mgr_res_type)vfe_acquire.rsrc_type;
-	ife_src_res->res_id = vfe_acquire.vfe_in.res_id;
-	ife_src_res->is_dual_vfe = (uint32_t)ife_ctx->is_dual;
-	cam_ife_hw_mgr_put_res(&ife_ctx->res_list_ife_src, &ife_src_res);
-
-	if (ife_ctx->is_dual) {
-		vfe_acquire.vfe_in.sync_mode = CAM_ISP_HW_SYNC_SLAVE;
-
-		hw_intf = ife_hw_mgr->ife_devices[
-			ife_bus_rd_res->hw_res[++i]->hw_intf->hw_idx];
-
-		rc = hw_intf->hw_ops.reserve(hw_intf->hw_priv, &vfe_acquire,
-			sizeof(struct cam_vfe_acquire_args));
-
-		if (rc) {
-			CAM_ERR(CAM_ISP, "Failed to acquire CAMIF for RIGHT");
-			goto end;
-		}
-
-		ife_src_res->hw_res[i] = vfe_acquire.vfe_in.rsrc_node;
-
-		*acquired_hw_id |= cam_convert_hw_idx_to_ife_hw_num(
-			hw_intf->hw_idx);
-
-		acquired_hw_path[i] |= cam_convert_res_id_to_hw_path(
-			ife_src_res->hw_res[i]->res_id);
-
-		CAM_DBG(CAM_ISP, "Acquired VFE:%d CAMIF for RIGHT",
-			ife_src_res->hw_res[i]->hw_intf->hw_idx);
-	}
-
-	ife_src_res->parent = ife_bus_rd_res;
-	ife_bus_rd_res->child[ife_bus_rd_res->num_children++] = ife_src_res;
-
-	return rc;
-
-put_res:
-	cam_ife_hw_mgr_put_res(&ife_ctx->free_res_list, &ife_src_res);
-
-end:
-	return rc;
-}
-
-static int cam_ife_mgr_acquire_hw_for_offline_ctx(
-	struct cam_ife_hw_mgr_ctx           *ife_ctx,
-	struct cam_isp_in_port_generic_info *in_port,
-	uint32_t                            *num_pix_port,
-	uint32_t                            *acquired_hw_id,
-	uint32_t                            *acquired_hw_path)
-{
-	int                                  rc = -1;
-	int                                  ipp_count = 0;
-	int                                  rdi_count = 0;
-	int                                  ppp_count = 0;
-	int                                  ife_rd_count = 0;
-	int                                  lcr_count = 0;
-
-	ife_ctx->is_dual = (bool)in_port->usage_type;
-
-	cam_ife_hw_mgr_preprocess_port(ife_ctx, in_port, &ipp_count,
-		&rdi_count, &ppp_count, &ife_rd_count, &lcr_count);
-
-	if ((!ipp_count && !lcr_count) || !ife_rd_count) {
-		CAM_ERR(CAM_ISP,
-			"Invalid %d BUS RD %d PIX %d LCR ports for FE ctx");
-		return -EINVAL;
-	}
-
-	if (rdi_count || ppp_count) {
-		CAM_ERR(CAM_ISP,
-			"%d RDI %d PPP ports invalid for FE ctx",
-			rdi_count, ppp_count);
-		return -EINVAL;
-	}
-
-	rc = cam_ife_hw_mgr_acquire_res_ife_bus_rd(ife_ctx, in_port);
-
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Acquire IFE BUS RD resource Failed");
-		goto err;
-	}
-
-	if (ipp_count)
-		rc = cam_ife_hw_mgr_acquire_offline_res_ife_camif(ife_ctx,
-			in_port, false, acquired_hw_id, acquired_hw_path);
-
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Acquire IFE IPP SRC resource Failed");
-		goto err;
-	}
-
-	if (lcr_count)
-		rc = cam_ife_hw_mgr_acquire_offline_res_ife_camif(ife_ctx,
-			in_port, true, acquired_hw_id, acquired_hw_path);
-
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Acquire IFE LCR SRC resource Failed");
-		goto err;
-	}
-
-	rc = cam_ife_hw_mgr_acquire_res_ife_out(ife_ctx, in_port);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Acquire IFE OUT resource Failed");
-		goto err;
-	}
-
-	*num_pix_port += ipp_count + lcr_count;
-
-	return 0;
-
-err:
-	return rc;
-}
-
-
 static int cam_ife_mgr_acquire_hw_for_ctx(
 	struct cam_ife_hw_mgr_ctx           *ife_ctx,
 	struct cam_isp_in_port_generic_info *in_port,
-	uint32_t *num_pix_port, uint32_t *num_rdi_port,
-	uint32_t *num_pd_port, uint32_t *acquired_hw_id,
-	uint32_t *acquired_hw_path)
+	uint32_t  *num_pix_port, uint32_t  *num_rdi_port,
+	uint32_t *acquired_hw_id, uint32_t *acquired_hw_path)
 {
 	int rc                                    = -1;
 	int is_dual_vfe                           = 0;
@@ -2610,7 +2313,6 @@ static int cam_ife_mgr_acquire_hw_for_ctx(
 	bool crop_enable                          = true;
 
 	is_dual_vfe = in_port->usage_type;
-	ife_ctx->dsp_enabled = (bool)in_port->dsp_mode;
 
 	/* get root node resource */
 	rc = cam_ife_hw_mgr_acquire_res_root(ife_ctx, in_port);
@@ -2622,19 +2324,11 @@ static int cam_ife_mgr_acquire_hw_for_ctx(
 	cam_ife_hw_mgr_preprocess_port(ife_ctx, in_port, &ipp_count,
 		&rdi_count, &ppp_count, &ife_rd_count, &lcr_count);
 
-	if (!ipp_count && !rdi_count && !ppp_count && !lcr_count) {
+	if (!ipp_count && !rdi_count && !ppp_count && !ife_rd_count
+		&& !lcr_count) {
 		CAM_ERR(CAM_ISP,
-			"No PIX or RDI or PPP or LCR resource");
-		return -EINVAL;
-	}
-
-	if (ife_rd_count) {
-		rc = cam_ife_hw_mgr_acquire_res_ife_bus_rd(ife_ctx, in_port);
-
-		if (rc) {
-			CAM_ERR(CAM_ISP, "Acquire IFE BUS RD resource Failed");
-			goto err;
-		}
+			"No PIX or RDI or PPP or IFE RD or LCR resource");
+		return -EINVAL;
 	}
 
 	if (ipp_count || lcr_count) {
@@ -2678,7 +2372,15 @@ static int cam_ife_mgr_acquire_hw_for_ctx(
 	}
 
 	/* get ife src resource */
-	if (ipp_count || ppp_count || rdi_count) {
+	if (ife_rd_count) {
+		rc = cam_ife_hw_mgr_acquire_res_ife_rd_src(ife_ctx, in_port);
+		rc = cam_ife_hw_mgr_acquire_res_bus_rd(ife_ctx, in_port);
+
+		if (rc) {
+			CAM_ERR(CAM_ISP, "Acquire IFE RD SRC resource Failed");
+			goto err;
+		}
+	} else if (ipp_count || ppp_count || rdi_count) {
 		rc = cam_ife_hw_mgr_acquire_res_ife_src(ife_ctx,
 			in_port, false,
 			acquired_hw_id, acquired_hw_path);
@@ -2707,8 +2409,7 @@ static int cam_ife_mgr_acquire_hw_for_ctx(
 		goto err;
 	}
 
-	*num_pix_port = ipp_count + ife_rd_count + lcr_count;
-	*num_pd_port = ppp_count;
+	*num_pix_port = ipp_count + ppp_count + ife_rd_count + lcr_count;
 	*num_rdi_port = rdi_count;
 
 	return 0;
@@ -2734,13 +2435,11 @@ void cam_ife_cam_cdm_callback(uint32_t handle, void *userdata,
 	if (status == CAM_CDM_CB_STATUS_BL_SUCCESS) {
 		complete_all(&ctx->config_done_complete);
 		atomic_set(&ctx->cdm_done, 1);
-		ctx->last_cdm_done_req = cookie;
 		if (g_ife_hw_mgr.debug_cfg.per_req_reg_dump)
 			cam_ife_mgr_handle_reg_dump(ctx,
 				hw_update_data->reg_dump_buf_desc,
 				hw_update_data->num_reg_dump_buf,
-				CAM_ISP_PACKET_META_REG_DUMP_PER_REQUEST,
-				NULL, false);
+				CAM_ISP_PACKET_META_REG_DUMP_PER_REQUEST);
 
 		CAM_DBG(CAM_ISP,
 			"Called by CDM hdl=%x, udata=%pK, status=%d, cookie=%llu ctx_index=%d",
@@ -2884,12 +2583,10 @@ static int cam_ife_mgr_acquire_get_unified_structure_v2(
 
 	if (port_info->num_valid_vc_dt == 0 ||
 		port_info->num_valid_vc_dt >= CAM_ISP_VC_DT_CFG) {
-		if (in->res_type != CAM_ISP_IFE_IN_RES_RD) {
-			CAM_ERR(CAM_ISP, "Invalid i/p arg invalid vc-dt: %d",
-				in->num_valid_vc_dt);
-			rc = -EINVAL;
-			goto release_mem;
-		}
+		CAM_ERR(CAM_ISP, "Invalid i/p arg invalid vc-dt: %d",
+			in->num_valid_vc_dt);
+		rc = -EINVAL;
+		goto release_mem;
 	}
 
 	for (i = 0; i < port_info->num_valid_vc_dt; i++) {
@@ -2897,27 +2594,26 @@ static int cam_ife_mgr_acquire_get_unified_structure_v2(
 		port_info->dt[i]      =  in->dt[i];
 	}
 
-	port_info->format          =  in->format;
-	port_info->test_pattern    =  in->test_pattern;
-	port_info->usage_type      =  in->usage_type;
-	port_info->left_start      =  in->left_start;
-	port_info->left_stop       =  in->left_stop;
-	port_info->left_width      =  in->left_width;
-	port_info->right_start     =  in->right_start;
-	port_info->right_stop      =  in->right_stop;
-	port_info->right_width     =  in->right_width;
-	port_info->line_start      =  in->line_start;
-	port_info->line_stop       =  in->line_stop;
-	port_info->height          =  in->height;
-	port_info->pixel_clk       =  in->pixel_clk;
-	port_info->batch_size      =  in->batch_size;
-	port_info->dsp_mode        =  in->dsp_mode;
-	port_info->fe_unpacker_fmt =  in->format;
-	port_info->hbi_cnt         =  in->hbi_cnt;
-	port_info->cust_node       =  in->cust_node;
-	port_info->horizontal_bin  =  in->horizontal_bin;
-	port_info->qcfa_bin        =  in->qcfa_bin;
-	port_info->num_out_res     =  in->num_out_res;
+	port_info->format         =  in->format;
+	port_info->test_pattern   =  in->test_pattern;
+	port_info->usage_type     =  in->usage_type;
+	port_info->left_start     =  in->left_start;
+	port_info->left_stop      =  in->left_stop;
+	port_info->left_width     =  in->left_width;
+	port_info->right_start    =  in->right_start;
+	port_info->right_stop     =  in->right_stop;
+	port_info->right_width    =  in->right_width;
+	port_info->line_start     =  in->line_start;
+	port_info->line_stop      =  in->line_stop;
+	port_info->height         =  in->height;
+	port_info->pixel_clk      =  in->pixel_clk;
+	port_info->batch_size     =  in->batch_size;
+	port_info->dsp_mode       =  in->dsp_mode;
+	port_info->hbi_cnt        =  in->hbi_cnt;
+	port_info->cust_node      =  in->cust_node;
+	port_info->horizontal_bin =  in->horizontal_bin;
+	port_info->qcfa_bin       =  in->qcfa_bin;
+	port_info->num_out_res    =  in->num_out_res;
 
 	port_info->data = kcalloc(in->num_out_res,
 		sizeof(struct cam_isp_out_port_generic_info),
@@ -2987,10 +2683,8 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 	struct cam_cdm_acquire_data        cdm_acquire;
 	uint32_t                           num_pix_port_per_in = 0;
 	uint32_t                           num_rdi_port_per_in = 0;
-	uint32_t                           num_pd_port_per_in = 0;
 	uint32_t                           total_pix_port = 0;
 	uint32_t                           total_rdi_port = 0;
-	uint32_t                           total_pd_port = 0;
 	struct cam_isp_acquire_hw_info    *acquire_hw_info = NULL;
 	uint32_t                           input_size = 0;
 
@@ -3008,7 +2702,6 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 		goto err;
 	}
 
-	ife_ctx->custom_enabled = false;
 	ife_ctx->common.cb_priv = acquire_args->context_data;
 	for (i = 0; i < CAM_ISP_HW_EVENT_MAX; i++)
 		ife_ctx->common.event_cb[i] = acquire_args->event_cb;
@@ -3041,13 +2734,11 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 	ife_ctx->cdm_handle = cdm_acquire.handle;
 	ife_ctx->cdm_ops = cdm_acquire.ops;
 	atomic_set(&ife_ctx->cdm_done, 1);
-	ife_ctx->last_cdm_done_req = 0;
 
 	acquire_hw_info =
 		(struct cam_isp_acquire_hw_info *)acquire_args->acquire_info;
 
-	rc = cam_ife_mgr_check_and_update_fe(ife_ctx, acquire_hw_info,
-		acquire_args->acquire_info_size);
+	rc = cam_ife_mgr_check_and_update_fe(ife_ctx, acquire_hw_info);
 	if (rc) {
 		CAM_ERR(CAM_ISP, "buffer size is not enough");
 		goto free_cdm;
@@ -3063,33 +2754,18 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 		}
 		CAM_DBG(CAM_ISP, "in_res_type %x", in_port->res_type);
 
-		if ((in_port->cust_node) && (!ife_ctx->custom_enabled)) {
-			ife_ctx->custom_enabled = true;
-			/* This can be obtained from uapi */
-			ife_ctx->use_frame_header_ts = true;
-		}
-
-		if (ife_ctx->is_offline)
-			rc = cam_ife_mgr_acquire_hw_for_offline_ctx(
-				ife_ctx, in_port,
-				&num_pix_port_per_in,
-				&acquire_args->acquired_hw_id[i],
-				acquire_args->acquired_hw_path[i]);
-		else
-			rc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,
-				&num_pix_port_per_in, &num_rdi_port_per_in,
-				&num_pd_port_per_in,
-				&acquire_args->acquired_hw_id[i],
-				acquire_args->acquired_hw_path[i]);
+		rc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,
+			&num_pix_port_per_in, &num_rdi_port_per_in,
+			&acquire_args->acquired_hw_id[i],
+			acquire_args->acquired_hw_path[i]);
 
 		total_pix_port += num_pix_port_per_in;
 		total_rdi_port += num_rdi_port_per_in;
-		total_pd_port += num_pd_port_per_in;
 
 		if (rc) {
-			cam_ife_hw_mgr_print_acquire_info(ife_ctx,
-				total_pix_port, total_pd_port,
-				total_rdi_port, rc);
+			CAM_ERR(CAM_ISP, "can not acquire resource");
+			cam_ife_hw_mgr_dump_src_acq_info(ife_ctx,
+				total_pix_port, total_rdi_port);
 			goto free_mem;
 		}
 
@@ -3099,7 +2775,7 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 	}
 
 	/* Check whether context has only RDI resource */
-	if (!total_pix_port && !total_pd_port) {
+	if (!total_pix_port) {
 		ife_ctx->is_rdi_only_context = 1;
 		CAM_DBG(CAM_ISP, "RDI only context");
 	}
@@ -3111,21 +2787,17 @@ static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)
 		goto free_res;
 	}
 
-	acquire_args->support_consumed_addr =
-		g_ife_hw_mgr.support_consumed_addr;
-
 	acquire_args->ctxt_to_hw_map = ife_ctx;
-	acquire_args->custom_enabled = ife_ctx->custom_enabled;
-	acquire_args->use_frame_header_ts = ife_ctx->use_frame_header_ts;
 	ife_ctx->ctx_in_use = 1;
-	ife_ctx->num_reg_dump_buf = 0;
 
 	acquire_args->valid_acquired_hw =
 		acquire_hw_info->num_inputs;
 
 	getnstimeofday64(&ife_ctx->ts);
-	cam_ife_hw_mgr_print_acquire_info(ife_ctx, total_pix_port,
-		total_pd_port, total_rdi_port, rc);
+	CAM_INFO(CAM_ISP,
+		"Acquire HW success with total_pix: %u total_rdi: %u is_dual: %u in ctx: %u",
+		total_pix_port, total_rdi_port,
+		ife_ctx->is_dual, ife_ctx->ctx_index);
 
 	cam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);
 
@@ -3172,7 +2844,6 @@ void cam_ife_mgr_acquire_get_unified_dev_str(struct cam_isp_in_port_info *in,
 	gen_port_info->batch_size      =  in->batch_size;
 	gen_port_info->dsp_mode        =  in->dsp_mode;
 	gen_port_info->hbi_cnt         =  in->hbi_cnt;
-	gen_port_info->fe_unpacker_fmt =  in->format;
 	gen_port_info->cust_node       =  0;
 	gen_port_info->num_out_res     =  in->num_out_res;
 
@@ -3201,8 +2872,6 @@ static int cam_ife_mgr_acquire_dev(void *hw_mgr_priv, void *acquire_hw_args)
 	struct cam_isp_in_port_generic_info   *gen_port_info = NULL;
 	uint32_t                               num_pix_port_per_in = 0;
 	uint32_t                               num_rdi_port_per_in = 0;
-	uint32_t                               num_pd_port_per_in = 0;
-	uint32_t                               total_pd_port = 0;
 	uint32_t                               total_pix_port = 0;
 	uint32_t                               total_rdi_port = 0;
 	uint32_t                               in_port_length = 0;
@@ -3254,7 +2923,6 @@ static int cam_ife_mgr_acquire_dev(void *hw_mgr_priv, void *acquire_hw_args)
 	ife_ctx->cdm_handle = cdm_acquire.handle;
 	ife_ctx->cdm_ops = cdm_acquire.ops;
 	atomic_set(&ife_ctx->cdm_done, 1);
-	ife_ctx->last_cdm_done_req = 0;
 
 	isp_resource = (struct cam_isp_resource *)acquire_args->acquire_info;
 
@@ -3323,13 +2991,12 @@ static int cam_ife_mgr_acquire_dev(void *hw_mgr_priv, void *acquire_hw_args)
 
 			rc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx,
 				gen_port_info, &num_pix_port_per_in,
-				&num_rdi_port_per_in, &num_pd_port_per_in,
+				&num_rdi_port_per_in,
 				&acquire_args->acquired_hw_id[i],
 				acquire_args->acquired_hw_path[i]);
 
 			total_pix_port += num_pix_port_per_in;
 			total_rdi_port += num_rdi_port_per_in;
-			total_pd_port += num_pd_port_per_in;
 
 			kfree(in_port);
 			if (gen_port_info != NULL) {
@@ -3338,9 +3005,7 @@ static int cam_ife_mgr_acquire_dev(void *hw_mgr_priv, void *acquire_hw_args)
 				gen_port_info = NULL;
 			}
 			if (rc) {
-				cam_ife_hw_mgr_print_acquire_info(ife_ctx,
-					total_pix_port, total_pd_port,
-					total_rdi_port, rc);
+				CAM_ERR(CAM_ISP, "can not acquire resource");
 				goto free_res;
 			}
 		} else {
@@ -3367,10 +3032,11 @@ static int cam_ife_mgr_acquire_dev(void *hw_mgr_priv, void *acquire_hw_args)
 
 	acquire_args->ctxt_to_hw_map = ife_ctx;
 	ife_ctx->ctx_in_use = 1;
-	ife_ctx->num_reg_dump_buf = 0;
 
-	cam_ife_hw_mgr_print_acquire_info(ife_ctx, total_pix_port,
-		total_pd_port, total_rdi_port, rc);
+	CAM_INFO(CAM_ISP,
+		"Acquire HW success with total_pix: %u total_rdi: %u is_dual: %u in ctx: %u",
+		total_pix_port, total_rdi_port,
+		ife_ctx->is_dual, ife_ctx->ctx_index);
 
 	cam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);
 
@@ -3691,13 +3357,10 @@ static int cam_ife_mgr_config_hw(void *hw_mgr_priv,
 	struct cam_cdm_bl_request *cdm_cmd;
 	struct cam_ife_hw_mgr_ctx *ctx;
 	struct cam_isp_prepare_hw_update_data *hw_update_data;
-	unsigned long rem_jiffies = 0;
-	bool cdm_hang_detect = false;
 
+	CAM_DBG(CAM_ISP, "Enter");
 	if (!hw_mgr_priv || !config_hw_args) {
-		CAM_ERR(CAM_ISP,
-			"Invalid arguments, hw_mgr_priv=%pK, config_hw_args=%pK",
-			hw_mgr_priv, config_hw_args);
+		CAM_ERR(CAM_ISP, "Invalid arguments");
 		return -EINVAL;
 	}
 
@@ -3705,53 +3368,21 @@ static int cam_ife_mgr_config_hw(void *hw_mgr_priv,
 	ctx = (struct cam_ife_hw_mgr_ctx *)cfg->ctxt_to_hw_map;
 	if (!ctx) {
 		CAM_ERR(CAM_ISP, "Invalid context is used");
-		return -EINVAL;
-	}
-
-	if (!ctx->ctx_in_use || !ctx->cdm_cmd) {
-		CAM_ERR(CAM_ISP,
-			"Invalid context parameters : ctx_in_use=%d, cdm_cmd=%pK",
-			ctx->ctx_in_use, ctx->cdm_cmd);
 		return -EPERM;
 	}
 
-	if (atomic_read(&ctx->overflow_pending)) {
-		CAM_DBG(CAM_ISP,
-			"Ctx[%pK][%d] Overflow pending, cannot apply req %llu",
-			ctx, ctx->ctx_index, cfg->request_id);
+	if (!ctx->ctx_in_use || !ctx->cdm_cmd) {
+		CAM_ERR(CAM_ISP, "Invalid context parameters");
 		return -EPERM;
 	}
+	if (atomic_read(&ctx->overflow_pending))
+		return -EINVAL;
 
 	hw_update_data = (struct cam_isp_prepare_hw_update_data  *) cfg->priv;
 	hw_update_data->ife_mgr_ctx = ctx;
 
-	CAM_DBG(CAM_ISP, "Ctx[%pK][%d] : Applying Req %lld, init_packet=%d",
-		ctx, ctx->ctx_index, cfg->request_id, cfg->init_packet);
-
-	if (cfg->reapply && cfg->cdm_reset_before_apply) {
-		if (ctx->last_cdm_done_req < cfg->request_id) {
-			cdm_hang_detect =
-				cam_cdm_detect_hang_error(ctx->cdm_handle);
-			CAM_ERR_RATE_LIMIT(CAM_ISP,
-				"CDM callback not received for req: %lld, last_cdm_done_req: %lld, cdm_hang_detect: %d",
-				cfg->request_id, ctx->last_cdm_done_req,
-				cdm_hang_detect);
-			rc = cam_cdm_reset_hw(ctx->cdm_handle);
-			if (rc) {
-				CAM_ERR_RATE_LIMIT(CAM_ISP,
-					"CDM reset unsuccessful for req: %lld. ctx: %d, rc: %d",
-					cfg->request_id, ctx->ctx_index, rc);
-				ctx->last_cdm_done_req = 0;
-				return rc;
-			}
-		} else {
-			CAM_ERR_RATE_LIMIT(CAM_ISP,
-				"CDM callback received, should wait for buf done for req: %lld",
-				cfg->request_id);
-			return -EALREADY;
-		}
-		ctx->last_cdm_done_req = 0;
-	}
+	CAM_DBG(CAM_ISP, "Ctx[%pK][%d] : Applying Req %lld",
+		ctx, ctx->ctx_index, cfg->request_id);
 
 	for (i = 0; i < CAM_IFE_HW_NUM_MAX; i++) {
 		if (hw_update_data->bw_config_valid[i] == true) {
@@ -3823,51 +3454,30 @@ static int cam_ife_mgr_config_hw(void *hw_mgr_priv,
 		atomic_set(&ctx->cdm_done, 0);
 		rc = cam_cdm_submit_bls(ctx->cdm_handle, cdm_cmd);
 		if (rc) {
-			CAM_ERR(CAM_ISP,
-				"Failed to apply the configs for req %llu, rc %d",
-				cfg->request_id, rc);
+			CAM_ERR(CAM_ISP, "Failed to apply the configs");
 			return rc;
 		}
 
-		if (!cfg->init_packet)
-			goto end;
-
-		for (i = 0; i < CAM_IFE_HW_CONFIG_WAIT_MAX_TRY; i++) {
-			rem_jiffies = wait_for_completion_timeout(
+		if (cfg->init_packet) {
+			rc = wait_for_completion_timeout(
 				&ctx->config_done_complete,
-				msecs_to_jiffies(30));
-			if (rem_jiffies == 0) {
-				if (!cam_cdm_detect_hang_error(
-						ctx->cdm_handle)) {
-					CAM_INFO(CAM_ISP,
-						"CDM workqueue delay detected, wait for some more time req_id=%llu rc=%d ctx_index %d",
-						cfg->request_id, rc,
-						ctx->ctx_index);
-					continue;
-				}
+				msecs_to_jiffies(100));
+			if (rc <= 0) {
 				CAM_ERR(CAM_ISP,
-					"config done completion timeout for req_id=%llu ctx_index %d",
-					cfg->request_id, ctx->ctx_index);
-				rc = -ETIMEDOUT;
-				goto end;
+					"config done completion timeout for req_id=%llu rc=%d ctx_index %d",
+					cfg->request_id, rc, ctx->ctx_index);
+				if (rc == 0)
+					rc = -ETIMEDOUT;
 			} else {
 				rc = 0;
 				CAM_DBG(CAM_ISP,
 					"config done Success for req_id=%llu ctx_index %d",
 					cfg->request_id, ctx->ctx_index);
-				break;
 			}
 		}
-		if ((i == CAM_IFE_HW_CONFIG_WAIT_MAX_TRY) && (rc == 0)) {
-			CAM_ERR(CAM_ISP,
-				"config done completion timeout for req_id=%llu ctx_index %d",
-				cfg->request_id, ctx->ctx_index);
-			rc = -ETIMEDOUT;
-		}
 	} else {
 		CAM_ERR(CAM_ISP, "No commands to config");
 	}
-end:
 	CAM_DBG(CAM_ISP, "Exit: Config Done: %llu",  cfg->request_id);
 
 	return rc;
@@ -4011,7 +3621,6 @@ static int cam_ife_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 	struct cam_ife_hw_mgr_ctx        *ctx;
 	enum cam_ife_csid_halt_cmd        csid_halt_type;
 	uint32_t                          i, master_base_idx = 0;
-	unsigned long                     rem_jiffies = 0;
 
 	if (!hw_mgr_priv || !stop_hw_args) {
 		CAM_ERR(CAM_ISP, "Invalid arguments");
@@ -4028,8 +3637,7 @@ static int cam_ife_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 	stop_isp = (struct cam_isp_stop_args    *)stop_args->args;
 
 	/* Set the csid halt command */
-	if ((stop_isp->hw_stop_cmd == CAM_ISP_HW_STOP_AT_FRAME_BOUNDARY) ||
-		ctx->dsp_enabled)
+	if (stop_isp->hw_stop_cmd == CAM_ISP_HW_STOP_AT_FRAME_BOUNDARY)
 		csid_halt_type = CAM_CSID_HALT_AT_FRAME_BOUNDARY;
 	else
 		csid_halt_type = CAM_CSID_HALT_IMMEDIATELY;
@@ -4057,19 +3665,6 @@ static int cam_ife_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 	 */
 	if (i == ctx->num_base)
 		master_base_idx = ctx->base[0].idx;
-
-	/*Change slave mode*/
-	if (csid_halt_type == CAM_CSID_HALT_IMMEDIATELY) {
-		for (i = 0; i < ctx->num_base; i++) {
-			if (ctx->base[i].idx == master_base_idx)
-				continue;
-			cam_ife_mgr_csid_change_halt_mode(
-				&ctx->res_list_ife_csid,
-				ctx->base[i].idx,
-				CAM_CSID_HALT_MODE_INTERNAL);
-		}
-	}
-
 	CAM_DBG(CAM_ISP, "Stopping master CSID idx %d", master_base_idx);
 
 	/* Stop the master CSID path first */
@@ -4109,6 +3704,11 @@ static int cam_ife_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 	for (i = 0; i < CAM_IFE_HW_OUT_RES_MAX; i++)
 		cam_ife_hw_mgr_stop_hw_res(&ctx->res_list_ife_out[i]);
 
+	/* IFE bus rd resources */
+	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_in_rd, list) {
+		cam_ife_hw_mgr_stop_hw_res(hw_mgr_res);
+	}
+
 	CAM_DBG(CAM_ISP, "Going to stop IFE Mux");
 
 	/* IFE mux in resources */
@@ -4116,25 +3716,23 @@ static int cam_ife_mgr_stop_hw(void *hw_mgr_priv, void *stop_hw_args)
 		cam_ife_hw_mgr_stop_hw_res(hw_mgr_res);
 	}
 
-	/* IFE bus rd resources */
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_in_rd, list) {
-		cam_ife_hw_mgr_stop_hw_res(hw_mgr_res);
-	}
-
 	cam_tasklet_stop(ctx->common.tasklet_info);
 
-	cam_ife_mgr_pause_hw(ctx);
-
-	rem_jiffies = wait_for_completion_timeout(&ctx->config_done_complete,
-		msecs_to_jiffies(10));
-	if (rem_jiffies == 0) {
-		CAM_WARN(CAM_ISP,
-			"config done completion timeout for last applied req_id=%llu rc=%d ctx_index %d",
-			ctx->applied_req_id, rc, ctx->ctx_index);
-		rc = -ETIMEDOUT;
-	}
-
-	if (stop_isp->stop_only)
+    cam_ife_mgr_pause_hw(ctx);
+
+    rc = wait_for_completion_timeout(&ctx->config_done_complete,msecs_to_jiffies(300));
+    if (rc <= 0) {
+        CAM_WARN(CAM_ISP,
+                 "config done completion timeout for last applied req_id=%llu rc=%d ctx_index %d",
+                 ctx->applied_req_id, rc, ctx->ctx_index);
+        rc = -ETIMEDOUT;
+    } else {
+        CAM_DBG(CAM_ISP,
+                "config done Success for req_id=%llu ctx_index %d",
+                ctx->applied_req_id, ctx->ctx_index);
+        rc = 0;
+    }
+    if (stop_isp->stop_only)
 		goto end;
 
 	if (cam_cdm_stream_off(ctx->cdm_handle))
@@ -4366,16 +3964,11 @@ static int cam_ife_mgr_start_hw(void *hw_mgr_priv, void *start_hw_args)
 	}
 
 start_only:
-
-	atomic_set(&ctx->overflow_pending, 0);
-
 	/* Apply initial configuration */
 	CAM_DBG(CAM_ISP, "Config HW");
 	rc = cam_ife_mgr_config_hw(hw_mgr_priv, &start_isp->hw_config);
 	if (rc) {
-		CAM_ERR(CAM_ISP,
-			"Config HW failed, start_only=%d, rc=%d",
-			start_isp->start_only, rc);
+		CAM_ERR(CAM_ISP, "Config HW failed");
 		goto cdm_streamoff;
 	}
 
@@ -4408,6 +4001,18 @@ static int cam_ife_mgr_start_hw(void *hw_mgr_priv, void *start_hw_args)
 		}
 	}
 
+	CAM_DBG(CAM_ISP, "START IFE BUS RD ... in ctx id:%d",
+		ctx->ctx_index);
+	/* Start the IFE mux in devices */
+	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_in_rd, list) {
+		rc = cam_ife_hw_mgr_start_hw_res(hw_mgr_res, ctx);
+		if (rc) {
+			CAM_ERR(CAM_ISP, "Can not start IFE BUS RD (%d)",
+				 hw_mgr_res->res_id);
+			goto err;
+		}
+	}
+
 	if (primary_rdi_out_res < CAM_ISP_IFE_OUT_RES_MAX)
 		primary_rdi_src_res =
 			cam_convert_rdi_out_res_id_to_src(primary_rdi_out_res);
@@ -4420,21 +4025,11 @@ static int cam_ife_mgr_start_hw(void *hw_mgr_priv, void *start_hw_args)
 			hw_mgr_res->hw_res[0]->rdi_only_ctx =
 				ctx->is_rdi_only_context;
 		}
-		rc = cam_ife_hw_mgr_start_hw_res(hw_mgr_res, ctx);
-		if (rc) {
-			CAM_ERR(CAM_ISP, "Can not start IFE Mux (%d)",
-				 hw_mgr_res->res_id);
-			goto err;
-		}
-	}
 
-	CAM_DBG(CAM_ISP, "START IFE BUS RD ... in ctx id:%d", ctx->ctx_index);
-	/* Start IFE Bus RD devices */
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_in_rd, list) {
 		rc = cam_ife_hw_mgr_start_hw_res(hw_mgr_res, ctx);
 		if (rc) {
-			CAM_ERR(CAM_ISP, "Can not start IFE BUS RD (%d)",
-				hw_mgr_res->res_id);
+			CAM_ERR(CAM_ISP, "Can not start IFE MUX (%d)",
+				 hw_mgr_res->res_id);
 			goto err;
 		}
 	}
@@ -4463,7 +4058,6 @@ static int cam_ife_mgr_start_hw(void *hw_mgr_priv, void *start_hw_args)
 		}
 	}
 
-	ctx->dual_ife_irq_mismatch_cnt = 0;
 	/* Start IFE root node: do nothing */
 	CAM_DBG(CAM_ISP, "Start success for ctx id:%d", ctx->ctx_index);
 
@@ -4588,15 +4182,6 @@ static int cam_ife_mgr_release_hw(void *hw_mgr_priv,
 	ctx->is_rdi_only_context = 0;
 	ctx->cdm_handle = 0;
 	ctx->cdm_ops = NULL;
-	ctx->custom_enabled = false;
-	ctx->use_frame_header_ts = false;
-	ctx->num_reg_dump_buf = 0;
-	ctx->is_dual = false;
-	ctx->dsp_enabled = false;
-	ctx->is_fe_enabled = false;
-	ctx->is_offline = false;
-	ctx->dual_ife_irq_mismatch_cnt = 0;
-	ctx->last_cdm_done_req = 0;
 	atomic_set(&ctx->overflow_pending, 0);
 	for (i = 0; i < CAM_IFE_HW_NUM_MAX; i++) {
 		ctx->sof_cnt[i] = 0;
@@ -4771,10 +4356,10 @@ static int cam_isp_blob_ubwc_update(
 				&bytes_used);
 			if (rc < 0) {
 				CAM_ERR(CAM_ISP,
-					"Failed cmd_update, base_idx=%d, bytes_used=%u, res_id_out=0x%X",
+					"Failed cmd_update, base_idx=%d, bytes_used=%u, res_id_out=0x%x",
 					blob_info->base_info->idx,
 					bytes_used,
-					ubwc_plane_cfg->port_type);
+					res_id_out);
 				goto end;
 			}
 
@@ -4944,10 +4529,10 @@ static int cam_isp_blob_ubwc_update_v2(
 			&bytes_used);
 		if (rc < 0) {
 			CAM_ERR(CAM_ISP,
-				"Failed cmd_update, base_idx=%d, bytes_used=%u, res_id_out=0x%X",
+				"Failed cmd_update, base_idx=%d, bytes_used=%u, res_id_out=0x%x",
 				blob_info->base_info->idx,
 				bytes_used,
-				ubwc_plane_cfg->port_type);
+				res_id_out);
 			goto end;
 		}
 
@@ -5045,9 +4630,8 @@ static int cam_isp_blob_hfr_update(
 			&bytes_used);
 		if (rc < 0) {
 			CAM_ERR(CAM_ISP,
-				"Failed cmd_update, base_idx=%d, rc=%d, res_id_out:0x%X",
-				blob_info->base_info->idx, bytes_used,
-				port_hfr_config->resource_type);
+				"Failed cmd_update, base_idx=%d, rc=%d",
+				blob_info->base_info->idx, bytes_used);
 			return rc;
 		}
 
@@ -5185,36 +4769,29 @@ static int cam_isp_blob_core_cfg_update(
 	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_src, list) {
 		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
 			clk_rate = 0;
-			if (!hw_mgr_res->hw_res[i])
+			if (!hw_mgr_res->hw_res[i] ||
+				hw_mgr_res->res_id != CAM_ISP_HW_VFE_IN_CAMIF)
 				continue;
 
-			if ((hw_mgr_res->res_id ==
-				CAM_ISP_HW_VFE_IN_CAMIF) ||
-				(hw_mgr_res->res_id ==
-				CAM_ISP_HW_VFE_IN_PDLIB)) {
-				hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-				if (hw_intf && hw_intf->hw_ops.process_cmd) {
-					vfe_core_config.node_res =
-						hw_mgr_res->hw_res[i];
-
-					memcpy(&vfe_core_config.core_config,
-						core_config,
-						sizeof(
-						struct cam_isp_core_config));
-
-					rc = hw_intf->hw_ops.process_cmd(
-						hw_intf->hw_priv,
-						CAM_ISP_HW_CMD_CORE_CONFIG,
-						&vfe_core_config,
-						sizeof(
-						struct cam_vfe_core_config_args)
-						);
-					if (rc)
-						CAM_ERR(CAM_ISP,
-						"Core cfg parse fail");
-				} else {
-					CAM_WARN(CAM_ISP, "NULL hw_intf!");
-				}
+			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
+			if (hw_intf && hw_intf->hw_ops.process_cmd) {
+				vfe_core_config.node_res =
+					hw_mgr_res->hw_res[i];
+
+				memcpy(&vfe_core_config.core_config,
+					core_config,
+					sizeof(struct cam_isp_core_config));
+
+				rc = hw_intf->hw_ops.process_cmd(
+					hw_intf->hw_priv,
+					CAM_ISP_HW_CMD_CORE_CONFIG,
+					&vfe_core_config,
+					sizeof(
+					struct cam_vfe_core_config_args));
+				if (rc)
+					CAM_ERR(CAM_ISP, "Core cfg parse fail");
+			} else {
+				CAM_WARN(CAM_ISP, "NULL hw_intf!");
 			}
 		}
 	}
@@ -5332,76 +4909,6 @@ static int cam_isp_blob_clock_update(
 	return rc;
 }
 
-static int cam_isp_blob_sensor_config(
-	uint32_t                               blob_type,
-	struct cam_isp_generic_blob_info      *blob_info,
-	struct cam_isp_sensor_config          *dim_config,
-	struct cam_hw_prepare_update_args     *prepare)
-{
-	struct cam_ife_hw_mgr_ctx                   *ctx = NULL;
-	struct cam_ife_hw_mgr_res                   *hw_mgr_res;
-	struct cam_hw_intf                          *hw_intf;
-	struct cam_ife_sensor_dimension_update_args  update_args;
-	int                                          rc = -EINVAL, found = 0;
-	uint32_t                                     i, j;
-	struct cam_isp_sensor_dimension             *path_config;
-
-	ctx = prepare->ctxt_to_hw_map;
-
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_csid, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-			found = 1;
-			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-			if (hw_intf && hw_intf->hw_ops.process_cmd) {
-				path_config = &(dim_config->ipp_path);
-				update_args.ipp_path.width =
-					path_config->width;
-				update_args.ipp_path.height =
-					path_config->height;
-				update_args.ipp_path.measure_enabled =
-					path_config->measure_enabled;
-				path_config = &(dim_config->ppp_path);
-				update_args.ppp_path.width =
-					path_config->width;
-				update_args.ppp_path.height =
-					path_config->height;
-				update_args.ppp_path.measure_enabled =
-					path_config->measure_enabled;
-				for (j = 0; j < CAM_IFE_RDI_NUM_MAX; j++) {
-					path_config =
-						&(dim_config->rdi_path[j]);
-					update_args.rdi_path[j].width =
-						path_config->width;
-					update_args.rdi_path[j].height =
-						path_config->height;
-				update_args.rdi_path[j].measure_enabled =
-						path_config->measure_enabled;
-				}
-				rc = hw_intf->hw_ops.process_cmd(
-					hw_intf->hw_priv,
-					CAM_IFE_CSID_SET_SENSOR_DIMENSION_CFG,
-					&update_args,
-					sizeof(
-					struct
-					cam_ife_sensor_dimension_update_args)
-					);
-				if (rc) {
-					CAM_ERR(CAM_ISP,
-						"Dimension Update failed");
-					break;
-				}
-			} else
-				CAM_ERR(CAM_ISP, "hw_intf is NULL");
-		}
-		if (found)
-			break;
-	}
-
-	return rc;
-}
-
 static int cam_isp_blob_vfe_out_update(
 	uint32_t                               blob_type,
 	struct cam_isp_generic_blob_info      *blob_info,
@@ -5497,51 +5004,6 @@ static int cam_isp_blob_vfe_out_update(
 	return rc;
 }
 
-static int cam_isp_blob_csid_config_update(
-	uint32_t                               blob_type,
-	struct cam_isp_generic_blob_info      *blob_info,
-	struct cam_isp_csid_epd_config        *epd_config,
-	struct cam_hw_prepare_update_args     *prepare)
-{
-	struct cam_ife_hw_mgr_ctx                   *ctx = NULL;
-	struct cam_ife_hw_mgr_res                   *hw_mgr_res;
-	struct cam_hw_intf                          *hw_intf;
-	struct cam_ife_csid_epd_update_args         epd_update_args;
-	int                                         rc = -EINVAL;
-	uint32_t                                    i = 0;
-
-	ctx = prepare->ctxt_to_hw_map;
-
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_csid, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-
-			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-			if (hw_intf && hw_intf->hw_ops.process_cmd) {
-				epd_update_args.epd_supported =
-					epd_config->is_epd_supported;
-
-				rc = hw_intf->hw_ops.process_cmd(
-					hw_intf->hw_priv,
-					CAM_IFE_CSID_SET_CONFIG,
-					&epd_update_args,
-					sizeof(
-					struct cam_ife_csid_epd_update_args)
-					);
-				if (rc)
-					CAM_ERR(CAM_ISP,
-						"Failed to epd config:%d",
-						epd_config->is_epd_supported);
-			} else {
-				CAM_WARN(CAM_ISP, "NULL hw_intf!");
-			}
-
-		}
-	}
-
-	return rc;
-}
 static int cam_isp_packet_generic_blob_handler(void *user_data,
 	uint32_t blob_type, uint32_t blob_size, uint8_t *blob_data)
 {
@@ -5556,6 +5018,12 @@ static int cam_isp_packet_generic_blob_handler(void *user_data,
 		return -EINVAL;
 	}
 
+	if (blob_type >= CAM_ISP_GENERIC_BLOB_TYPE_MAX) {
+		CAM_ERR(CAM_ISP, "Invalid Blob Type %d Max %d", blob_type,
+			CAM_ISP_GENERIC_BLOB_TYPE_MAX);
+		return -EINVAL;
+	}
+
 	prepare = blob_info->prepare;
 	if (!prepare || !prepare->ctxt_to_hw_map) {
 		CAM_ERR(CAM_ISP, "Failed. prepare is NULL, blob_type %d",
@@ -5731,8 +5199,7 @@ static int cam_isp_packet_generic_blob_handler(void *user_data,
 
 		bw_config = (struct cam_isp_bw_config_v2 *)blob_data;
 
-		if ((bw_config->num_paths > CAM_ISP_MAX_PER_PATH_VOTES) ||
-			!bw_config->num_paths) {
+		if (bw_config->num_paths > CAM_ISP_MAX_PER_PATH_VOTES) {
 			CAM_ERR(CAM_ISP, "Invalid num paths %d",
 				bw_config->num_paths);
 			return -EINVAL;
@@ -6006,43 +5473,7 @@ static int cam_isp_packet_generic_blob_handler(void *user_data,
 			CAM_ERR(CAM_ISP, "VFE out update failed rc: %d", rc);
 	}
 		break;
-	case CAM_ISP_GENERIC_BLOB_TYPE_CSID_CONFIG: {
-		struct cam_isp_csid_epd_config *epd_config;
-
-		if (blob_size < sizeof(struct cam_isp_csid_epd_config)) {
-			CAM_ERR(CAM_ISP,
-				"Invalid epd config blob size %u expected %u",
-				blob_size,
-				sizeof(struct cam_isp_csid_epd_config));
-			return -EINVAL;
-		}
-		epd_config = (struct cam_isp_csid_epd_config *)blob_data;
-		rc = cam_isp_blob_csid_config_update(blob_type, blob_info,
-			epd_config, prepare);
-		if (rc)
-			CAM_ERR(CAM_ISP, "CSID Config failed rc: %d", rc);
-	}
-		break;
-	case CAM_ISP_GENERIC_BLOB_TYPE_SENSOR_DIMENSION_CONFIG: {
-		struct cam_isp_sensor_config *csid_dim_config;
-
-		if (blob_size < sizeof(struct cam_isp_sensor_config)) {
-			CAM_ERR(CAM_ISP, "Invalid blob size %zu expected %zu",
-				blob_size,
-				sizeof(struct cam_isp_sensor_config));
-			return -EINVAL;
-		}
-
-		csid_dim_config =
-			(struct cam_isp_sensor_config *)blob_data;
 
-		rc = cam_isp_blob_sensor_config(blob_type, blob_info,
-			csid_dim_config, prepare);
-		if (rc)
-			CAM_ERR(CAM_ISP,
-				"Sensor Dimension Update Failed rc: %d", rc);
-	}
-		break;
 	default:
 		CAM_WARN(CAM_ISP, "Invalid blob type %d", blob_type);
 		break;
@@ -6051,58 +5482,6 @@ static int cam_isp_packet_generic_blob_handler(void *user_data,
 	return rc;
 }
 
-static int cam_ife_mgr_util_insert_frame_header(
-	struct cam_kmd_buf_info *kmd_buf,
-	struct cam_isp_prepare_hw_update_data *prepare_hw_data)
-{
-	int mmu_hdl = -1, rc = 0;
-	dma_addr_t iova_addr;
-	uint32_t frame_header_iova, padded_bytes = 0;
-	size_t len;
-	struct cam_ife_hw_mgr *hw_mgr = &g_ife_hw_mgr;
-
-	mmu_hdl = cam_mem_is_secure_buf(
-			kmd_buf->handle) ?
-			hw_mgr->mgr_common.img_iommu_hdl_secure :
-			hw_mgr->mgr_common.img_iommu_hdl;
-
-	rc = cam_mem_get_io_buf(kmd_buf->handle, mmu_hdl,
-		&iova_addr, &len);
-	if (rc) {
-		CAM_ERR(CAM_ISP,
-			"Failed to get io addr for handle = %d for mmu_hdl = %u",
-			kmd_buf->handle, mmu_hdl);
-		return rc;
-	}
-
-	frame_header_iova = (uint32_t)iova_addr;
-	frame_header_iova += kmd_buf->offset;
-
-	/* frame header address needs to be 16 byte aligned */
-	if (frame_header_iova % 16) {
-		padded_bytes = (uint32_t)(16 - (frame_header_iova % 16));
-		iova_addr += padded_bytes;
-	}
-
-	prepare_hw_data->frame_header_iova = frame_header_iova;
-
-	/* update the padding if any for the cpu addr as well */
-	prepare_hw_data->frame_header_cpu_addr = kmd_buf->cpu_addr +
-			(padded_bytes / 4);
-
-	CAM_DBG(CAM_ISP,
-		"Frame Header iova_addr: %pK cpu_addr: %pK padded_bytes: %llu",
-		prepare_hw_data->frame_header_iova,
-		prepare_hw_data->frame_header_cpu_addr,
-		padded_bytes);
-
-	/* Reserve memory for frame header */
-	kmd_buf->used_bytes += 128;
-	kmd_buf->offset += kmd_buf->used_bytes;
-
-	return rc;
-}
-
 static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 	void *prepare_hw_update_args)
 {
@@ -6114,9 +5493,7 @@ static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 	struct cam_kmd_buf_info                  kmd_buf;
 	uint32_t                                 i;
 	bool                                     fill_fence = true;
-	bool                                     frame_header_enable = false;
 	struct cam_isp_prepare_hw_update_data   *prepare_hw_data;
-	struct cam_isp_frame_header_info         frame_header_info;
 
 	if (!hw_mgr_priv || !prepare_hw_update_args) {
 		CAM_ERR(CAM_ISP, "Invalid args");
@@ -6143,15 +5520,6 @@ static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 	if (rc)
 		return rc;
 
-	if (ctx->use_frame_header_ts) {
-		rc = cam_ife_mgr_util_insert_frame_header(&kmd_buf,
-			prepare_hw_data);
-		if (rc)
-			return rc;
-
-		frame_header_enable = true;
-	}
-
 	rc = cam_packet_util_process_patches(prepare->packet,
 		hw_mgr->mgr_common.cmd_iommu_hdl,
 		hw_mgr->mgr_common.cmd_iommu_hdl_secure);
@@ -6200,23 +5568,13 @@ static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 			}
 		}
 
-		memset(&frame_header_info, 0,
-			sizeof(struct cam_isp_frame_header_info));
-		if (frame_header_enable) {
-			frame_header_info.frame_header_enable = true;
-			frame_header_info.frame_header_iova_addr =
-				prepare_hw_data->frame_header_iova;
-		}
-
 		/* get IO buffers */
-		rc = cam_isp_add_io_buffers(
-			hw_mgr->mgr_common.img_iommu_hdl,
+		rc = cam_isp_add_io_buffers(hw_mgr->mgr_common.img_iommu_hdl,
 			hw_mgr->mgr_common.img_iommu_hdl_secure,
 			prepare, ctx->base[i].idx,
 			&kmd_buf, ctx->res_list_ife_out,
 			&ctx->res_list_ife_in_rd,
-			CAM_IFE_HW_OUT_RES_MAX, fill_fence,
-			&frame_header_info);
+			CAM_IFE_HW_OUT_RES_MAX, fill_fence);
 
 		if (rc) {
 			CAM_ERR(CAM_ISP,
@@ -6228,29 +5586,6 @@ static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 		/* fence map table entries need to fill only once in the loop */
 		if (fill_fence)
 			fill_fence = false;
-
-		if (frame_header_info.frame_header_res_id &&
-			frame_header_enable) {
-			frame_header_enable = false;
-			prepare_hw_data->frame_header_res_id =
-				frame_header_info.frame_header_res_id;
-
-			CAM_DBG(CAM_ISP,
-				"Frame header enabled for res_id 0x%x cpu_addr %pK",
-				prepare_hw_data->frame_header_res_id,
-				prepare_hw_data->frame_header_cpu_addr);
-		}
-	}
-
-	/* add go_cmd for offline context */
-	if (prepare->num_out_map_entries && prepare->num_in_map_entries &&
-		ctx->is_offline) {
-		rc = cam_isp_add_go_cmd(prepare, &ctx->res_list_ife_in_rd,
-			ctx->base[i].idx, &kmd_buf);
-		if (rc)
-			CAM_ERR(CAM_ISP,
-				"Add GO_CMD faled i: %d, idx: %d, rc: %d",
-				i, ctx->base[i].idx, rc);
 	}
 
 	/*
@@ -6262,24 +5597,13 @@ static int cam_ife_mgr_prepare_hw_update(void *hw_mgr_priv,
 	if (((prepare->packet->header.op_code + 1) & 0xF) ==
 		CAM_ISP_PACKET_INIT_DEV) {
 		prepare_hw_data->packet_opcode_type = CAM_ISP_PACKET_INIT_DEV;
-
-		if ((!prepare->num_reg_dump_buf) || (prepare->num_reg_dump_buf >
-			CAM_REG_DUMP_MAX_BUF_ENTRIES))
-			goto end;
-
-		if (!ctx->num_reg_dump_buf) {
+		if ((prepare->num_reg_dump_buf) && (prepare->num_reg_dump_buf <
+			CAM_REG_DUMP_MAX_BUF_ENTRIES)) {
 			ctx->num_reg_dump_buf = prepare->num_reg_dump_buf;
 			memcpy(ctx->reg_dump_buf_desc,
 				prepare->reg_dump_buf_desc,
 				sizeof(struct cam_cmd_buf_desc) *
 				prepare->num_reg_dump_buf);
-		} else {
-			prepare_hw_data->num_reg_dump_buf =
-				prepare->num_reg_dump_buf;
-			memcpy(prepare_hw_data->reg_dump_buf_desc,
-				prepare->reg_dump_buf_desc,
-				sizeof(struct cam_cmd_buf_desc) *
-				prepare_hw_data->num_reg_dump_buf);
 		}
 
 		goto end;
@@ -6450,15 +5774,12 @@ static void cam_ife_mgr_print_io_bufs(struct cam_packet *packet,
 
 static int cam_ife_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 {
-	int i, rc = 0;
+	int rc = 0;
 	struct cam_hw_cmd_args *hw_cmd_args = cmd_args;
 	struct cam_ife_hw_mgr  *hw_mgr = hw_mgr_priv;
 	struct cam_ife_hw_mgr_ctx *ctx = (struct cam_ife_hw_mgr_ctx *)
 		hw_cmd_args->ctxt_to_hw_map;
-	struct cam_isp_hw_cmd_args      *isp_hw_cmd_args = NULL;
-	struct cam_packet               *packet;
-	struct cam_isp_hw_event_info     event_info;
-	unsigned long rem_jiffies = 0;
+	struct cam_isp_hw_cmd_args *isp_hw_cmd_args = NULL;
 
 	if (!hw_mgr_priv || !cmd_args) {
 		CAM_ERR(CAM_ISP, "Invalid arguments");
@@ -6492,31 +5813,13 @@ static int cam_ife_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 				isp_hw_cmd_args->u.sof_irq_enable);
 			break;
 		case CAM_ISP_HW_MGR_CMD_CTX_TYPE:
-			if (ctx->is_fe_enabled && ctx->is_offline)
-				isp_hw_cmd_args->u.ctx_type =
-					CAM_ISP_CTX_OFFLINE;
-			else if (ctx->is_fe_enabled && !ctx->is_offline)
+			if (ctx->is_fe_enable)
 				isp_hw_cmd_args->u.ctx_type = CAM_ISP_CTX_FS2;
 			else if (ctx->is_rdi_only_context)
 				isp_hw_cmd_args->u.ctx_type = CAM_ISP_CTX_RDI;
 			else
 				isp_hw_cmd_args->u.ctx_type = CAM_ISP_CTX_PIX;
 			break;
-		case CAM_ISP_HW_MGR_GET_PACKET_OPCODE:
-			packet = (struct cam_packet *)
-				isp_hw_cmd_args->cmd_data;
-			if (((packet->header.op_code + 1) & 0xF) ==
-				CAM_ISP_PACKET_INIT_DEV)
-				isp_hw_cmd_args->u.packet_op_code =
-				CAM_ISP_PACKET_INIT_DEV;
-			else
-				isp_hw_cmd_args->u.packet_op_code =
-				CAM_ISP_PACKET_UPDATE_DEV;
-			break;
-		case CAM_ISP_HW_MGR_GET_LAST_CDM_DONE:
-			isp_hw_cmd_args->u.last_cdm_done =
-				ctx->last_cdm_done_req;
-			break;
 		default:
 			CAM_ERR(CAM_ISP, "Invalid HW mgr command:0x%x",
 				hw_cmd_args->cmd_type);
@@ -6531,32 +5834,25 @@ static int cam_ife_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 			hw_mgr->mgr_common.img_iommu_hdl_secure,
 			hw_cmd_args->u.pf_args.buf_info,
 			hw_cmd_args->u.pf_args.mem_found);
-		event_info.err_type = CAM_ISP_HW_ERROR_BUSIF_OVERFLOW;
-		event_info.res_type = CAM_ISP_RESOURCE_VFE_OUT;
-		event_info.hw_idx = 0;
-		for (i = 0; i < CAM_IFE_HW_OUT_RES_MAX; i++) {
-			event_info.res_id =
-				CAM_ISP_IFE_OUT_RES_BASE + (i & 0xFF);
-			cam_ife_hw_mgr_handle_hw_dump_bus_info(ctx,
-				&event_info);
-		}
 		break;
 	case CAM_HW_MGR_CMD_REG_DUMP_ON_FLUSH:
 		if (ctx->last_dump_flush_req_id == ctx->applied_req_id)
 			return 0;
 
-		rem_jiffies = wait_for_completion_timeout(
+		rc = wait_for_completion_timeout(
 			&ctx->config_done_complete,
 			msecs_to_jiffies(30));
-		if (rem_jiffies == 0)
+		if (rc <= 0) {
 			CAM_ERR(CAM_ISP,
-				"config done completion timeout, Reg dump will be unreliable ctx_index %d",
-				ctx->ctx_index);
+				"config done completion timeout, Reg dump will be unreliable rc=%d ctx_index %d",
+				rc, ctx->ctx_index);
+			rc = 0;
+		}
 
 		ctx->last_dump_flush_req_id = ctx->applied_req_id;
 		rc = cam_ife_mgr_handle_reg_dump(ctx, ctx->reg_dump_buf_desc,
 			ctx->num_reg_dump_buf,
-			CAM_ISP_PACKET_META_REG_DUMP_ON_FLUSH, NULL, false);
+			CAM_ISP_PACKET_META_REG_DUMP_ON_FLUSH);
 		if (rc) {
 			CAM_ERR(CAM_ISP,
 				"Reg dump on flush failed req id: %llu rc: %d",
@@ -6572,7 +5868,7 @@ static int cam_ife_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 		ctx->last_dump_err_req_id = ctx->applied_req_id;
 		rc = cam_ife_mgr_handle_reg_dump(ctx, ctx->reg_dump_buf_desc,
 			ctx->num_reg_dump_buf,
-			CAM_ISP_PACKET_META_REG_DUMP_ON_ERROR, NULL, false);
+			CAM_ISP_PACKET_META_REG_DUMP_ON_ERROR);
 		if (rc) {
 			CAM_ERR(CAM_ISP,
 				"Reg dump on error failed req id: %llu rc: %d",
@@ -6591,166 +5887,6 @@ static int cam_ife_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 	return rc;
 }
 
-static int cam_ife_mgr_user_dump_hw(
-		struct cam_ife_hw_mgr_ctx *ife_ctx,
-		struct cam_hw_dump_args *dump_args)
-{
-	int rc = 0;
-	struct cam_hw_soc_dump_args soc_dump_args;
-
-	if (!ife_ctx || !dump_args) {
-		CAM_ERR(CAM_ISP, "Invalid parameters %pK %pK",
-			ife_ctx, dump_args);
-		rc = -EINVAL;
-		goto end;
-	}
-	soc_dump_args.buf_handle = dump_args->buf_handle;
-	soc_dump_args.request_id = dump_args->request_id;
-	soc_dump_args.offset = dump_args->offset;
-
-	rc = cam_ife_mgr_handle_reg_dump(ife_ctx,
-		ife_ctx->reg_dump_buf_desc,
-		ife_ctx->num_reg_dump_buf,
-		CAM_ISP_PACKET_META_REG_DUMP_ON_ERROR,
-		&soc_dump_args,
-		true);
-	if (rc) {
-		CAM_ERR(CAM_ISP,
-			"Dump failed req: %lld handle %u offset %u",
-			dump_args->request_id,
-			dump_args->buf_handle,
-			dump_args->offset);
-		goto end;
-	}
-	dump_args->offset = soc_dump_args.offset;
-end:
-	return rc;
-}
-
-static int cam_ife_mgr_dump(void *hw_mgr_priv, void *args)
-{
-	struct cam_isp_hw_dump_args isp_hw_dump_args;
-	struct cam_hw_dump_args *dump_args = (struct cam_hw_dump_args *)args;
-	struct cam_ife_hw_mgr_res            *hw_mgr_res;
-	struct cam_hw_intf                   *hw_intf;
-	struct cam_ife_hw_mgr_ctx *ife_ctx = (struct cam_ife_hw_mgr_ctx *)
-						dump_args->ctxt_to_hw_map;
-	int i;
-	int rc = 0;
-
-	/* for some targets, information about the IFE registers to be dumped
-	 * is already submitted with the hw manager. In this case, we
-	 * can dump just the related registers and skip going to core files.
-	 */
-	if (ife_ctx->num_reg_dump_buf) {
-		cam_ife_mgr_user_dump_hw(ife_ctx, dump_args);
-		goto end;
-	}
-
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&isp_hw_dump_args.cpu_addr,
-		&isp_hw_dump_args.buf_len);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		return rc;
-	}
-
-	isp_hw_dump_args.offset = dump_args->offset;
-	isp_hw_dump_args.req_id = dump_args->request_id;
-
-	list_for_each_entry(hw_mgr_res, &ife_ctx->res_list_ife_csid, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-			switch (hw_mgr_res->hw_res[i]->res_id) {
-			case CAM_IFE_PIX_PATH_RES_RDI_0:
-			case CAM_IFE_PIX_PATH_RES_RDI_1:
-			case CAM_IFE_PIX_PATH_RES_RDI_2:
-			case CAM_IFE_PIX_PATH_RES_RDI_3:
-				if (ife_ctx->is_rdi_only_context &&
-					hw_intf->hw_ops.process_cmd) {
-					rc = hw_intf->hw_ops.process_cmd(
-						hw_intf->hw_priv,
-						CAM_ISP_HW_CMD_DUMP_HW,
-						&isp_hw_dump_args,
-						sizeof(struct
-						    cam_isp_hw_dump_args));
-				}
-				break;
-			case CAM_IFE_PIX_PATH_RES_IPP:
-				if (hw_intf->hw_ops.process_cmd) {
-					rc = hw_intf->hw_ops.process_cmd(
-						hw_intf->hw_priv,
-						CAM_ISP_HW_CMD_DUMP_HW,
-						&isp_hw_dump_args,
-						sizeof(struct
-						    cam_isp_hw_dump_args));
-				}
-				break;
-			default:
-				CAM_DBG(CAM_ISP, "not a valid res %d",
-				hw_mgr_res->res_id);
-				break;
-			}
-		}
-	}
-
-	list_for_each_entry(hw_mgr_res, &ife_ctx->res_list_ife_src, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-			switch (hw_mgr_res->res_id) {
-			case CAM_ISP_HW_VFE_IN_RDI0:
-			case CAM_ISP_HW_VFE_IN_RDI1:
-			case CAM_ISP_HW_VFE_IN_RDI2:
-			case CAM_ISP_HW_VFE_IN_RDI3:
-				if (ife_ctx->is_rdi_only_context &&
-					hw_intf->hw_ops.process_cmd) {
-					rc = hw_intf->hw_ops.process_cmd(
-						hw_intf->hw_priv,
-						CAM_ISP_HW_CMD_DUMP_HW,
-						&isp_hw_dump_args,
-						sizeof(struct
-						    cam_isp_hw_dump_args));
-				}
-				break;
-			case CAM_ISP_HW_VFE_IN_CAMIF:
-				if (hw_intf->hw_ops.process_cmd) {
-					rc = hw_intf->hw_ops.process_cmd(
-						hw_intf->hw_priv,
-						CAM_ISP_HW_CMD_DUMP_HW,
-						&isp_hw_dump_args,
-						sizeof(struct
-						    cam_isp_hw_dump_args));
-				}
-				break;
-			default:
-				CAM_DBG(CAM_ISP, "not a valid res %d",
-					hw_mgr_res->res_id);
-				break;
-			}
-		}
-	}
-	dump_args->offset = isp_hw_dump_args.offset;
-end:
-	CAM_DBG(CAM_ISP, "offset %u", dump_args->offset);
-	return rc;
-}
-
-static inline void cam_ife_hw_mgr_get_offline_sof_timestamp(
-	uint64_t                             *timestamp,
-	uint64_t                             *boot_time)
-{
-	struct timespec64                     ts;
-
-	get_monotonic_boottime64(&ts);
-	*timestamp = (uint64_t)((ts.tv_sec * 1000000000) + ts.tv_nsec);
-	*boot_time = *timestamp;
-}
-
 static int cam_ife_mgr_cmd_get_sof_timestamp(
 	struct cam_ife_hw_mgr_ctx            *ife_ctx,
 	uint64_t                             *time_stamp,
@@ -6846,9 +5982,6 @@ static int cam_ife_mgr_process_recovery_cb(void *priv, void *data)
 			}
 		}
 
-		if (!g_ife_hw_mgr.debug_cfg.enable_recovery)
-			break;
-
 		CAM_DBG(CAM_ISP, "RESET: CSID PATH");
 		for (i = 0; i < recovery_data->no_of_context; i++) {
 			ctx = recovery_data->affected_ctx[i];
@@ -7021,18 +6154,6 @@ static int  cam_ife_hw_mgr_find_affected_ctx(
 			affected_core, CAM_IFE_HW_NUM_MAX))
 			continue;
 
-		if (error_event_data->error_type ==
-			CAM_ISP_HW_ERROR_CSID_FATAL) {
-			CAM_DBG(CAM_ISP, "CSID recovery");
-			goto skip_overflow;
-		}
-
-		if (atomic_read(&ife_hwr_mgr_ctx->overflow_pending)) {
-			CAM_INFO(CAM_ISP, "CTX:%d already error reported",
-				ife_hwr_mgr_ctx->ctx_index);
-			continue;
-		}
-skip_overflow:
 		atomic_set(&ife_hwr_mgr_ctx->overflow_pending, 1);
 		notify_err_cb = ife_hwr_mgr_ctx->common.event_cb[event_type];
 
@@ -7048,13 +6169,8 @@ static int  cam_ife_hw_mgr_find_affected_ctx(
 		 * In the call back function corresponding ISP context
 		 * will update CRM about fatal Error
 		 */
-		if (notify_err_cb) {
-			notify_err_cb(ife_hwr_mgr_ctx->common.cb_priv,
-				CAM_ISP_HW_EVENT_ERROR, error_event_data);
-		} else {
-			CAM_WARN(CAM_ISP, "Error call back is not set");
-			goto end;
-		}
+		notify_err_cb(ife_hwr_mgr_ctx->common.cb_priv,
+			CAM_ISP_HW_EVENT_ERROR, error_event_data);
 	}
 
 	/* fill the affected_core in recovery data */
@@ -7063,150 +6179,15 @@ static int  cam_ife_hw_mgr_find_affected_ctx(
 		CAM_DBG(CAM_ISP, "Vfe core %d is affected (%d)",
 			 i, recovery_data->affected_core[i]);
 	}
-end:
-	return 0;
-}
-
-static int cam_ife_hw_mgr_handle_csid_event(
-	struct cam_isp_hw_event_info *event_info)
-{
-	struct cam_isp_hw_error_event_data  error_event_data = {0};
-	struct cam_hw_event_recovery_data     recovery_data = {0};
-
-	/* this can be extended based on the types of error
-	 * received from CSID
-	 */
-	switch (event_info->err_type) {
-	case CAM_ISP_HW_ERROR_CSID_FATAL: {
-
-		if (!g_ife_hw_mgr.debug_cfg.enable_csid_recovery)
-			break;
 
-		error_event_data.error_type = event_info->err_type;
-		cam_ife_hw_mgr_find_affected_ctx(&error_event_data,
-			event_info->hw_idx,
-			&recovery_data);
-		break;
-	}
-	default:
-		break;
-	}
 	return 0;
 }
 
-static int cam_ife_hw_mgr_handle_hw_dump_bus_info(
-	void                                 *ctx,
-	void                                 *evt_info)
-{
-	struct cam_ife_hw_mgr_ctx     *ife_hw_mgr_ctx =
-		(struct cam_ife_hw_mgr_ctx *)ctx;
-	struct cam_isp_hw_event_info  *event_info =
-		(struct cam_isp_hw_event_info *)evt_info;
-	struct cam_ife_hw_mgr_res     *hw_mgr_res = NULL;
-	struct cam_hw_intf            *hw_intf;
-	uint32_t i, out_port_id;
-	int rc = 0;
-
-	out_port_id = event_info->res_id & 0xFF;
-	hw_mgr_res =
-		&ife_hw_mgr_ctx->res_list_ife_out[out_port_id];
-	for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-		if (!hw_mgr_res->hw_res[i])
-			continue;
-		hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-		if (hw_intf->hw_ops.process_cmd) {
-			rc = hw_intf->hw_ops.process_cmd(
-				hw_intf->hw_priv,
-				CAM_ISP_HW_CMD_DUMP_BUS_INFO,
-				(void *)event_info,
-				sizeof(struct cam_isp_hw_event_info));
-		}
-	}
-
-	return rc;
-}
-
-static int cam_ife_hw_mgr_handle_hw_dump_info(
-	void                                 *ctx,
-	void                                 *evt_info)
-{
-	struct cam_ife_hw_mgr_ctx     *ife_hw_mgr_ctx =
-		(struct cam_ife_hw_mgr_ctx *)ctx;
-	struct cam_isp_hw_event_info  *event_info =
-		(struct cam_isp_hw_event_info *)evt_info;
-	struct cam_ife_hw_mgr_res     *hw_mgr_res = NULL;
-	struct cam_isp_resource_node  *rsrc_node = NULL;
-	struct cam_hw_intf            *hw_intf;
-	uint32_t i, out_port_id;
-	uint64_t dummy_args;
-	int rc = 0;
-
-	list_for_each_entry(hw_mgr_res,
-		&ife_hw_mgr_ctx->res_list_ife_src, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-
-			rsrc_node = hw_mgr_res->hw_res[i];
-			if (rsrc_node->res_id ==
-				CAM_ISP_HW_VFE_IN_CAMIF) {
-				hw_intf = rsrc_node->hw_intf;
-				if (hw_intf &&
-					hw_intf->hw_ops.process_cmd)
-					rc = hw_intf->hw_ops.process_cmd(
-					hw_intf->hw_priv,
-					CAM_ISP_HW_CMD_CAMIF_DATA,
-					rsrc_node,
-					sizeof(struct cam_isp_resource_node));
-			}
-		}
-	}
-
-	list_for_each_entry(hw_mgr_res,
-		&ife_hw_mgr_ctx->res_list_ife_csid, list) {
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-			hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-			if (hw_intf->hw_ops.process_cmd) {
-				rc = hw_intf->hw_ops.process_cmd(
-					hw_intf->hw_priv,
-					CAM_ISP_HW_CMD_CSID_CLOCK_DUMP,
-					&dummy_args,
-					sizeof(uint64_t));
-				if (rc)
-					CAM_ERR(CAM_ISP,
-						"CSID Clock Dump failed");
-			}
-		}
-	}
-
-	out_port_id = event_info->res_id & 0xFF;
-	hw_mgr_res =
-		&ife_hw_mgr_ctx->res_list_ife_out[out_port_id];
-	for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-		if (!hw_mgr_res->hw_res[i])
-			continue;
-		hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-		if (hw_intf->hw_ops.process_cmd) {
-			rc = hw_intf->hw_ops.process_cmd(
-				hw_intf->hw_priv,
-				CAM_ISP_HW_CMD_DUMP_BUS_INFO,
-				(void *)event_info,
-				sizeof(struct cam_isp_hw_event_info));
-		}
-	}
-
-	return rc;
-}
-
 static int cam_ife_hw_mgr_handle_hw_err(
-	void                                *ctx,
 	void                                *evt_info)
 {
-	struct cam_ife_hw_mgr_ctx           *ife_hw_mgr_ctx;
 	struct cam_isp_hw_event_info        *event_info = evt_info;
-	uint32_t                             core_idx;
+	uint32_t core_idx;
 	struct cam_isp_hw_error_event_data   error_event_data = {0};
 	struct cam_hw_event_recovery_data    recovery_data = {0};
 	int                                  rc = -EINVAL;
@@ -7218,25 +6199,6 @@ static int cam_ife_hw_mgr_handle_hw_err(
 	else if (event_info->res_type == CAM_ISP_RESOURCE_VFE_OUT)
 		error_event_data.error_type = CAM_ISP_HW_ERROR_BUSIF_OVERFLOW;
 
-	spin_lock(&g_ife_hw_mgr.ctx_lock);
-	if (event_info->err_type == CAM_ISP_HW_ERROR_CSID_FATAL) {
-		rc = cam_ife_hw_mgr_handle_csid_event(event_info);
-		spin_unlock(&g_ife_hw_mgr.ctx_lock);
-		return rc;
-	}
-
-	if (ctx) {
-		ife_hw_mgr_ctx =
-			(struct cam_ife_hw_mgr_ctx *)ctx;
-		if (event_info->res_type ==
-			CAM_ISP_RESOURCE_VFE_IN &&
-			!ife_hw_mgr_ctx->is_rdi_only_context &&
-			event_info->res_id !=
-			CAM_ISP_HW_VFE_IN_CAMIF)
-			cam_ife_hw_mgr_handle_hw_dump_info(
-			ife_hw_mgr_ctx, event_info);
-	}
-
 	core_idx = event_info->hw_idx;
 
 	if (g_ife_hw_mgr.debug_cfg.enable_recovery)
@@ -7247,17 +6209,24 @@ static int cam_ife_hw_mgr_handle_hw_err(
 
 	rc = cam_ife_hw_mgr_find_affected_ctx(&error_event_data,
 		core_idx, &recovery_data);
-	if ((rc != 0) || !(recovery_data.no_of_context))
-		goto end;
 
-	if (event_info->err_type == CAM_VFE_IRQ_STATUS_VIOLATION)
-		recovery_data.error_type = CAM_ISP_HW_ERROR_VIOLATION;
-	else
-		recovery_data.error_type = CAM_ISP_HW_ERROR_OVERFLOW;
+	if (event_info->res_type == CAM_ISP_RESOURCE_VFE_OUT)
+		return rc;
+
+	if (g_ife_hw_mgr.debug_cfg.enable_recovery) {
+		CAM_DBG(CAM_ISP, "IFE Mgr recovery is enabled");
+
+		/* Trigger for recovery */
+		if (event_info->err_type == CAM_VFE_IRQ_STATUS_VIOLATION)
+			recovery_data.error_type = CAM_ISP_HW_ERROR_VIOLATION;
+		else
+			recovery_data.error_type = CAM_ISP_HW_ERROR_OVERFLOW;
+		cam_ife_hw_mgr_do_error_recovery(&recovery_data);
+	} else {
+		CAM_DBG(CAM_ISP, "recovery is not enabled");
+		rc = 0;
+	}
 
-	cam_ife_hw_mgr_do_error_recovery(&recovery_data);
-end:
-	spin_unlock(&g_ife_hw_mgr.ctx_lock);
 	return rc;
 }
 
@@ -7270,24 +6239,17 @@ static int cam_ife_hw_mgr_handle_hw_rup(
 	cam_hw_event_cb_func                     ife_hwr_irq_rup_cb;
 	struct cam_isp_hw_reg_update_event_data  rup_event_data;
 
-	if (!ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_REG_UPDATE]) {
-		CAM_ERR(CAM_ISP, "event_cb[HW_EVENT_REG_UPDATE] is null");
-		return 0;
-	}
-
-	if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
-		return 0;
-
 	ife_hwr_irq_rup_cb =
 		ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_REG_UPDATE];
 
 	switch (event_info->res_id) {
 	case CAM_ISP_HW_VFE_IN_CAMIF:
-		if ((ife_hw_mgr_ctx->is_dual) &&
-			(event_info->hw_idx !=
-			ife_hw_mgr_ctx->master_hw_idx))
-			break;
+		if (ife_hw_mgr_ctx->is_dual)
+			if (event_info->hw_idx != 1)
+				break;
 
+		if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+			break;
 		ife_hwr_irq_rup_cb(ife_hw_mgr_ctx->common.cb_priv,
 			CAM_ISP_HW_EVENT_REG_UPDATE, &rup_event_data);
 		break;
@@ -7298,13 +6260,14 @@ static int cam_ife_hw_mgr_handle_hw_rup(
 	case CAM_ISP_HW_VFE_IN_RDI3:
 		if (!ife_hw_mgr_ctx->is_rdi_only_context)
 			break;
+		if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+			break;
 		ife_hwr_irq_rup_cb(ife_hw_mgr_ctx->common.cb_priv,
 			CAM_ISP_HW_EVENT_REG_UPDATE, &rup_event_data);
 		break;
 
 	case CAM_ISP_HW_VFE_IN_PDLIB:
 	case CAM_ISP_HW_VFE_IN_LCR:
-	case CAM_ISP_HW_VFE_IN_RD:
 		break;
 	default:
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid res_id: %d",
@@ -7314,37 +6277,8 @@ static int cam_ife_hw_mgr_handle_hw_rup(
 
 	CAM_DBG(CAM_ISP, "RUP done for VFE:%d source %d", event_info->hw_idx,
 		event_info->res_id);
-	return 0;
-}
-
-static void cam_ife_mgr_ctx_irq_dump(struct cam_ife_hw_mgr_ctx *ctx)
-{
-	struct cam_ife_hw_mgr_res        *hw_mgr_res;
-	struct cam_hw_intf               *hw_intf;
-	struct cam_isp_hw_get_cmd_update  cmd_update;
-	int i = 0;
 
-	list_for_each_entry(hw_mgr_res, &ctx->res_list_ife_src, list) {
-		if (hw_mgr_res->res_type == CAM_IFE_HW_MGR_RES_UNINIT)
-			continue;
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-			switch (hw_mgr_res->hw_res[i]->res_id) {
-			case CAM_ISP_HW_VFE_IN_CAMIF:
-				hw_intf = hw_mgr_res->hw_res[i]->hw_intf;
-				cmd_update.res = hw_mgr_res->hw_res[i];
-				cmd_update.cmd_type =
-					CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP;
-				hw_intf->hw_ops.process_cmd(hw_intf->hw_priv,
-					CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP,
-					&cmd_update, sizeof(cmd_update));
-				break;
-			default:
-				break;
-			}
-		}
-	}
+	return 0;
 }
 
 static int cam_ife_hw_mgr_check_irq_for_dual_vfe(
@@ -7353,8 +6287,8 @@ static int cam_ife_hw_mgr_check_irq_for_dual_vfe(
 {
 	int32_t                               rc = -1;
 	uint32_t                             *event_cnt = NULL;
-	uint32_t                              master_hw_idx;
-	uint32_t                              slave_hw_idx;
+	uint32_t                              core_idx0 = 0;
+	uint32_t                              core_idx1 = 1;
 
 	if (!ife_hw_mgr_ctx->is_dual)
 		return 0;
@@ -7373,48 +6307,26 @@ static int cam_ife_hw_mgr_check_irq_for_dual_vfe(
 		return 0;
 	}
 
-	master_hw_idx = ife_hw_mgr_ctx->master_hw_idx;
-	slave_hw_idx =  ife_hw_mgr_ctx->slave_hw_idx;
-
-	if (event_cnt[master_hw_idx] == event_cnt[slave_hw_idx]) {
+	if (event_cnt[core_idx0] == event_cnt[core_idx1]) {
 
-		event_cnt[master_hw_idx] = 0;
-		event_cnt[slave_hw_idx] = 0;
+		event_cnt[core_idx0] = 0;
+		event_cnt[core_idx1] = 0;
 
 		rc = 0;
 		return rc;
 	}
 
-	if ((event_cnt[master_hw_idx] &&
-		((int)(event_cnt[master_hw_idx] - event_cnt[slave_hw_idx]) > 1
-		)) ||
-		(event_cnt[slave_hw_idx] &&
-		((int)(event_cnt[slave_hw_idx] - event_cnt[master_hw_idx]) > 1
-		))) {
+	if ((event_cnt[core_idx0] &&
+		(event_cnt[core_idx0] - event_cnt[core_idx1] > 1)) ||
+		(event_cnt[core_idx1] &&
+		(event_cnt[core_idx1] - event_cnt[core_idx0] > 1))) {
 
 		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"One of the VFE could not generate hw event %d master[%d] core_cnt %d slave[%d] core_cnt %d",
-			hw_event_type, master_hw_idx, event_cnt[master_hw_idx],
-			slave_hw_idx, event_cnt[slave_hw_idx]);
-
-		if (ife_hw_mgr_ctx->dual_ife_irq_mismatch_cnt > 10) {
-			rc = -1;
-			return rc;
-		}
-
-		if (event_cnt[master_hw_idx] >= 2) {
-			event_cnt[master_hw_idx]--;
-			ife_hw_mgr_ctx->dual_ife_irq_mismatch_cnt++;
-		}
-
-		if (event_cnt[slave_hw_idx] >= 2) {
-			event_cnt[slave_hw_idx]--;
-			 ife_hw_mgr_ctx->dual_ife_irq_mismatch_cnt++;
-		}
-
-		if (ife_hw_mgr_ctx->dual_ife_irq_mismatch_cnt == 1)
-			cam_ife_mgr_ctx_irq_dump(ife_hw_mgr_ctx);
-		rc = 0;
+			"One of the VFE could not generate hw event %d core_0_cnt %d core_1_cnt %d",
+			hw_event_type, event_cnt[core_idx0],
+			event_cnt[core_idx1]);
+		rc = -1;
+		return rc;
 	}
 
 	CAM_DBG(CAM_ISP, "Only one core_index has given hw event %d",
@@ -7433,14 +6345,6 @@ static int cam_ife_hw_mgr_handle_hw_epoch(
 	struct cam_isp_hw_epoch_event_data    epoch_done_event_data;
 	int                                   rc = 0;
 
-	if (!ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_EPOCH]) {
-		CAM_ERR(CAM_ISP, "event_cb[CAM_ISP_HW_EVENT_EPOCH] is null");
-		return 0;
-	}
-
-	if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
-		return 0;
-
 	ife_hw_irq_epoch_cb =
 		ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_EPOCH];
 
@@ -7450,8 +6354,8 @@ static int cam_ife_hw_mgr_handle_hw_epoch(
 		rc = cam_ife_hw_mgr_check_irq_for_dual_vfe(ife_hw_mgr_ctx,
 			CAM_ISP_HW_EVENT_EPOCH);
 		if (!rc) {
-			epoch_done_event_data.frame_id_meta =
-				event_info->reg_val;
+			if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+				break;
 			ife_hw_irq_epoch_cb(ife_hw_mgr_ctx->common.cb_priv,
 				CAM_ISP_HW_EVENT_EPOCH, &epoch_done_event_data);
 		}
@@ -7487,16 +6391,6 @@ static int cam_ife_hw_mgr_handle_hw_sof(
 	struct cam_isp_hw_sof_event_data      sof_done_event_data;
 	int                                   rc = 0;
 
-	if (!ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_SOF]) {
-		CAM_ERR(CAM_ISP, "event_cb[CAM_ISP_HW_EVENT_SOF] is null");
-		return 0;
-	}
-
-	if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
-		return 0;
-
-	memset(&sof_done_event_data, 0, sizeof(sof_done_event_data));
-
 	ife_hw_irq_sof_cb =
 		ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_SOF];
 
@@ -7507,19 +6401,12 @@ static int cam_ife_hw_mgr_handle_hw_sof(
 		rc = cam_ife_hw_mgr_check_irq_for_dual_vfe(ife_hw_mgr_ctx,
 			CAM_ISP_HW_EVENT_SOF);
 		if (!rc) {
-			if (ife_hw_mgr_ctx->is_offline)
-				cam_ife_hw_mgr_get_offline_sof_timestamp(
-					&sof_done_event_data.timestamp,
-					&sof_done_event_data.boot_time);
-			else
-				cam_ife_mgr_cmd_get_sof_timestamp(
-					ife_hw_mgr_ctx,
-					&sof_done_event_data.timestamp,
-					&sof_done_event_data.boot_time);
+			cam_ife_mgr_cmd_get_sof_timestamp(ife_hw_mgr_ctx,
+				&sof_done_event_data.timestamp,
+				&sof_done_event_data.boot_time);
 
-			/* if frame header is enabled reset qtimer ts */
-			if (ife_hw_mgr_ctx->use_frame_header_ts)
-				sof_done_event_data.timestamp = 0x0;
+			if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+				break;
 
 			ife_hw_irq_sof_cb(ife_hw_mgr_ctx->common.cb_priv,
 				CAM_ISP_HW_EVENT_SOF, &sof_done_event_data);
@@ -7535,6 +6422,8 @@ static int cam_ife_hw_mgr_handle_hw_sof(
 		cam_ife_mgr_cmd_get_sof_timestamp(ife_hw_mgr_ctx,
 			&sof_done_event_data.timestamp,
 			&sof_done_event_data.boot_time);
+		if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+			break;
 		ife_hw_irq_sof_cb(ife_hw_mgr_ctx->common.cb_priv,
 			CAM_ISP_HW_EVENT_SOF, &sof_done_event_data);
 		break;
@@ -7565,14 +6454,6 @@ static int cam_ife_hw_mgr_handle_hw_eof(
 	struct cam_isp_hw_eof_event_data      eof_done_event_data;
 	int                                   rc = 0;
 
-	if (!ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_EOF]) {
-		CAM_ERR(CAM_ISP, "event_cb[CAM_ISP_HW_EVENT_EOF] is null");
-		return 0;
-	}
-
-	if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
-		return  0;
-
 	ife_hw_irq_eof_cb =
 		ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_EOF];
 
@@ -7582,6 +6463,8 @@ static int cam_ife_hw_mgr_handle_hw_eof(
 		rc = cam_ife_hw_mgr_check_irq_for_dual_vfe(ife_hw_mgr_ctx,
 			CAM_ISP_HW_EVENT_EOF);
 		if (!rc) {
+			if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
+				break;
 			ife_hw_irq_eof_cb(ife_hw_mgr_ctx->common.cb_priv,
 				CAM_ISP_HW_EVENT_EOF, &eof_done_event_data);
 		}
@@ -7616,18 +6499,11 @@ static int cam_ife_hw_mgr_handle_hw_buf_done(
 	struct cam_isp_hw_done_event_data    buf_done_event_data = {0};
 	struct cam_isp_hw_event_info        *event_info = evt_info;
 
-	if (!ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_DONE]) {
-		CAM_ERR(CAM_ISP, "event_cb[CAM_ISP_HW_EVENT_DONE] is null");
-		return 0;
-	}
-
 	ife_hwr_irq_wm_done_cb =
 		ife_hw_mgr_ctx->common.event_cb[CAM_ISP_HW_EVENT_DONE];
 
 	buf_done_event_data.num_handles = 1;
 	buf_done_event_data.resource_handle[0] = event_info->res_id;
-	buf_done_event_data.last_consumed_addr[0] =
-		event_info->reg_val;
 
 	if (atomic_read(&ife_hw_mgr_ctx->overflow_pending))
 		return 0;
@@ -7638,9 +6514,8 @@ static int cam_ife_hw_mgr_handle_hw_buf_done(
 			CAM_ISP_HW_EVENT_DONE, &buf_done_event_data);
 	}
 
-	CAM_DBG(CAM_ISP,
-		"Buf done for VFE:%d res_id: 0x%x last consumed addr: 0x%x",
-		event_info->hw_idx, event_info->res_id, event_info->reg_val);
+	CAM_DBG(CAM_ISP, "Buf done for VFE:%d out_res->res_id: 0x%x",
+		event_info->hw_idx, event_info->res_id);
 
 	return 0;
 }
@@ -7683,7 +6558,7 @@ static int cam_ife_hw_mgr_event_handler(
 		break;
 
 	case CAM_ISP_HW_EVENT_ERROR:
-		rc = cam_ife_hw_mgr_handle_hw_err(priv, evt_info);
+		rc = cam_ife_hw_mgr_handle_hw_err(evt_info);
 		break;
 
 	default:
@@ -7794,14 +6669,6 @@ static int cam_ife_hw_mgr_debug_register(void)
 		goto err;
 	}
 
-	if (!debugfs_create_u32("enable_csid_recovery",
-		0644,
-		g_ife_hw_mgr.debug_cfg.dentry,
-		&g_ife_hw_mgr.debug_cfg.enable_csid_recovery)) {
-		CAM_ERR(CAM_ISP, "failed to create enable_csid_recovery");
-		goto err;
-	}
-
 	if (!debugfs_create_bool("enable_req_dump",
 		0644,
 		g_ife_hw_mgr.debug_cfg.dentry,
@@ -7826,14 +6693,6 @@ static int cam_ife_hw_mgr_debug_register(void)
 		goto err;
 	}
 
-	if (!debugfs_create_bool("disable_ubwc_comp",
-		0644,
-		g_ife_hw_mgr.debug_cfg.dentry,
-		&g_ife_hw_mgr.debug_cfg.disable_ubwc_comp)) {
-		CAM_ERR(CAM_ISP, "failed to create disable_ubwc_comp entry");
-		goto err;
-	}
-
 	g_ife_hw_mgr.debug_cfg.enable_recovery = 0;
 
 	return 0;
@@ -7843,16 +6702,10 @@ static int cam_ife_hw_mgr_debug_register(void)
 	return -ENOMEM;
 }
 
-static void cam_req_mgr_process_workq_cam_ife_worker(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 {
 	int rc = -EFAULT;
 	int i, j;
-	bool support_consumed_addr = false;
 	struct cam_iommu_handle cdm_handles;
 	struct cam_ife_hw_mgr_ctx *ctx_pool;
 	struct cam_ife_hw_mgr_res *res_list_ife_out;
@@ -7862,7 +6715,6 @@ int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 	memset(&g_ife_hw_mgr, 0, sizeof(g_ife_hw_mgr));
 
 	mutex_init(&g_ife_hw_mgr.ctx_mutex);
-	spin_lock_init(&g_ife_hw_mgr.ctx_lock);
 
 	if (CAM_IFE_HW_NUM_MAX != CAM_IFE_CSID_HW_NUM_MAX) {
 		CAM_ERR(CAM_ISP, "CSID num is different then IFE num");
@@ -7873,19 +6725,11 @@ int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 	for (i = 0, j = 0; i < CAM_IFE_HW_NUM_MAX; i++) {
 		rc = cam_vfe_hw_init(&g_ife_hw_mgr.ife_devices[i], i);
 		if (!rc) {
-			struct cam_hw_intf *ife_device =
-				g_ife_hw_mgr.ife_devices[i];
 			struct cam_hw_info *vfe_hw =
 				(struct cam_hw_info *)
-				ife_device->hw_priv;
+				g_ife_hw_mgr.ife_devices[i]->hw_priv;
 			struct cam_hw_soc_info *soc_info = &vfe_hw->soc_info;
 
-			if (j == 0)
-				ife_device->hw_ops.process_cmd(
-					vfe_hw,
-					CAM_ISP_HW_CMD_IS_CONSUMED_ADDR_SUPPORT,
-					&support_consumed_addr,
-					sizeof(support_consumed_addr));
 			j++;
 
 			g_ife_hw_mgr.cdm_reg_map[i] = &soc_info->reg_map[0];
@@ -7902,8 +6746,6 @@ int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 		return -EINVAL;
 	}
 
-	g_ife_hw_mgr.support_consumed_addr = support_consumed_addr;
-
 	/* fill csid hw intf information */
 	for (i = 0, j = 0; i < CAM_IFE_CSID_HW_NUM_MAX; i++) {
 		rc = cam_ife_csid_hw_init(&g_ife_hw_mgr.csid_devices[i], i);
@@ -8008,8 +6850,7 @@ int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 
 	/* Create Worker for ife_hw_mgr with 10 tasks */
 	rc = cam_req_mgr_workq_create("cam_ife_worker", 10,
-			&g_ife_hw_mgr.workq, CRM_WORKQ_USAGE_NON_IRQ, 0, false,
-			cam_req_mgr_process_workq_cam_ife_worker);
+			&g_ife_hw_mgr.workq, CRM_WORKQ_USAGE_NON_IRQ, 0);
 	if (rc < 0) {
 		CAM_ERR(CAM_ISP, "Unable to create worker");
 		goto end;
@@ -8028,7 +6869,6 @@ int cam_ife_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf, int *iommu_hdl)
 	hw_mgr_intf->hw_config = cam_ife_mgr_config_hw;
 	hw_mgr_intf->hw_cmd = cam_ife_mgr_cmd;
 	hw_mgr_intf->hw_reset = cam_ife_mgr_reset;
-	hw_mgr_intf->hw_dump = cam_ife_mgr_dump;
 
 	if (iommu_hdl)
 		*iommu_hdl = g_ife_hw_mgr.mgr_common.img_iommu_hdl;
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.h
index 7786027a0fae..7e6b91bab916 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_HW_MGR_H_
@@ -81,22 +81,18 @@ struct ctx_base_info {
  * @dentry:                    Debugfs entry
  * @csid_debug:                csid debug information
  * @enable_recovery:           enable recovery
- * @enable_csid_recovery:      enable csid recovery
  * @enable_diag_sensor_status: enable sensor diagnosis status
  * @enable_req_dump:           Enable request dump on HW errors
  * @per_req_reg_dump:          Enable per request reg dump
- * @disable_ubwc_comp:         Disable UBWC compression
  *
  */
 struct cam_ife_hw_mgr_debug {
 	struct dentry  *dentry;
 	uint64_t       csid_debug;
 	uint32_t       enable_recovery;
-	uint32_t       enable_csid_recovery;
 	uint32_t       camif_debug;
 	bool           enable_req_dump;
 	bool           per_req_reg_dump;
-	bool           disable_ubwc_comp;
 };
 
 /**
@@ -105,8 +101,6 @@ struct cam_ife_hw_mgr_debug {
  * @list:                   used by the ctx list.
  * @common:                 common acquired context data
  * @ctx_index:              acquired context id.
- * @master_hw_idx:          hw index for master core
- * @slave_hw_idx:           hw index for slave core
  * @hw_mgr:                 IFE hw mgr which owns this context
  * @ctx_in_use:             flag to tell whether context is active
  * @res_list_ife_in:        Starting resource(TPG,PHY0, PHY1...) Can only be
@@ -133,7 +127,6 @@ struct cam_ife_hw_mgr_debug {
  *                          context
  * @cdm_done                flag to indicate cdm has finished writing shadow
  *                          registers
- * @last_cdm_done_req:      Last cdm done request
  * @is_rdi_only_context     flag to specify the context has only rdi resource
  * @config_done_complete    indicator for configuration complete
  * @reg_dump_buf_desc:      cmd buffer descriptors for reg dump
@@ -142,23 +135,15 @@ struct cam_ife_hw_mgr_debug {
  * @last_dump_flush_req_id  Last req id for which reg dump on flush was called
  * @last_dump_err_req_id    Last req id for which reg dump on error was called
  * @init_done               indicate whether init hw is done
- * @is_fe_enabled           Indicate whether fetch engine\read path is enabled
+ * @is_fe_enable            indicate whether fetch engine\read path is enabled
  * @is_dual                 indicate whether context is in dual VFE mode
- * @custom_enabled          update the flag if context is connected to custom HW
- * @use_frame_header_ts     obtain qtimer ts using frame header
  * @ts                      captured timestamp when the ctx is acquired
- * @is_offline              Indicate whether context is for offline IFE
- * @dsp_enabled             Indicate whether dsp is enabled in this context
- * @dual_ife_irq_mismatch_cnt   irq mismatch count value per core, used for
- *                              dual VFE
  */
 struct cam_ife_hw_mgr_ctx {
 	struct list_head                list;
 	struct cam_isp_hw_mgr_ctx       common;
 
 	uint32_t                        ctx_index;
-	uint32_t                        master_hw_idx;
-	uint32_t                        slave_hw_idx;
 	struct cam_ife_hw_mgr          *hw_mgr;
 	uint32_t                        ctx_in_use;
 
@@ -186,7 +171,6 @@ struct cam_ife_hw_mgr_ctx {
 	uint32_t                        eof_cnt[CAM_IFE_HW_NUM_MAX];
 	atomic_t                        overflow_pending;
 	atomic_t                        cdm_done;
-	uint64_t                        last_cdm_done_req;
 	uint32_t                        is_rdi_only_context;
 	struct completion               config_done_complete;
 	struct cam_cmd_buf_desc         reg_dump_buf_desc[
@@ -196,14 +180,9 @@ struct cam_ife_hw_mgr_ctx {
 	uint64_t                        last_dump_flush_req_id;
 	uint64_t                        last_dump_err_req_id;
 	bool                            init_done;
-	bool                            is_fe_enabled;
+	bool                            is_fe_enable;
 	bool                            is_dual;
-	bool                            custom_enabled;
-	bool                            use_frame_header_ts;
 	struct timespec64               ts;
-	bool                            is_offline;
-	bool                            dsp_enabled;
-	uint32_t                        dual_ife_irq_mismatch_cnt;
 };
 
 /**
@@ -222,7 +201,6 @@ struct cam_ife_hw_mgr_ctx {
  * @ife_dev_caps           ife device capability per core
  * @work q                 work queue for IFE hw manager
  * @debug_cfg              debug configuration
- * @support_consumed_addr  indicate whether hw supports last consumed address
  */
 struct cam_ife_hw_mgr {
 	struct cam_isp_hw_mgr          mgr_common;
@@ -241,8 +219,6 @@ struct cam_ife_hw_mgr {
 	struct cam_vfe_hw_get_hw_cap   ife_dev_caps[CAM_IFE_HW_NUM_MAX];
 	struct cam_req_mgr_core_workq *workq;
 	struct cam_ife_hw_mgr_debug    debug_cfg;
-	spinlock_t                     ctx_lock;
-	bool                           support_consumed_addr;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
index 2f1ad4d82f46..86a14229915f 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/cam_isp_packet_parser.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <media/cam_defs.h>
@@ -140,14 +140,6 @@ static int cam_isp_update_dual_config(
 		}
 
 		hw_mgr_res = &res_list_isp_out[i];
-		if (!hw_mgr_res) {
-			CAM_ERR(CAM_ISP,
-				"Invalid isp out resource i %d num_out_res %d",
-				i, dual_config->num_ports);
-			rc = -EINVAL;
-			goto end;
-		}
-
 		for (j = 0; j < CAM_ISP_HW_SPLIT_MAX; j++) {
 			if (!hw_mgr_res->hw_res[j])
 				continue;
@@ -204,8 +196,8 @@ int cam_isp_add_cmd_buf_update(
 	uint32_t                            total_used_bytes = 0;
 
 	if (hw_mgr_res->res_type == CAM_IFE_HW_MGR_RES_UNINIT) {
-		CAM_ERR(CAM_ISP, "VFE out resource:0x%X type:%d not valid",
-			hw_mgr_res->res_id, hw_mgr_res->res_type);
+		CAM_ERR(CAM_ISP, "io res id:%d not valid",
+			hw_mgr_res->res_type);
 		return -EINVAL;
 	}
 
@@ -471,8 +463,7 @@ int cam_isp_add_io_buffers(
 	struct cam_ife_hw_mgr_res            *res_list_isp_out,
 	struct list_head                     *res_list_ife_in_rd,
 	uint32_t                              size_isp_out,
-	bool                                  fill_fence,
-	struct cam_isp_frame_header_info     *frame_header_info)
+	bool                                  fill_fence)
 {
 	int                                 rc = 0;
 	dma_addr_t                          io_addr[CAM_PACKET_MAX_PLANES];
@@ -488,9 +479,6 @@ int cam_isp_add_io_buffers(
 	uint32_t                            i, j, num_out_buf, num_in_buf;
 	uint32_t                            res_id_out, res_id_in, plane_id;
 	uint32_t                            io_cfg_used_bytes, num_ent;
-	uint32_t                           *image_buf_addr;
-	uint32_t                           *image_buf_offset;
-	uint64_t                            iova_addr;
 	size_t                              size;
 	int32_t                             hdl;
 	int                                 mmu_hdl;
@@ -691,25 +679,6 @@ int cam_isp_add_io_buffers(
 			wm_update.image_buf = io_addr;
 			wm_update.num_buf   = plane_id;
 			wm_update.io_cfg    = &io_cfg[i];
-			wm_update.frame_header = 0;
-			for (plane_id = 0; plane_id < CAM_PACKET_MAX_PLANES;
-				plane_id++)
-				wm_update.image_buf_offset[plane_id] = 0;
-
-			iova_addr = frame_header_info->frame_header_iova_addr;
-			if ((frame_header_info->frame_header_enable) &&
-				!(frame_header_info->frame_header_res_id)) {
-				wm_update.frame_header = iova_addr;
-				frame_header_info->frame_header_res_id =
-					res->res_id;
-				wm_update.local_id =
-					prepare->packet->header.request_id;
-				CAM_DBG(CAM_ISP,
-					"Frame header enabled for res: 0x%x iova: %pK",
-					frame_header_info->frame_header_res_id,
-					wm_update.frame_header);
-			}
-
 			update_buf.cmd.size = kmd_buf_remain_size;
 			update_buf.wm_update = &wm_update;
 
@@ -728,18 +697,6 @@ int cam_isp_add_io_buffers(
 				return rc;
 			}
 			io_cfg_used_bytes += update_buf.cmd.used_bytes;
-			image_buf_addr =
-				out_map_entries->image_buf_addr;
-			image_buf_offset =
-				wm_update.image_buf_offset;
-			if (j == CAM_ISP_HW_SPLIT_LEFT) {
-				for (plane_id = 0;
-					plane_id < CAM_PACKET_MAX_PLANES;
-					plane_id++)
-					image_buf_addr[plane_id] =
-						io_addr[plane_id] +
-						image_buf_offset[plane_id];
-			}
 		}
 		for (j = 0; j < CAM_ISP_HW_SPLIT_MAX &&
 			io_cfg[i].direction == CAM_BUF_INPUT; j++) {
@@ -952,7 +909,7 @@ int cam_isp_add_reg_update(
 				return rc;
 
 			CAM_DBG(CAM_ISP, "Reg update added for res %d hw_id %d",
-				res->res_type, res->hw_intf->hw_idx);
+				res->res_id, res->hw_intf->hw_idx);
 			reg_update_size += get_regup.cmd.used_bytes;
 		}
 	}
@@ -986,100 +943,3 @@ int cam_isp_add_reg_update(
 
 	return rc;
 }
-
-int cam_isp_add_go_cmd(
-	struct cam_hw_prepare_update_args    *prepare,
-	struct list_head                     *res_list_isp_rd,
-	uint32_t                              base_idx,
-	struct cam_kmd_buf_info              *kmd_buf_info)
-{
-	int rc = -EINVAL;
-	struct cam_isp_resource_node         *res;
-	struct cam_ife_hw_mgr_res            *hw_mgr_res;
-	struct cam_hw_update_entry           *hw_entry;
-	struct cam_isp_hw_get_cmd_update      get_regup;
-	uint32_t kmd_buf_remain_size, num_ent, i, reg_update_size;
-
-	hw_entry = prepare->hw_update_entries;
-	if (prepare->num_hw_update_entries + 1 >=
-		prepare->max_hw_update_entries) {
-		CAM_ERR(CAM_ISP, "Insufficient HW entries current: %d max: %d",
-			prepare->num_hw_update_entries,
-			prepare->max_hw_update_entries);
-		return -EINVAL;
-	}
-
-	reg_update_size = 0;
-	list_for_each_entry(hw_mgr_res, res_list_isp_rd, list) {
-		if (hw_mgr_res->res_type == CAM_IFE_HW_MGR_RES_UNINIT)
-			continue;
-
-		for (i = 0; i < CAM_ISP_HW_SPLIT_MAX; i++) {
-			if (!hw_mgr_res->hw_res[i])
-				continue;
-
-			res = hw_mgr_res->hw_res[i];
-			if (res->hw_intf->hw_idx != base_idx)
-				continue;
-
-			if (kmd_buf_info->size > (kmd_buf_info->used_bytes +
-				reg_update_size)) {
-				kmd_buf_remain_size =  kmd_buf_info->size -
-					(kmd_buf_info->used_bytes +
-					reg_update_size);
-			} else {
-				CAM_ERR(CAM_ISP, "no free mem %d %d %d",
-					base_idx, kmd_buf_info->size,
-					kmd_buf_info->used_bytes +
-					reg_update_size);
-				rc = -EINVAL;
-				return rc;
-			}
-
-			get_regup.cmd.cmd_buf_addr = kmd_buf_info->cpu_addr +
-				kmd_buf_info->used_bytes/4 +
-				reg_update_size/4;
-			get_regup.cmd.size = kmd_buf_remain_size;
-			get_regup.cmd_type = CAM_ISP_HW_CMD_FE_TRIGGER_CMD;
-			get_regup.res = res;
-
-			rc = res->process_cmd(res->res_priv,
-				CAM_ISP_HW_CMD_FE_TRIGGER_CMD, &get_regup,
-				sizeof(struct cam_isp_hw_get_cmd_update));
-			if (rc)
-				return rc;
-
-			CAM_DBG(CAM_ISP, "GO_CMD added for RD res %d hw_id %d",
-				res->res_type, res->hw_intf->hw_idx);
-			reg_update_size += get_regup.cmd.used_bytes;
-		}
-	}
-
-	if (reg_update_size) {
-		/* Update the HW entries */
-		num_ent = prepare->num_hw_update_entries;
-		prepare->hw_update_entries[num_ent].handle =
-					kmd_buf_info->handle;
-		prepare->hw_update_entries[num_ent].len = reg_update_size;
-		prepare->hw_update_entries[num_ent].offset =
-			kmd_buf_info->offset;
-
-		prepare->hw_update_entries[num_ent].flags =
-			CAM_ISP_IOCFG_BL;
-		CAM_DBG(CAM_ISP,
-			"num_ent=%d handle=0x%x, len=%u, offset=%u",
-			num_ent,
-			prepare->hw_update_entries[num_ent].handle,
-			prepare->hw_update_entries[num_ent].len,
-			prepare->hw_update_entries[num_ent].offset);
-		num_ent++;
-
-		kmd_buf_info->used_bytes += reg_update_size;
-		kmd_buf_info->offset     += reg_update_size;
-		prepare->num_hw_update_entries = num_ent;
-		rc = 0;
-	}
-
-	return rc;
-}
-
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/include/cam_isp_packet_parser.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/include/cam_isp_packet_parser.h
index 5813208a6421..c9bd4c4430e9 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/include/cam_isp_packet_parser.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/include/cam_isp_packet_parser.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_ISP_HW_PARSER_H_
@@ -34,19 +34,6 @@ struct cam_isp_generic_blob_info {
 	struct cam_kmd_buf_info               *kmd_buf_info;
 };
 
-/*
- * struct cam_isp_frame_header_info
- *
- * @frame_header_enable:    Enable frame header
- * @frame_header_iova_addr: frame header iova
- * @frame_header_res_id:    res id for which frame header is enabled
- */
-struct cam_isp_frame_header_info {
-	bool                     frame_header_enable;
-	uint64_t                 frame_header_iova_addr;
-	uint32_t                 frame_header_res_id;
-};
-
 /*
  * cam_isp_add_change_base()
  *
@@ -140,7 +127,7 @@ int cam_isp_add_command_buffers(
  * @res_list_ife_in_rd:    IFE /VFE in rd resource list
  * @size_isp_out:          Size of the res_list_isp_out array
  * @fill_fence:            If true, Fence map table will be filled
- * @frame_header_info:     Frame header related params
+ *
  * @return:                0 for success
  *                         -EINVAL for Fail
  */
@@ -153,8 +140,7 @@ int cam_isp_add_io_buffers(
 	struct cam_ife_hw_mgr_res            *res_list_isp_out,
 	struct list_head                     *res_list_ife_in_rd,
 	uint32_t                              size_isp_out,
-	bool                                  fill_fence,
-	struct cam_isp_frame_header_info     *frame_header_info);
+	bool                                  fill_fence);
 
 /*
  * cam_isp_add_reg_update()
@@ -176,23 +162,4 @@ int cam_isp_add_reg_update(
 	uint32_t                              base_idx,
 	struct cam_kmd_buf_info              *kmd_buf_info);
 
-/*
- * cam_isp_add_go_cmd()
- *
- * @brief                  Add go_cmd in the hw entries list for each rd source
- *
- * @prepare:               Contain the  packet and HW update variables
- * @res_list_isp_rd:       Resource list for BUS RD ports
- * @base_idx:              Base or dev index of the IFE/VFE HW instance
- * @kmd_buf_info:          Kmd buffer to store the change base command
- * @return:                0 for success
- *                         -EINVAL for Fail
- */
-int cam_isp_add_go_cmd(
-	struct cam_hw_prepare_update_args    *prepare,
-	struct list_head                     *res_list_isp_rd,
-	uint32_t                              base_idx,
-	struct cam_kmd_buf_info              *kmd_buf_info);
-
-
 #endif /*_CAM_ISP_HW_PARSER_H */
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller/cam_irq_controller.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller/cam_irq_controller.c
index 5763939fd310..cc1fe18e05fd 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller/cam_irq_controller.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller/cam_irq_controller.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -515,8 +515,8 @@ int cam_irq_controller_unsubscribe_irq(void *irq_controller,
 		}
 	}
 
+	priority = evt_handler->priority;
 	if (found) {
-		priority = evt_handler->priority;
 		for (i = 0; i < controller->num_registers; i++) {
 			irq_register = &controller->irq_register_arr[i];
 			irq_register->top_half_enable_mask[priority] &=
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/include/cam_isp_hw_mgr_intf.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/include/cam_isp_hw_mgr_intf.h
index 1d7e529f4448..6d5d0fd61c88 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/include/cam_isp_hw_mgr_intf.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/include/cam_isp_hw_mgr_intf.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_ISP_HW_MGR_INTF_H_
@@ -45,7 +44,6 @@ enum cam_isp_hw_err_type {
 	CAM_ISP_HW_ERROR_P2I_ERROR,
 	CAM_ISP_HW_ERROR_VIOLATION,
 	CAM_ISP_HW_ERROR_BUSIF_OVERFLOW,
-	CAM_ISP_HW_ERROR_CSID_FATAL,
 	CAM_ISP_HW_ERROR_MAX,
 };
 
@@ -121,9 +119,6 @@ struct cam_isp_bw_config_internal {
  * @packet_opcode_type:     Packet header opcode in the packet header
  *                          this opcode defines, packet is init packet or
  *                          update packet
- * @frame_header_cpu_addr:  Frame header cpu addr
- * @frame_header_iova:      Frame header iova
- * @frame_header_res_id:    Out port res_id corresponding to frame header
  * @bw_config_version:      BW config version indicator
  * @bw_config:              BW config information
  * @bw_config_v2:           BW config info for AXI bw voting v2
@@ -136,13 +131,10 @@ struct cam_isp_bw_config_internal {
 struct cam_isp_prepare_hw_update_data {
 	struct cam_ife_hw_mgr_ctx            *ife_mgr_ctx;
 	uint32_t                              packet_opcode_type;
-	uint32_t                             *frame_header_cpu_addr;
-	uint64_t                              frame_header_iova;
-	uint32_t                              frame_header_res_id;
 	uint32_t                              bw_config_version;
 	struct cam_isp_bw_config_internal     bw_config[CAM_IFE_HW_NUM_MAX];
 	struct cam_isp_bw_config_internal_v2  bw_config_v2[CAM_IFE_HW_NUM_MAX];
-	bool                               bw_config_valid[CAM_IFE_HW_NUM_MAX];
+	bool                                bw_config_valid[CAM_IFE_HW_NUM_MAX];
 	struct cam_cmd_buf_desc               reg_dump_buf_desc[
 						CAM_REG_DUMP_MAX_BUF_ENTRIES];
 	uint32_t                              num_reg_dump_buf;
@@ -176,11 +168,10 @@ struct cam_isp_hw_reg_update_event_data {
  * struct cam_isp_hw_epoch_event_data - Event payload for CAM_HW_EVENT_EPOCH
  *
  * @timestamp:     Time stamp for the epoch event
- * @frame_id_meta: Frame id value corresponding to this frame
+ *
  */
 struct cam_isp_hw_epoch_event_data {
 	uint64_t       timestamp;
-	uint32_t       frame_id_meta;
 };
 
 /**
@@ -188,7 +179,6 @@ struct cam_isp_hw_epoch_event_data {
  *
  * @num_handles:           Number of resource handeles
  * @resource_handle:       Resource handle array
- * @last_consumed_addr:    Last consumed addr
  * @timestamp:             Timestamp for the buf done event
  *
  */
@@ -196,8 +186,6 @@ struct cam_isp_hw_done_event_data {
 	uint32_t             num_handles;
 	uint32_t             resource_handle[
 				CAM_NUM_OUT_PER_COMP_IRQ_MAX];
-	uint32_t             last_consumed_addr[
-				CAM_NUM_OUT_PER_COMP_IRQ_MAX];
 	uint64_t       timestamp;
 };
 
@@ -234,8 +222,6 @@ enum cam_isp_hw_mgr_command {
 	CAM_ISP_HW_MGR_CMD_RESUME_HW,
 	CAM_ISP_HW_MGR_CMD_SOF_DEBUG,
 	CAM_ISP_HW_MGR_CMD_CTX_TYPE,
-	CAM_ISP_HW_MGR_GET_PACKET_OPCODE,
-	CAM_ISP_HW_MGR_GET_LAST_CDM_DONE,
 	CAM_ISP_HW_MGR_CMD_MAX,
 };
 
@@ -243,27 +229,20 @@ enum cam_isp_ctx_type {
 	CAM_ISP_CTX_FS2 = 1,
 	CAM_ISP_CTX_RDI,
 	CAM_ISP_CTX_PIX,
-	CAM_ISP_CTX_OFFLINE,
 	CAM_ISP_CTX_MAX,
 };
 /**
  * struct cam_isp_hw_cmd_args - Payload for hw manager command
  *
- * @cmd_type:              HW command type
- * @cmd_data:              Command data
- * @sof_irq_enable:        To debug if SOF irq is enabled
- * @ctx_type:              RDI_ONLY, PIX and RDI, or FS2
- * @packet_op_code:        Packet opcode
- * @last_cdm_done:         Last cdm done request
+ * @cmd_type               HW command type
+ * @sof_irq_enable         To debug if SOF irq is enabled
+ * @ctx_type               RDI_ONLY, PIX and RDI, or FS2
  */
 struct cam_isp_hw_cmd_args {
 	uint32_t                          cmd_type;
-	void                             *cmd_data;
 	union {
 		uint32_t                      sof_irq_enable;
 		uint32_t                      ctx_type;
-		uint32_t                      packet_op_code;
-		uint64_t                      last_cdm_done;
 	} u;
 };
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid170.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid170.h
index bc564b2e1f77..714fa8ef2b31 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid170.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid170.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_170_H_
@@ -286,10 +286,6 @@ static struct cam_ife_csid_common_reg_offset
 	.ppp_irq_mask_all                             = 0x0,
 	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
 	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static struct cam_ife_csid_reg_offset cam_ife_csid_170_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175.h
index 734218bf5144..70f96ea416d8 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_175_H_
@@ -327,10 +327,6 @@ static struct cam_ife_csid_common_reg_offset
 	.ppp_irq_mask_all                             = 0xFFFF,
 	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
 	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static struct cam_ife_csid_reg_offset cam_ife_csid_175_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175_200.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175_200.h
index 1794a860b84e..612379ec4bdd 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175_200.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid175_200.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_175_200_H_
@@ -345,10 +345,6 @@ static struct cam_ife_csid_common_reg_offset
 	.ppp_irq_mask_all                             = 0xFFFF,
 	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
 	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static struct cam_ife_csid_reg_offset cam_ife_csid_175_200_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid17x.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid17x.c
index d06dafcbcbbc..d88347caa388 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid17x.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid17x.c
@@ -1,13 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 
 #include <linux/module.h>
 #include "cam_ife_csid_core.h"
 #include "cam_ife_csid170.h"
-#include "cam_ife_csid170_200.h"
 #include "cam_ife_csid175.h"
 #include "cam_ife_csid175_200.h"
 #include "cam_ife_csid480.h"
@@ -23,11 +22,6 @@ static struct cam_ife_csid_hw_info cam_ife_csid170_hw_info = {
 	.hw_dts_version = CAM_CSID_VERSION_V170,
 };
 
-static struct cam_ife_csid_hw_info cam_ife_csid170_200_hw_info = {
-	.csid_reg = &cam_ife_csid_170_200_reg_offset,
-	.hw_dts_version = CAM_CSID_VERSION_V170,
-};
-
 static struct cam_ife_csid_hw_info cam_ife_csid175_hw_info = {
 	.csid_reg = &cam_ife_csid_175_reg_offset,
 	.hw_dts_version = CAM_CSID_VERSION_V175,
@@ -48,10 +42,6 @@ static const struct of_device_id cam_ife_csid17x_dt_match[] = {
 		.compatible = "qcom,csid170",
 		.data = &cam_ife_csid170_hw_info,
 	},
-	{
-		.compatible = "qcom,csid170_200",
-		.data = &cam_ife_csid170_200_hw_info,
-	},
 	{
 		.compatible = "qcom,csid175",
 		.data = &cam_ife_csid175_hw_info,
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid480.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid480.h
index 316c3e2ab629..66c1b32d51b0 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid480.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid480.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_480_H_
@@ -365,10 +365,6 @@ static struct cam_ife_csid_common_reg_offset
 	.ppp_irq_mask_all                             = 0xFFFF,
 	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
 	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static struct cam_ife_csid_reg_offset cam_ife_csid_480_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.c
index f5fc6a84c722..add344087243 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.c
@@ -1,24 +1,21 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/iopoll.h>
 #include <linux/slab.h>
 #include <uapi/media/cam_isp.h>
 #include <uapi/media/cam_defs.h>
-#include <media/cam_req_mgr.h>
+
 #include <dt-bindings/msm/msm-camera.h>
 
-#include "cam_isp_hw_mgr_intf.h"
 #include "cam_ife_csid_core.h"
 #include "cam_isp_hw.h"
 #include "cam_soc_util.h"
 #include "cam_io_util.h"
 #include "cam_debug_util.h"
 #include "cam_cpas_api.h"
-#include "cam_tasklet_util.h"
-#include "cam_subdev.h"
 
 /* Timeout value in msec */
 #define IFE_CSID_TIMEOUT                               1000
@@ -46,184 +43,8 @@
 /* Max CSI Rx irq error count threshold value */
 #define CAM_IFE_CSID_MAX_IRQ_ERROR_COUNT               100
 
-/* factor to conver qtime to boottime */
-static int64_t qtime_to_boottime;
-
 static int cam_ife_csid_reset_regs(
 	struct cam_ife_csid_hw *csid_hw, bool reset_hw);
-
-static void cam_ife_csid_enable_path_for_init_frame_drop(
-	struct cam_ife_csid_hw *csid_hw,
-	int res_id)
-{
-	struct cam_ife_csid_path_cfg *path_data;
-	const struct cam_ife_csid_pxl_reg_offset *pxl_reg = NULL;
-	const struct cam_ife_csid_rdi_reg_offset *rdi_reg = NULL;
-	const struct cam_ife_csid_reg_offset     *csid_reg;
-	struct cam_hw_soc_info                   *soc_info;
-	struct cam_isp_resource_node *res;
-	uint32_t val;
-
-	if (!csid_hw) {
-		CAM_WARN(CAM_ISP, "csid_hw cannot be NULL");
-		return;
-	}
-
-	csid_reg  = csid_hw->csid_info->csid_reg;
-	soc_info  = &csid_hw->hw_info->soc_info;
-
-	if (res_id == CAM_IFE_PIX_PATH_RES_IPP) {
-		res = &csid_hw->ipp_res;
-		pxl_reg = csid_reg->ipp_reg;
-	} else if (res_id == CAM_IFE_PIX_PATH_RES_PPP) {
-		res = &csid_hw->ppp_res;
-		pxl_reg = csid_reg->ppp_reg;
-	} else if (res_id >= CAM_IFE_PIX_PATH_RES_RDI_0 &&
-			res_id <= CAM_IFE_PIX_PATH_RES_RDI_3) {
-		res = &csid_hw->rdi_res[res_id];
-		rdi_reg = csid_reg->rdi_reg[res_id];
-	} else {
-		CAM_ERR(CAM_ISP, "Invalid res_id");
-		return;
-	}
-
-	path_data = (struct cam_ife_csid_path_cfg *)res->res_priv;
-
-	if (!path_data || !path_data->init_frame_drop)
-		return;
-	if (res->res_state != CAM_ISP_RESOURCE_STATE_STREAMING)
-		return;
-
-	csid_hw->res_sof_cnt[res_id]++;
-	if ((csid_hw->res_sof_cnt[res_id] + 1) <
-			csid_hw->res_sof_cnt[res_id]) {
-		CAM_WARN(CAM_ISP, "Res %d sof count overflow %d",
-			res_id, csid_hw->res_sof_cnt[res_id]);
-		return;
-	}
-
-	CAM_DBG(CAM_ISP, "CSID:%d res_id %d SOF cnt:%d init_frame_drop:%d",
-		csid_hw->hw_intf->hw_idx, res_id, csid_hw->res_sof_cnt[res_id],
-		path_data->init_frame_drop);
-
-	if ((csid_hw->res_sof_cnt[res_id] ==
-		path_data->init_frame_drop) &&
-		pxl_reg) {
-		CAM_DBG(CAM_ISP, "Enabling pixel %s Path",
-			(res_id == CAM_IFE_PIX_PATH_RES_IPP) ? "IPP" : "PPP");
-		if (path_data->sync_mode !=
-			CAM_ISP_HW_SYNC_SLAVE) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				pxl_reg->csid_pxl_ctrl_addr);
-			val |= CAM_CSID_RESUME_AT_FRAME_BOUNDARY;
-			cam_io_w_mb(val,
-				soc_info->reg_map[0].mem_base +
-				pxl_reg->csid_pxl_ctrl_addr);
-		}
-
-		if (!(csid_hw->csid_debug &
-				CSID_DEBUG_ENABLE_SOF_IRQ)) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				pxl_reg->csid_pxl_irq_mask_addr);
-			val &= ~(CSID_PATH_INFO_INPUT_SOF);
-			cam_io_w_mb(val,
-				soc_info->reg_map[0].mem_base +
-				pxl_reg->csid_pxl_irq_mask_addr);
-		}
-	} else if ((csid_hw->res_sof_cnt[res_id] ==
-		path_data->init_frame_drop) && rdi_reg) {
-		CAM_DBG(CAM_ISP, "Enabling RDI %d Path", res_id);
-		cam_io_w_mb(CAM_CSID_RESUME_AT_FRAME_BOUNDARY,
-			soc_info->reg_map[0].mem_base +
-			rdi_reg->csid_rdi_ctrl_addr);
-		if (!(csid_hw->csid_debug &
-				CSID_DEBUG_ENABLE_SOF_IRQ)) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				rdi_reg->csid_rdi_irq_mask_addr);
-			val &= ~(CSID_PATH_INFO_INPUT_SOF);
-			cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-				rdi_reg->csid_rdi_irq_mask_addr);
-		}
-	}
-}
-
-static bool cam_ife_csid_check_path_active(struct cam_ife_csid_hw   *csid_hw)
-{
-	const struct cam_ife_csid_reg_offset  *csid_reg;
-	struct cam_hw_soc_info                *soc_info;
-	uint32_t i;
-	uint32_t path_status = 1;
-
-	if (!csid_hw) {
-		CAM_WARN(CAM_ISP, "csid_hw cannot be NULL");
-		return -EINVAL;
-	}
-
-	csid_reg = csid_hw->csid_info->csid_reg;
-	soc_info = &csid_hw->hw_info->soc_info;
-
-	/* check the IPP path status */
-	if (csid_reg->cmn_reg->num_pix) {
-		path_status = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				csid_reg->ipp_reg->csid_pxl_status_addr);
-		CAM_DBG(CAM_ISP, "CSID:%d IPP path status:%d",
-			csid_hw->hw_intf->hw_idx, path_status);
-		/* if status is 0 then it is active */
-		if (!path_status)
-			goto end;
-	}
-
-	if (csid_reg->cmn_reg->num_ppp) {
-		path_status = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				csid_reg->ppp_reg->csid_pxl_status_addr);
-		CAM_DBG(CAM_ISP, "CSID:%d PPP path status:%d",
-			csid_hw->hw_intf->hw_idx, path_status);
-		/* if status is 0 then it is active */
-		if (!path_status)
-			goto end;
-	}
-
-	/* Check the RDI path status */
-	for (i = 0; i < csid_reg->cmn_reg->num_rdis; i++) {
-		path_status = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-				csid_reg->rdi_reg[i]->csid_rdi_status_addr);
-		CAM_DBG(CAM_ISP, "CSID:%d RDI:%d path status:%d",
-			csid_hw->hw_intf->hw_idx, i,  path_status);
-		/* if status is 0 then it is active */
-		if (!path_status)
-			goto end;
-	}
-
-end:
-	/* if status is 0 then path is active */
-	return path_status ? false : true;
-}
-
-static void cam_ife_csid_reset_path_data(
-	struct cam_ife_csid_hw       *csid_hw,
-	struct cam_isp_resource_node *res)
-{
-	struct cam_ife_csid_path_cfg *path_data = NULL;
-
-	if (!csid_hw || !res) {
-		CAM_WARN(CAM_ISP, "csid_hw or res cannot be NULL");
-		return;
-	}
-	path_data = res->res_priv;
-
-	if (res->res_id == CAM_IFE_PIX_PATH_RES_IPP)
-		csid_hw->ipp_path_config.measure_enabled = 0;
-	else if (res->res_id == CAM_IFE_PIX_PATH_RES_PPP)
-		csid_hw->ppp_path_config.measure_enabled = 0;
-	else if (res->res_id >= CAM_IFE_PIX_PATH_RES_RDI_0 &&
-			res->res_id <= CAM_IFE_PIX_PATH_RES_RDI_3)
-		csid_hw->rdi_path_config[res->res_id].measure_enabled
-			= 0;
-
-	if (path_data)
-		path_data->init_frame_drop = 0;
-}
-
 static int cam_ife_csid_is_ipp_ppp_format_supported(
 	uint32_t in_format)
 {
@@ -254,7 +75,7 @@ static int cam_ife_csid_is_ipp_ppp_format_supported(
 
 static int cam_ife_csid_get_format_rdi(
 	uint32_t in_format, uint32_t out_format, uint32_t *decode_fmt,
-	uint32_t *plain_fmt, uint32_t *packing_fmt, bool rpp, uint32_t *in_bpp)
+	uint32_t *plain_fmt, uint32_t *packing_fmt, bool rpp)
 {
 	int rc = 0;
 
@@ -276,7 +97,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 6;
 		break;
 	case CAM_FORMAT_MIPI_RAW_8:
 		switch (out_format) {
@@ -296,16 +116,9 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 8;
 		break;
 	case CAM_FORMAT_MIPI_RAW_10:
 		switch (out_format) {
-		case CAM_FORMAT_MIPI_RAW_8:
-		case CAM_FORMAT_PLAIN8:
-			*plain_fmt = 0x0;
-			*decode_fmt = 0x2;
-			*packing_fmt = 0;
-			break;
 		case CAM_FORMAT_MIPI_RAW_10:
 		case CAM_FORMAT_PLAIN128:
 			*decode_fmt = 0xf;
@@ -322,7 +135,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 10;
 		break;
 	case CAM_FORMAT_MIPI_RAW_12:
 		switch (out_format) {
@@ -341,7 +153,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 12;
 		break;
 	case CAM_FORMAT_MIPI_RAW_14:
 		switch (out_format) {
@@ -360,7 +171,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 14;
 		break;
 	case CAM_FORMAT_MIPI_RAW_16:
 		switch (out_format) {
@@ -379,7 +189,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 16;
 		break;
 	case CAM_FORMAT_MIPI_RAW_20:
 		switch (out_format) {
@@ -398,7 +207,6 @@ static int cam_ife_csid_get_format_rdi(
 			rc = -EINVAL;
 			break;
 		}
-		*in_bpp = 20;
 		break;
 	case CAM_FORMAT_DPCM_10_6_10:
 		*decode_fmt  = 0x7;
@@ -606,6 +414,7 @@ static int cam_ife_csid_cid_get(struct cam_ife_csid_hw *csid_hw,
 	return -EINVAL;
 }
 
+
 static int cam_ife_csid_global_reset(struct cam_ife_csid_hw *csid_hw)
 {
 	struct cam_hw_soc_info                *soc_info;
@@ -711,9 +520,6 @@ static int cam_ife_csid_global_reset(struct cam_ife_csid_hw *csid_hw)
 	csid_hw->prev_boot_timestamp = 0;
 
 end:
-	for (i = 0 ; i < CAM_IFE_PIX_PATH_RES_MAX; i++)
-		csid_hw->res_sof_cnt[i] = 0;
-
 	return rc;
 }
 
@@ -721,7 +527,6 @@ static int cam_ife_csid_path_reset(struct cam_ife_csid_hw *csid_hw,
 	struct cam_csid_reset_cfg_args  *reset)
 {
 	int rc = 0;
-	unsigned long rem_jiffies;
 	struct cam_hw_soc_info                    *soc_info;
 	struct cam_isp_resource_node              *res;
 	const struct cam_ife_csid_reg_offset      *csid_reg;
@@ -841,13 +646,14 @@ static int cam_ife_csid_path_reset(struct cam_ife_csid_hw *csid_hw,
 	cam_io_w_mb(reset_strb_val, soc_info->reg_map[0].mem_base +
 				reset_strb_addr);
 
-	rem_jiffies = wait_for_completion_timeout(complete,
+	rc = wait_for_completion_timeout(complete,
 		msecs_to_jiffies(IFE_CSID_TIMEOUT));
-	if (!rem_jiffies) {
-		rc = -ETIMEDOUT;
+	if (rc <= 0) {
 		CAM_ERR(CAM_ISP, "CSID:%d Res id %d fail rc = %d",
 			 csid_hw->hw_intf->hw_idx,
 			res->res_id,  rc);
+		if (rc == 0)
+			rc = -ETIMEDOUT;
 	}
 
 end:
@@ -964,39 +770,17 @@ int cam_ife_csid_cid_reserve(struct cam_ife_csid_hw *csid_hw,
 		}
 		break;
 	case CAM_CPAS_TITAN_480_V100:
-		/*
-		 * Assigning existing two IFEs for custom in KONA,
-		 * this needs to be addressed accordingly for
-		 * upcoming targets
-		 */
-		if (cid_reserv->in_port->cust_node) {
-			if (cid_reserv->in_port->usage_type ==
-				CAM_ISP_RES_USAGE_DUAL) {
-				CAM_ERR(CAM_ISP,
-					"Dual IFE is not supported for cust_node %u",
-					cid_reserv->in_port->cust_node);
+		if (cid_reserv->in_port->cust_node == 1) {
+			if (cid_reserv->in_port->usage_type == 1) {
+				CAM_ERR(CAM_ISP, "Dual IFE is not supported");
 				rc = -EINVAL;
 				goto end;
 			}
-
-			if (cid_reserv->in_port->cust_node ==
-				CAM_ISP_ACQ_CUSTOM_PRIMARY) {
-				if (csid_hw->hw_intf->hw_idx != 0) {
-					CAM_ERR(CAM_ISP, "CSID%d not eligible",
-						csid_hw->hw_intf->hw_idx);
-					rc = -EINVAL;
-					goto end;
-				}
-			}
-
-			if (cid_reserv->in_port->cust_node ==
-				CAM_ISP_ACQ_CUSTOM_SECONDARY) {
-				if (csid_hw->hw_intf->hw_idx != 1) {
-					CAM_ERR(CAM_ISP, "CSID%d not eligible",
-						csid_hw->hw_intf->hw_idx);
-					rc = -EINVAL;
-					goto end;
-				}
+			if (csid_hw->hw_intf->hw_idx != 0) {
+				CAM_DBG(CAM_ISP, "CSID%d not eligible",
+					csid_hw->hw_intf->hw_idx);
+				rc = -EINVAL;
+				goto end;
 			}
 		}
 		break;
@@ -1012,31 +796,28 @@ int cam_ife_csid_cid_reserve(struct cam_ife_csid_hw *csid_hw,
 			goto end;
 		}
 
-		if ((cid_reserv->in_port->res_type !=
-			CAM_ISP_IFE_IN_RES_TPG) &&
-			(csid_hw->csi2_rx_cfg.lane_cfg !=
-			cid_reserv->in_port->lane_cfg  ||
-			csid_hw->csi2_rx_cfg.lane_type !=
-			cid_reserv->in_port->lane_type ||
-			csid_hw->csi2_rx_cfg.lane_num !=
-			cid_reserv->in_port->lane_num)) {
-
-			rc = -EINVAL;
-			goto end;
-		}
-		if ((cid_reserv->in_port->res_type ==
-			CAM_ISP_IFE_IN_RES_TPG) &&
-			(csid_hw->tpg_cfg.in_format !=
-			cid_reserv->in_port->format     ||
-			csid_hw->tpg_cfg.width !=
-			cid_reserv->in_port->left_width ||
-			csid_hw->tpg_cfg.height !=
-			cid_reserv->in_port->height     ||
-			csid_hw->tpg_cfg.test_pattern !=
-			cid_reserv->in_port->test_pattern)) {
-
-			rc = -EINVAL;
-			goto end;
+		if (cid_reserv->in_port->res_type != CAM_ISP_IFE_IN_RES_TPG) {
+			if (csid_hw->csi2_rx_cfg.lane_cfg !=
+				cid_reserv->in_port->lane_cfg  ||
+				csid_hw->csi2_rx_cfg.lane_type !=
+				cid_reserv->in_port->lane_type ||
+				csid_hw->csi2_rx_cfg.lane_num !=
+				cid_reserv->in_port->lane_num) {
+				rc = -EINVAL;
+				goto end;
+				}
+		} else {
+			if (csid_hw->tpg_cfg.in_format !=
+				cid_reserv->in_port->format     ||
+				csid_hw->tpg_cfg.width !=
+				cid_reserv->in_port->left_width ||
+				csid_hw->tpg_cfg.height !=
+				cid_reserv->in_port->height     ||
+				csid_hw->tpg_cfg.test_pattern !=
+				cid_reserv->in_port->test_pattern) {
+				rc = -EINVAL;
+				goto end;
+			}
 		}
 	}
 
@@ -1044,7 +825,7 @@ int cam_ife_csid_cid_reserve(struct cam_ife_csid_hw *csid_hw,
 	case CAM_IFE_PIX_PATH_RES_IPP:
 		if (csid_hw->ipp_res.res_state !=
 			CAM_ISP_RESOURCE_STATE_AVAILABLE) {
-			CAM_ERR(CAM_ISP,
+			CAM_DBG(CAM_ISP,
 				"CSID:%d IPP resource not available",
 				csid_hw->hw_intf->hw_idx);
 			rc = -EINVAL;
@@ -1121,45 +902,39 @@ int cam_ife_csid_cid_reserve(struct cam_ife_csid_hw *csid_hw,
 		csid_hw->csi2_rx_cfg.lane_num =
 			cid_reserv->in_port->lane_num;
 
-		if (cid_reserv->in_port->res_type != CAM_ISP_IFE_IN_RES_TPG) {
-			csid_hw->csi2_rx_cfg.phy_sel =
-				(cid_reserv->in_port->res_type & 0xFF) - 1;
-			csid_hw->csi2_reserve_cnt++;
-			CAM_DBG(CAM_ISP, "CSID:%d CID:%d acquired",
+		if (cid_reserv->in_port->res_type == CAM_ISP_IFE_IN_RES_TPG) {
+			csid_hw->csi2_rx_cfg.phy_sel = 0;
+			if (cid_reserv->in_port->format >
+			    CAM_FORMAT_MIPI_RAW_16) {
+				CAM_ERR(CAM_ISP, " Wrong TPG format");
+				rc = -EINVAL;
+				goto end;
+			}
+			csid_hw->tpg_cfg.in_format =
+				cid_reserv->in_port->format;
+			csid_hw->tpg_cfg.usage_type =
+				cid_reserv->in_port->usage_type;
+			if (cid_reserv->in_port->usage_type)
+				csid_hw->tpg_cfg.width =
+					(cid_reserv->in_port->right_stop + 1);
+			else
+				csid_hw->tpg_cfg.width =
+					cid_reserv->in_port->left_width;
+
+			csid_hw->tpg_cfg.height = cid_reserv->in_port->height;
+			csid_hw->tpg_cfg.test_pattern =
+				cid_reserv->in_port->test_pattern;
+
+			CAM_DBG(CAM_ISP, "CSID:%d TPG width:%d height:%d",
 				csid_hw->hw_intf->hw_idx,
-				cid_reserv->node_res->res_id);
-			goto end;
-		}
+				csid_hw->tpg_cfg.width,
+				csid_hw->tpg_cfg.height);
 
-		/* Below code is executed only for TPG in_res type */
-		csid_hw->csi2_rx_cfg.phy_sel = 0;
-		if (cid_reserv->in_port->format >
-		    CAM_FORMAT_MIPI_RAW_16) {
-			CAM_ERR(CAM_ISP, " Wrong TPG format");
-			rc = -EINVAL;
-			goto end;
+			cid_data->tpg_set = 1;
+		} else {
+			csid_hw->csi2_rx_cfg.phy_sel =
+				(cid_reserv->in_port->res_type & 0xFF) - 1;
 		}
-		csid_hw->tpg_cfg.in_format =
-			cid_reserv->in_port->format;
-		csid_hw->tpg_cfg.usage_type =
-			cid_reserv->in_port->usage_type;
-		if (cid_reserv->in_port->usage_type)
-			csid_hw->tpg_cfg.width =
-				(cid_reserv->in_port->right_stop + 1);
-		else
-			csid_hw->tpg_cfg.width =
-				cid_reserv->in_port->left_width;
-
-		csid_hw->tpg_cfg.height = cid_reserv->in_port->height;
-		csid_hw->tpg_cfg.test_pattern =
-			cid_reserv->in_port->test_pattern;
-
-		CAM_DBG(CAM_ISP, "CSID:%d TPG width:%d height:%d",
-			csid_hw->hw_intf->hw_idx,
-			csid_hw->tpg_cfg.width,
-			csid_hw->tpg_cfg.height);
-
-		cid_data->tpg_set = 1;
 	}
 
 	csid_hw->csi2_reserve_cnt++;
@@ -1313,7 +1088,6 @@ int cam_ife_csid_path_reserve(struct cam_ife_csid_hw *csid_hw,
 	path_data->in_format = reserve->in_port->format;
 	path_data->out_format = reserve->out_port->format;
 	path_data->sync_mode = reserve->sync_mode;
-	path_data->usage_type = reserve->in_port->usage_type;
 	path_data->height  = reserve->in_port->height;
 	path_data->start_line = reserve->in_port->line_start;
 	path_data->end_line = reserve->in_port->line_stop;
@@ -1393,8 +1167,6 @@ int cam_ife_csid_path_reserve(struct cam_ife_csid_hw *csid_hw,
 		csid_hw->hw_intf->hw_idx, reserve->res_id,
 		path_data->width, path_data->height);
 	reserve->node_res = res;
-	csid_hw->event_cb = reserve->event_cb;
-	csid_hw->priv = reserve->priv;
 
 end:
 	return rc;
@@ -1493,13 +1265,8 @@ static int cam_ife_csid_enable_hw(struct cam_ife_csid_hw  *csid_hw)
 		csid_hw->hw_intf->hw_idx, val);
 
 	spin_lock_irqsave(&csid_hw->lock_state, flags);
-	csid_hw->fatal_err_detected = false;
 	csid_hw->device_enabled = 1;
 	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
-	cam_tasklet_start(csid_hw->tasklet);
-
-	for (i = 0; i < CAM_IFE_PIX_PATH_RES_MAX; i++)
-		csid_hw->res_sof_cnt[i] = 0;
 
 	return 0;
 
@@ -1514,7 +1281,6 @@ static int cam_ife_csid_enable_hw(struct cam_ife_csid_hw  *csid_hw)
 static int cam_ife_csid_disable_hw(struct cam_ife_csid_hw *csid_hw)
 {
 	int rc = -EINVAL;
-	uint32_t i;
 	struct cam_hw_soc_info                   *soc_info;
 	const struct cam_ife_csid_reg_offset     *csid_reg;
 	unsigned long                             flags;
@@ -1552,20 +1318,12 @@ static int cam_ife_csid_disable_hw(struct cam_ife_csid_hw *csid_hw)
 		CAM_ERR(CAM_ISP, "CSID:%d Disable CSID SOC failed",
 			csid_hw->hw_intf->hw_idx);
 
-	cam_tasklet_stop(csid_hw->tasklet);
 	spin_lock_irqsave(&csid_hw->lock_state, flags);
 	csid_hw->device_enabled = 0;
 	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
-
-	csid_hw->ipp_path_config.measure_enabled = 0;
-	csid_hw->ppp_path_config.measure_enabled = 0;
-	for (i = 0; i <= CAM_IFE_PIX_PATH_RES_RDI_3; i++)
-		csid_hw->rdi_path_config[i].measure_enabled = 0;
-
 	csid_hw->hw_info->hw_state = CAM_HW_STATE_POWER_DOWN;
 	csid_hw->error_irq_count = 0;
 	csid_hw->prev_boot_timestamp = 0;
-	csid_hw->epd_supported = 0;
 
 	return rc;
 }
@@ -1734,71 +1492,6 @@ static int cam_ife_csid_config_tpg(struct cam_ife_csid_hw   *csid_hw,
 	return 0;
 }
 
-static int cam_ife_csid_csi2_irq_ctrl(
-	struct cam_ife_csid_hw *csid_hw,
-	bool irq_enable)
-{
-	uint32_t val = 0;
-	struct cam_hw_soc_info                     *soc_info;
-	const struct cam_ife_csid_reg_offset       *csid_reg;
-
-	csid_reg = csid_hw->csid_info->csid_reg;
-	soc_info = &csid_hw->hw_info->soc_info;
-
-	if (irq_enable) {
-		/*Enable the CSI2 rx interrupts */
-		val = CSID_CSI2_RX_INFO_RST_DONE |
-			CSID_CSI2_RX_ERROR_TG_FIFO_OVERFLOW |
-			CSID_CSI2_RX_ERROR_LANE0_FIFO_OVERFLOW |
-			CSID_CSI2_RX_ERROR_LANE1_FIFO_OVERFLOW |
-			CSID_CSI2_RX_ERROR_LANE2_FIFO_OVERFLOW |
-			CSID_CSI2_RX_ERROR_LANE3_FIFO_OVERFLOW |
-			CSID_CSI2_RX_ERROR_CPHY_SOT_RECEPTION |
-			CSID_CSI2_RX_ERROR_CRC |
-			CSID_CSI2_RX_ERROR_ECC |
-			CSID_CSI2_RX_ERROR_MMAPPED_VC_DT |
-			CSID_CSI2_RX_ERROR_STREAM_UNDERFLOW |
-			CSID_CSI2_RX_ERROR_UNBOUNDED_FRAME |
-			CSID_CSI2_RX_ERROR_CPHY_PH_CRC;
-
-		if (csid_hw->epd_supported == 1)
-			CAM_INFO(CAM_ISP,
-				"Disable CSID_CSI2_RX_ERROR_CPHY_EOT_RECEPTION for EPD");
-		else
-			val = val | CSID_CSI2_RX_ERROR_CPHY_EOT_RECEPTION;
-
-		/* Enable the interrupt based on csid debug info set */
-		if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOT_IRQ)
-			val |= CSID_CSI2_RX_INFO_PHY_DL0_SOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL1_SOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL2_SOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL3_SOT_CAPTURED;
-
-		if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOT_IRQ)
-			val |= CSID_CSI2_RX_INFO_PHY_DL0_EOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL1_EOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL2_EOT_CAPTURED |
-				CSID_CSI2_RX_INFO_PHY_DL3_EOT_CAPTURED;
-
-		if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SHORT_PKT_CAPTURE)
-			val |= CSID_CSI2_RX_INFO_SHORT_PKT_CAPTURED;
-
-		if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_LONG_PKT_CAPTURE)
-			val |= CSID_CSI2_RX_INFO_LONG_PKT_CAPTURED;
-		if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_CPHY_PKT_CAPTURE)
-			val |= CSID_CSI2_RX_INFO_CPHY_PKT_HDR_CAPTURED;
-
-		cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-			csid_reg->csi2_reg->csid_csi2_rx_irq_mask_addr);
-	} else {
-		/* Disable the CSI2 rx inerrupts */
-		cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
-			csid_reg->csi2_reg->csid_csi2_rx_irq_mask_addr);
-	}
-
-	return 0;
-}
-
 static int cam_ife_csid_enable_csi2(
 	struct cam_ife_csid_hw          *csid_hw,
 	struct cam_isp_resource_node    *res)
@@ -1807,12 +1500,12 @@ static int cam_ife_csid_enable_csi2(
 	const struct cam_ife_csid_reg_offset       *csid_reg;
 	struct cam_hw_soc_info                     *soc_info;
 	struct cam_ife_csid_cid_data               *cid_data;
-	uint32_t val = 0, val2;
+	uint32_t val = 0;
 
 	csid_reg = csid_hw->csid_info->csid_reg;
 	soc_info = &csid_hw->hw_info->soc_info;
-	CAM_DBG(CAM_ISP, "CSID:%d count:%d config csi2 rx  res_id:%d",
-		csid_hw->hw_intf->hw_idx, csid_hw->csi2_cfg_cnt, res->res_id);
+	CAM_DBG(CAM_ISP, "CSID:%d count:%d config csi2 rx",
+		csid_hw->hw_intf->hw_idx, csid_hw->csi2_cfg_cnt);
 
 	/* overflow check before increment */
 	if (csid_hw->csi2_cfg_cnt == UINT_MAX) {
@@ -1822,7 +1515,7 @@ static int cam_ife_csid_enable_csi2(
 	}
 
 	cid_data = (struct cam_ife_csid_cid_data *)res->res_priv;
-	cid_data->init_cnt++;
+
 	res->res_state  = CAM_ISP_RESOURCE_STATE_STREAMING;
 	csid_hw->csi2_cfg_cnt++;
 	if (csid_hw->csi2_cfg_cnt > 1)
@@ -1859,20 +1552,46 @@ static int cam_ife_csid_enable_csi2(
 		}
 	}
 
-	/* after configuring the csi rx,  reset hw once */
-	rc = cam_ife_csid_reset_regs(csid_hw, true);
-	if (rc < 0) {
-		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->csi2_reg->csid_csi2_rx_cfg0_addr);
-		val2 = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->csi2_reg->csid_csi2_rx_irq_status_addr);
-		CAM_ERR(CAM_ISP,
-			"Failed in HW reset csid hw:%d top reset failed csi rx cfg:0x%x CSI RX status:0x%x",
-			csid_hw->hw_intf->hw_idx, val, val2);
-		return rc;
-	}
+	/*Enable the CSI2 rx interrupts */
+	val = CSID_CSI2_RX_INFO_RST_DONE |
+		CSID_CSI2_RX_ERROR_TG_FIFO_OVERFLOW |
+		CSID_CSI2_RX_ERROR_LANE0_FIFO_OVERFLOW |
+		CSID_CSI2_RX_ERROR_LANE1_FIFO_OVERFLOW |
+		CSID_CSI2_RX_ERROR_LANE2_FIFO_OVERFLOW |
+		CSID_CSI2_RX_ERROR_LANE3_FIFO_OVERFLOW |
+		CSID_CSI2_RX_ERROR_CPHY_EOT_RECEPTION |
+		CSID_CSI2_RX_ERROR_CPHY_SOT_RECEPTION |
+		CSID_CSI2_RX_ERROR_CRC |
+		CSID_CSI2_RX_ERROR_ECC |
+		CSID_CSI2_RX_ERROR_MMAPPED_VC_DT |
+		CSID_CSI2_RX_ERROR_STREAM_UNDERFLOW |
+		CSID_CSI2_RX_ERROR_UNBOUNDED_FRAME |
+		CSID_CSI2_RX_ERROR_CPHY_PH_CRC;
+
+	/* Enable the interrupt based on csid debug info set */
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOT_IRQ)
+		val |= CSID_CSI2_RX_INFO_PHY_DL0_SOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL1_SOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL2_SOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL3_SOT_CAPTURED;
+
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOT_IRQ)
+		val |= CSID_CSI2_RX_INFO_PHY_DL0_EOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL1_EOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL2_EOT_CAPTURED |
+			CSID_CSI2_RX_INFO_PHY_DL3_EOT_CAPTURED;
+
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SHORT_PKT_CAPTURE)
+		val |= CSID_CSI2_RX_INFO_SHORT_PKT_CAPTURED;
+
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_LONG_PKT_CAPTURE)
+		val |= CSID_CSI2_RX_INFO_LONG_PKT_CAPTURED;
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_CPHY_PKT_CAPTURE)
+		val |= CSID_CSI2_RX_INFO_CPHY_PKT_HDR_CAPTURED;
+
+	cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
+		csid_reg->csi2_reg->csid_csi2_rx_irq_mask_addr);
 
-	cam_ife_csid_csi2_irq_ctrl(csid_hw, true);
 	return 0;
 }
 
@@ -1882,7 +1601,6 @@ static int cam_ife_csid_disable_csi2(
 {
 	const struct cam_ife_csid_reg_offset      *csid_reg;
 	struct cam_hw_soc_info                    *soc_info;
-	struct cam_ife_csid_cid_data              *cid_data;
 
 	if (res->res_id >= CAM_IFE_CSID_CID_MAX) {
 		CAM_ERR(CAM_ISP, "CSID:%d Invalid res id :%d",
@@ -1892,24 +1610,18 @@ static int cam_ife_csid_disable_csi2(
 
 	csid_reg = csid_hw->csid_info->csid_reg;
 	soc_info = &csid_hw->hw_info->soc_info;
-	cid_data = (struct cam_ife_csid_cid_data *)res->res_priv;
-	CAM_DBG(CAM_ISP, "CSID:%d cnt : %d Disable csi2 rx res->res_id:%d",
-		csid_hw->hw_intf->hw_idx, csid_hw->csi2_cfg_cnt, res->res_id);
-
-	if (cid_data->init_cnt)
-		cid_data->init_cnt--;
-	if (!cid_data->init_cnt)
-		res->res_state = CAM_ISP_RESOURCE_STATE_RESERVED;
+	CAM_DBG(CAM_ISP, "CSID:%d cnt : %d Disable csi2 rx",
+		csid_hw->hw_intf->hw_idx, csid_hw->csi2_cfg_cnt);
 
 	if (csid_hw->csi2_cfg_cnt)
 		csid_hw->csi2_cfg_cnt--;
-	CAM_DBG(CAM_ISP, "res_id %d res_state=%d",
-		res->res_id, res->res_state);
 
 	if (csid_hw->csi2_cfg_cnt)
 		return 0;
 
-	cam_ife_csid_csi2_irq_ctrl(csid_hw, false);
+	/* Disable the CSI2 rx inerrupts */
+	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
+		csid_reg->csi2_reg->csid_csi2_rx_irq_mask_addr);
 
 	/* Reset the Rx CFG registers */
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
@@ -1942,9 +1654,6 @@ static void cam_ife_csid_halt_csi2(
 		csid_reg->csi2_reg->csid_csi2_rx_cfg0_addr);
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
 		csid_reg->csi2_reg->csid_csi2_rx_cfg1_addr);
-	cam_subdev_notify_message(CAM_CSIPHY_DEVICE_TYPE,
-		CAM_SUBDEV_MESSAGE_IRQ_ERR,
-		csid_hw->csi2_rx_cfg.phy_sel);
 }
 
 static int cam_ife_csid_init_config_pxl_path(
@@ -1959,7 +1668,6 @@ static int cam_ife_csid_init_config_pxl_path(
 	bool                                      is_ipp;
 	uint32_t decode_format = 0, plain_format = 0, val = 0;
 	uint32_t camera_hw_version;
-	struct cam_isp_sensor_dimension  *path_config;
 
 	path_data = (struct cam_ife_csid_path_cfg  *) res->res_priv;
 	csid_reg = csid_hw->csid_info->csid_reg;
@@ -1968,11 +1676,9 @@ static int cam_ife_csid_init_config_pxl_path(
 	if (res->res_id == CAM_IFE_PIX_PATH_RES_IPP) {
 		is_ipp = true;
 		pxl_reg = csid_reg->ipp_reg;
-		path_config = &(csid_hw->ipp_path_config);
 	} else {
 		is_ipp = false;
 		pxl_reg = csid_reg->ppp_reg;
-		path_config = &(csid_hw->ppp_path_config);
 	}
 
 	if (!pxl_reg) {
@@ -2085,25 +1791,6 @@ static int cam_ife_csid_init_config_pxl_path(
 		pxl_reg->csid_pxl_irq_subsample_period_addr);
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
 		pxl_reg->csid_pxl_irq_subsample_pattern_addr);
-
-	/* configure pixel format measure */
-	if (path_config->measure_enabled) {
-		val = (((path_config->height  &
-			csid_reg->cmn_reg->format_measure_height_mask_val) <<
-			csid_reg->cmn_reg->format_measure_height_shift_val) |
-			(path_config->width &
-			csid_reg->cmn_reg->format_measure_width_mask_val));
-		CAM_DBG(CAM_ISP, "CSID:%d format measure cfg1 value : 0x%x",
-			csid_hw->hw_intf->hw_idx, val);
-
-		cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-			pxl_reg->csid_pxl_format_measure_cfg1_addr);
-
-		/* enable pixel and line counter */
-		cam_io_w_mb(3, soc_info->reg_map[0].mem_base +
-			pxl_reg->csid_pxl_format_measure_cfg0_addr);
-	}
-
 	/* set pxl drop pattern to 0 and period to 1 */
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
 		pxl_reg->csid_pxl_pix_drop_pattern_addr);
@@ -2253,21 +1940,17 @@ static int cam_ife_csid_enable_pxl_path(
 	const struct cam_ife_csid_pxl_reg_offset *pxl_reg = NULL;
 	bool                                      is_ipp;
 	uint32_t                                  val = 0;
-	struct cam_isp_sensor_dimension          *path_config;
-	bool                                      path_active = false;
 
-	path_data = (struct cam_ife_csid_path_cfg *) res->res_priv;
+	path_data = (struct cam_ife_csid_path_cfg   *) res->res_priv;
 	csid_reg = csid_hw->csid_info->csid_reg;
 	soc_info = &csid_hw->hw_info->soc_info;
 
 	if (res->res_id == CAM_IFE_PIX_PATH_RES_IPP) {
 		is_ipp = true;
 		pxl_reg = csid_reg->ipp_reg;
-		path_config = &(csid_hw->ipp_path_config);
 	} else {
 		is_ipp = false;
 		pxl_reg = csid_reg->ppp_reg;
-		path_config = &(csid_hw->ppp_path_config);
 	}
 
 	if (res->res_state != CAM_ISP_RESOURCE_STATE_INIT_HW) {
@@ -2288,59 +1971,31 @@ static int cam_ife_csid_enable_pxl_path(
 
 	CAM_DBG(CAM_ISP, "Enable %s path", (is_ipp) ? "IPP" : "PPP");
 
-	if ((!is_ipp) && (path_data->usage_type == CAM_ISP_RES_USAGE_DUAL))
-		path_data->init_frame_drop = 1;
-
-
 	/* Set master or slave path */
-	if (path_data->sync_mode == CAM_ISP_HW_SYNC_MASTER) {
+	if (path_data->sync_mode == CAM_ISP_HW_SYNC_MASTER)
 		/*Set halt mode as master */
-		if (pxl_reg->halt_master_sel_en)
-			val = pxl_reg->halt_sel_internal_master_val << 4 |
-				CSID_HALT_MODE_MASTER << 2;
-		else
-			val = CSID_HALT_MODE_MASTER << 2;
-	} else if (path_data->sync_mode == CAM_ISP_HW_SYNC_SLAVE) {
+		val = CSID_HALT_MODE_MASTER << 2;
+	else if (path_data->sync_mode == CAM_ISP_HW_SYNC_SLAVE)
 		/*Set halt mode as slave and set master idx */
-		if (pxl_reg->halt_master_sel_en)
-			val = CSID_HALT_MODE_SLAVE << 2;
-		else
-			val = path_data->master_idx  << 4 |
-				CSID_HALT_MODE_SLAVE << 2;
-	} else {
+		val = path_data->master_idx  << 4 | CSID_HALT_MODE_SLAVE << 2;
+	else
 		/* Default is internal halt mode */
 		val = 0;
-	}
 
-	/* Resume at frame boundary */
-	if (!path_data->init_frame_drop) {
-		CAM_DBG(CAM_ISP,
-			"CSID:%d Starting %s path",
-			csid_hw->hw_intf->hw_idx, (is_ipp) ? "IPP" : "PPP");
-		if (path_data->sync_mode == CAM_ISP_HW_SYNC_MASTER ||
-			path_data->sync_mode == CAM_ISP_HW_SYNC_NONE)
-			val |= CAM_CSID_RESUME_AT_FRAME_BOUNDARY;
-	} else {
-		path_active = cam_ife_csid_check_path_active(csid_hw);
-		if (path_active) {
-			if (path_data->sync_mode == CAM_ISP_HW_SYNC_MASTER ||
-				path_data->sync_mode == CAM_ISP_HW_SYNC_NONE)
-				val |= CAM_CSID_RESUME_AT_FRAME_BOUNDARY;
-		}
-		CAM_DBG(CAM_ISP,
-			"CSID:%d %s %s path f drop %d val %d",
-			csid_hw->hw_intf->hw_idx,
-			path_active ? "Starting" : "Not Starting",
-			(is_ipp) ? "IPP" : "PPP",
-			path_data->init_frame_drop, val);
-	}
+	/*
+	 * Resume at frame boundary if Master or No Sync.
+	 * Slave will get resume command from Master.
+	 */
+	if (path_data->sync_mode == CAM_ISP_HW_SYNC_MASTER ||
+		path_data->sync_mode == CAM_ISP_HW_SYNC_NONE)
+		val |= CAM_CSID_RESUME_AT_FRAME_BOUNDARY;
 
 	cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
 		pxl_reg->csid_pxl_ctrl_addr);
 
 	CAM_DBG(CAM_ISP, "CSID:%d %s Ctrl val: 0x%x",
-		csid_hw->hw_intf->hw_idx,
-		(is_ipp) ? "IPP" : "PPP", val);
+			csid_hw->hw_intf->hw_idx,
+			(is_ipp) ? "IPP" : "PPP", val);
 
 	/* Enable the required pxl path interrupts */
 	val = CSID_PATH_INFO_RST_DONE | CSID_PATH_ERROR_FIFO_OVERFLOW;
@@ -2351,16 +2006,11 @@ static int cam_ife_csid_enable_pxl_path(
 	if (pxl_reg->overflow_ctrl_en)
 		val |= CSID_PATH_OVERFLOW_RECOVERY;
 
-	if ((csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ) ||
-		(path_data->init_frame_drop && !path_active))
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)
 		val |= CSID_PATH_INFO_INPUT_SOF;
 	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ)
 		val |= CSID_PATH_INFO_INPUT_EOF;
 
-	if (path_config->measure_enabled)
-		val |= (CSID_PATH_ERROR_PIX_COUNT |
-			CSID_PATH_ERROR_LINE_COUNT);
-
 	cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
 		pxl_reg->csid_pxl_irq_mask_addr);
 
@@ -2372,64 +2022,6 @@ static int cam_ife_csid_enable_pxl_path(
 	return 0;
 }
 
-
-static void cam_ife_csid_change_pxl_halt_mode(
-	struct cam_ife_csid_hw          *csid_hw,
-	struct cam_isp_resource_node    *res,
-	enum cam_ife_csid_halt_mode      halt_mode)
-{
-	uint32_t val = 0;
-	const struct cam_ife_csid_reg_offset       *csid_reg;
-	struct cam_hw_soc_info                     *soc_info;
-	struct cam_ife_csid_path_cfg               *path_data;
-	const struct cam_ife_csid_pxl_reg_offset   *pxl_reg;
-	bool                                        is_ipp;
-
-	path_data = (struct cam_ife_csid_path_cfg *) res->res_priv;
-	csid_reg = csid_hw->csid_info->csid_reg;
-	soc_info = &csid_hw->hw_info->soc_info;
-
-	if (res->res_id >= CAM_IFE_PIX_PATH_RES_MAX) {
-		CAM_ERR(CAM_ISP, "CSID:%d Invalid res id%d",
-			csid_hw->hw_intf->hw_idx, res->res_id);
-		goto end;
-	}
-
-	if (res->res_state == CAM_ISP_RESOURCE_STATE_INIT_HW ||
-		res->res_state == CAM_ISP_RESOURCE_STATE_RESERVED) {
-		CAM_ERR(CAM_ISP, "CSID:%d Res:%d already in stopped state:%d",
-			csid_hw->hw_intf->hw_idx, res->res_id, res->res_state);
-		goto end;
-	}
-
-	if (res->res_id == CAM_IFE_PIX_PATH_RES_IPP) {
-		is_ipp = true;
-		pxl_reg = csid_reg->ipp_reg;
-	} else {
-		goto end;
-	}
-
-	if (res->res_state != CAM_ISP_RESOURCE_STATE_STREAMING) {
-		CAM_ERR(CAM_ISP, "CSID:%d %s path Res:%d Invalid state%d",
-			csid_hw->hw_intf->hw_idx, (is_ipp) ? "IPP" : "PPP",
-			res->res_id, res->res_state);
-		goto end;
-	}
-
-	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
-		pxl_reg->csid_pxl_irq_mask_addr);
-
-	/* configure Halt for slave */
-	val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-		pxl_reg->csid_pxl_ctrl_addr);
-	val &= ~0xC;
-	val |= (halt_mode << 2);
-	cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-		pxl_reg->csid_pxl_ctrl_addr);
-end:
-	return;
-}
-
 static int cam_ife_csid_disable_pxl_path(
 	struct cam_ife_csid_hw          *csid_hw,
 	struct cam_isp_resource_node    *res,
@@ -2494,9 +2086,6 @@ static int cam_ife_csid_disable_pxl_path(
 		csid_hw->hw_intf->hw_idx, res->res_id,
 		(is_ipp) ? "IPP" : "PPP");
 
-	path_data->init_frame_drop = 0;
-	csid_hw->res_sof_cnt[res->res_id] = 0;
-
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
 		pxl_reg->csid_pxl_irq_mask_addr);
 
@@ -2535,10 +2124,9 @@ static int cam_ife_csid_init_config_rdi_path(
 	const struct cam_ife_csid_reg_offset   *csid_reg;
 	struct cam_hw_soc_info                 *soc_info;
 	uint32_t path_format = 0, plain_fmt = 0, val = 0, id;
-	uint32_t format_measure_addr, camera_hw_version;
-	uint32_t packing_fmt = 0, in_bpp = 0;
+	uint32_t format_measure_addr, camera_hw_version, packing_fmt = 0;
 
-	path_data = (struct cam_ife_csid_path_cfg *) res->res_priv;
+	path_data = (struct cam_ife_csid_path_cfg   *) res->res_priv;
 	csid_reg = csid_hw->csid_info->csid_reg;
 	soc_info = &csid_hw->hw_info->soc_info;
 
@@ -2551,7 +2139,7 @@ static int cam_ife_csid_init_config_rdi_path(
 
 	rc = cam_ife_csid_get_format_rdi(path_data->in_format,
 		path_data->out_format, &path_format, &plain_fmt, &packing_fmt,
-		path_data->crop_enable || path_data->drop_enable, &in_bpp);
+		path_data->crop_enable || path_data->drop_enable);
 	if (rc)
 		return rc;
 
@@ -2578,8 +2166,7 @@ static int cam_ife_csid_init_config_rdi_path(
 	CAM_DBG(CAM_ISP, "HW version: %x", camera_hw_version);
 
 	if (camera_hw_version == CAM_CPAS_TITAN_480_V100 ||
-		camera_hw_version == CAM_CPAS_TITAN_175_V130 ||
-		camera_hw_version == CAM_CPAS_TITAN_170_V200) {
+		camera_hw_version == CAM_CPAS_TITAN_175_V130) {
 		val |= (path_data->drop_enable <<
 			csid_reg->cmn_reg->drop_h_en_shift_val) |
 			(path_data->drop_enable <<
@@ -2632,35 +2219,6 @@ static int cam_ife_csid_init_config_rdi_path(
 			csid_reg->rdi_reg[id]->csid_rdi_err_recovery_cfg0_addr);
 	}
 
-	/* configure pixel format measure */
-	if (csid_hw->rdi_path_config[id].measure_enabled) {
-		val = ((csid_hw->rdi_path_config[id].height &
-		csid_reg->cmn_reg->format_measure_height_mask_val) <<
-		csid_reg->cmn_reg->format_measure_height_shift_val);
-
-		if (path_format == 0xF)
-			val |= (__KERNEL_DIV_ROUND_UP(
-				(csid_hw->rdi_path_config[id].width *
-				in_bpp), 8) &
-			csid_reg->cmn_reg->format_measure_width_mask_val);
-		else
-			val |= (csid_hw->rdi_path_config[id].width &
-			csid_reg->cmn_reg->format_measure_width_mask_val);
-
-		CAM_DBG(CAM_ISP, "CSID:%d format measure cfg1 value : 0x%x",
-			csid_hw->hw_intf->hw_idx, val);
-		CAM_DBG(CAM_ISP, "format measure width : 0x%x height : 0x%x",
-			csid_hw->rdi_path_config[id].width,
-			csid_hw->rdi_path_config[id].height);
-
-		cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-		csid_reg->rdi_reg[id]->csid_rdi_format_measure_cfg1_addr);
-
-		/* enable pixel and line counter */
-		cam_io_w_mb(3, soc_info->reg_map[0].mem_base +
-		csid_reg->rdi_reg[id]->csid_rdi_format_measure_cfg0_addr);
-	}
-
 	/* set frame drop pattern to 0 and period to 1 */
 	cam_io_w_mb(1, soc_info->reg_map[0].mem_base +
 		csid_reg->rdi_reg[id]->csid_rdi_frm_drop_period_addr);
@@ -2757,7 +2315,7 @@ static int cam_ife_csid_init_config_udi_path(
 	const struct cam_ife_csid_reg_offset   *csid_reg;
 	struct cam_hw_soc_info                 *soc_info;
 	uint32_t path_format = 0, plain_fmt = 0, val = 0, val1, id;
-	uint32_t format_measure_addr, packing_fmt = 0, in_bpp = 0;
+	uint32_t format_measure_addr, packing_fmt = 0;
 
 	path_data = (struct cam_ife_csid_path_cfg *)res->res_priv;
 	csid_reg = csid_hw->csid_info->csid_reg;
@@ -2772,7 +2330,7 @@ static int cam_ife_csid_init_config_udi_path(
 
 	rc = cam_ife_csid_get_format_rdi(path_data->in_format,
 		path_data->out_format, &path_format, &plain_fmt, &packing_fmt,
-		path_data->crop_enable || path_data->drop_enable, &in_bpp);
+		path_data->crop_enable || path_data->drop_enable);
 	if (rc) {
 		CAM_ERR(CAM_ISP,
 			"Failed to get format in_format: %u out_format: %u rc: %d",
@@ -3004,11 +2562,8 @@ static int cam_ife_csid_enable_rdi_path(
 {
 	const struct cam_ife_csid_reg_offset      *csid_reg;
 	struct cam_hw_soc_info                    *soc_info;
-	struct cam_ife_csid_path_cfg              *path_data;
 	uint32_t id, val;
-	bool path_active = false;
 
-	path_data = (struct cam_ife_csid_path_cfg   *) res->res_priv;
 	csid_reg = csid_hw->csid_info->csid_reg;
 	soc_info = &csid_hw->hw_info->soc_info;
 	id = res->res_id;
@@ -3023,28 +2578,10 @@ static int cam_ife_csid_enable_rdi_path(
 		return -EINVAL;
 	}
 
-	/*Drop one frame extra on RDI for dual IFE use case */
-	if (path_data->usage_type == CAM_ISP_RES_USAGE_DUAL)
-		path_data->init_frame_drop = 1;
-
 	/*resume at frame boundary */
-	if (!path_data->init_frame_drop) {
-		CAM_DBG(CAM_ISP, "Start RDI:%d path", id);
-		cam_io_w_mb(CAM_CSID_RESUME_AT_FRAME_BOUNDARY,
+	cam_io_w_mb(CAM_CSID_RESUME_AT_FRAME_BOUNDARY,
 			soc_info->reg_map[0].mem_base +
 			csid_reg->rdi_reg[id]->csid_rdi_ctrl_addr);
-	} else {
-		path_active = cam_ife_csid_check_path_active(csid_hw);
-		if (path_active)
-			cam_io_w_mb(CAM_CSID_RESUME_AT_FRAME_BOUNDARY,
-				soc_info->reg_map[0].mem_base +
-				csid_reg->rdi_reg[id]->csid_rdi_ctrl_addr);
-		CAM_DBG(CAM_ISP,
-			"CSID:%d %s RDI%d path frame drop %d val 0x%x",
-			csid_hw->hw_intf->hw_idx,
-			path_active ? "Starting" : "Not Starting", id,
-			path_data->init_frame_drop);
-	}
 
 	/* Enable the required RDI interrupts */
 	val = CSID_PATH_INFO_RST_DONE | CSID_PATH_ERROR_FIFO_OVERFLOW;
@@ -3055,17 +2592,11 @@ static int cam_ife_csid_enable_rdi_path(
 	if (csid_reg->rdi_reg[id]->overflow_ctrl_en)
 		val |= CSID_PATH_OVERFLOW_RECOVERY;
 
-	if ((csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ) ||
-		(path_data->init_frame_drop && !path_active))
+	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)
 		val |= CSID_PATH_INFO_INPUT_SOF;
-
 	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ)
 		val |= CSID_PATH_INFO_INPUT_EOF;
 
-	if (csid_hw->rdi_path_config[id].measure_enabled)
-		val |= (CSID_PATH_ERROR_PIX_COUNT |
-			CSID_PATH_ERROR_LINE_COUNT);
-
 	cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
 		csid_reg->rdi_reg[id]->csid_rdi_irq_mask_addr);
 
@@ -3134,12 +2665,10 @@ static int cam_ife_csid_disable_rdi_path(
 	uint32_t id, val = 0;
 	const struct cam_ife_csid_reg_offset       *csid_reg;
 	struct cam_hw_soc_info                     *soc_info;
-	struct cam_ife_csid_path_cfg               *path_data;
 
-	path_data = (struct cam_ife_csid_path_cfg *)res->res_priv;
-	csid_reg  = csid_hw->csid_info->csid_reg;
-	soc_info  = &csid_hw->hw_info->soc_info;
-	id        = res->res_id;
+	csid_reg = csid_hw->csid_info->csid_reg;
+	soc_info = &csid_hw->hw_info->soc_info;
+	id = res->res_id;
 
 	if ((res->res_id > CAM_IFE_PIX_PATH_RES_RDI_3) ||
 		(!csid_reg->rdi_reg[res->res_id])) {
@@ -3175,9 +2704,6 @@ static int cam_ife_csid_disable_rdi_path(
 	CAM_DBG(CAM_ISP, "CSID:%d res_id:%d",
 		csid_hw->hw_intf->hw_idx, res->res_id);
 
-	path_data->init_frame_drop = 0;
-	csid_hw->res_sof_cnt[id] = 0;
-
 	cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
 		csid_reg->rdi_reg[id]->csid_rdi_irq_mask_addr);
 
@@ -3397,6 +2923,7 @@ static int cam_ife_csid_get_time_stamp(
 	const struct cam_ife_csid_udi_reg_offset   *udi_reg;
 	struct timespec64 ts;
 	uint32_t  time_32, id;
+	uint64_t  time_delta;
 
 	time_stamp = (struct cam_csid_get_time_stamp_args  *)cmd_args;
 	res = time_stamp->node_res;
@@ -3468,19 +2995,20 @@ static int cam_ife_csid_get_time_stamp(
 		CAM_IFE_CSID_QTIMER_MUL_FACTOR,
 		CAM_IFE_CSID_QTIMER_DIV_FACTOR);
 
-	/* use a universal qtime-2-boottime offset for all cameras
-	 * this enables uniform timestamp comparision between cameras
-	 */
-	if (qtime_to_boottime == 0) {
+	if (!csid_hw->prev_boot_timestamp) {
 		get_monotonic_boottime64(&ts);
-		qtime_to_boottime =
-			(int64_t)((ts.tv_sec * 1000000000) + ts.tv_nsec) -
-			(int64_t)time_stamp->time_stamp_val;
-		CAM_DBG(CAM_ISP, "qtime_to_boottime:%lld", qtime_to_boottime);
+		time_stamp->boot_timestamp =
+			(uint64_t)((ts.tv_sec * 1000000000) +
+			ts.tv_nsec);
+		csid_hw->prev_qtimer_ts = 0;
+		CAM_DBG(CAM_ISP, "timestamp:%lld",
+			time_stamp->boot_timestamp);
+	} else {
+		time_delta = time_stamp->time_stamp_val -
+			csid_hw->prev_qtimer_ts;
+		time_stamp->boot_timestamp =
+			csid_hw->prev_boot_timestamp + time_delta;
 	}
-
-	time_stamp->boot_timestamp = time_stamp->time_stamp_val +
-		qtime_to_boottime;
 	csid_hw->prev_qtimer_ts = time_stamp->time_stamp_val;
 	csid_hw->prev_boot_timestamp = time_stamp->boot_timestamp;
 
@@ -3631,8 +3159,6 @@ int cam_ife_csid_release(void *hw_priv,
 	res = (struct cam_isp_resource_node *)release_args;
 
 	mutex_lock(&csid_hw->hw_info->hw_mutex);
-	csid_hw->event_cb = NULL;
-	csid_hw->priv = NULL;
 	if ((res->res_type == CAM_ISP_RESOURCE_CID &&
 		res->res_id >= CAM_IFE_CSID_CID_MAX) ||
 		(res->res_type == CAM_ISP_RESOURCE_PIX_PATH &&
@@ -3680,8 +3206,6 @@ int cam_ife_csid_release(void *hw_priv,
 		break;
 	case CAM_ISP_RESOURCE_PIX_PATH:
 		res->res_state = CAM_ISP_RESOURCE_STATE_AVAILABLE;
-		cam_ife_csid_reset_path_data(csid_hw, res);
-
 		break;
 	default:
 		CAM_ERR(CAM_ISP, "CSID:%d Invalid res type:%d res id%d",
@@ -3704,7 +3228,7 @@ static int cam_ife_csid_reset_regs(
 		csid_hw->csid_info->csid_reg;
 	struct cam_hw_soc_info          *soc_info;
 	uint32_t val = 0;
-	unsigned long flags, rem_jiffies = 0;
+	unsigned long flags;
 
 	soc_info = &csid_hw->hw_info->soc_info;
 
@@ -3749,9 +3273,9 @@ static int cam_ife_csid_reset_regs(
 
 	spin_unlock_irqrestore(&csid_hw->hw_info->hw_lock, flags);
 	CAM_DBG(CAM_ISP, "CSID reset start");
-	rem_jiffies = wait_for_completion_timeout(&csid_hw->csid_top_complete,
+	rc = wait_for_completion_timeout(&csid_hw->csid_top_complete,
 		msecs_to_jiffies(IFE_CSID_TIMEOUT));
-	if (rem_jiffies == 0) {
+	if (rc <= 0) {
 		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 			csid_reg->cmn_reg->csid_top_irq_status_addr);
 		if (val & 0x1) {
@@ -3763,18 +3287,19 @@ static int cam_ife_csid_reset_regs(
 			CAM_DBG(CAM_ISP, "CSID:%d %s reset completed %d",
 				csid_hw->hw_intf->hw_idx,
 				reset_hw ? "hw" : "sw",
-				rem_jiffies);
+				rc);
+			rc = 0;
 			goto end;
 		}
 		CAM_ERR(CAM_ISP, "CSID:%d csid_reset %s fail rc = %d",
-			csid_hw->hw_intf->hw_idx, reset_hw ? "hw" : "sw",
-			rem_jiffies);
+			csid_hw->hw_intf->hw_idx, reset_hw ? "hw" : "sw", rc);
 		rc = -ETIMEDOUT;
 		goto end;
-	} else
+	} else {
 		CAM_DBG(CAM_ISP, "CSID:%d %s reset completed %d",
-			csid_hw->hw_intf->hw_idx, reset_hw ? "hw" : "sw",
-			rem_jiffies);
+			csid_hw->hw_intf->hw_idx, reset_hw ? "hw" : "sw", rc);
+		rc = 0;
+	}
 
 end:
 	csid_hw->is_resetting = false;
@@ -3862,14 +3387,12 @@ int cam_ife_csid_init_hw(void *hw_priv,
 		break;
 	}
 
-	/* csid hw reset done after configuring the csi2  */
-	if (res->res_type != CAM_ISP_RESOURCE_CID) {
-		rc = cam_ife_csid_reset_regs(csid_hw, true);
-		if (rc) {
-			CAM_ERR(CAM_ISP, "CSID: Failed in HW reset");
-			cam_ife_csid_disable_hw(csid_hw);
-		}
-	}
+	rc = cam_ife_csid_reset_regs(csid_hw, true);
+	if (rc < 0)
+		CAM_ERR(CAM_ISP, "CSID: Failed in HW reset");
+
+	if (rc)
+		cam_ife_csid_disable_hw(csid_hw);
 
 end:
 	mutex_unlock(&csid_hw->hw_info->hw_mutex);
@@ -3983,8 +3506,6 @@ int cam_ife_csid_start(void *hw_priv, void *start_args,
 	csid_hw->irq_debug_cnt = 0;
 
 	spin_lock_irqsave(&csid_hw->lock_state, flags);
-	if (!csid_hw->device_enabled)
-		cam_ife_csid_csi2_irq_ctrl(csid_hw, true);
 	csid_hw->device_enabled = 1;
 	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
 
@@ -4026,41 +3547,6 @@ int cam_ife_csid_start(void *hw_priv, void *start_args,
 	return rc;
 }
 
-int cam_ife_csid_halt(struct cam_ife_csid_hw *csid_hw,
-		void *halt_args)
-{
-	struct cam_isp_resource_node         *res;
-	struct cam_csid_hw_halt_args         *csid_halt;
-
-	if (!csid_hw || !halt_args) {
-		CAM_ERR(CAM_ISP, "CSID: Invalid args");
-		return -EINVAL;
-	}
-
-	csid_halt = (struct cam_csid_hw_halt_args *)halt_args;
-
-	/* Change the halt mode */
-	res = csid_halt->node_res;
-	CAM_DBG(CAM_ISP, "CSID:%d res_type %d res_id %d",
-		csid_hw->hw_intf->hw_idx,
-		res->res_type, res->res_id);
-
-	switch (res->res_type) {
-	case CAM_ISP_RESOURCE_PIX_PATH:
-		if (res->res_id == CAM_IFE_PIX_PATH_RES_IPP)
-			cam_ife_csid_change_pxl_halt_mode(csid_hw, res,
-				csid_halt->halt_mode);
-		break;
-	default:
-		CAM_ERR(CAM_ISP, "CSID:%d Invalid res type%d",
-			csid_hw->hw_intf->hw_idx,
-			res->res_type);
-		break;
-	}
-
-	return 0;
-}
-
 int cam_ife_csid_stop(void *hw_priv,
 	void *stop_args, uint32_t arg_size)
 {
@@ -4091,11 +3577,6 @@ int cam_ife_csid_stop(void *hw_priv,
 		csid_hw->hw_intf->hw_idx,
 		csid_stop->num_res);
 
-	spin_lock_irqsave(&csid_hw->lock_state, flags);
-	csid_hw->device_enabled = 0;
-	cam_ife_csid_csi2_irq_ctrl(csid_hw, false);
-	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
-
 	/* Stop the resource first */
 	for (i = 0; i < csid_stop->num_res; i++) {
 		res = csid_stop->node_res[i];
@@ -4139,6 +3620,10 @@ int cam_ife_csid_stop(void *hw_priv,
 		}
 	}
 
+	spin_lock_irqsave(&csid_hw->lock_state, flags);
+	csid_hw->device_enabled = 0;
+	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
+
 	if (res_mask)
 		rc = cam_ife_csid_poll_stop_status(csid_hw, res_mask);
 
@@ -4248,13 +3733,6 @@ static int cam_ife_csid_sof_irq_debug(
 	CAM_INFO(CAM_ISP, "SOF freeze: CSID SOF irq %s",
 		(sof_irq_enable == true) ? "enabled" : "disabled");
 
-	CAM_INFO(CAM_ISP, "Notify CSIPHY: %d",
-		csid_hw->csi2_rx_cfg.phy_sel);
-
-	cam_subdev_notify_message(CAM_CSIPHY_DEVICE_TYPE,
-		CAM_SUBDEV_MESSAGE_IRQ_ERR,
-		csid_hw->csi2_rx_cfg.phy_sel);
-
 	return 0;
 }
 
@@ -4275,71 +3753,6 @@ static int cam_ife_csid_set_csid_clock(
 	return 0;
 }
 
-static int cam_ife_csid_dump_csid_clock(
-	struct cam_ife_csid_hw *csid_hw, void *cmd_args)
-{
-	if (!csid_hw)
-		return -EINVAL;
-
-	CAM_INFO(CAM_ISP, "CSID:%d clock rate %llu",
-		csid_hw->hw_intf->hw_idx,
-		csid_hw->clk_rate);
-
-	return 0;
-}
-
-static int cam_ife_csid_set_sensor_dimension(
-	struct cam_ife_csid_hw *csid_hw, void *cmd_args)
-{
-	struct cam_ife_sensor_dimension_update_args *dimension_update = NULL;
-	uint32_t i;
-
-	if (!csid_hw)
-		return -EINVAL;
-
-	dimension_update =
-		(struct cam_ife_sensor_dimension_update_args *)cmd_args;
-	csid_hw->ipp_path_config.measure_enabled =
-		dimension_update->ipp_path.measure_enabled;
-	if (dimension_update->ipp_path.measure_enabled) {
-		csid_hw->ipp_path_config.width  =
-			dimension_update->ipp_path.width;
-		csid_hw->ipp_path_config.height =
-			dimension_update->ipp_path.height;
-		CAM_DBG(CAM_ISP, "CSID ipp path width %d height %d",
-			csid_hw->ipp_path_config.width,
-			csid_hw->ipp_path_config.height);
-	}
-	csid_hw->ppp_path_config.measure_enabled =
-		dimension_update->ppp_path.measure_enabled;
-	if (dimension_update->ppp_path.measure_enabled) {
-		csid_hw->ppp_path_config.width  =
-			dimension_update->ppp_path.width;
-		csid_hw->ppp_path_config.height =
-			dimension_update->ppp_path.height;
-		CAM_DBG(CAM_ISP, "CSID ppp path width %d height %d",
-			csid_hw->ppp_path_config.width,
-			csid_hw->ppp_path_config.height);
-	}
-	for (i = 0; i <= CAM_IFE_PIX_PATH_RES_RDI_3; i++) {
-		csid_hw->rdi_path_config[i].measure_enabled
-			= dimension_update->rdi_path[i].measure_enabled;
-		if (csid_hw->rdi_path_config[i].measure_enabled) {
-			csid_hw->rdi_path_config[i].width =
-				dimension_update->rdi_path[i].width;
-			csid_hw->rdi_path_config[i].height =
-				dimension_update->rdi_path[i].height;
-			if (csid_hw->rdi_path_config[i].height == 1)
-				csid_hw->rdi_path_config[i].measure_enabled = 0;
-			CAM_DBG(CAM_ISP,
-				"CSID rdi path[%d] width %d height %d",
-				i, csid_hw->rdi_path_config[i].width,
-				csid_hw->rdi_path_config[i].height);
-		}
-	}
-	return 0;
-}
-
 static int cam_ife_csid_set_csid_qcfa(
 	struct cam_ife_csid_hw *csid_hw, void *cmd_args)
 {
@@ -4357,87 +3770,6 @@ static int cam_ife_csid_set_csid_qcfa(
 	return 0;
 }
 
-static int cam_ife_csid_dump_hw(
-	struct cam_ife_csid_hw *csid_hw, void *cmd_args)
-{
-	int                             i;
-	uint8_t                        *dst;
-	uint32_t                       *addr, *start;
-	uint32_t                        min_len;
-	uint32_t                        num_reg;
-	size_t                          remain_len;
-	struct cam_isp_hw_dump_header  *hdr;
-	struct cam_isp_hw_dump_args    *dump_args =
-		(struct cam_isp_hw_dump_args *)cmd_args;
-	struct cam_hw_soc_info         *soc_info;
-
-	if (!dump_args) {
-		CAM_ERR(CAM_ISP, "Invalid args");
-		return -EINVAL;
-	}
-	if (!dump_args->cpu_addr || !dump_args->buf_len) {
-		CAM_ERR(CAM_ISP,
-			"Invalid params %pK %zu",
-			(void *)dump_args->cpu_addr,
-			dump_args->buf_len);
-		return -EINVAL;
-	}
-	soc_info = &csid_hw->hw_info->soc_info;
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_ISP,
-			"Dump offset overshoot offset %zu buf_len %zu",
-			dump_args->offset, dump_args->buf_len);
-		return -ENOSPC;
-	}
-	min_len = soc_info->reg_map[0].size +
-		sizeof(struct cam_isp_hw_dump_header) +
-		sizeof(uint32_t);
-	remain_len = dump_args->buf_len - dump_args->offset;
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_ISP, "Dump buffer exhaust remain %zu, min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_isp_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_ISP_HW_DUMP_TAG_MAX_LEN, "CSID_REG:");
-	addr = (uint32_t *)(dst + sizeof(struct cam_isp_hw_dump_header));
-
-	start = addr;
-	num_reg = soc_info->reg_map[0].size/4;
-	hdr->word_size = sizeof(uint32_t);
-	*addr = soc_info->index;
-	addr++;
-	for (i = 0; i < num_reg; i++) {
-		addr[0] = soc_info->mem_block[0]->start + (i*4);
-		addr[1] = cam_io_r(soc_info->reg_map[0].mem_base
-			+ (i*4));
-		addr += 2;
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset +=  hdr->size +
-		sizeof(struct cam_isp_hw_dump_header);
-	CAM_DBG(CAM_ISP, "offset %zu", dump_args->offset);
-	return 0;
-}
-
-static int cam_ife_csid_set_epd_config(
-	struct cam_ife_csid_hw *csid_hw, void *cmd_args)
-{
-	struct cam_ife_csid_epd_update_args *epd_update = NULL;
-
-	if ((!csid_hw) || (!cmd_args))
-		return -EINVAL;
-
-	epd_update =
-		(struct cam_ife_csid_epd_update_args *)cmd_args;
-
-	csid_hw->epd_supported = epd_update->epd_supported;
-	CAM_DBG(CAM_ISP, "CSID EPD supported %d", csid_hw->epd_supported);
-
-	return 0;
-}
-
 static int cam_ife_csid_process_cmd(void *hw_priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
 {
@@ -4472,24 +3804,9 @@ static int cam_ife_csid_process_cmd(void *hw_priv,
 	case CAM_ISP_HW_CMD_CSID_CLOCK_UPDATE:
 		rc = cam_ife_csid_set_csid_clock(csid_hw, cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_CSID_CLOCK_DUMP:
-		rc = cam_ife_csid_dump_csid_clock(csid_hw, cmd_args);
-		break;
 	case CAM_ISP_HW_CMD_CSID_QCFA_SUPPORTED:
 		rc = cam_ife_csid_set_csid_qcfa(csid_hw, cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_DUMP_HW:
-		rc = cam_ife_csid_dump_hw(csid_hw, cmd_args);
-		break;
-	case CAM_IFE_CSID_SET_CONFIG:
-		rc = cam_ife_csid_set_epd_config(csid_hw, cmd_args);
-		break;
-	case CAM_IFE_CSID_SET_SENSOR_DIMENSION_CFG:
-		rc = cam_ife_csid_set_sensor_dimension(csid_hw, cmd_args);
-		break;
-	case CAM_ISP_HW_CMD_CSID_CHANGE_HALT_MODE:
-		rc = cam_ife_csid_halt(csid_hw, cmd_args);
-		break;
 	default:
 		CAM_ERR(CAM_ISP, "CSID:%d unsupported cmd:%d",
 			csid_hw->hw_intf->hw_idx, cmd_type);
@@ -4501,212 +3818,16 @@ static int cam_ife_csid_process_cmd(void *hw_priv,
 
 }
 
-static int cam_csid_get_evt_payload(
-	struct cam_ife_csid_hw *csid_hw,
-	struct cam_csid_evt_payload **evt_payload)
-{
-
-	spin_lock(&csid_hw->lock_state);
-
-	if (list_empty(&csid_hw->free_payload_list)) {
-		*evt_payload = NULL;
-		spin_unlock(&csid_hw->lock_state);
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "No free payload core %d",
-			csid_hw->hw_intf->hw_idx);
-		return -ENOMEM;
-	}
-
-	*evt_payload = list_first_entry(&csid_hw->free_payload_list,
-			struct cam_csid_evt_payload, list);
-	list_del_init(&(*evt_payload)->list);
-	spin_unlock(&csid_hw->lock_state);
-
-	return 0;
-}
-
-static int cam_csid_put_evt_payload(
-	struct cam_ife_csid_hw *csid_hw,
-	struct cam_csid_evt_payload **evt_payload)
-{
-	unsigned long flags;
-
-	if (*evt_payload == NULL) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid payload core %d",
-			csid_hw->hw_intf->hw_idx);
-		return -EINVAL;
-	}
-	spin_lock_irqsave(&csid_hw->lock_state, flags);
-	list_add_tail(&(*evt_payload)->list,
-		&csid_hw->free_payload_list);
-	*evt_payload = NULL;
-	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
-
-	return 0;
-}
-static char *cam_csid_status_to_str(uint32_t status)
-{
-	switch (status) {
-	case CAM_IFE_CSID_IRQ_REG_TOP:
-		return "TOP";
-	case CAM_IFE_CSID_IRQ_REG_RX:
-		return "RX";
-	case CAM_IFE_CSID_IRQ_REG_IPP:
-		return "IPP";
-	case CAM_IFE_CSID_IRQ_REG_PPP:
-		return "PPP";
-	case CAM_IFE_CSID_IRQ_REG_RDI_0:
-		return "RDI0";
-	case CAM_IFE_CSID_IRQ_REG_RDI_1:
-		return "RDI1";
-	case CAM_IFE_CSID_IRQ_REG_RDI_2:
-		return "RDI2";
-	case CAM_IFE_CSID_IRQ_REG_RDI_3:
-		return "RDI3";
-	case CAM_IFE_CSID_IRQ_REG_UDI_0:
-		return "UDI0";
-	case CAM_IFE_CSID_IRQ_REG_UDI_1:
-		return "UDI1";
-	case CAM_IFE_CSID_IRQ_REG_UDI_2:
-		return "UDI2";
-	default:
-		return "Invalid IRQ";
-	}
-}
-
-static int cam_csid_evt_bottom_half_handler(
-	void *handler_priv,
-	void *evt_payload_priv)
-{
-	struct cam_ife_csid_hw *csid_hw;
-	struct cam_csid_evt_payload *evt_payload;
-	int i;
-	int rc = 0;
-	struct cam_isp_hw_event_info event_info;
-
-	if (!handler_priv || !evt_payload_priv) {
-		CAM_ERR(CAM_ISP,
-			"Invalid Param handler_priv %pK evt_payload_priv %pK",
-			handler_priv, evt_payload_priv);
-		return 0;
-	}
-
-	csid_hw = (struct cam_ife_csid_hw *)handler_priv;
-	evt_payload = (struct cam_csid_evt_payload *)evt_payload_priv;
-
-	if (!csid_hw->event_cb || !csid_hw->priv) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"hw_idx %d Invalid args %pK %pK",
-			csid_hw->hw_intf->hw_idx,
-			csid_hw->event_cb,
-			csid_hw->priv);
-		goto end;
-	}
-
-	if (csid_hw->priv != evt_payload->priv) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"hw_idx %d priv mismatch %pK, %pK",
-			csid_hw->hw_intf->hw_idx,
-			csid_hw->priv,
-			evt_payload->priv);
-		goto end;
-	}
-
-	CAM_ERR_RATE_LIMIT(CAM_ISP,
-		"idx %d err %d phy %d  lane type:%d ln num:%d ln cfg:0x%x cnt %d",
-		csid_hw->hw_intf->hw_idx,
-		evt_payload->evt_type,
-		csid_hw->csi2_rx_cfg.phy_sel,
-		csid_hw->csi2_rx_cfg.lane_type,
-		csid_hw->csi2_rx_cfg.lane_num,
-		csid_hw->csi2_rx_cfg.lane_cfg,
-		csid_hw->csi2_cfg_cnt);
-
-	for (i = 0; i < CAM_IFE_CSID_IRQ_REG_MAX; i++)
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "status %s: %x",
-			cam_csid_status_to_str(i),
-			evt_payload->irq_status[i]);
-
-	/* this hunk can be extended to handle more cases
-	 * which we want to offload to bottom half from
-	 * irq handlers
-	 */
-	event_info.err_type = evt_payload->evt_type;
-	event_info.hw_idx = evt_payload->hw_idx;
-
-	switch (evt_payload->evt_type) {
-	case CAM_ISP_HW_ERROR_CSID_FATAL:
-		if (csid_hw->fatal_err_detected)
-			break;
-		csid_hw->fatal_err_detected = true;
-		rc = csid_hw->event_cb(NULL,
-			CAM_ISP_HW_EVENT_ERROR, (void *)&event_info);
-		break;
-
-	default:
-		CAM_DBG(CAM_ISP, "CSID[%d] invalid error type %d",
-			csid_hw->hw_intf->hw_idx,
-			evt_payload->evt_type);
-		break;
-	}
-end:
-	cam_csid_put_evt_payload(csid_hw, &evt_payload);
-	return 0;
-}
-
-static int cam_csid_handle_hw_err_irq(
-	struct cam_ife_csid_hw *csid_hw,
-	int                     evt_type,
-	uint32_t               *irq_status)
-{
-	int      rc = 0;
-	int      i;
-	void    *bh_cmd = NULL;
-	struct cam_csid_evt_payload *evt_payload;
-
-	CAM_DBG(CAM_ISP, "CSID[%d] error %d",
-		csid_hw->hw_intf->hw_idx, evt_type);
-
-	rc = cam_csid_get_evt_payload(csid_hw, &evt_payload);
-	if (rc) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"No free payload core %d",
-			csid_hw->hw_intf->hw_idx);
-		return rc;
-	}
-
-	rc = tasklet_bh_api.get_bh_payload_func(csid_hw->tasklet, &bh_cmd);
-	if (rc || !bh_cmd) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP,
-			"CSID[%d] Can not get cmd for tasklet, evt_type %d",
-			csid_hw->hw_intf->hw_idx,
-			evt_type);
-		return rc;
-	}
-
-	evt_payload->evt_type = evt_type;
-	evt_payload->priv = csid_hw->priv;
-	evt_payload->hw_idx = csid_hw->hw_intf->hw_idx;
-
-	for (i = 0; i < CAM_IFE_CSID_IRQ_REG_MAX; i++)
-		evt_payload->irq_status[i] = irq_status[i];
-
-	tasklet_bh_api.bottom_half_enqueue_func(csid_hw->tasklet,
-		bh_cmd,
-		csid_hw,
-		evt_payload,
-		cam_csid_evt_bottom_half_handler);
-
-	return rc;
-}
-
 irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 {
 	struct cam_ife_csid_hw                         *csid_hw;
 	struct cam_hw_soc_info                         *soc_info;
 	const struct cam_ife_csid_reg_offset           *csid_reg;
 	const struct cam_ife_csid_csi2_rx_reg_offset   *csi2_reg;
-	uint32_t i, val, val2;
-	uint32_t irq_status[CAM_IFE_CSID_IRQ_REG_MAX] = {0};
+	uint32_t i, irq_status_top, irq_status_rx, irq_status_ipp = 0;
+	uint32_t irq_status_rdi[CAM_IFE_CSID_RDI_MAX] = {0, 0, 0, 0};
+	uint32_t irq_status_udi[CAM_IFE_CSID_UDI_MAX] = {0, 0, 0};
+	uint32_t val, irq_status_ppp = 0;
 	bool fatal_err_detected = false;
 	uint32_t sof_irq_debug_en = 0;
 	unsigned long flags;
@@ -4725,27 +3846,23 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 	csi2_reg = csid_reg->csi2_reg;
 
 	/* read */
-	irq_status[CAM_IFE_CSID_IRQ_REG_TOP] =
-		cam_io_r_mb(soc_info->reg_map[0].mem_base +
+	irq_status_top = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 		csid_reg->cmn_reg->csid_top_irq_status_addr);
 
-	irq_status[CAM_IFE_CSID_IRQ_REG_RX] =
-		cam_io_r_mb(soc_info->reg_map[0].mem_base +
+	irq_status_rx = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 		csid_reg->csi2_reg->csid_csi2_rx_irq_status_addr);
 
 	if (csid_reg->cmn_reg->num_pix)
-		irq_status[CAM_IFE_CSID_IRQ_REG_IPP] =
-			cam_io_r_mb(soc_info->reg_map[0].mem_base +
+		irq_status_ipp = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 			csid_reg->ipp_reg->csid_pxl_irq_status_addr);
 
 	if (csid_reg->cmn_reg->num_ppp)
-		irq_status[CAM_IFE_CSID_IRQ_REG_PPP] =
-			cam_io_r_mb(soc_info->reg_map[0].mem_base +
+		irq_status_ppp = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 			csid_reg->ppp_reg->csid_pxl_irq_status_addr);
 
 	if (csid_reg->cmn_reg->num_rdis <= CAM_IFE_CSID_RDI_MAX) {
 		for (i = 0; i < csid_reg->cmn_reg->num_rdis; i++) {
-			irq_status[i] =
+			irq_status_rdi[i] =
 				cam_io_r_mb(soc_info->reg_map[0].mem_base +
 				csid_reg->rdi_reg[i]->csid_rdi_irq_status_addr);
 		}
@@ -4753,7 +3870,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 
 	if (csid_reg->cmn_reg->num_udis <= CAM_IFE_CSID_UDI_MAX) {
 		for (i = 0; i < csid_reg->cmn_reg->num_udis; i++) {
-			irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] =
+			irq_status_udi[i] =
 				cam_io_r_mb(soc_info->reg_map[0].mem_base +
 				csid_reg->udi_reg[i]->csid_udi_irq_status_addr);
 		}
@@ -4761,26 +3878,22 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 
 	spin_lock_irqsave(&csid_hw->hw_info->hw_lock, flags);
 	/* clear */
-	cam_io_w_mb(irq_status[CAM_IFE_CSID_IRQ_REG_TOP],
-		soc_info->reg_map[0].mem_base +
+	cam_io_w_mb(irq_status_top, soc_info->reg_map[0].mem_base +
 		csid_reg->cmn_reg->csid_top_irq_clear_addr);
 
-	cam_io_w_mb(irq_status[CAM_IFE_CSID_IRQ_REG_RX],
-		soc_info->reg_map[0].mem_base +
+	cam_io_w_mb(irq_status_rx, soc_info->reg_map[0].mem_base +
 		csid_reg->csi2_reg->csid_csi2_rx_irq_clear_addr);
 	if (csid_reg->cmn_reg->num_pix)
-		cam_io_w_mb(irq_status[CAM_IFE_CSID_IRQ_REG_IPP],
-			soc_info->reg_map[0].mem_base +
+		cam_io_w_mb(irq_status_ipp, soc_info->reg_map[0].mem_base +
 			csid_reg->ipp_reg->csid_pxl_irq_clear_addr);
 
 	if (csid_reg->cmn_reg->num_ppp)
-		cam_io_w_mb(irq_status[CAM_IFE_CSID_IRQ_REG_PPP],
-			soc_info->reg_map[0].mem_base +
+		cam_io_w_mb(irq_status_ppp, soc_info->reg_map[0].mem_base +
 			csid_reg->ppp_reg->csid_pxl_irq_clear_addr);
 
 	if (csid_reg->cmn_reg->num_rdis <= CAM_IFE_CSID_RDI_MAX) {
 		for (i = 0; i < csid_reg->cmn_reg->num_rdis; i++) {
-			cam_io_w_mb(irq_status[i],
+			cam_io_w_mb(irq_status_rdi[i],
 				soc_info->reg_map[0].mem_base +
 				csid_reg->rdi_reg[i]->csid_rdi_irq_clear_addr);
 		}
@@ -4788,7 +3901,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 
 	if (csid_reg->cmn_reg->num_udis <= CAM_IFE_CSID_UDI_MAX) {
 		for (i = 0; i < csid_reg->cmn_reg->num_udis; i++) {
-			cam_io_w_mb(irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i],
+			cam_io_w_mb(irq_status_udi[i],
 				soc_info->reg_map[0].mem_base +
 				csid_reg->udi_reg[i]->csid_udi_irq_clear_addr);
 		}
@@ -4799,24 +3912,18 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 
 	spin_unlock_irqrestore(&csid_hw->hw_info->hw_lock, flags);
 
-	CAM_DBG(CAM_ISP, "irq_status_top = 0x%x",
-		irq_status[CAM_IFE_CSID_IRQ_REG_TOP]);
-	CAM_DBG(CAM_ISP, "irq_status_rx = 0x%x",
-		irq_status[CAM_IFE_CSID_IRQ_REG_RX]);
-	CAM_DBG(CAM_ISP, "irq_status_ipp = 0x%x",
-		irq_status[CAM_IFE_CSID_IRQ_REG_IPP]);
-	CAM_DBG(CAM_ISP, "irq_status_ppp = 0x%x",
-		irq_status[CAM_IFE_CSID_IRQ_REG_PPP]);
+	CAM_DBG(CAM_ISP, "irq_status_top = 0x%x", irq_status_top);
+	CAM_DBG(CAM_ISP, "irq_status_rx = 0x%x", irq_status_rx);
+	CAM_DBG(CAM_ISP, "irq_status_ipp = 0x%x", irq_status_ipp);
+	CAM_DBG(CAM_ISP, "irq_status_ppp = 0x%x", irq_status_ppp);
 	CAM_DBG(CAM_ISP,
 		"irq_status_rdi0= 0x%x irq_status_rdi1= 0x%x irq_status_rdi2= 0x%x",
-		irq_status[0], irq_status[1], irq_status[2]);
+		irq_status_rdi[0], irq_status_rdi[1], irq_status_rdi[2]);
 	CAM_DBG(CAM_ISP,
 		"irq_status_udi0= 0x%x irq_status_udi1= 0x%x irq_status_udi2= 0x%x",
-		irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0],
-		irq_status[CAM_IFE_CSID_IRQ_REG_UDI_1],
-		irq_status[CAM_IFE_CSID_IRQ_REG_UDI_2]);
+		irq_status_udi[0], irq_status_udi[1], irq_status_udi[2]);
 
-	if (irq_status[CAM_IFE_CSID_IRQ_REG_TOP] & CSID_TOP_IRQ_DONE) {
+	if (irq_status_top & CSID_TOP_IRQ_DONE) {
 		CAM_DBG(CAM_ISP, "csid top reset complete");
 		complete(&csid_hw->csid_top_complete);
 		csid_hw->is_resetting = false;
@@ -4829,102 +3936,78 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 		return IRQ_HANDLED;
 	}
 
-	if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-		BIT(csid_reg->csi2_reg->csi2_rst_done_shift_val)) {
+	if (irq_status_rx & BIT(csid_reg->csi2_reg->csi2_rst_done_shift_val)) {
 		CAM_DBG(CAM_ISP, "csi rx reset complete");
 		complete(&csid_hw->csid_csi2_complete);
 	}
 
 	spin_lock_irqsave(&csid_hw->lock_state, flags);
 	if (csid_hw->device_enabled == 1) {
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_LANE0_FIFO_OVERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_LANE0_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d lane 0 over flow",
 				 csid_hw->hw_intf->hw_idx);
 			fatal_err_detected = true;
-			goto handle_fatal_error;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_LANE1_FIFO_OVERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_LANE1_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d lane 1 over flow",
 				 csid_hw->hw_intf->hw_idx);
 			fatal_err_detected = true;
-			goto handle_fatal_error;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_LANE2_FIFO_OVERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_LANE2_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d lane 2 over flow",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			fatal_err_detected = true;
-			goto handle_fatal_error;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_LANE3_FIFO_OVERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_LANE3_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d lane 3 over flow",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			fatal_err_detected = true;
-			goto handle_fatal_error;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_TG_FIFO_OVERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_TG_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d TG OVER FLOW",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			fatal_err_detected = true;
-			goto handle_fatal_error;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_CPHY_EOT_RECEPTION) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_CPHY_EOT_RECEPTION) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d CPHY_EOT_RECEPTION",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			csid_hw->error_irq_count++;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_CPHY_SOT_RECEPTION) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_CPHY_SOT_RECEPTION) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d CPHY_SOT_RECEPTION",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			csid_hw->error_irq_count++;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_CPHY_PH_CRC) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_CPHY_PH_CRC) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d CPHY_PH_CRC",
-				csid_hw->hw_intf->hw_idx);
-			csid_hw->error_irq_count++;
+				 csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_CRC) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_CRC) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d ERROR_CRC",
-				csid_hw->hw_intf->hw_idx);
-			csid_hw->error_irq_count++;
+				 csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_ECC) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_ECC) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d ERROR_ECC",
-				csid_hw->hw_intf->hw_idx);
-			csid_hw->error_irq_count++;
+				 csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_MMAPPED_VC_DT) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_MMAPPED_VC_DT) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d MMAPPED_VC_DT",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_STREAM_UNDERFLOW) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_STREAM_UNDERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d ERROR_STREAM_UNDERFLOW",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			csid_hw->error_irq_count++;
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_ERROR_UNBOUNDED_FRAME) {
+		if (irq_status_rx & CSID_CSI2_RX_ERROR_UNBOUNDED_FRAME) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP, "CSID:%d UNBOUNDED_FRAME",
-				csid_hw->hw_intf->hw_idx);
+				 csid_hw->hw_intf->hw_idx);
 			csid_hw->error_irq_count++;
 		}
 	}
-
-handle_fatal_error:
 	spin_unlock_irqrestore(&csid_hw->lock_state, flags);
 
 	if (csid_hw->error_irq_count >
@@ -4933,33 +4016,26 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 		csid_hw->error_irq_count = 0;
 	}
 
-	if (fatal_err_detected) {
+	if (fatal_err_detected)
 		cam_ife_csid_halt_csi2(csid_hw);
-		cam_csid_handle_hw_err_irq(csid_hw,
-			CAM_ISP_HW_ERROR_CSID_FATAL, irq_status);
-	}
 
 	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOT_IRQ) {
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL0_EOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL0_EOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL0_EOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL1_EOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL1_EOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL1_EOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL2_EOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL2_EOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL2_EOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL3_EOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL3_EOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL3_EOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
@@ -4967,26 +4043,22 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 	}
 
 	if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOT_IRQ) {
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL0_SOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL0_SOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL0_SOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL1_SOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL1_SOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL1_SOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL2_SOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL2_SOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL2_SOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
 		}
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_PHY_DL3_SOT_CAPTURED) {
+		if (irq_status_rx & CSID_CSI2_RX_INFO_PHY_DL3_SOT_CAPTURED) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PHY_DL3_SOT_CAPTURED",
 				csid_hw->hw_intf->hw_idx);
@@ -4994,9 +4066,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 	}
 
 	if ((csid_hw->csid_debug & CSID_DEBUG_ENABLE_LONG_PKT_CAPTURE) &&
-		(irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_LONG_PKT_CAPTURED)) {
-
+		(irq_status_rx & CSID_CSI2_RX_INFO_LONG_PKT_CAPTURED)) {
 		CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d LONG_PKT_CAPTURED",
 			csid_hw->hw_intf->hw_idx);
 		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
@@ -5016,9 +4086,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 			csid_hw->hw_intf->hw_idx, (val >> 16), (val & 0xFFFF));
 	}
 	if ((csid_hw->csid_debug & CSID_DEBUG_ENABLE_SHORT_PKT_CAPTURE) &&
-		(irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_SHORT_PKT_CAPTURED)) {
-
+		(irq_status_rx & CSID_CSI2_RX_INFO_SHORT_PKT_CAPTURED)) {
 		CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d SHORT_PKT_CAPTURED",
 			csid_hw->hw_intf->hw_idx);
 		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
@@ -5026,7 +4094,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 		CAM_INFO_RATE_LIMIT(CAM_ISP,
 			"CSID:%d short pkt VC :%d DT:%d LC:%d",
 			csid_hw->hw_intf->hw_idx,
-			(val >> 22), ((val >> 16) & 0x3F), (val & 0xFFFF));
+			(val >> 22), ((val >> 16) & 0x1F), (val & 0xFFFF));
 		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
 			csi2_reg->csid_csi2_rx_captured_short_pkt_1_addr);
 		CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d short packet ECC :%d",
@@ -5034,8 +4102,7 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 	}
 
 	if ((csid_hw->csid_debug & CSID_DEBUG_ENABLE_CPHY_PKT_CAPTURE) &&
-		(irq_status[CAM_IFE_CSID_IRQ_REG_RX] &
-			CSID_CSI2_RX_INFO_CPHY_PKT_HDR_CAPTURED)) {
+		(irq_status_rx & CSID_CSI2_RX_INFO_CPHY_PKT_HDR_CAPTURED)) {
 		CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d CPHY_PKT_HDR_CAPTURED",
 			csid_hw->hw_intf->hw_idx);
 		val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
@@ -5043,20 +4110,19 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 		CAM_INFO_RATE_LIMIT(CAM_ISP,
 			"CSID:%d cphy packet VC :%d DT:%d WC:%d",
 			csid_hw->hw_intf->hw_idx,
-			(val >> 22), ((val >> 16) & 0x3F), (val & 0xFFFF));
+			(val >> 22), ((val >> 16) & 0x1F), (val & 0xFFFF));
 	}
 
 	/*read the IPP errors */
 	if (csid_reg->cmn_reg->num_pix) {
 		/* IPP reset done bit */
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
+		if (irq_status_ipp &
 			BIT(csid_reg->cmn_reg->path_rst_done_shift_val)) {
 			CAM_DBG(CAM_ISP, "CSID IPP reset complete");
 			complete(&csid_hw->csid_ipp_complete);
 		}
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_INFO_INPUT_SOF) &&
+		if ((irq_status_ipp & CSID_PATH_INFO_INPUT_SOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d IPP SOF received",
 				csid_hw->hw_intf->hw_idx);
@@ -5064,26 +4130,22 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 				csid_hw->irq_debug_cnt++;
 		}
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_INFO_INPUT_EOF) &&
+		if ((irq_status_ipp & CSID_PATH_INFO_INPUT_EOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ))
 			CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d IPP EOF received",
 				csid_hw->hw_intf->hw_idx);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_ERROR_CCIF_VIOLATION))
+		if ((irq_status_ipp & CSID_PATH_ERROR_CCIF_VIOLATION))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d IPP CCIF violation",
 				csid_hw->hw_intf->hw_idx);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_OVERFLOW_RECOVERY))
+		if ((irq_status_ipp & CSID_PATH_OVERFLOW_RECOVERY))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d IPP Overflow due to back pressure",
 				csid_hw->hw_intf->hw_idx);
 
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_ERROR_FIFO_OVERFLOW) {
+		if (irq_status_ipp & CSID_PATH_ERROR_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d IPP fifo over flow",
 				csid_hw->hw_intf->hw_idx);
@@ -5092,72 +4154,41 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 				soc_info->reg_map[0].mem_base +
 				csid_reg->ipp_reg->csid_pxl_ctrl_addr);
 		}
-
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_ERROR_PIX_COUNT) ||
-			(irq_status[CAM_IFE_CSID_IRQ_REG_IPP] &
-			CSID_PATH_ERROR_LINE_COUNT)) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->ipp_reg->csid_pxl_format_measure0_addr);
-
-			CAM_ERR(CAM_ISP,
-				"CSID:%d irq_status_ipp:0x%x",
-				csid_hw->hw_intf->hw_idx,
-				irq_status[CAM_IFE_CSID_IRQ_REG_IPP]);
-			CAM_ERR(CAM_ISP,
-			"Expected:: h: 0x%x w: 0x%x actual:: h: 0x%x w: 0x%x",
-			csid_hw->ipp_path_config.height,
-			csid_hw->ipp_path_config.width,
-			((val >>
-			csid_reg->cmn_reg->format_measure_height_shift_val) &
-			csid_reg->cmn_reg->format_measure_height_mask_val),
-			val &
-			csid_reg->cmn_reg->format_measure_width_mask_val);
-		}
 	}
 
 	/*read PPP errors */
 	if (csid_reg->cmn_reg->num_ppp) {
 		/* PPP reset done bit */
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
+		if (irq_status_ppp &
 			BIT(csid_reg->cmn_reg->path_rst_done_shift_val)) {
 			CAM_DBG(CAM_ISP, "CSID PPP reset complete");
 			complete(&csid_hw->csid_ppp_complete);
 		}
 
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_INFO_INPUT_SOF) {
-			cam_ife_csid_enable_path_for_init_frame_drop(csid_hw,
-				CAM_IFE_PIX_PATH_RES_PPP);
-			if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)
-				CAM_INFO_RATE_LIMIT(CAM_ISP,
-					"CSID:%d PPP SOF received",
-					csid_hw->hw_intf->hw_idx);
+		if ((irq_status_ppp & CSID_PATH_INFO_INPUT_SOF) &&
+			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)) {
+			CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d PPP SOF received",
+				csid_hw->hw_intf->hw_idx);
 			if (csid_hw->sof_irq_triggered)
 				csid_hw->irq_debug_cnt++;
 		}
 
-
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_INFO_INPUT_EOF) &&
+		if ((irq_status_ppp & CSID_PATH_INFO_INPUT_EOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ))
 			CAM_INFO_RATE_LIMIT(CAM_ISP, "CSID:%d PPP EOF received",
 				csid_hw->hw_intf->hw_idx);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_ERROR_CCIF_VIOLATION))
+		if ((irq_status_ppp & CSID_PATH_ERROR_CCIF_VIOLATION))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PPP CCIF violation",
 				csid_hw->hw_intf->hw_idx);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_OVERFLOW_RECOVERY))
+		if ((irq_status_ppp & CSID_PATH_OVERFLOW_RECOVERY))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID:%d IPP Overflow due to back pressure",
 				csid_hw->hw_intf->hw_idx);
 
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_ERROR_FIFO_OVERFLOW) {
+		if (irq_status_ppp & CSID_PATH_ERROR_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d PPP fifo over flow",
 				csid_hw->hw_intf->hw_idx);
@@ -5166,63 +4197,38 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 				soc_info->reg_map[0].mem_base +
 				csid_reg->ppp_reg->csid_pxl_ctrl_addr);
 		}
-
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			CSID_PATH_ERROR_PIX_COUNT) ||
-			(irq_status[CAM_IFE_CSID_IRQ_REG_PPP] &
-			 CSID_PATH_ERROR_LINE_COUNT)) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->ppp_reg->csid_pxl_format_measure0_addr);
-
-			CAM_ERR(CAM_ISP,
-				"CSID:%d irq_status_ppp:0x%x",
-				csid_hw->hw_intf->hw_idx,
-				irq_status[CAM_IFE_CSID_IRQ_REG_PPP]);
-			CAM_ERR(CAM_ISP,
-			"Expected:: h:  0x%x w: 0x%x actual:: h: 0x%x w: 0x%x",
-			csid_hw->ppp_path_config.height,
-			csid_hw->ppp_path_config.width,
-			((val >>
-			csid_reg->cmn_reg->format_measure_height_shift_val) &
-			csid_reg->cmn_reg->format_measure_height_mask_val),
-			val &
-			csid_reg->cmn_reg->format_measure_width_mask_val);
-		}
 	}
 
 	for (i = 0; i < csid_reg->cmn_reg->num_rdis; i++) {
-		if (irq_status[i] &
+		if (irq_status_rdi[i] &
 			BIT(csid_reg->cmn_reg->path_rst_done_shift_val)) {
 			CAM_DBG(CAM_ISP, "CSID RDI%d reset complete", i);
 			complete(&csid_hw->csid_rdin_complete[i]);
 		}
 
-		if (irq_status[i] & CSID_PATH_INFO_INPUT_SOF) {
-			cam_ife_csid_enable_path_for_init_frame_drop(
-				csid_hw, i);
-			if (csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)
-				CAM_INFO_RATE_LIMIT(CAM_ISP,
-					"CSID RDI:%d SOF received", i);
+		if ((irq_status_rdi[i] & CSID_PATH_INFO_INPUT_SOF) &&
+			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)) {
+			CAM_INFO_RATE_LIMIT(CAM_ISP,
+				"CSID RDI:%d SOF received", i);
 			if (csid_hw->sof_irq_triggered)
 				csid_hw->irq_debug_cnt++;
 		}
 
-
-		if ((irq_status[i]  & CSID_PATH_INFO_INPUT_EOF) &&
+		if ((irq_status_rdi[i]  & CSID_PATH_INFO_INPUT_EOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID RDI:%d EOF received", i);
 
-		if ((irq_status[i] & CSID_PATH_ERROR_CCIF_VIOLATION))
+		if ((irq_status_rdi[i] & CSID_PATH_ERROR_CCIF_VIOLATION))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID RDI :%d CCIF violation", i);
 
-		if ((irq_status[i] & CSID_PATH_OVERFLOW_RECOVERY))
+		if ((irq_status_rdi[i] & CSID_PATH_OVERFLOW_RECOVERY))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID RDI :%d Overflow due to back pressure",
 				i);
 
-		if (irq_status[i] & CSID_PATH_ERROR_FIFO_OVERFLOW) {
+		if (irq_status_rdi[i] & CSID_PATH_ERROR_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d RDI fifo over flow",
 				csid_hw->hw_intf->hw_idx);
@@ -5231,41 +4237,16 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 				soc_info->reg_map[0].mem_base +
 				csid_reg->rdi_reg[i]->csid_rdi_ctrl_addr);
 		}
-
-		if ((irq_status[i] & CSID_PATH_ERROR_PIX_COUNT) ||
-			(irq_status[i] & CSID_PATH_ERROR_LINE_COUNT)) {
-			val = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->rdi_reg[i]->csid_rdi_format_measure0_addr);
-			val2 = cam_io_r_mb(soc_info->reg_map[0].mem_base +
-			csid_reg->rdi_reg[i]->csid_rdi_format_measure_cfg1_addr
-			);
-			CAM_ERR(CAM_ISP,
-				"CSID:%d irq_status[%d]:0x%x",
-				csid_hw->hw_intf->hw_idx, i, irq_status[i]);
-			CAM_ERR(CAM_ISP,
-			"Expected:: h: 0x%x w: 0x%x actual:: h: 0x%x w: 0x%x",
-			((val2 >>
-			csid_reg->cmn_reg->format_measure_height_shift_val) &
-			csid_reg->cmn_reg->format_measure_height_mask_val),
-			val2 &
-			csid_reg->cmn_reg->format_measure_width_mask_val,
-			((val >>
-			csid_reg->cmn_reg->format_measure_height_shift_val) &
-			csid_reg->cmn_reg->format_measure_height_mask_val),
-			val &
-			csid_reg->cmn_reg->format_measure_width_mask_val);
-		}
 	}
 
 	for (i = 0; i < csid_reg->cmn_reg->num_udis; i++) {
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] &
+		if (irq_status_udi[i] &
 			BIT(csid_reg->cmn_reg->path_rst_done_shift_val)) {
 			CAM_DBG(CAM_ISP, "CSID UDI%d reset complete", i);
 			complete(&csid_hw->csid_udin_complete[i]);
 		}
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] &
-			CSID_PATH_INFO_INPUT_SOF) &&
+		if ((irq_status_udi[i] & CSID_PATH_INFO_INPUT_SOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_SOF_IRQ)) {
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID UDI:%d SOF received", i);
@@ -5273,25 +4254,21 @@ irqreturn_t cam_ife_csid_irq(int irq_num, void *data)
 				csid_hw->irq_debug_cnt++;
 		}
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i]  &
-			CSID_PATH_INFO_INPUT_EOF) &&
+		if ((irq_status_udi[i]  & CSID_PATH_INFO_INPUT_EOF) &&
 			(csid_hw->csid_debug & CSID_DEBUG_ENABLE_EOF_IRQ))
 			CAM_INFO_RATE_LIMIT(CAM_ISP,
 				"CSID UDI:%d EOF received", i);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] &
-			CSID_PATH_ERROR_CCIF_VIOLATION))
+		if ((irq_status_udi[i] & CSID_PATH_ERROR_CCIF_VIOLATION))
 			CAM_WARN_RATE_LIMIT(CAM_ISP,
 				"CSID UDI :%d CCIF violation", i);
 
-		if ((irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] &
-			CSID_PATH_OVERFLOW_RECOVERY))
+		if ((irq_status_udi[i] & CSID_PATH_OVERFLOW_RECOVERY))
 			CAM_WARN_RATE_LIMIT(CAM_ISP,
 				"CSID UDI :%d Overflow due to back pressure",
 				i);
 
-		if (irq_status[CAM_IFE_CSID_IRQ_REG_UDI_0 + i] &
-			CSID_PATH_ERROR_FIFO_OVERFLOW) {
+		if (irq_status_udi[i] & CSID_PATH_ERROR_FIFO_OVERFLOW) {
 			CAM_ERR_RATE_LIMIT(CAM_ISP,
 				"CSID:%d UDI fifo over flow",
 				csid_hw->hw_intf->hw_idx);
@@ -5470,25 +4447,8 @@ int cam_ife_csid_hw_probe_init(struct cam_hw_intf  *csid_hw_intf,
 		ife_csid_hw->udi_res[i].res_priv = path_data;
 	}
 
-	rc = cam_tasklet_init(&ife_csid_hw->tasklet, ife_csid_hw, csid_idx);
-	if (rc) {
-		CAM_ERR(CAM_ISP, "Unable to create CSID tasklet rc %d", rc);
-		goto err;
-	}
-
-	INIT_LIST_HEAD(&ife_csid_hw->free_payload_list);
-	for (i = 0; i < CAM_CSID_EVT_PAYLOAD_MAX; i++) {
-		INIT_LIST_HEAD(&ife_csid_hw->evt_payload[i].list);
-		list_add_tail(&ife_csid_hw->evt_payload[i].list,
-			&ife_csid_hw->free_payload_list);
-	}
-
 	ife_csid_hw->csid_debug = 0;
 	ife_csid_hw->error_irq_count = 0;
-	ife_csid_hw->ipp_path_config.measure_enabled = 0;
-	ife_csid_hw->ppp_path_config.measure_enabled = 0;
-	for (i = 0; i <= CAM_IFE_PIX_PATH_RES_RDI_3; i++)
-		ife_csid_hw->rdi_path_config[i].measure_enabled = 0;
 
 	return 0;
 err:
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.h
index 8e9eecf48e88..dcc6e6a131f7 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_core.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_HW_H_
@@ -72,8 +72,6 @@
 #define CSID_DEBUG_ENABLE_HBI_VBI_INFO            BIT(7)
 #define CSID_DEBUG_DISABLE_EARLY_EOF              BIT(8)
 
-#define CAM_CSID_EVT_PAYLOAD_MAX                  10
-
 /* enum cam_csid_path_halt_mode select the path halt mode control */
 enum cam_csid_path_halt_mode {
 	CSID_HALT_MODE_INTERNAL,
@@ -93,24 +91,6 @@ enum cam_csid_path_timestamp_stb_sel {
 	CSID_TIMESTAMP_STB_MAX,
 };
 
-/**
- * enum cam_ife_pix_path_res_id - Specify the csid patch
- */
-enum cam_ife_csid_irq_reg {
-	CAM_IFE_CSID_IRQ_REG_RDI_0,
-	CAM_IFE_CSID_IRQ_REG_RDI_1,
-	CAM_IFE_CSID_IRQ_REG_RDI_2,
-	CAM_IFE_CSID_IRQ_REG_RDI_3,
-	CAM_IFE_CSID_IRQ_REG_TOP,
-	CAM_IFE_CSID_IRQ_REG_RX,
-	CAM_IFE_CSID_IRQ_REG_IPP,
-	CAM_IFE_CSID_IRQ_REG_PPP,
-	CAM_IFE_CSID_IRQ_REG_UDI_0,
-	CAM_IFE_CSID_IRQ_REG_UDI_1,
-	CAM_IFE_CSID_IRQ_REG_UDI_2,
-	CAM_IFE_CSID_IRQ_REG_MAX,
-};
-
 struct cam_ife_csid_pxl_reg_offset {
 	/* Pxl path register offsets*/
 	uint32_t csid_pxl_irq_status_addr;
@@ -159,8 +139,6 @@ struct cam_ife_csid_pxl_reg_offset {
 	uint32_t quad_cfa_bin_en_shift_val;
 	uint32_t ccif_violation_en;
 	uint32_t overflow_ctrl_en;
-	uint32_t halt_master_sel_en;
-	uint32_t halt_sel_internal_master_val;
 };
 
 struct cam_ife_csid_rdi_reg_offset {
@@ -393,10 +371,6 @@ struct cam_ife_csid_common_reg_offset {
 	uint32_t measure_en_hbi_vbi_cnt_mask;
 	uint32_t format_measure_en_val;
 	uint32_t num_bytes_out_shift_val;
-	uint32_t format_measure_width_shift_val;
-	uint32_t format_measure_width_mask_val;
-	uint32_t format_measure_height_shift_val;
-	uint32_t format_measure_height_mask_val;
 };
 
 /**
@@ -478,7 +452,6 @@ struct cam_ife_csid_tpg_cfg  {
  * @cnt:              Cid resource reference count.
  * @tpg_set:          Tpg used for this cid resource
  * @is_valid_vc1_dt1: Valid vc1 and dt1
- * @init_cnt          cid resource init count
  *
  */
 struct cam_ife_csid_cid_data {
@@ -489,7 +462,6 @@ struct cam_ife_csid_cid_data {
 	uint32_t                     cnt;
 	uint32_t                     tpg_set;
 	uint32_t                     is_valid_vc1_dt1;
-	uint32_t                     init_cnt;
 };
 
 
@@ -514,13 +486,10 @@ struct cam_ife_csid_cid_data {
  *                  Reserving the path for master IPP or slave IPP
  *                  master (set value 1), Slave ( set value 2)
  *                  for RDI, set  mode to none
- * @usage_type:     dual or single IFE information
  * @master_idx:     For Slave reservation, Give master IFE instance Index.
  *                  Slave will synchronize with master Start and stop operations
  * @clk_rate        Clock rate
  * @num_bytes_out:  Number of output bytes per cycle
- * @init_frame_drop init frame drop value. In dual ife case rdi need to drop one
- *                  more frame than pix.
  *
  */
 struct cam_ife_csid_path_cfg {
@@ -541,29 +510,11 @@ struct cam_ife_csid_path_cfg {
 	uint32_t                        end_line;
 	uint32_t                        height;
 	enum cam_isp_hw_sync_mode       sync_mode;
-	uint32_t                        usage_type;
 	uint32_t                        master_idx;
 	uint64_t                        clk_rate;
 	uint32_t                        horizontal_bin;
 	uint32_t                        qcfa_bin;
 	uint32_t                        num_bytes_out;
-	uint32_t                        init_frame_drop;
-};
-
-/**
- * struct cam_csid_evt_payload- payload for csid hw event
- * @list       : list head
- * @evt_type   : Event type from CSID
- * @irq_status : IRQ Status register
- * @hw_idx     : Hw index
- * @priv       : Private data of payload
- */
-struct cam_csid_evt_payload {
-	struct list_head   list;
-	uint32_t           evt_type;
-	uint32_t           irq_status[CAM_IFE_CSID_IRQ_REG_MAX];
-	uint32_t           hw_idx;
-	void              *priv;
 };
 
 /**
@@ -572,10 +523,6 @@ struct cam_csid_evt_payload {
  * @hw_intf:                  contain the csid hw interface information
  * @hw_info:                  csid hw device information
  * @csid_info:                csid hw specific information
- * @tasklet:                  tasklet to handle csid errors
- * @priv:                     private data to be sent with callback
- * @free_payload_list:        list head for payload
- * @evt_payload:              Event payload to be passed to tasklet
  * @res_type:                 CSID in resource type
  * @csi2_rx_cfg:              Csi2 rx decoder configuration for csid
  * @tpg_cfg:                  TPG configuration
@@ -602,27 +549,16 @@ struct cam_csid_evt_payload {
  * @irq_debug_cnt:            Counter to track sof irq's when above flag is set.
  * @error_irq_count           Error IRQ count, if continuous error irq comes
  *                            need to stop the CSID and mask interrupts.
- * @device_enabled            Device enabled will set once CSID powered on and
- *                            initial configuration are done.
- * @lock_state                csid spin lock
  * @binning_enable            Flag is set if hardware supports QCFA binning
  * @binning_supported         Flag is set if sensor supports QCFA binning
+ *
  * @first_sof_ts              first bootime stamp at the start
  * @prev_qtimer_ts            stores csid timestamp
- * @epd_supported             Flag is set if sensor supports EPD
- * @fatal_err_detected        flag to indicate fatal errror is reported
- * @event_cb                  Callback to hw manager if CSID event reported
- * @res_sof_cnt               path resource sof count value. it used for initial
- *                            frame drop
  */
 struct cam_ife_csid_hw {
 	struct cam_hw_intf              *hw_intf;
 	struct cam_hw_info              *hw_info;
 	struct cam_ife_csid_hw_info     *csid_info;
-	void                            *tasklet;
-	void                            *priv;
-	struct list_head                 free_payload_list;
-	struct cam_csid_evt_payload      evt_payload[CAM_CSID_EVT_PAYLOAD_MAX];
 	uint32_t                         res_type;
 	struct cam_ife_csid_csi2_rx_cfg  csi2_rx_cfg;
 	struct cam_ife_csid_tpg_cfg      tpg_cfg;
@@ -642,11 +578,6 @@ struct cam_ife_csid_hw {
 	struct completion    csid_udin_complete[CAM_IFE_CSID_UDI_MAX];
 	uint64_t                         csid_debug;
 	uint64_t                         clk_rate;
-	struct cam_isp_sensor_dimension  ipp_path_config;
-	struct cam_isp_sensor_dimension  ppp_path_config;
-	struct cam_isp_sensor_dimension  rdi_path_config[CAM_IFE_CSID_RDI_MAX];
-	uint32_t                         hbi;
-	uint32_t                         vbi;
 	bool                             sof_irq_triggered;
 	bool                             is_resetting;
 	uint32_t                         irq_debug_cnt;
@@ -657,10 +588,6 @@ struct cam_ife_csid_hw {
 	uint32_t                         binning_supported;
 	uint64_t                         prev_boot_timestamp;
 	uint64_t                         prev_qtimer_ts;
-	uint32_t                         epd_supported;
-	bool                             fatal_err_detected;
-	cam_hw_mgr_event_cb_func         event_cb;
-	uint32_t                         res_sof_cnt[CAM_IFE_PIX_PATH_RES_MAX];
 };
 
 int cam_ife_csid_hw_probe_init(struct cam_hw_intf  *csid_hw_intf,
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite17x.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite17x.h
index 18ccc9846aea..4d8783ce0c0f 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite17x.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite17x.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_LITE17X_H_
@@ -298,12 +298,6 @@ static const struct cam_ife_csid_common_reg_offset
 	.ipp_irq_mask_all                             = 0x7FFF,
 	.rdi_irq_mask_all                             = 0x7FFF,
 	.ppp_irq_mask_all                             = 0xFFFF,
-	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
-	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static const struct cam_ife_csid_reg_offset cam_ife_csid_lite_17x_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite480.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite480.h
index 6b6cdd96fa0a..b77f2dfa350e 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite480.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/ife_csid_hw/cam_ife_csid_lite480.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_IFE_CSID_LITE_480_H_
@@ -321,10 +321,6 @@ static struct cam_ife_csid_common_reg_offset
 	.ppp_irq_mask_all                             = 0xFFFF,
 	.measure_en_hbi_vbi_cnt_mask                  = 0xC,
 	.format_measure_en_val                        = 1,
-	.format_measure_height_mask_val               = 0xFFFF,
-	.format_measure_height_shift_val              = 0x10,
-	.format_measure_width_mask_val                = 0xFFFF,
-	.format_measure_width_shift_val               = 0x0,
 };
 
 static struct cam_ife_csid_reg_offset cam_ife_csid_lite_480_reg_offset = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_ife_csid_hw_intf.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_ife_csid_hw_intf.h
index 498854b90f92..56ce59636dda 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_ife_csid_hw_intf.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_ife_csid_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSID_HW_INTF_H_
@@ -97,7 +97,6 @@ struct cam_isp_in_port_generic_info {
 	uint32_t                        batch_size;
 	uint32_t                        dsp_mode;
 	uint32_t                        hbi_cnt;
-	uint32_t                        fe_unpacker_fmt;
 	uint32_t                        cust_node;
 	uint32_t                        num_out_res;
 	uint32_t                        horizontal_bin;
@@ -124,8 +123,6 @@ struct cam_isp_in_port_generic_info {
  * @node_res :    Reserved resource structure pointer
  * @crop_enable : Flag to indicate CSID crop enable
  * @drop_enable : Flag to indicate CSID drop enable
- * @priv:         private data to be sent in callback
- * @event_cb:     CSID event callback to hw manager
  *
  */
 struct cam_csid_hw_reserve_resource_args {
@@ -139,8 +136,6 @@ struct cam_csid_hw_reserve_resource_args {
 	struct cam_isp_resource_node             *node_res;
 	bool                                      crop_enable;
 	bool                                      drop_enable;
-	void                                     *priv;
-	cam_hw_mgr_event_cb_func                  event_cb;
 };
 
 /**
@@ -153,33 +148,6 @@ enum cam_ife_csid_halt_cmd {
 	CAM_CSID_HALT_MAX,
 };
 
-/**
- *  enum cam_ife_csid_halt_mode_cmd - Specify the halt command type
- */
-enum cam_ife_csid_halt_mode {
-	CAM_CSID_HALT_MODE_INTERNAL,
-	CAM_CSID_HALT_MODE_GLOBAL,
-	CAM_CSID_HALT_MODE_MASTER,
-	CAM_CSID_HALT_MODE_SLAVE,
-	CAM_CSID_HALT_MODE_MAX,
-};
-
-/**
- * struct cam_csid_hw_halt_args
- * @halt_mode : Applicable only for PATH resources
- * 0 Internal : The CSID responds to the HALT_CMD
- * 1 Global : The CSID responds to the GLOBAL_HALT_CMD
- * 2 Master : The CSID responds to the HALT_CMD
- * 3 Slave : The CSID responds to the external halt command
- * and not the HALT_CMD register
- * @node_res : reource pointer array( ie cid or CSID)
- *
- */
-struct cam_csid_hw_halt_args {
-	enum cam_ife_csid_halt_mode   halt_mode;
-	struct cam_isp_resource_node *node_res;
-};
-
 /**
  * struct cam_csid_hw_stop- stop all resources
  * @stop_cmd : Applicable only for PATH resources
@@ -219,9 +187,9 @@ struct cam_csid_reset_cfg_args {
 
 /**
  * struct cam_csid_get_time_stamp_args-  time stamp capture arguments
- * @node_res         : resource to get the time stamp
- * @time_stamp_val   : captured time stamp
- * @boot_timestamp   : boot time stamp
+ * @res_node :   resource to get the time stamp
+ * @time_stamp_val : captured time stamp
+ * @boot_timestamp : boot time stamp
  */
 struct cam_csid_get_time_stamp_args {
 	struct cam_isp_resource_node      *node_res;
@@ -236,8 +204,6 @@ enum cam_ife_csid_cmd_type {
 	CAM_IFE_CSID_CMD_GET_TIME_STAMP,
 	CAM_IFE_CSID_SET_CSID_DEBUG,
 	CAM_IFE_CSID_SOF_IRQ_DEBUG,
-	CAM_IFE_CSID_SET_CONFIG,
-	CAM_IFE_CSID_SET_SENSOR_DIMENSION_CFG,
 	CAM_IFE_CSID_CMD_MAX,
 };
 
@@ -270,26 +236,5 @@ struct cam_ife_csid_qcfa_update_args {
 	uint32_t                           qcfa_binning;
 };
 
-/*
- * struct cam_ife_csid_epd_update_args:
- *
- * @epd_supported:                flag to check epd supported or not
- */
-struct cam_ife_csid_epd_update_args {
-	uint32_t                           epd_supported;
-};
-
-/*
- * struct cam_ife_sensor_dim_update_args:
- *
- * @ppp_path:             expected ppp path configuration
- * @ipp_path:             expected ipp path configuration
- * @rdi_path:             expected rdi path configuration
- */
-struct cam_ife_sensor_dimension_update_args {
-	struct cam_isp_sensor_dimension  ppp_path;
-	struct cam_isp_sensor_dimension  ipp_path;
-	struct cam_isp_sensor_dimension  rdi_path[CAM_IFE_CSID_RDI_MAX];
-};
 
 #endif /* _CAM_CSID_HW_INTF_H_ */
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_isp_hw.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_isp_hw.h
index 3323597f65ad..7ac79feb2a9f 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_isp_hw.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_isp_hw.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_ISP_HW_H_
@@ -14,8 +13,6 @@
 #include "cam_irq_controller.h"
 #include "cam_hw_intf.h"
 
-/* Maximum length of tag while dumping */
-#define CAM_ISP_HW_DUMP_TAG_MAX_LEN 32
 /*
  * struct cam_isp_timestamp:
  *
@@ -75,8 +72,8 @@ enum cam_isp_resource_type {
 	CAM_ISP_RESOURCE_CID,
 	CAM_ISP_RESOURCE_PIX_PATH,
 	CAM_ISP_RESOURCE_VFE_IN,
-	CAM_ISP_RESOURCE_VFE_BUS_RD,
 	CAM_ISP_RESOURCE_VFE_OUT,
+	CAM_ISP_RESOURCE_VFE_BUS_RD,
 	CAM_ISP_RESOURCE_MAX,
 };
 
@@ -95,10 +92,8 @@ enum cam_isp_hw_cmd_type {
 	CAM_ISP_HW_CMD_BW_CONTROL,
 	CAM_ISP_HW_CMD_STOP_BUS_ERR_IRQ,
 	CAM_ISP_HW_CMD_UBWC_UPDATE,
-	CAM_ISP_HW_CMD_DUMP_BUS_INFO,
 	CAM_ISP_HW_CMD_SOF_IRQ_DEBUG,
 	CAM_ISP_HW_CMD_SET_CAMIF_DEBUG,
-	CAM_ISP_HW_CMD_CAMIF_DATA,
 	CAM_ISP_HW_CMD_CSID_CLOCK_UPDATE,
 	CAM_ISP_HW_CMD_FE_UPDATE_IN_RD,
 	CAM_ISP_HW_CMD_FE_UPDATE_BUS_RD,
@@ -107,30 +102,9 @@ enum cam_isp_hw_cmd_type {
 	CAM_ISP_HW_CMD_WM_CONFIG_UPDATE,
 	CAM_ISP_HW_CMD_CSID_QCFA_SUPPORTED,
 	CAM_ISP_HW_CMD_QUERY_REGSPACE_DATA,
-	CAM_ISP_HW_CMD_QUERY,
-	CAM_ISP_HW_CMD_QUERY_DSP_MODE,
-	CAM_ISP_HW_CMD_DUMP_HW,
-	CAM_ISP_HW_CMD_FE_TRIGGER_CMD,
-	CAM_ISP_HW_CMD_CSID_CHANGE_HALT_MODE,
-	CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP,
-	CAM_ISP_HW_CMD_CSID_CLOCK_DUMP,
-	CAM_ISP_HW_CMD_SET_NUM_OF_ACQUIRED_RESOURCE,
-	CAM_ISP_HW_CMD_GET_NUM_OF_ACQUIRED_RESOURCE,
-	CAM_ISP_HW_CMD_IS_CONSUMED_ADDR_SUPPORT,
 	CAM_ISP_HW_CMD_MAX,
 };
 
-/*
- * struct cam_isp_hw_cmd_query
- *
- * @Brief:              Structure representing query command to HW
- *
- * @query_cmd:          Command identifier
- */
-struct cam_isp_hw_cmd_query {
-	int query_cmd;
-};
-
 /*
  * struct cam_isp_resource_node:
  *
@@ -191,7 +165,6 @@ struct cam_isp_resource_node {
  * @res_id:         Unique resource ID
  * @hw_idx:         IFE hw index
  * @err_type:       Error type if any
- * @reg_val:        Any critical register value captured during irq handling
  *
  */
 struct cam_isp_hw_event_info {
@@ -199,7 +172,6 @@ struct cam_isp_hw_event_info {
 	uint32_t                       res_id;
 	uint32_t                       hw_idx;
 	uint32_t                       err_type;
-	uint32_t                       reg_val;
 };
 
 /*
@@ -221,22 +193,16 @@ struct cam_isp_hw_cmd_buf_update {
 /*
  * struct cam_isp_hw_get_wm_update:
  *
- * @Brief:             Get cmd buffer for WM updates.
+ * @Brief:         Get cmd buffer for WM updates.
  *
  * @ image_buf:    image buffer address array
- * @ image_buf_offset: image buffer address offset array
  * @ num_buf:      Number of buffers in the image_buf array
- * @ frame_header: frame header iova
- * @ local_id:     local id for the wm
  * @ io_cfg:       IO buffer config information sent from UMD
  *
  */
 struct cam_isp_hw_get_wm_update {
 	dma_addr_t                     *image_buf;
-	uint32_t                        image_buf_offset[CAM_PACKET_MAX_PLANES];
 	uint32_t                        num_buf;
-	uint64_t                        frame_header;
-	uint32_t                        local_id;
 	struct cam_buf_io_cfg          *io_cfg;
 };
 
@@ -283,40 +249,4 @@ struct cam_isp_hw_dual_isp_update_args {
 	struct cam_isp_resource_node    *res;
 	struct cam_isp_dual_config      *dual_cfg;
 };
-
-/*
- * struct cam_isp_hw_dump_args:
- *
- * @Brief:        isp hw dump args
- *
- * @ req_id:         request id
- * @ cpu_addr:       cpu address
- * @ buf_len:        buf len
- * @ offset:         offset of buffer
- * @ ctxt_to_hw_map: ctx to hw map
- */
-struct cam_isp_hw_dump_args {
-	uint64_t                req_id;
-	uintptr_t               cpu_addr;
-	size_t                  buf_len;
-	size_t                  offset;
-	void                   *ctxt_to_hw_map;
-};
-
-/**
- * struct cam_isp_hw_dump_header - ISP context dump header
- *
- * @Brief:        isp hw dump header
- *
- * @tag:       Tag name for the header
- * @word_size: Size of word
- * @size:      Size of data
- *
- */
-struct cam_isp_hw_dump_header {
-	uint8_t   tag[CAM_ISP_HW_DUMP_TAG_MAX_LEN];
-	uint64_t  size;
-	uint32_t  word_size;
-};
-
 #endif /* _CAM_ISP_HW_H_ */
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_vfe_hw_intf.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_vfe_hw_intf.h
index dbf61f5d6f55..a1d1c6a60881 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_vfe_hw_intf.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/include/cam_vfe_hw_intf.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_HW_INTF_H_
@@ -103,27 +102,6 @@ struct cam_vfe_hw_get_hw_cap {
 	uint32_t                max_rdi_num;
 };
 
-/*
- * struct cam_vfe_hw_vfe_bus_rd_acquire_args:
- *
- * @rsrc_node:               Pointer to Resource Node object, filled if acquire
- *                           is successful
- * @res_id:                  Unique Identity of port to associate with this
- *                           resource.
- * @is_dual:                 Flag to indicate dual VFE usecase
- * @cdm_ops:                 CDM operations
- * @unpacket_fmt:            Unpacker format for read engine
- * @is_offline:              Flag to indicate offline usecase
- */
-struct cam_vfe_hw_vfe_bus_rd_acquire_args {
-	struct cam_isp_resource_node         *rsrc_node;
-	uint32_t                              res_id;
-	uint32_t                              is_dual;
-	struct cam_cdm_utils_ops             *cdm_ops;
-	uint32_t                              unpacker_fmt;
-	bool                                  is_offline;
-};
-
 /*
  * struct cam_vfe_hw_vfe_out_acquire_args:
  *
@@ -140,7 +118,6 @@ struct cam_vfe_hw_vfe_bus_rd_acquire_args {
  *                           (Default is Master in case of Single VFE)
  * @dual_slave_core:         If Master and Slave exists, HW Index of Slave
  * @cdm_ops:                 CDM operations
- * disable_ubwc_comp:        Disable UBWC compression
  */
 struct cam_vfe_hw_vfe_out_acquire_args {
 	struct cam_isp_resource_node         *rsrc_node;
@@ -151,7 +128,6 @@ struct cam_vfe_hw_vfe_out_acquire_args {
 	uint32_t                              is_master;
 	uint32_t                              dual_slave_core;
 	struct cam_cdm_utils_ops             *cdm_ops;
-	bool                                  disable_ubwc_comp;
 };
 
 /*
@@ -161,25 +137,17 @@ struct cam_vfe_hw_vfe_out_acquire_args {
  *                           is successful
  * @res_id:                  Resource ID of resource to acquire if specific,
  *                           else CAM_ISP_HW_VFE_IN_MAX
- * @dual_hw_idx:             Slave core for this master core if dual vfe case
- * @is_dual:                 flag to indicate if dual vfe case
  * @cdm_ops:                 CDM operations
  * @sync_mode:               In case of Dual VFE, this is Master or Slave.
  *                           (Default is Master in case of Single VFE)
  * @in_port:                 Input port details to acquire
- * @is_fe_enabled:           Flag to indicate if FE is enabled
- * @is_offline:              Flag to indicate Offline IFE
  */
 struct cam_vfe_hw_vfe_in_acquire_args {
 	struct cam_isp_resource_node         *rsrc_node;
 	uint32_t                              res_id;
-	uint32_t                              dual_hw_idx;
-	uint32_t                              is_dual;
 	void                                 *cdm_ops;
 	enum cam_isp_hw_sync_mode             sync_mode;
 	struct cam_isp_in_port_generic_info  *in_port;
-	bool                                  is_fe_enabled;
-	bool                                  is_offline;
 };
 
 /*
@@ -201,9 +169,9 @@ struct cam_vfe_acquire_args {
 	void                                *priv;
 	cam_hw_mgr_event_cb_func             event_cb;
 	union {
-		struct cam_vfe_hw_vfe_out_acquire_args     vfe_out;
-		struct cam_vfe_hw_vfe_bus_rd_acquire_args  vfe_bus_rd;
-		struct cam_vfe_hw_vfe_in_acquire_args      vfe_in;
+		struct cam_vfe_hw_vfe_out_acquire_args  vfe_out;
+		struct cam_vfe_hw_vfe_out_acquire_args  vfe_bus_rd;
+		struct cam_vfe_hw_vfe_in_acquire_args   vfe_in;
 	};
 };
 
@@ -254,19 +222,6 @@ struct cam_vfe_bw_update_args {
 	uint64_t                           external_bw_bytes;
 };
 
-/*
- * struct cam_vfe_num_of_acquired_resources:
- *
- * @num_pix_rsrc:            Number of pix resources acquired in context
- * @num_pd_rsrc:             Number of pd resources acquired in context
- * @num_rdi_rsrc:            Number of rdi resources acquired in context
- */
-struct cam_vfe_num_of_acquired_resources {
-	uint32_t      num_pix_rsrc;
-	uint32_t      num_pd_rsrc;
-	uint32_t      num_rdi_rsrc;
-};
-
 /*
  * struct cam_vfe_fe_update_args:
  *
@@ -304,15 +259,11 @@ struct cam_vfe_bw_control_args {
  * @list:                    list_head node for the payload
  * @irq_reg_val:             IRQ and Error register values, read when IRQ was
  *                           handled
- * @reg_val:                 Value of any critical register that needs to be
- *                           read at during irq handling
- *
  * @ts:                      Timestamp
  */
 struct cam_vfe_top_irq_evt_payload {
 	struct list_head            list;
 	uint32_t                    irq_reg_val[CAM_IFE_IRQ_REGISTERS_MAX];
-	uint32_t                    reg_val;
 	struct cam_isp_timestamp    ts;
 };
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_core.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_core.c
index dc5c6229ae0d..11d6a602117c 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_core.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_core.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/delay.h>
@@ -148,7 +147,6 @@ int cam_vfe_init_hw(void *hw_priv, void *init_hw_args, uint32_t arg_size)
 	struct cam_hw_soc_info            *soc_info = NULL;
 	struct cam_vfe_hw_core_info       *core_info = NULL;
 	struct cam_isp_resource_node      *isp_res = NULL;
-	struct cam_vfe_num_of_acquired_resources num_rsrc;
 	int rc = 0;
 	uint32_t                           reset_core_args =
 					CAM_VFE_HW_RESET_HW_AND_REG;
@@ -171,26 +169,16 @@ int cam_vfe_init_hw(void *hw_priv, void *init_hw_args, uint32_t arg_size)
 
 	soc_info = &vfe_hw->soc_info;
 	core_info = (struct cam_vfe_hw_core_info *)vfe_hw->core_info;
-	isp_res   = (struct cam_isp_resource_node *)init_hw_args;
-
-	rc = core_info->vfe_top->hw_ops.process_cmd(
-		core_info->vfe_top->top_priv,
-		CAM_ISP_HW_CMD_GET_NUM_OF_ACQUIRED_RESOURCE,
-		&num_rsrc,
-		sizeof(struct cam_vfe_num_of_acquired_resources));
-	if (rc)
-		CAM_ERR(CAM_ISP, "Failed to get the port information rc=%d",
-			rc);
 
 	/* Turn ON Regulators, Clocks and other SOC resources */
-	rc = cam_vfe_enable_soc_resources(soc_info, num_rsrc.num_pix_rsrc,
-		num_rsrc.num_pd_rsrc, num_rsrc.num_rdi_rsrc);
+	rc = cam_vfe_enable_soc_resources(soc_info);
 	if (rc) {
 		CAM_ERR(CAM_ISP, "Enable SOC failed");
 		rc = -EFAULT;
 		goto decrement_open_cnt;
 	}
 
+	isp_res   = (struct cam_isp_resource_node *)init_hw_args;
 	if (isp_res && isp_res->init) {
 		rc = isp_res->init(isp_res, NULL, 0);
 		if (rc) {
@@ -605,13 +593,6 @@ int cam_vfe_process_cmd(void *hw_priv, uint32_t cmd_type,
 	case CAM_ISP_HW_CMD_BW_CONTROL:
 	case CAM_ISP_HW_CMD_CORE_CONFIG:
 	case CAM_ISP_HW_CMD_BW_UPDATE_V2:
-	case CAM_ISP_HW_CMD_DUMP_HW:
-	case CAM_ISP_HW_CMD_QUERY:
-	case CAM_ISP_HW_CMD_QUERY_DSP_MODE:
-	case CAM_ISP_HW_CMD_CAMIF_DATA:
-	case CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP:
-	case CAM_ISP_HW_CMD_SET_NUM_OF_ACQUIRED_RESOURCE:
-	case CAM_ISP_HW_CMD_GET_NUM_OF_ACQUIRED_RESOURCE:
 		rc = core_info->vfe_top->hw_ops.process_cmd(
 			core_info->vfe_top->top_priv, cmd_type, cmd_args,
 			arg_size);
@@ -623,8 +604,6 @@ int cam_vfe_process_cmd(void *hw_priv, uint32_t cmd_type,
 	case CAM_ISP_HW_CMD_UBWC_UPDATE:
 	case CAM_ISP_HW_CMD_UBWC_UPDATE_V2:
 	case CAM_ISP_HW_CMD_WM_CONFIG_UPDATE:
-	case CAM_ISP_HW_CMD_DUMP_BUS_INFO:
-	case CAM_ISP_HW_CMD_IS_CONSUMED_ADDR_SUPPORT:
 		rc = core_info->vfe_bus->hw_ops.process_cmd(
 			core_info->vfe_bus->bus_priv, cmd_type, cmd_args,
 			arg_size);
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.c
index 4a4b4149da8d..77e2a059af57 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -85,9 +85,6 @@ static int cam_vfe_get_dt_properties(struct cam_hw_soc_info *soc_info)
 		break;
 	}
 
-	vfe_soc_private->dsp_disabled = of_property_read_bool(of_node,
-		"dsp-disabled");
-
 end:
 	return rc;
 }
@@ -220,8 +217,7 @@ int cam_vfe_deinit_soc_resources(struct cam_hw_soc_info *soc_info)
 	return rc;
 }
 
-int cam_vfe_enable_soc_resources(struct cam_hw_soc_info *soc_info,
-	int num_pix_rsrc, int num_pd_rsrc, int num_rdi_rsrc)
+int cam_vfe_enable_soc_resources(struct cam_hw_soc_info *soc_info)
 {
 	int                               rc = 0;
 	struct cam_vfe_soc_private       *soc_private;
@@ -243,18 +239,8 @@ int cam_vfe_enable_soc_resources(struct cam_hw_soc_info *soc_info,
 		axi_vote.axi_path[0].path_data_type =
 			CAM_AXI_PATH_DATA_IFE_RDI1;
 	} else {
-		if (num_pix_rsrc)
-			axi_vote.axi_path[0].path_data_type =
-				CAM_AXI_PATH_DATA_IFE_VID;
-		else if (num_pd_rsrc)
-			axi_vote.axi_path[0].path_data_type =
-				CAM_AXI_PATH_DATA_IFE_PDAF;
-		else if (num_rdi_rsrc)
-			axi_vote.axi_path[0].path_data_type =
-				CAM_AXI_PATH_DATA_IFE_RDI0;
-		else
-			axi_vote.axi_path[0].path_data_type =
-				CAM_AXI_PATH_DATA_IFE_VID;
+		axi_vote.axi_path[0].path_data_type =
+			CAM_AXI_PATH_DATA_IFE_VID;
 	}
 
 	axi_vote.axi_path[0].transac_type = CAM_AXI_TRANSACTION_WRITE;
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.h
index 4a87529218b6..64d9de084ec1 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/cam_vfe_soc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_SOC_H_
@@ -24,8 +24,6 @@
  * @cpas_version:            Has cpas version read from Hardware
  * @ubwc_static_ctrl:        UBWC static control configuration
  * @is_ife_lite:             Flag to indicate full vs lite IFE
- * @dsp_disabled:            Flag to indicate DSP is not supported for VFE
- * @ife_clk_src:             IFE source clock
  */
 struct cam_vfe_soc_private {
 	uint32_t    cpas_handle;
@@ -35,8 +33,6 @@ struct cam_vfe_soc_private {
 	int32_t     dsp_clk_rate;
 	uint32_t    ubwc_static_ctrl[UBWC_STATIC_CONFIG_MAX];
 	bool        is_ife_lite;
-	bool        dsp_disabled;
-	uint64_t    ife_clk_src;
 };
 
 /*
@@ -73,17 +69,10 @@ int cam_vfe_deinit_soc_resources(struct cam_hw_soc_info *soc_info);
  *
  * @soc_info:                Device soc information
  *
- * @num_pix_rsrc:            Number of pix resource in input port
- *
- * @num_pd_rsrc:             Number of pdaf resource in input port
- *
- * @num_rdi_rsrc:            Number of rdi resource in input port
- *
  * @Return:                  0: Success
  *                           Non-zero: Failure
  */
-int cam_vfe_enable_soc_resources(struct cam_hw_soc_info *soc_info,
-	int num_pix_rsrc, int num_pd_rsrc, int num_rdi_rsrc);
+int cam_vfe_enable_soc_resources(struct cam_hw_soc_info *soc_info);
 
 /*
  * cam_vfe_disable_soc_resources()
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe.c
index 9972e2f64a7c..5336352a4797 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe.c
@@ -1,11 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
 #include "cam_vfe170.h"
-#include "cam_vfe170_150.h"
 #include "cam_vfe175.h"
 #include "cam_vfe175_130.h"
 #include "cam_vfe480.h"
@@ -20,10 +19,6 @@ static const struct of_device_id cam_vfe_dt_match[] = {
 		.compatible = "qcom,vfe170",
 		.data = &cam_vfe170_hw_info,
 	},
-	{
-		.compatible = "qcom,vfe170_150",
-		.data = &cam_vfe170_150_hw_info,
-	},
 	{
 		.compatible = "qcom,vfe175",
 		.data = &cam_vfe175_hw_info,
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe170.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe170.h
index 58c3a0c3c7be..663bc247b27f 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe170.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe170.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE170_H_
@@ -145,40 +144,6 @@ static struct cam_vfe_rdi_reg_data  vfe_170_rdi_2_data = {
 	.reg_update_irq_mask      = 0x80,
 };
 
-struct cam_vfe_top_dump_data vfe170_dump_data = {
-	.num_reg_dump_entries  =  2,
-	.num_lut_dump_entries  =  1,
-	.dmi_cfg               =  0xc24,
-	.dmi_addr              =  0xc28,
-	.dmi_data_path_hi      =  0xc2C,
-	.dmi_data_path_lo      =  0xc30,
-	.reg_entry = {
-		{
-			.reg_dump_start = 0x0,
-			.reg_dump_end   = 0x1164,
-		},
-		{
-			.reg_dump_start = 0x2000,
-			.reg_dump_end   = 0x397C,
-		},
-	},
-	.lut_entry = {
-		{
-			.lut_word_size = 64,
-			.lut_bank_sel  = 0x40,
-			.lut_addr_size = 180,
-		},
-	},
-};
-
-static struct cam_vfe_rdi_overflow_status vfe170_rdi_irq_status = {
-	.rdi0_overflow_mask = 0x8,
-	.rdi1_overflow_mask = 0x10,
-	.rdi2_overflow_mask = 0x18,
-	.rdi3_overflow_mask = 0x20,
-	.rdi_overflow_mask  = 0x3c,
-};
-
 static struct cam_vfe_top_ver2_hw_info vfe170_top_hw_info = {
 	.common_reg = &vfe170_top_common_reg,
 	.camif_hw_info = {
@@ -192,9 +157,8 @@ static struct cam_vfe_top_ver2_hw_info vfe170_top_hw_info = {
 		.reg_data       = NULL,
 		},
 	.rdi_hw_info = {
-		.common_reg      = &vfe170_top_common_reg,
-		.rdi_reg         = &vfe170_rdi_reg,
-		.rdi_irq_status  = &vfe170_rdi_irq_status,
+		.common_reg = &vfe170_top_common_reg,
+		.rdi_reg    = &vfe170_rdi_reg,
 		.reg_data = {
 			&vfe_170_rdi_0_data,
 			&vfe_170_rdi_1_data,
@@ -209,7 +173,6 @@ static struct cam_vfe_top_ver2_hw_info vfe170_top_hw_info = {
 		CAM_VFE_RDI_VER_1_0,
 		CAM_VFE_RDI_VER_1_0,
 	},
-	.dump_data = &vfe170_dump_data,
 };
 
 static struct cam_irq_register_set vfe170_bus_irq_reg[3] = {
@@ -239,7 +202,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_client ubwc_regs_client_3 = {
 	.meta_stride      = 0x00002540,
 	.mode_cfg_0       = 0x00002544,
 	.bw_limit         = 0x000025A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_client ubwc_regs_client_4 = {
@@ -251,7 +213,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_client ubwc_regs_client_4 = {
 	.meta_stride      = 0x00002640,
 	.mode_cfg_0       = 0x00002644,
 	.bw_limit         = 0x000026A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_hw_info vfe170_bus_hw_info = {
@@ -861,7 +822,6 @@ static struct cam_vfe_bus_ver2_hw_info vfe170_bus_hw_info = {
 			.max_height    = -1,
 		},
 	},
-	.support_consumed_addr = false,
 };
 
 struct cam_vfe_hw_info cam_vfe170_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175.h
index 4d9bcf24a5f3..6823b6386b91 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE175_H_
@@ -179,32 +178,6 @@ static struct cam_vfe_rdi_reg_data  vfe_175_rdi_2_data = {
 	.reg_update_irq_mask      = 0x80,
 };
 
-struct cam_vfe_top_dump_data vfe175_dump_data = {
-	.num_reg_dump_entries  =  2,
-	.num_lut_dump_entries  =  1,
-	.dmi_cfg               =  0xc24,
-	.dmi_addr              =  0xc28,
-	.dmi_data_path_hi      =  0xc2C,
-	.dmi_data_path_lo      =  0xc30,
-	.reg_entry = {
-		{
-			.reg_dump_start = 0x0,
-			.reg_dump_end   = 0x1164,
-		},
-		{
-			.reg_dump_start = 0x2000,
-			.reg_dump_end   = 0x397C,
-		},
-	},
-	.lut_entry = {
-		{
-			.lut_word_size = 64,
-			.lut_bank_sel  = 0x40,
-			.lut_addr_size = 180,
-		},
-	},
-};
-
 static struct cam_vfe_top_ver2_hw_info vfe175_top_hw_info = {
 	.common_reg = &vfe175_top_common_reg,
 	.camif_hw_info = {
@@ -236,7 +209,6 @@ static struct cam_vfe_top_ver2_hw_info vfe175_top_hw_info = {
 		CAM_VFE_RDI_VER_1_0,
 		CAM_VFE_CAMIF_LITE_VER_2_0,
 	},
-	.dump_data = &vfe175_dump_data,
 };
 
 static struct cam_irq_register_set vfe175_bus_irq_reg[3] = {
@@ -268,7 +240,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00002544,
 	.mode_cfg_1       = 0x000025A4,
 	.bw_limit         = 0x000025A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -282,7 +253,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00002644,
 	.mode_cfg_1       = 0x000026A4,
 	.bw_limit         = 0x000026A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -296,7 +266,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00003644,
 	.mode_cfg_1       = 0x000036A4,
 	.bw_limit         = 0x000036A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -310,7 +279,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00003744,
 	.mode_cfg_1       = 0x000037A4,
 	.bw_limit         = 0x000037A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_hw_info vfe175_bus_hw_info = {
@@ -1024,7 +992,6 @@ static struct cam_vfe_bus_ver2_hw_info vfe175_bus_hw_info = {
 			.max_height    = 1080,
 		},
 	},
-	.support_consumed_addr = false,
 };
 
 struct cam_vfe_hw_info cam_vfe175_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175_130.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175_130.h
index 0277b9464ca0..8acd77d1f1e2 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175_130.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe175_130.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE175_130_H_
@@ -28,14 +27,6 @@ static struct cam_irq_register_set vfe175_130_top_irq_reg_set[2] = {
 	},
 };
 
-static struct cam_vfe_rdi_overflow_status vfe175_130_rdi_irq_status = {
-	.rdi0_overflow_mask = 0x8,
-	.rdi1_overflow_mask = 0x10,
-	.rdi2_overflow_mask = 0x18,
-	.rdi3_overflow_mask = 0x20,
-	.rdi_overflow_mask  = 0x3c,
-};
-
 static struct cam_irq_controller_reg_info vfe175_130_top_irq_reg_info = {
 	.num_registers = 2,
 	.irq_reg_set = vfe175_130_top_irq_reg_set,
@@ -185,179 +176,6 @@ struct cam_vfe_top_ver2_reg_offset_module_ctrl zoom_175_130_reg = {
 	.enable   = 0x0000004C,
 };
 
-static struct cam_vfe_bus_ver2_stats_cfg_info stats_175_130_info  = {
-	.dmi_offset_info = {
-		.auto_increment = 0x00000100,
-		.cfg_offset     = 0x00000C24,
-		.addr_offset    = 0x00000C28,
-		.data_hi_offset = 0x00000C2C,
-		.data_lo_offset = 0x00000C30,
-	},
-	.stats_cfg_offset = {
-		/* CAM_VFE_BUS_VER2_VFE_OUT_RDI0 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_RDI1 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_RDI2 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_RDI3 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_FULL */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_DS4 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_DS16 */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_RAW_DUMP */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_FD */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_PDAF */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BE */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BE,
-			.cfg_offset     = 0x00000AB8,
-			.num_cfg        = 0x00000ABC,
-			.cfg_size       = 0x00000AC0,
-			.is_lut         = 0,
-			.lut            = {
-				.size           = -1,
-				.bank_0         = -1,
-				.bank_1         = -1,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST */
-		{
-			.res_index      =
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST,
-			.cfg_offset     = 0x00000AD4,
-			.num_cfg        = 0x00000AD8,
-			.cfg_size       = 0x00000000,
-			.is_lut         = 1,
-			.lut            = {
-				.size           = 180,
-				.bank_0         = 0x36,
-				.bank_1         = 0x37,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_TL_BG */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF,
-			.cfg_offset     = 0x00000AE4,
-			.num_cfg        = 0x00000000,
-			.cfg_size       = 0x00000000,
-			.is_lut         = 1,
-			.lut            = {
-				.size           = 180,
-				.bank_0         = 0x40,
-				.bank_1         = 0x41,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_AWB_BG */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_AWB_BG,
-			.cfg_offset     = 0x00000BC8,
-			.num_cfg        = 0x00000BCC,
-			.cfg_size       = 0x00000BD0,
-			.is_lut         = 0,
-			.lut            = {
-				.size           = -1,
-				.bank_0         = -1,
-				.bank_1         = -1,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST,
-			.cfg_offset     = 0x00000BE4,
-			.num_cfg        = 0x00000BE8,
-			.cfg_size       = 0x00000000,
-			.is_lut         = 1,
-			.lut            = {
-				.size           = 180,
-				.bank_0         = 0x3A,
-				.bank_1         = -1,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_RS */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_RS,
-			.cfg_offset     = 0x00000BEC,
-			.num_cfg        = 0x00000BF0,
-			.cfg_size       = 0x00000BF4,
-			.is_lut         = 0,
-			.lut            = {
-				.size           = -1,
-				.bank_0         = -1,
-				.bank_1         = -1,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_CS */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_CS,
-			.cfg_offset     = 0x00000BF8,
-			.num_cfg        = 0x00000BFC,
-			.cfg_size       = 0x00000C00,
-			.is_lut         = 0,
-			.lut            = {
-				.size           = -1,
-				.bank_0         = -1,
-				.bank_1         = -1,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_STATS_IHIST */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_STATS_IHIST,
-			.cfg_offset     = 0x00000C04,
-			.num_cfg        = 0x00000C08,
-			.cfg_size       = 0x00000000,
-			.is_lut         = 1,
-			.lut            = {
-				.size           = 180,
-				.bank_0         = 0x3B,
-				.bank_1         = 0x3C,
-			},
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_FULL_DISP */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_DS4_DISP */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_DS16_DISP */
-		{
-		},
-		/* CAM_VFE_BUS_VER2_VFE_OUT_2PD */
-		{
-			.res_index      = CAM_VFE_BUS_VER2_VFE_OUT_2PD,
-			.cfg_offset     = 0x00000FF0,
-			.num_cfg        = 0x00000FF4,
-			.cfg_size       = 0x00000FF8,
-			.is_lut         = 1,
-			.lut            = {
-				.size           = 180,
-				.bank_0         = 0x44,
-				.bank_1         = 0x45,
-			},
-		},
-	},
-};
-
-
 static struct cam_vfe_top_ver2_reg_offset_common vfe175_130_top_common_reg = {
 	.hw_version               = 0x00000000,
 	.hw_capability            = 0x00000004,
@@ -377,10 +195,6 @@ static struct cam_vfe_top_ver2_reg_offset_common vfe175_130_top_common_reg = {
 	.three_D_cfg              = 0x00000054,
 	.violation_status         = 0x0000007C,
 	.reg_update_cmd           = 0x000004AC,
-	.irq_mask_0               = 0x0000005C,
-	.irq_mask_1               = 0x00000060,
-	.irq_status_0             = 0x0000006C,
-	.irq_status_1             = 0x00000070,
 };
 
 static struct cam_vfe_rdi_ver2_reg vfe175_130_rdi_reg = {
@@ -412,32 +226,6 @@ static struct cam_vfe_rdi_reg_data  vfe_175_130_rdi_2_data = {
 	.reg_update_irq_mask      = 0x80,
 };
 
-struct cam_vfe_top_dump_data vfe175_130_dump_data = {
-	.num_reg_dump_entries  =  2,
-	.num_lut_dump_entries  =  1,
-	.dmi_cfg               =  0xc24,
-	.dmi_addr              =  0xc28,
-	.dmi_data_path_hi      =  0xc2C,
-	.dmi_data_path_lo      =  0xc30,
-	.reg_entry = {
-		{
-			.reg_dump_start = 0x0,
-			.reg_dump_end   = 0x1164,
-		},
-		{
-			.reg_dump_start = 0x2000,
-			.reg_dump_end   = 0x397C,
-		},
-	},
-	.lut_entry = {
-		{
-			.lut_word_size = 64,
-			.lut_bank_sel  = 0x40,
-			.lut_addr_size = 180,
-		},
-	},
-};
-
 static struct cam_vfe_top_ver2_hw_info vfe175_130_top_hw_info = {
 	.common_reg = &vfe175_130_top_common_reg,
 	.camif_hw_info = {
@@ -454,7 +242,6 @@ static struct cam_vfe_top_ver2_hw_info vfe175_130_top_hw_info = {
 		.common_reg      = &vfe175_130_top_common_reg,
 		.rdi_reg         = &vfe175_130_rdi_reg,
 		.common_reg_data = &vfe175_130_rdi_reg_data,
-		.rdi_irq_status  = &vfe175_130_rdi_irq_status,
 		.reg_data = {
 			&vfe_175_130_rdi_0_data,
 			&vfe_175_130_rdi_1_data,
@@ -476,7 +263,6 @@ static struct cam_vfe_top_ver2_hw_info vfe175_130_top_hw_info = {
 		CAM_VFE_CAMIF_LITE_VER_2_0,
 		CAM_VFE_IN_RD_VER_1_0,
 	},
-	.dump_data = &vfe175_130_dump_data,
 };
 
 static struct cam_irq_register_set vfe175_130_bus_rd_irq_reg[1] = {
@@ -516,7 +302,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00002544,
 	.mode_cfg_1       = 0x000025A4,
 	.bw_limit         = 0x000025A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -530,7 +315,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00002644,
 	.mode_cfg_1       = 0x000026A4,
 	.bw_limit         = 0x000026A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -544,7 +328,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00003644,
 	.mode_cfg_1       = 0x000036A4,
 	.bw_limit         = 0x000036A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
@@ -558,7 +341,6 @@ static struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client
 	.mode_cfg_0       = 0x00003744,
 	.mode_cfg_1       = 0x000037A4,
 	.bw_limit         = 0x000037A0,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_rd_ver1_hw_info vfe175_130_bus_rd_hw_info = {
@@ -598,7 +380,6 @@ static struct cam_vfe_bus_rd_ver1_hw_info vfe175_130_bus_rd_hw_info = {
 			.max_height    = -1,
 		},
 	},
-	.top_irq_shift = 23,
 };
 
 static struct cam_vfe_bus_ver2_hw_info vfe175_130_bus_hw_info = {
@@ -1316,8 +1097,6 @@ static struct cam_vfe_bus_ver2_hw_info vfe175_130_bus_hw_info = {
 			.max_height    = 1080,
 		},
 	},
-	.stats_data = &stats_175_130_info,
-	.support_consumed_addr = false,
 };
 
 struct cam_vfe_hw_info cam_vfe175_130_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe480.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe480.h
index 5b676ae8cf2a..ae65df7c1126 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe480.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe480.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 
@@ -78,7 +77,6 @@ static struct cam_vfe_camif_ver3_reg_data vfe_480_camif_reg_data = {
 	.error_irq_mask0                 = 0x82000200,
 	.error_irq_mask2                 = 0x30301F80,
 	.subscribe_irq_mask1             = 0x00000007,
-	.frame_id_irq_mask               = 0x400,
 	.enable_diagnostic_hw            = 0x1,
 	.pp_camif_cfg_en_shift           = 0,
 	.pp_camif_cfg_ife_out_en_shift   = 8,
@@ -96,12 +94,6 @@ static struct cam_vfe_top_ver3_reg_offset_common vfe480_top_common_reg = {
 	.global_reset_cmd         = 0x0000001C,
 	.core_cfg_0               = 0x0000002C,
 	.core_cfg_1               = 0x00000030,
-	.irq_mask_0               = 0x0000003C,
-	.irq_mask_1               = 0x00000040,
-	.irq_mask_2               = 0x00000044,
-	.irq_status_0             = 0x00000054,
-	.irq_status_1             = 0x00000058,
-	.irq_status_2             = 0x0000005C,
 	.reg_update_cmd           = 0x00000034,
 	.violation_status         = 0x00000074,
 	.core_cgc_ovd_0           = 0x00000020,
@@ -109,7 +101,7 @@ static struct cam_vfe_top_ver3_reg_offset_common vfe480_top_common_reg = {
 	.ahb_cgc_ovd              = 0x00000024,
 	.noc_cgc_ovd              = 0x00000028,
 	.trigger_cdm_events       = 0x00000090,
-	.custom_frame_idx         = 0x00000110,
+	.sbi_frame_idx            = 0x00000110,
 	.dsp_status               = 0x0000007C,
 	.diag_config              = 0x00000064,
 	.diag_sensor_status_0     = 0x00000068,
@@ -347,7 +339,6 @@ static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
 	.lossy_thresh1    = 0x0000AC58,
 	.off_lossy_var    = 0x0000AC5C,
 	.bw_limit         = 0x0000AC1C,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
@@ -361,7 +352,6 @@ static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
 	.lossy_thresh1    = 0x0000AD58,
 	.off_lossy_var    = 0x0000AD5C,
 	.bw_limit         = 0x0000AD1C,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
@@ -375,7 +365,6 @@ static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
 	.lossy_thresh1    = 0x0000B058,
 	.off_lossy_var    = 0x0000B05C,
 	.bw_limit         = 0x0000B01C,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
@@ -389,7 +378,6 @@ static struct cam_vfe_bus_ver3_reg_offset_ubwc_client
 	.lossy_thresh1    = 0x0000B158,
 	.off_lossy_var    = 0x0000B15C,
 	.bw_limit         = 0x0000B11C,
-	.ubwc_comp_en_bit = BIT(1),
 };
 
 static struct cam_vfe_bus_ver3_hw_info vfe480_bus_hw_info = {
@@ -1324,7 +1312,6 @@ static struct cam_vfe_bus_ver3_hw_info vfe480_bus_hw_info = {
 	},
 	.comp_done_shift = 6,
 	.top_irq_shift   = 7,
-	.support_consumed_addr = true,
 };
 
 static struct cam_irq_register_set vfe480_bus_rd_irq_reg[1] = {
@@ -1372,7 +1359,6 @@ static struct cam_vfe_bus_rd_ver1_hw_info vfe480_bus_rd_hw_info = {
 			.max_height    = -1,
 		},
 	},
-	.top_irq_shift = 8,
 };
 
 struct cam_vfe_hw_info cam_vfe480_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite17x.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite17x.h
index ce7a4fb6711e..aab38c791637 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite17x.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite17x.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_LITE17X_H_
@@ -88,14 +87,6 @@ static struct cam_vfe_rdi_reg_data  vfe17x_rdi_3_data = {
 	.reg_update_irq_mask      = 0x100,
 };
 
-static struct cam_vfe_rdi_overflow_status vfe17x_rdi_irq_status = {
-	.rdi0_overflow_mask = 0x8,
-	.rdi1_overflow_mask = 0x10,
-	.rdi2_overflow_mask = 0x18,
-	.rdi3_overflow_mask = 0x20,
-	.rdi_overflow_mask  = 0x3c,
-};
-
 static struct cam_vfe_top_ver2_hw_info vfe17x_top_hw_info = {
 	.common_reg = &vfe17x_top_common_reg,
 	.camif_hw_info = {
@@ -113,7 +104,6 @@ static struct cam_vfe_top_ver2_hw_info vfe17x_top_hw_info = {
 			&vfe17x_rdi_2_data,
 			&vfe17x_rdi_3_data,
 			},
-		.rdi_irq_status  = &vfe17x_rdi_irq_status,
 		},
 	.num_mux = 4,
 	.mux_type = {
@@ -332,7 +322,6 @@ static struct cam_vfe_bus_ver2_hw_info vfe17x_bus_hw_info = {
 			.max_height    = -1,
 		},
 	},
-	.support_consumed_addr = false,
 };
 
 static struct cam_vfe_hw_info cam_vfe_lite17x_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite48x.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite48x.h
index 9601eb6ee1a5..c19ade50bec9 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite48x.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe17x/cam_vfe_lite48x.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_LITE48x_H_
@@ -394,7 +394,6 @@ static struct cam_vfe_bus_ver3_hw_info vfe48x_bus_hw_info = {
 	},
 	.comp_done_shift = 4,
 	.top_irq_shift   = 4,
-	.support_consumed_addr = true,
 };
 
 static struct cam_vfe_hw_info cam_vfe_lite48x_hw_info = {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/Makefile b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/Makefile
index aa3fb1c74358..d5ab83c81dd7 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/Makefile
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/Makefile
@@ -3,7 +3,6 @@
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_utils/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_cdm/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_core/
-ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_req_mgr/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/include
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.c
index ca1ef5977a53..314ebff70fc0 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/ratelimit.h>
@@ -37,29 +37,24 @@ static const char drv_name[] = "vfe_bus_rd";
 		buf_array[(index)++] = val;                \
 	} while (0)
 
-#define BUS_RD_VER1_DEFAULT_LATENCY_BUF_ALLOC 512
-
 enum cam_vfe_bus_rd_ver1_unpacker_format {
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_128             = 0x0,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_8               = 0x1,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_10BPP        = 0x2,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_12BPP        = 0x3,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_14BPP        = 0x4,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_32_20BPP        = 0x5,
-	BUS_RD_VER1_UNPACKER_FMT_ARGB_10               = 0x6,
-	BUS_RD_VER1_UNPACKER_FMT_ARGB_12               = 0x7,
-	BUS_RD_VER1_UNPACKER_FMT_ARGB_14               = 0x8,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_32              = 0x9,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_64              = 0xA,
-	BUS_RD_VER1_UNPACKER_FMT_TP_10                 = 0xB,
-	BUS_RD_VER1_UNPACKER_FMT_MIPI8                 = 0xC,
-	BUS_RD_VER1_UNPACKER_FMT_MIPI10                = 0xD,
-	BUS_RD_VER1_UNPACKER_FMT_MIPI12                = 0xE,
-	BUS_RD_VER1_UNPACKER_FMT_MIPI14                = 0xF,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_16BPP        = 0x10,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_128_ODD_EVEN    = 0x11,
-	BUS_RD_VER1_UNPACKER_FMT_PLAIN_8_ODD_EVEN      = 0x12,
-	BUS_RD_VER1_UNPACKER_FMT_MAX                   = 0x13,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_128                   = 0x0,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_8                     = 0x1,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_16_10BPP              = 0x2,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_16_12BPP              = 0x3,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_16_14BPP              = 0x4,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_16_16BPP              = 0x5,
+	BUS_RD_VER1_PACKER_FMT_ARGB_10                     = 0x6,
+	BUS_RD_VER1_PACKER_FMT_ARGB_12                     = 0x7,
+	BUS_RD_VER1_PACKER_FMT_ARGB_14                     = 0x8,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_32_20BPP              = 0x9,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_64                    = 0xA,
+	BUS_RD_VER1_PACKER_FMT_TP_10                       = 0xB,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_32_32BPP              = 0xC,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_8_ODD_EVEN            = 0xD,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_8_LSB_MSB_10          = 0xE,
+	BUS_RD_VER1_PACKER_FMT_PLAIN_8_LSB_MSB_10_ODD_EVEN = 0xF,
+	BUS_RD_VER1_PACKER_FMT_MAX                         = 0xF,
 };
 
 struct cam_vfe_bus_rd_ver1_common_data {
@@ -79,7 +74,6 @@ struct cam_vfe_bus_rd_ver1_common_data {
 	uint32_t                                    num_sec_out;
 	uint32_t                                    fs_sync_enable;
 	uint32_t                                    go_cmd_sel;
-	cam_hw_mgr_event_cb_func                    event_cb;
 };
 
 struct cam_vfe_bus_rd_ver1_rm_resource_data {
@@ -89,6 +83,7 @@ struct cam_vfe_bus_rd_ver1_rm_resource_data {
 	void                *ctx;
 
 	bool                 init_cfg_done;
+	bool                 hfr_cfg_done;
 
 	uint32_t             offset;
 
@@ -130,16 +125,12 @@ struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data {
 	uint32_t                         max_height;
 	struct cam_cdm_utils_ops        *cdm_util_ops;
 	uint32_t                         secure_mode;
-	int                              irq_handle;
-	void                            *priv;
-	uint32_t                         status;
-	bool                             is_offline;
 };
 
 struct cam_vfe_bus_rd_ver1_priv {
 	struct cam_vfe_bus_rd_ver1_common_data common_data;
-	uint32_t                               num_client;
-	uint32_t                               num_bus_rd_resc;
+	uint32_t                            num_client;
+	uint32_t                            num_bus_rd_resc;
 
 	struct cam_isp_resource_node  bus_client[
 		CAM_VFE_BUS_RD_VER1_MAX_CLIENTS];
@@ -147,105 +138,32 @@ struct cam_vfe_bus_rd_ver1_priv {
 		CAM_VFE_BUS_RD_VER1_VFE_BUSRD_MAX];
 
 	int                                 irq_handle;
-	void                               *tasklet_info;
-	uint32_t                            top_irq_shift;
+	int                                 error_irq_handle;
 };
 
-static int cam_vfe_bus_rd_process_cmd(
+static int cam_vfe_bus_process_cmd(
 	struct cam_isp_resource_node *priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size);
 
-static void cam_vfe_bus_rd_pxls_to_bytes(uint32_t pxls, uint32_t fmt,
-	uint32_t *bytes)
+static enum cam_vfe_bus_rd_ver1_unpacker_format
+	cam_vfe_bus_get_unpacker_fmt(uint32_t unpack_fmt)
 {
-	switch (fmt) {
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_128:
-		*bytes = pxls * 16;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_8:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_8_ODD_EVEN:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_10BPP:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_12BPP:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_14BPP:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_16BPP:
-	case BUS_RD_VER1_UNPACKER_FMT_ARGB_10:
-	case BUS_RD_VER1_UNPACKER_FMT_ARGB_12:
-	case BUS_RD_VER1_UNPACKER_FMT_ARGB_14:
-		*bytes = pxls * 2;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_32_20BPP:
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_32:
-		*bytes = pxls * 4;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_PLAIN_64:
-		*bytes = pxls * 8;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_TP_10:
-		*bytes = ALIGNUP(pxls, 3) * 4 / 3;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_MIPI8:
-		*bytes = pxls;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_MIPI10:
-		*bytes = ALIGNUP(pxls * 5, 4) / 4;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_MIPI12:
-		*bytes = ALIGNUP(pxls * 3, 2) / 2;
-		break;
-	case BUS_RD_VER1_UNPACKER_FMT_MIPI14:
-		*bytes = ALIGNUP(pxls * 7, 4) / 4;
-		break;
+	switch (unpack_fmt) {
+	case CAM_FORMAT_MIPI_RAW_10:
+		return BUS_RD_VER1_PACKER_FMT_PLAIN_8_ODD_EVEN;
 	default:
-		CAM_ERR(CAM_ISP, "Invalid unpacker_fmt:%d", fmt);
-		break;
+		return BUS_RD_VER1_PACKER_FMT_MAX;
 	}
 }
 
-static enum cam_vfe_bus_rd_ver1_unpacker_format
-	cam_vfe_bus_get_unpacker_fmt(uint32_t unpack_fmt)
+static bool cam_vfe_bus_can_be_secure(uint32_t out_type)
 {
-	switch (unpack_fmt) {
-	case CAM_FORMAT_PLAIN128:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_128;
-	case CAM_FORMAT_PLAIN8:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_8;
-	case CAM_FORMAT_PLAIN16_10:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_10BPP;
-	case CAM_FORMAT_PLAIN16_12:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_12BPP;
-	case CAM_FORMAT_PLAIN16_14:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_14BPP;
-	case CAM_FORMAT_PLAIN32_20:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_32_20BPP;
-	case CAM_FORMAT_ARGB_10:
-		return BUS_RD_VER1_UNPACKER_FMT_ARGB_10;
-	case CAM_FORMAT_ARGB_12:
-		return BUS_RD_VER1_UNPACKER_FMT_ARGB_12;
-	case CAM_FORMAT_ARGB_14:
-		return BUS_RD_VER1_UNPACKER_FMT_ARGB_14;
-	case CAM_FORMAT_PLAIN32:
-	case CAM_FORMAT_ARGB:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_32;
-	case CAM_FORMAT_PLAIN64:
-	case CAM_FORMAT_ARGB_16:
-	case CAM_FORMAT_PD10:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_64;
-	case CAM_FORMAT_TP10:
-		return BUS_RD_VER1_UNPACKER_FMT_TP_10;
-	case CAM_FORMAT_MIPI_RAW_8:
-		return BUS_RD_VER1_UNPACKER_FMT_MIPI8;
-	case CAM_FORMAT_MIPI_RAW_10:
-		return BUS_RD_VER1_UNPACKER_FMT_MIPI10;
-	case CAM_FORMAT_MIPI_RAW_12:
-		return BUS_RD_VER1_UNPACKER_FMT_MIPI12;
-	case CAM_FORMAT_MIPI_RAW_14:
-		return BUS_RD_VER1_UNPACKER_FMT_MIPI14;
-	case CAM_FORMAT_PLAIN16_16:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_16_16BPP;
-	case CAM_FORMAT_PLAIN8_SWAP:
-		return BUS_RD_VER1_UNPACKER_FMT_PLAIN_8_ODD_EVEN;
+	switch (out_type) {
+	case CAM_VFE_BUS_RD_VER1_VFE_BUSRD_RDI0:
+		return false;
+
 	default:
-		return BUS_RD_VER1_UNPACKER_FMT_MAX;
+		return false;
 	}
 }
 
@@ -267,58 +185,12 @@ static int cam_vfe_bus_get_num_rm(
 	case CAM_VFE_BUS_RD_VER1_VFE_BUSRD_RDI0:
 		return 1;
 	default:
-		CAM_ERR(CAM_ISP, "Unsupported resource_type %u", res_type);
-		return -EINVAL;
-	}
-}
-
-static int cam_vfe_bus_rd_handle_irq_top_half(uint32_t evt_id,
-	struct cam_irq_th_payload *th_payload)
-{
-	struct cam_isp_resource_node                *bus_rd = NULL;
-	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rsrc_data = NULL;
-
-	bus_rd = th_payload->handler_priv;
-	if (!bus_rd) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "No resource");
-		return -ENODEV;
-	}
-	rsrc_data = bus_rd->res_priv;
-	rsrc_data->status = th_payload->evt_status_arr[0];
-
-	CAM_DBG(CAM_ISP, "VFE:%d Bus RD IRQ status_0: 0x%X",
-		rsrc_data->common_data->core_index,
-		th_payload->evt_status_arr[0]);
-
-	return 0;
-}
-
-static int cam_vfe_bus_rd_handle_irq_bottom_half(
-	void  *handler_priv, void *evt_payload_priv)
-{
-	struct cam_isp_resource_node                *bus_rd = NULL;
-	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rsrc_data = NULL;
-
-	bus_rd = (struct cam_isp_resource_node *)handler_priv;
-	if (!bus_rd) {
-		CAM_ERR_RATE_LIMIT(CAM_ISP, "No resource");
-		return -ENODEV;
-	}
-	rsrc_data = bus_rd->res_priv;
-
-	if (rsrc_data->status & 0x2)
-		CAM_DBG(CAM_ISP, "Received VFE:%d BUS RD RUP",
-			rsrc_data->common_data->core_index);
-	else if (rsrc_data->status & 0x4)
-		CAM_DBG(CAM_ISP, "Received VFE:%d BUS RD BUF DONE",
-			rsrc_data->common_data->core_index);
-	else if (rsrc_data->status & 0x10000) {
-		CAM_ERR(CAM_ISP, "Received VFE:%d BUS RD CCIF Violation",
-			rsrc_data->common_data->core_index);
-		return CAM_VFE_IRQ_STATUS_VIOLATION;
+		break;
 	}
 
-	return CAM_VFE_IRQ_STATUS_SUCCESS;
+	CAM_ERR(CAM_ISP, "Unsupported resource_type %u",
+		res_type);
+	return -EINVAL;
 }
 
 static int cam_vfe_bus_get_rm_idx(
@@ -345,18 +217,19 @@ static int cam_vfe_bus_get_rm_idx(
 }
 
 static int cam_vfe_bus_acquire_rm(
-	struct cam_vfe_bus_rd_ver1_priv             *ver1_bus_rd_priv,
-	void                                        *tasklet,
-	void                                        *ctx,
-	enum cam_vfe_bus_rd_ver1_vfe_bus_rd_type     vfe_bus_rd_res_id,
-	enum cam_vfe_bus_plane_type                  plane,
-	struct cam_isp_resource_node               **rm_res,
-	uint32_t                                    *client_done_mask,
-	uint32_t                                     is_dual,
-	uint32_t                                     unpacker_fmt)
+	struct cam_vfe_bus_rd_ver1_priv          *ver1_bus_rd_priv,
+	struct cam_isp_out_port_generic_info     *out_port_info,
+	void                                     *tasklet,
+	void                                     *ctx,
+	enum cam_vfe_bus_rd_ver1_vfe_bus_rd_type  vfe_bus_rd_res_id,
+	enum cam_vfe_bus_plane_type               plane,
+	uint32_t                                  subscribe_irq,
+	struct cam_isp_resource_node            **rm_res,
+	uint32_t                                 *client_done_mask,
+	uint32_t                                  is_dual)
 {
-	uint32_t                                     rm_idx = 0;
-	struct cam_isp_resource_node                *rm_res_local = NULL;
+	uint32_t rm_idx = 0;
+	struct cam_isp_resource_node              *rm_res_local = NULL;
 	struct cam_vfe_bus_rd_ver1_rm_resource_data *rsrc_data = NULL;
 
 	*rm_res = NULL;
@@ -365,15 +238,14 @@ static int cam_vfe_bus_acquire_rm(
 	/* No need to allocate for BUS VER2. VFE OUT to RM is fixed. */
 	rm_idx = cam_vfe_bus_get_rm_idx(vfe_bus_rd_res_id, plane);
 	if (rm_idx < 0 || rm_idx >= ver1_bus_rd_priv->num_client) {
-		CAM_ERR(CAM_ISP, "Unsupported VFE RM:%d plane:%d",
+		CAM_ERR(CAM_ISP, "Unsupported VFE out %d plane %d",
 			vfe_bus_rd_res_id, plane);
 		return -EINVAL;
 	}
 
 	rm_res_local = &ver1_bus_rd_priv->bus_client[rm_idx];
 	if (rm_res_local->res_state != CAM_ISP_RESOURCE_STATE_AVAILABLE) {
-		CAM_ERR(CAM_ISP, "VFE:%d RM:%d res not available state:%d",
-			ver1_bus_rd_priv->common_data.core_index, rm_idx,
+		CAM_ERR(CAM_ISP, "RM res not available state:%d",
 			rm_res_local->res_state);
 		return -EALREADY;
 	}
@@ -383,22 +255,18 @@ static int cam_vfe_bus_acquire_rm(
 	rsrc_data = rm_res_local->res_priv;
 	rsrc_data->ctx = ctx;
 	rsrc_data->is_dual = is_dual;
-	rsrc_data->unpacker_cfg = cam_vfe_bus_get_unpacker_fmt(unpacker_fmt);
-	rsrc_data->latency_buf_allocation =
-		BUS_RD_VER1_DEFAULT_LATENCY_BUF_ALLOC;
 	/* Set RM offset value to default */
 	rsrc_data->offset  = 0;
 
-	*client_done_mask = (1 << (rm_idx + 2));
+	*client_done_mask = (1 << rm_idx);
 	*rm_res = rm_res_local;
 
-	CAM_DBG(CAM_ISP, "VFE:%d RM:%d Acquired",
-		rsrc_data->common_data->core_index, rsrc_data->index);
+	CAM_DBG(CAM_ISP, "RM %d: Acquired");
 	return 0;
 }
 
-static int cam_vfe_bus_release_rm(void              *bus_priv,
-	struct cam_isp_resource_node                *rm_res)
+static int cam_vfe_bus_release_rm(void   *bus_priv,
+	struct cam_isp_resource_node     *rm_res)
 {
 	struct cam_vfe_bus_rd_ver1_rm_resource_data *rsrc_data =
 		rm_res->res_priv;
@@ -411,49 +279,68 @@ static int cam_vfe_bus_release_rm(void              *bus_priv,
 	rsrc_data->unpacker_cfg = 0;
 	rsrc_data->burst_len = 0;
 	rsrc_data->init_cfg_done = false;
+	rsrc_data->hfr_cfg_done = false;
 	rsrc_data->en_cfg = 0;
 	rsrc_data->is_dual = 0;
 
 	rm_res->tasklet_info = NULL;
 	rm_res->res_state = CAM_ISP_RESOURCE_STATE_AVAILABLE;
 
-	CAM_DBG(CAM_ISP, "VFE:%d RM:%d released",
-		rsrc_data->common_data->core_index, rsrc_data->index);
 	return 0;
 }
 
 static int cam_vfe_bus_start_rm(struct cam_isp_resource_node *rm_res)
 {
-	struct cam_vfe_bus_rd_ver1_rm_resource_data *rm_data;
-	struct cam_vfe_bus_rd_ver1_common_data      *common_data;
-	uint32_t                                     buf_size;
-
-	rm_data = rm_res->res_priv;
-	common_data = rm_data->common_data;
-
+	int rc = 0;
+	struct cam_vfe_bus_rd_ver1_rm_resource_data *rm_data =
+		rm_res->res_priv;
+	struct cam_vfe_bus_rd_ver1_common_data        *common_data =
+		rm_data->common_data;
+	uint32_t buf_size;
+	uint32_t val;
+	uint32_t offset;
+
+	CAM_DBG(CAM_ISP, "w: 0x%x", rm_data->width);
+	CAM_DBG(CAM_ISP, "h: 0x%x", rm_data->height);
+	CAM_DBG(CAM_ISP, "format: 0x%x", rm_data->format);
+	CAM_DBG(CAM_ISP, "unpacker_cfg: 0x%x", rm_data->unpacker_cfg);
+	CAM_DBG(CAM_ISP, "latency_buf_allocation: 0x%x",
+		rm_data->latency_buf_allocation);
+	CAM_DBG(CAM_ISP, "stride: 0x%x", rm_data->stride);
+	CAM_DBG(CAM_ISP, "go_cmd_sel: 0x%x", rm_data->go_cmd_sel);
+	CAM_DBG(CAM_ISP, "fs_sync_enable: 0x%x", rm_data->fs_sync_enable);
+	CAM_DBG(CAM_ISP, "hbi_count: 0x%x", rm_data->hbi_count);
+	CAM_DBG(CAM_ISP, "fs_line_sync_en: 0x%x", rm_data->fs_line_sync_en);
+	CAM_DBG(CAM_ISP, "fs_mode: 0x%x", rm_data->fs_mode);
+	CAM_DBG(CAM_ISP, "min_vbi: 0x%x", rm_data->min_vbi);
+
+	/* Write All the values*/
+	offset = rm_data->hw_regs->buf_size;
 	buf_size = ((rm_data->width)&(0x0000FFFF)) |
 		((rm_data->height<<16)&(0xFFFF0000));
-	cam_io_w_mb(buf_size, common_data->mem_base +
-		rm_data->hw_regs->buf_size);
-	cam_io_w_mb(rm_data->width, common_data->mem_base +
-		rm_data->hw_regs->stride);
-	cam_io_w_mb(rm_data->unpacker_cfg, common_data->mem_base +
-		rm_data->hw_regs->unpacker_cfg);
-	cam_io_w_mb(rm_data->latency_buf_allocation, common_data->mem_base +
-		rm_data->hw_regs->latency_buf_allocation);
-	cam_io_w_mb(0x1, common_data->mem_base + rm_data->hw_regs->cfg);
-
-	rm_res->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
-
-	CAM_DBG(CAM_ISP,
-		"Start VFE:%d RM:%d offset:0x%X en_cfg:0x%X width:%d height:%d",
-		rm_data->common_data->core_index, rm_data->index,
-		(uint32_t) rm_data->hw_regs->cfg, rm_data->en_cfg,
-		rm_data->width, rm_data->height);
-	CAM_DBG(CAM_ISP, "RM:%d pk_fmt:%d stride:%d", rm_data->index,
-		rm_data->unpacker_cfg, rm_data->stride);
-
-	return 0;
+	cam_io_w_mb(buf_size, common_data->mem_base + offset);
+	CAM_DBG(CAM_ISP, "buf_size: 0x%x", buf_size);
+
+	val = rm_data->width;
+	offset = rm_data->hw_regs->stride;
+	CAM_DBG(CAM_ISP, "offset:0x%x, value:0x%x", offset, val);
+	cam_io_w_mb(val, common_data->mem_base + offset);
+
+	CAM_DBG(CAM_ISP, "rm_data->unpacker_cfg:0x%x", rm_data->unpacker_cfg);
+	val = cam_vfe_bus_get_unpacker_fmt(rm_data->unpacker_cfg);
+	CAM_DBG(CAM_ISP, " value:0x%x", val);
+	offset = rm_data->hw_regs->unpacker_cfg;
+	CAM_DBG(CAM_ISP, "offset:0x%x, value:0x%x", offset, val);
+	cam_io_w_mb(val, common_data->mem_base + offset);
+
+	val = rm_data->latency_buf_allocation;
+	offset = rm_data->hw_regs->latency_buf_allocation;
+	CAM_DBG(CAM_ISP, "offset:0x%x, value:0x%x", offset, val);
+	cam_io_w_mb(val, common_data->mem_base + offset);
+
+	cam_io_w_mb(0x1, common_data->mem_base +
+		rm_data->hw_regs->cfg);
+	return rc;
 }
 
 static int cam_vfe_bus_stop_rm(struct cam_isp_resource_node *rm_res)
@@ -465,13 +352,12 @@ static int cam_vfe_bus_stop_rm(struct cam_isp_resource_node *rm_res)
 		rsrc_data->common_data;
 
 	/* Disable RM */
-	cam_io_w_mb(0x0, common_data->mem_base + rsrc_data->hw_regs->cfg);
+	cam_io_w_mb(0x0,
+		common_data->mem_base + rsrc_data->hw_regs->cfg);
 
 	rm_res->res_state = CAM_ISP_RESOURCE_STATE_RESERVED;
 	rsrc_data->init_cfg_done = false;
-
-	CAM_DBG(CAM_ISP, "VFE:%d RM:%d stopped",
-		rsrc_data->common_data->core_index, rsrc_data->index);
+	rsrc_data->hfr_cfg_done = false;
 
 	return rc;
 }
@@ -486,8 +372,7 @@ static int cam_vfe_bus_init_rm_resource(uint32_t index,
 	rsrc_data = kzalloc(sizeof(struct cam_vfe_bus_rd_ver1_rm_resource_data),
 		GFP_KERNEL);
 	if (!rsrc_data) {
-		CAM_DBG(CAM_ISP, "Failed to alloc VFE:%d RM res priv",
-			ver1_bus_rd_priv->common_data.core_index);
+		CAM_DBG(CAM_ISP, "Failed to alloc for RM res priv");
 		return -ENOMEM;
 	}
 	rm_res->res_priv = rsrc_data;
@@ -503,6 +388,7 @@ static int cam_vfe_bus_init_rm_resource(uint32_t index,
 	rm_res->stop = cam_vfe_bus_stop_rm;
 	rm_res->hw_intf = ver1_bus_rd_priv->common_data.hw_intf;
 
+
 	return 0;
 }
 
@@ -542,13 +428,15 @@ static int cam_vfe_bus_acquire_vfe_bus_rd(void *bus_priv, void *acquire_args,
 	int                                           i;
 	enum cam_vfe_bus_rd_ver1_vfe_bus_rd_type      bus_rd_res_id;
 	int                                           num_rm;
+	uint32_t                                      subscribe_irq;
 	uint32_t                                      client_done_mask;
 	struct cam_vfe_bus_rd_ver1_priv              *ver1_bus_rd_priv =
 		bus_priv;
 	struct cam_vfe_acquire_args                  *acq_args = acquire_args;
-	struct cam_vfe_hw_vfe_bus_rd_acquire_args    *bus_rd_acquire_args;
+	struct cam_vfe_hw_vfe_out_acquire_args       *bus_rd_acquire_args;
 	struct cam_isp_resource_node                 *rsrc_node = NULL;
 	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data   *rsrc_data = NULL;
+	uint32_t                                      secure_caps = 0, mode;
 
 	if (!bus_priv || !acquire_args) {
 		CAM_ERR(CAM_ISP, "Invalid Param");
@@ -557,6 +445,9 @@ static int cam_vfe_bus_acquire_vfe_bus_rd(void *bus_priv, void *acquire_args,
 
 	bus_rd_acquire_args = &acq_args->vfe_bus_rd;
 
+	CAM_DBG(CAM_ISP, "Acquiring resource type 0x%x",
+		acq_args->rsrc_type);
+
 	bus_rd_res_id = cam_vfe_bus_get_bus_rd_res_id(
 		acq_args->rsrc_type);
 	if (bus_rd_res_id == CAM_VFE_BUS_RD_VER1_VFE_BUSRD_MAX)
@@ -568,40 +459,61 @@ static int cam_vfe_bus_acquire_vfe_bus_rd(void *bus_priv, void *acquire_args,
 
 	rsrc_node = &ver1_bus_rd_priv->vfe_bus_rd[bus_rd_res_id];
 	if (rsrc_node->res_state != CAM_ISP_RESOURCE_STATE_AVAILABLE) {
-		CAM_ERR(CAM_ISP, "VFE:%d RM:0x%x not available state:%d",
-			ver1_bus_rd_priv->common_data.core_index,
-			acq_args->rsrc_type, rsrc_node->res_state);
+		CAM_ERR(CAM_ISP, "Resource not available: Res_id %d state:%d",
+			bus_rd_res_id, rsrc_node->res_state);
 		return -EBUSY;
 	}
 
-	rsrc_node->res_id = acq_args->rsrc_type;
 	rsrc_data = rsrc_node->res_priv;
-
-	CAM_DBG(CAM_ISP, "VFE:%d acquire RD type:0x%x",
-		rsrc_data->common_data->core_index, acq_args->rsrc_type);
+	secure_caps = cam_vfe_bus_can_be_secure(
+		rsrc_data->bus_rd_type);
+
+	mode = bus_rd_acquire_args->out_port_info->secure_mode;
+	mutex_lock(&rsrc_data->common_data->bus_mutex);
+	if (secure_caps) {
+		if (!rsrc_data->common_data->num_sec_out) {
+			rsrc_data->secure_mode = mode;
+			rsrc_data->common_data->secure_mode = mode;
+		} else {
+			if (mode == rsrc_data->common_data->secure_mode) {
+				rsrc_data->secure_mode =
+					rsrc_data->common_data->secure_mode;
+			} else {
+				rc = -EINVAL;
+				CAM_ERR_RATE_LIMIT(CAM_ISP,
+					"Mismatch: Acquire mode[%d], drvr mode[%d]",
+					rsrc_data->common_data->secure_mode,
+					mode);
+				mutex_unlock(
+					&rsrc_data->common_data->bus_mutex);
+				return -EINVAL;
+			}
+		}
+		rsrc_data->common_data->num_sec_out++;
+	}
+	mutex_unlock(&rsrc_data->common_data->bus_mutex);
 
 	rsrc_data->num_rm = num_rm;
 	rsrc_node->tasklet_info = acq_args->tasklet;
-	ver1_bus_rd_priv->tasklet_info = acq_args->tasklet;
 	rsrc_node->cdm_ops = bus_rd_acquire_args->cdm_ops;
 	rsrc_data->cdm_util_ops = bus_rd_acquire_args->cdm_ops;
-	rsrc_data->common_data->event_cb = acq_args->event_cb;
-	rsrc_data->priv = acq_args->priv;
-	rsrc_data->is_offline = bus_rd_acquire_args->is_offline;
+
+	subscribe_irq = 1;
 
 	for (i = 0; i < num_rm; i++) {
 		rc = cam_vfe_bus_acquire_rm(ver1_bus_rd_priv,
+			bus_rd_acquire_args->out_port_info,
 			acq_args->tasklet,
 			acq_args->priv,
 			bus_rd_res_id,
 			i,
+			subscribe_irq,
 			&rsrc_data->rm_res[i],
 			&client_done_mask,
-			bus_rd_acquire_args->is_dual,
-			bus_rd_acquire_args->unpacker_fmt);
+			bus_rd_acquire_args->is_dual);
 		if (rc) {
 			CAM_ERR(CAM_ISP,
-				"VFE:%d RM:%d acquire failed rc:%d",
+				"VFE%d RM acquire failed for Out %d rc=%d",
 				rsrc_data->common_data->core_index,
 				bus_rd_res_id, rc);
 			goto release_rm;
@@ -611,8 +523,7 @@ static int cam_vfe_bus_acquire_vfe_bus_rd(void *bus_priv, void *acquire_args,
 	rsrc_node->res_state = CAM_ISP_RESOURCE_STATE_RESERVED;
 	bus_rd_acquire_args->rsrc_node = rsrc_node;
 
-	CAM_DBG(CAM_ISP, "VFE:%d acquire RD 0x%x successful",
-		rsrc_data->common_data->core_index, acq_args->rsrc_type);
+	CAM_DBG(CAM_ISP, "Acquire successful");
 	return rc;
 
 release_rm:
@@ -627,6 +538,7 @@ static int cam_vfe_bus_release_vfe_bus_rd(void *bus_priv, void *release_args,
 	uint32_t i;
 	struct cam_isp_resource_node          *vfe_bus_rd = NULL;
 	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rsrc_data = NULL;
+	uint32_t                               secure_caps = 0;
 
 	if (!bus_priv || !release_args) {
 		CAM_ERR(CAM_ISP, "Invalid input bus_priv %pK release_args %pK",
@@ -638,10 +550,8 @@ static int cam_vfe_bus_release_vfe_bus_rd(void *bus_priv, void *release_args,
 	rsrc_data = vfe_bus_rd->res_priv;
 
 	if (vfe_bus_rd->res_state != CAM_ISP_RESOURCE_STATE_RESERVED) {
-		CAM_ERR(CAM_ISP,
-			"VFE:%d RD type:0x%x invalid resource state:%d",
-			rsrc_data->common_data->core_index,
-			vfe_bus_rd->res_id, vfe_bus_rd->res_state);
+		CAM_ERR(CAM_ISP, "Invalid resource state:%d",
+			vfe_bus_rd->res_state);
 	}
 
 	for (i = 0; i < rsrc_data->num_rm; i++)
@@ -652,6 +562,32 @@ static int cam_vfe_bus_release_vfe_bus_rd(void *bus_priv, void *release_args,
 	vfe_bus_rd->cdm_ops = NULL;
 	rsrc_data->cdm_util_ops = NULL;
 
+	secure_caps = cam_vfe_bus_can_be_secure(rsrc_data->bus_rd_type);
+	mutex_lock(&rsrc_data->common_data->bus_mutex);
+	if (secure_caps) {
+		if (rsrc_data->secure_mode ==
+			rsrc_data->common_data->secure_mode) {
+			rsrc_data->common_data->num_sec_out--;
+			rsrc_data->secure_mode =
+				CAM_SECURE_MODE_NON_SECURE;
+		} else {
+			/*
+			 * The validity of the mode is properly
+			 * checked while acquiring the output port.
+			 * not expected to reach here, unless there is
+			 * some corruption.
+			 */
+			CAM_ERR(CAM_ISP, "driver[%d],resource[%d] mismatch",
+				rsrc_data->common_data->secure_mode,
+				rsrc_data->secure_mode);
+		}
+
+		if (!rsrc_data->common_data->num_sec_out)
+			rsrc_data->common_data->secure_mode =
+				CAM_SECURE_MODE_NON_SECURE;
+	}
+	mutex_unlock(&rsrc_data->common_data->bus_mutex);
+
 	if (vfe_bus_rd->res_state == CAM_ISP_RESOURCE_STATE_RESERVED)
 		vfe_bus_rd->res_state = CAM_ISP_RESOURCE_STATE_AVAILABLE;
 
@@ -659,56 +595,31 @@ static int cam_vfe_bus_release_vfe_bus_rd(void *bus_priv, void *release_args,
 }
 
 static int cam_vfe_bus_start_vfe_bus_rd(
-	struct cam_isp_resource_node          *vfe_bus_rd)
+	struct cam_isp_resource_node          *vfe_out)
 {
 	int rc = 0, i;
-	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data *rsrc_data = NULL;
-	struct cam_vfe_bus_rd_ver1_common_data *common_data = NULL;
-	uint32_t irq_reg_mask[1] = {0x6}, val = 0;
+	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rsrc_data = NULL;
+	struct cam_vfe_bus_rd_ver1_common_data   *common_data = NULL;
 
-	if (!vfe_bus_rd) {
+	if (!vfe_out) {
 		CAM_ERR(CAM_ISP, "Invalid input");
 		return -EINVAL;
 	}
 
-	rsrc_data = vfe_bus_rd->res_priv;
+	rsrc_data = vfe_out->res_priv;
 	common_data = rsrc_data->common_data;
 
-	CAM_DBG(CAM_ISP, "VFE:%d start RD type:0x%x", vfe_bus_rd->res_id);
+	CAM_DBG(CAM_ISP, "Start resource type: %x", rsrc_data->bus_rd_type);
 
-	if (vfe_bus_rd->res_state != CAM_ISP_RESOURCE_STATE_RESERVED) {
+	if (vfe_out->res_state != CAM_ISP_RESOURCE_STATE_RESERVED) {
 		CAM_ERR(CAM_ISP, "Invalid resource state:%d",
-			vfe_bus_rd->res_state);
+			vfe_out->res_state);
 		return -EACCES;
 	}
 
-	if (!rsrc_data->is_offline) {
-		val = (common_data->fs_sync_enable << 5) |
-			(common_data->go_cmd_sel << 4);
-		cam_io_w_mb(val, common_data->mem_base +
-			common_data->common_reg->input_if_cmd);
-	}
-
 	for (i = 0; i < rsrc_data->num_rm; i++)
 		rc = cam_vfe_bus_start_rm(rsrc_data->rm_res[i]);
-
-	rsrc_data->irq_handle = cam_irq_controller_subscribe_irq(
-		common_data->bus_irq_controller,
-		CAM_IRQ_PRIORITY_1,
-		irq_reg_mask,
-		vfe_bus_rd,
-		cam_vfe_bus_rd_handle_irq_top_half,
-		cam_vfe_bus_rd_handle_irq_bottom_half,
-		vfe_bus_rd->tasklet_info,
-		&tasklet_bh_api);
-
-	if (rsrc_data->irq_handle < 1) {
-		CAM_ERR(CAM_ISP, "Failed to subscribe BUS RD IRQ");
-		rsrc_data->irq_handle = 0;
-		return -EFAULT;
-	}
-
-	vfe_bus_rd->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
+	vfe_out->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
 	return rc;
 }
 
@@ -718,6 +629,7 @@ static int cam_vfe_bus_stop_vfe_bus_rd(
 	int rc = 0, i;
 	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rsrc_data = NULL;
 
+	CAM_DBG(CAM_ISP, "E:Stop rd Res");
 	if (!vfe_bus_rd) {
 		CAM_ERR(CAM_ISP, "Invalid input");
 		return -EINVAL;
@@ -727,26 +639,14 @@ static int cam_vfe_bus_stop_vfe_bus_rd(
 
 	if (vfe_bus_rd->res_state == CAM_ISP_RESOURCE_STATE_AVAILABLE ||
 		vfe_bus_rd->res_state == CAM_ISP_RESOURCE_STATE_RESERVED) {
-		CAM_DBG(CAM_ISP, "VFE:%d Bus RD 0x%x state: %d",
-			rsrc_data->common_data->core_index, vfe_bus_rd->res_id,
+		CAM_DBG(CAM_ISP, "vfe_out res_state is %d",
 			vfe_bus_rd->res_state);
 		return rc;
 	}
 	for (i = 0; i < rsrc_data->num_rm; i++)
 		rc = cam_vfe_bus_stop_rm(rsrc_data->rm_res[i]);
 
-	if (rsrc_data->irq_handle) {
-		rc = cam_irq_controller_unsubscribe_irq(
-			rsrc_data->common_data->bus_irq_controller,
-			rsrc_data->irq_handle);
-		rsrc_data->irq_handle = 0;
-	}
-
 	vfe_bus_rd->res_state = CAM_ISP_RESOURCE_STATE_RESERVED;
-
-	CAM_DBG(CAM_ISP, "VFE:%d stopped Bus RD:0x%x",
-		rsrc_data->common_data->core_index,
-		vfe_bus_rd->res_id);
 	return rc;
 }
 
@@ -761,7 +661,7 @@ static int cam_vfe_bus_init_vfe_bus_read_resource(uint32_t  index,
 		bus_rd_hw_info->vfe_bus_rd_hw_info[index].vfe_bus_rd_type;
 
 	if (vfe_bus_rd_resc_type < 0 ||
-		vfe_bus_rd_resc_type >= CAM_VFE_BUS_RD_VER1_VFE_BUSRD_MAX) {
+		vfe_bus_rd_resc_type > CAM_VFE_BUS_RD_VER1_VFE_BUSRD_RDI0) {
 		CAM_ERR(CAM_ISP, "Init VFE Out failed, Invalid type=%d",
 			vfe_bus_rd_resc_type);
 		return -EINVAL;
@@ -799,7 +699,7 @@ static int cam_vfe_bus_init_vfe_bus_read_resource(uint32_t  index,
 
 	vfe_bus_rd->start = cam_vfe_bus_start_vfe_bus_rd;
 	vfe_bus_rd->stop = cam_vfe_bus_stop_vfe_bus_rd;
-	vfe_bus_rd->process_cmd = cam_vfe_bus_rd_process_cmd;
+	vfe_bus_rd->process_cmd = cam_vfe_bus_process_cmd;
 	vfe_bus_rd->hw_intf = bus_rd_priv->common_data.hw_intf;
 
 	return 0;
@@ -838,18 +738,13 @@ static int cam_vfe_bus_deinit_vfe_bus_rd_resource(
 }
 
 static int cam_vfe_bus_rd_ver1_handle_irq(uint32_t    evt_id,
-	struct cam_irq_th_payload *th_payload)
+	struct cam_irq_th_payload                 *th_payload)
 {
-	struct cam_vfe_bus_rd_ver1_priv *bus_priv;
-	int rc = 0;
-
-	bus_priv = th_payload->handler_priv;
-	CAM_DBG(CAM_ISP, "Top Bus RD IRQ Received");
-
-	rc = cam_irq_controller_handle_irq(evt_id,
-		bus_priv->common_data.bus_irq_controller);
+	struct cam_vfe_bus_rd_ver1_priv          *bus_priv;
 
-	return (rc == IRQ_HANDLED) ? 0 : -EINVAL;
+	bus_priv     = th_payload->handler_priv;
+	CAM_DBG(CAM_ISP, "BUS READ IRQ Received");
+	return 0;
 }
 
 static int cam_vfe_bus_rd_update_rm(void *priv, void *cmd_args,
@@ -862,6 +757,7 @@ static int cam_vfe_bus_rd_update_rm(void *priv, void *cmd_args,
 	struct cam_vfe_bus_rd_ver1_rm_resource_data *rm_data = NULL;
 	uint32_t *reg_val_pair;
 	uint32_t  i, j, size = 0;
+	uint32_t  val;
 	uint32_t buf_size = 0;
 
 	bus_priv = (struct cam_vfe_bus_rd_ver1_priv  *) priv;
@@ -898,32 +794,39 @@ static int cam_vfe_bus_rd_update_rm(void *priv, void *cmd_args,
 		rm_data = vfe_bus_rd_data->rm_res[i]->res_priv;
 
 		/* update size register */
-		cam_vfe_bus_rd_pxls_to_bytes(io_cfg->planes[i].width,
-			rm_data->unpacker_cfg, &rm_data->width);
+		rm_data->width = io_cfg->planes[i].width;
 		rm_data->height = io_cfg->planes[i].height;
+		CAM_DBG(CAM_ISP, "RM %d image w 0x%x h 0x%x image size 0x%x",
+			rm_data->index, rm_data->width, rm_data->height,
+			buf_size);
 
 		buf_size = ((rm_data->width)&(0x0000FFFF)) |
 			((rm_data->height<<16)&(0xFFFF0000));
 
+		CAM_DBG(CAM_ISP, "size offset 0x%x buf_size 0x%x",
+			rm_data->hw_regs->buf_size, buf_size);
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 			rm_data->hw_regs->buf_size, buf_size);
-		CAM_DBG(CAM_ISP, "VFE:%d RM:%d image_size:0x%X",
-			rm_data->common_data->core_index,
+		CAM_DBG(CAM_ISP, "RM %d image size 0x%x",
 			rm_data->index, reg_val_pair[j-1]);
 
-		rm_data->stride = io_cfg->planes[i].plane_stride;
+		val = rm_data->width;
+		CAM_DBG(CAM_ISP, "io_cfg stride 0x%x", val);
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-			rm_data->hw_regs->stride, rm_data->stride);
-		CAM_DBG(CAM_ISP, "VFE:%d RM:%d image_stride:0x%X",
-			rm_data->common_data->core_index,
+			rm_data->hw_regs->stride,
+			val);
+		rm_data->stride = val;
+		CAM_DBG(CAM_ISP, "RM %d image stride 0x%x",
 			rm_data->index, reg_val_pair[j-1]);
 
+		/* RM Image address */
+		CAM_DBG(CAM_ISP, "image_addr offset %x",
+			rm_data->hw_regs->image_addr);
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 			rm_data->hw_regs->image_addr,
 			update_buf->rm_update->image_buf[i] +
 				rm_data->offset);
-		CAM_DBG(CAM_ISP, "VFE:%d RM:%d image_address:0x%X",
-			rm_data->common_data->core_index,
+		CAM_DBG(CAM_ISP, "RM %d image address 0x%x",
 			rm_data->index, reg_val_pair[j-1]);
 		rm_data->img_addr = reg_val_pair[j-1];
 
@@ -984,93 +887,43 @@ static int cam_vfe_bus_rd_update_fs_cfg(void *priv, void *cmd_args,
 		common_data = rm_data->common_data;
 
 		rm_data->format = fe_cfg->format;
+		CAM_DBG(CAM_ISP, "format: 0x%x", rm_data->format);
+
 		rm_data->unpacker_cfg = fe_cfg->unpacker_cfg;
+		CAM_DBG(CAM_ISP, "unpacker_cfg: 0x%x", rm_data->unpacker_cfg);
+
 		rm_data->latency_buf_allocation = fe_cfg->latency_buf_size;
+		CAM_DBG(CAM_ISP, "latency_buf_allocation: 0x%x",
+			rm_data->latency_buf_allocation);
+
 		rm_data->stride = fe_cfg->stride;
+		CAM_DBG(CAM_ISP, "stride: 0x%x", rm_data->stride);
+
 		rm_data->go_cmd_sel = fe_cfg->go_cmd_sel;
+		CAM_DBG(CAM_ISP, "go_cmd_sel: 0x%x", rm_data->go_cmd_sel);
+
 		rm_data->fs_sync_enable = fe_cfg->fs_sync_enable;
+		CAM_DBG(CAM_ISP, "fs_sync_enable: 0x%x",
+			rm_data->fs_sync_enable);
+
 		rm_data->hbi_count = fe_cfg->hbi_count;
+		CAM_DBG(CAM_ISP, "hbi_count: 0x%x", rm_data->hbi_count);
+
 		rm_data->fs_line_sync_en = fe_cfg->fs_line_sync_en;
+		CAM_DBG(CAM_ISP, "fs_line_sync_en: 0x%x",
+			rm_data->fs_line_sync_en);
+
 		rm_data->fs_mode = fe_cfg->fs_mode;
-		rm_data->min_vbi = fe_cfg->min_vbi;
+		CAM_DBG(CAM_ISP, "fs_mode: 0x%x", rm_data->fs_mode);
 
-		CAM_DBG(CAM_ISP,
-			"VFE:%d RM:%d format:0x%x unpacker_cfg:0x%x",
-			rm_data->format, rm_data->unpacker_cfg);
-		CAM_DBG(CAM_ISP,
-			"latency_buf_alloc:0x%x stride:0x%x go_cmd_sel:0x%x",
-			rm_data->latency_buf_allocation, rm_data->stride,
-			rm_data->go_cmd_sel);
-		CAM_DBG(CAM_ISP,
-			"fs_sync_en:%d hbi_cnt:0x%x fs_mode:0x%x min_vbi:0x%x",
-			rm_data->fs_sync_enable, rm_data->hbi_count,
-			rm_data->fs_mode, rm_data->min_vbi);
+		rm_data->min_vbi = fe_cfg->min_vbi;
+		CAM_DBG(CAM_ISP, "min_vbi: 0x%x", rm_data->min_vbi);
 	}
 	bus_priv->common_data.fs_sync_enable = fe_cfg->fs_sync_enable;
 	bus_priv->common_data.go_cmd_sel = fe_cfg->go_cmd_sel;
 	return 0;
 }
 
-static int cam_vfe_bus_rd_add_go_cmd(void *priv, void *cmd_args,
-	uint32_t arg_size)
-{
-	struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *rd_data;
-	struct cam_isp_hw_get_cmd_update            *cdm_args = cmd_args;
-	struct cam_cdm_utils_ops                    *cdm_util_ops = NULL;
-	uint32_t reg_val_pair[2 * CAM_VFE_BUS_RD_VER1_VFE_BUSRD_MAX];
-	struct cam_vfe_bus_rd_ver1_rm_resource_data *rsrc_data;
-	int i = 0;
-	uint32_t val = 0, size = 0, offset = 0;
-
-	if (arg_size != sizeof(struct cam_isp_hw_get_cmd_update)) {
-		CAM_ERR(CAM_ISP, "invalid ars size");
-		return -EINVAL;
-	}
-
-	if (!cdm_args || !cdm_args->res) {
-		CAM_ERR(CAM_ISP, "Invalid args");
-		return -EINVAL;
-	}
-
-	rd_data = (struct cam_vfe_bus_rd_ver1_vfe_bus_rd_data  *) priv;
-
-	cdm_util_ops = (struct cam_cdm_utils_ops *)cdm_args->res->cdm_ops;
-
-	if (!cdm_util_ops) {
-		CAM_ERR(CAM_ISP, "Invalid CDM ops");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < rd_data->num_rm; i++) {
-		size = cdm_util_ops->cdm_required_size_reg_random(1);
-		/* since cdm returns dwords, we need to convert it into bytes */
-		if ((size * 4) > cdm_args->cmd.size) {
-			CAM_ERR(CAM_ISP,
-				"buf size:%d is not sufficient, expected: %d",
-				cdm_args->cmd.size, size);
-			return -EINVAL;
-		}
-
-		rsrc_data = rd_data->rm_res[i]->res_priv;
-		offset = rsrc_data->common_data->common_reg->input_if_cmd;
-		val = cam_io_r_mb(rsrc_data->common_data->mem_base + offset);
-		val |= 0x1;
-		reg_val_pair[i * 2] = offset;
-		reg_val_pair[i * 2 + 1] = val;
-		CAM_DBG(CAM_ISP, "VFE:%d Bus RD go_cmd: 0x%x offset 0x%x",
-			rd_data->common_data->core_index,
-			reg_val_pair[i * 2 + 1], reg_val_pair[i * 2]);
-	}
-
-	cdm_util_ops->cdm_write_regrandom(cdm_args->cmd.cmd_buf_addr,
-		1, reg_val_pair);
-
-	cdm_args->cmd.used_bytes = size * 4;
-
-	return 0;
-
-}
-
 static int cam_vfe_bus_start_hw(void *hw_priv,
 	void *start_hw_args, uint32_t arg_size)
 {
@@ -1088,7 +941,7 @@ static int cam_vfe_bus_init_hw(void *hw_priv,
 {
 	struct cam_vfe_bus_rd_ver1_priv    *bus_priv = hw_priv;
 	uint32_t                            top_irq_reg_mask[3] = {0};
-	uint32_t                            offset = 0;
+	uint32_t                            offset = 0, val = 0;
 	struct cam_vfe_bus_rd_ver1_reg_offset_common  *common_reg;
 
 	if (!bus_priv) {
@@ -1096,7 +949,7 @@ static int cam_vfe_bus_init_hw(void *hw_priv,
 		return -EINVAL;
 	}
 	common_reg = bus_priv->common_data.common_reg;
-	top_irq_reg_mask[0] = (1 << bus_priv->top_irq_shift);
+	top_irq_reg_mask[0] = (1 << 23);
 
 	bus_priv->irq_handle = cam_irq_controller_subscribe_irq(
 		bus_priv->common_data.vfe_irq_controller,
@@ -1113,15 +966,23 @@ static int cam_vfe_bus_init_hw(void *hw_priv,
 		bus_priv->irq_handle = 0;
 		return -EFAULT;
 	}
-
 	/* no clock gating at bus input */
 	offset = common_reg->cgc_ovd;
-	cam_io_w_mb(0x1, bus_priv->common_data.mem_base + offset);
+	cam_io_w_mb(0x0, bus_priv->common_data.mem_base + offset);
 
 	/* BUS_RD_TEST_BUS_CTRL */
 	offset = common_reg->test_bus_ctrl;
 	cam_io_w_mb(0x0, bus_priv->common_data.mem_base + offset);
 
+	/* Read irq mask */
+	offset = common_reg->irq_reg_info.irq_reg_set->mask_reg_offset;
+	cam_io_w_mb(0x5, bus_priv->common_data.mem_base + offset);
+
+	/* INPUT_IF_CMD */
+	val = (bus_priv->common_data.fs_sync_enable << 5) |
+		(bus_priv->common_data.go_cmd_sel << 4);
+	offset = common_reg->input_if_cmd;
+	cam_io_w_mb(val, bus_priv->common_data.mem_base + offset);
 	return 0;
 }
 
@@ -1136,6 +997,13 @@ static int cam_vfe_bus_deinit_hw(void *hw_priv,
 		return -EINVAL;
 	}
 
+	if (bus_priv->error_irq_handle) {
+		rc = cam_irq_controller_unsubscribe_irq(
+			bus_priv->common_data.bus_irq_controller,
+			bus_priv->error_irq_handle);
+		bus_priv->error_irq_handle = 0;
+	}
+
 	if (bus_priv->irq_handle) {
 		rc = cam_irq_controller_unsubscribe_irq(
 			bus_priv->common_data.vfe_irq_controller,
@@ -1146,13 +1014,13 @@ static int cam_vfe_bus_deinit_hw(void *hw_priv,
 	return rc;
 }
 
-static int __cam_vfe_bus_rd_process_cmd(void *priv,
+static int __cam_vfe_bus_process_cmd(void *priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
 {
-	return cam_vfe_bus_rd_process_cmd(priv, cmd_type, cmd_args, arg_size);
+	return cam_vfe_bus_process_cmd(priv, cmd_type, cmd_args, arg_size);
 }
 
-static int cam_vfe_bus_rd_process_cmd(
+static int cam_vfe_bus_process_cmd(
 	struct cam_isp_resource_node *priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
 {
@@ -1176,9 +1044,6 @@ static int cam_vfe_bus_rd_process_cmd(
 	case CAM_ISP_HW_CMD_FE_UPDATE_BUS_RD:
 		rc = cam_vfe_bus_rd_update_fs_cfg(priv, cmd_args, arg_size);
 		break;
-	case CAM_ISP_HW_CMD_FE_TRIGGER_CMD:
-		rc = cam_vfe_bus_rd_add_go_cmd(priv, cmd_args, arg_size);
-		break;
 	default:
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid camif process command:%d",
 			cmd_type);
@@ -1237,7 +1102,6 @@ int cam_vfe_bus_rd_ver1_init(
 	bus_priv->common_data.hw_intf            = hw_intf;
 	bus_priv->common_data.vfe_irq_controller = vfe_irq_controller;
 	bus_priv->common_data.common_reg         = &bus_rd_hw_info->common_reg;
-	bus_priv->top_irq_shift                 = bus_rd_hw_info->top_irq_shift;
 
 	mutex_init(&bus_priv->common_data.bus_mutex);
 
@@ -1277,7 +1141,7 @@ int cam_vfe_bus_rd_ver1_init(
 	vfe_bus_local->hw_ops.deinit       = cam_vfe_bus_deinit_hw;
 	vfe_bus_local->top_half_handler    = cam_vfe_bus_rd_ver1_handle_irq;
 	vfe_bus_local->bottom_half_handler = NULL;
-	vfe_bus_local->hw_ops.process_cmd  = __cam_vfe_bus_rd_process_cmd;
+	vfe_bus_local->hw_ops.process_cmd  = __cam_vfe_bus_process_cmd;
 
 	*vfe_bus = vfe_bus_local;
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.h
index 90229b179c0d..19cc86496371 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_rd_ver1.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_BUS_R_VER1_H_
@@ -88,7 +88,6 @@ struct cam_vfe_bus_rd_ver1_hw_info {
 	uint32_t num_bus_rd_resc;
 	struct cam_vfe_bus_rd_ver1_vfe_bus_hw_info
 		vfe_bus_rd_hw_info[CAM_VFE_BUS_RD_VER1_VFE_BUSRD_MAX];
-	uint32_t top_irq_shift;
 };
 
 /*
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.c
index 87822eb459b8..9094f1409a66 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/ratelimit.h>
@@ -28,8 +27,6 @@ static const char drv_name[] = "vfe_bus";
 #define CAM_VFE_BUS_IRQ_REG2                     2
 #define CAM_VFE_BUS_IRQ_MAX                      3
 
-#define CAM_VFE_BUS_LUT_WORD_SIZE_64             1
-
 #define CAM_VFE_BUS_VER2_PAYLOAD_MAX             256
 
 #define CAM_VFE_BUS_SET_DEBUG_REG                0x82
@@ -103,9 +100,6 @@ struct cam_vfe_bus_ver2_common_data {
 	uint32_t                                    addr_no_sync;
 	cam_hw_mgr_event_cb_func                    event_cb;
 	bool                                        hw_init;
-	struct cam_vfe_bus_ver2_stats_cfg_info     *stats_data;
-	bool                                        disable_ubwc_comp;
-	bool                                        support_consumed_addr;
 };
 
 struct cam_vfe_bus_ver2_wm_resource_data {
@@ -146,8 +140,6 @@ struct cam_vfe_bus_ver2_wm_resource_data {
 	uint32_t             ubwc_lossy_threshold_0;
 	uint32_t             ubwc_lossy_threshold_1;
 	uint32_t             ubwc_bandwidth_limit;
-	uint32_t             acquired_width;
-	uint32_t             acquired_height;
 };
 
 struct cam_vfe_bus_ver2_comp_grp_data {
@@ -263,28 +255,6 @@ static enum cam_vfe_bus_comp_grp_id
 	}
 }
 
-static enum cam_vfe_bus_ver2_comp_grp_type
-	cam_vfe_bus_dual_comp_grp_id_convert(uint32_t comp_grp)
-{
-	switch (comp_grp) {
-	case CAM_VFE_BUS_COMP_GROUP_ID_0:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_0;
-	case CAM_VFE_BUS_COMP_GROUP_ID_1:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_1;
-	case CAM_VFE_BUS_COMP_GROUP_ID_2:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_2;
-	case CAM_VFE_BUS_COMP_GROUP_ID_3:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_3;
-	case CAM_VFE_BUS_COMP_GROUP_ID_4:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_4;
-	case CAM_VFE_BUS_COMP_GROUP_ID_5:
-		return CAM_VFE_BUS_VER2_COMP_GRP_DUAL_5;
-	case CAM_VFE_BUS_COMP_GROUP_NONE:
-	default:
-		return CAM_VFE_BUS_VER2_COMP_GRP_MAX;
-	}
-}
-
 static int cam_vfe_bus_put_evt_payload(
 	struct cam_vfe_bus_ver2_common_data     *common_data,
 	struct cam_vfe_bus_irq_evt_payload     **evt_payload)
@@ -349,7 +319,6 @@ static int cam_vfe_bus_ver2_get_intra_client_mask(
 	case CAM_VFE_BUS_VER2_VFE_CORE_0:
 		switch (dual_slave_core) {
 		case CAM_VFE_BUS_VER2_VFE_CORE_1:
-		case CAM_VFE_BUS_VER2_VFE_CORE_2:
 			*intra_client_mask = version_based_intra_client_mask;
 			break;
 		default:
@@ -362,20 +331,6 @@ static int cam_vfe_bus_ver2_get_intra_client_mask(
 	case CAM_VFE_BUS_VER2_VFE_CORE_1:
 		switch (dual_slave_core) {
 		case CAM_VFE_BUS_VER2_VFE_CORE_0:
-		case CAM_VFE_BUS_VER2_VFE_CORE_2:
-			*intra_client_mask = version_based_intra_client_mask;
-			break;
-		default:
-			CAM_ERR(CAM_ISP, "Invalid value for slave core %u",
-				dual_slave_core);
-			rc = -EINVAL;
-			break;
-		}
-		break;
-	case CAM_VFE_BUS_VER2_VFE_CORE_2:
-		switch (dual_slave_core) {
-		case CAM_VFE_BUS_VER2_VFE_CORE_0:
-		case CAM_VFE_BUS_VER2_VFE_CORE_1:
 			*intra_client_mask = version_based_intra_client_mask;
 			break;
 		default:
@@ -1013,8 +968,6 @@ static int cam_vfe_bus_acquire_wm(
 
 	rsrc_data->width = out_port_info->width;
 	rsrc_data->height = out_port_info->height;
-	rsrc_data->acquired_width = out_port_info->width;
-	rsrc_data->acquired_height = out_port_info->height;
 	rsrc_data->is_dual = is_dual;
 	/* Set WM offset value to default */
 	rsrc_data->offset  = 0;
@@ -1285,13 +1238,6 @@ static int cam_vfe_bus_start_wm(
 			val = cam_io_r_mb(common_data->mem_base +
 				ubwc_regs->mode_cfg_0);
 			val |= 0x1;
-			if (rsrc_data->common_data->disable_ubwc_comp) {
-				val &= ~ubwc_regs->ubwc_comp_en_bit;
-				CAM_DBG(CAM_ISP,
-					"Force disable UBWC, VFE:%d, WM:%d",
-					rsrc_data->common_data->core_index,
-					rsrc_data->index);
-			}
 			cam_io_w_mb(val, common_data->mem_base +
 				ubwc_regs->mode_cfg_0);
 		} else if ((camera_hw_version == CAM_CPAS_TITAN_175_V100) ||
@@ -1308,13 +1254,6 @@ static int cam_vfe_bus_start_wm(
 			val = cam_io_r_mb(common_data->mem_base +
 				ubwc_regs->mode_cfg_0);
 			val |= 0x1;
-			if (rsrc_data->common_data->disable_ubwc_comp) {
-				val &= ~ubwc_regs->ubwc_comp_en_bit;
-				CAM_DBG(CAM_ISP,
-					"Force disable UBWC, VFE:%d, WM:%d",
-					rsrc_data->common_data->core_index,
-					rsrc_data->index);
-			}
 			cam_io_w_mb(val, common_data->mem_base +
 				ubwc_regs->mode_cfg_0);
 		} else {
@@ -1412,40 +1351,6 @@ static int cam_vfe_bus_handle_wm_done_bottom_half(void *handler_priv,
 	return rc;
 }
 
-static void cam_vfe_bus_dump_dmi_reg(
-	void __iomem    *mem_base,
-	uint32_t        lut_word_size,
-	uint32_t        lut_size,
-	uint32_t        lut_bank_sel,
-	struct cam_vfe_bus_ver2_dmi_offset_common dmi_cfg)
-{
-	uint32_t        i;
-	uint32_t        val_0;
-	uint32_t        val_1;
-
-	val_0 = dmi_cfg.auto_increment | lut_bank_sel;
-	cam_io_w_mb(val_0, mem_base + dmi_cfg.cfg_offset);
-	cam_io_w_mb(0, mem_base + dmi_cfg.addr_offset);
-	for (i = 0; i < lut_size; i++) {
-		if (lut_word_size == CAM_VFE_BUS_LUT_WORD_SIZE_64) {
-			val_0 = cam_io_r_mb(mem_base +
-				dmi_cfg.data_lo_offset);
-			val_1 = cam_io_r_mb(mem_base +
-				dmi_cfg.data_hi_offset);
-			CAM_INFO(CAM_ISP,
-				"Bank%d : 0x%x, LO: 0x%x, HI:0x%x",
-				lut_bank_sel, i, val_0, val_1);
-		} else {
-			val_0 = cam_io_r_mb(mem_base +
-				dmi_cfg.data_lo_offset);
-			CAM_INFO(CAM_ISP, "Bank%d : 0x%x, LO: 0x%x",
-				lut_bank_sel, i, val_0);
-		}
-	}
-	cam_io_w_mb(0, mem_base + dmi_cfg.cfg_offset);
-	cam_io_w_mb(0, mem_base + dmi_cfg.addr_offset);
-}
-
 
 static int cam_vfe_bus_err_bottom_half(void *handler_priv,
 	void *evt_payload_priv)
@@ -1454,8 +1359,6 @@ static int cam_vfe_bus_err_bottom_half(void *handler_priv,
 	struct cam_vfe_bus_ver2_priv *bus_priv = handler_priv;
 	struct cam_vfe_bus_ver2_common_data *common_data;
 	struct cam_isp_hw_event_info evt_info;
-	struct cam_vfe_bus_ver2_stats_cfg_offset *stats_cfg = NULL;
-	struct cam_vfe_bus_ver2_dmi_offset_common dmi_cfg = {0};
 	uint32_t val = 0;
 
 	if (!handler_priv || !evt_payload_priv)
@@ -1464,13 +1367,6 @@ static int cam_vfe_bus_err_bottom_half(void *handler_priv,
 	evt_payload = evt_payload_priv;
 	common_data = &bus_priv->common_data;
 
-	if (common_data && common_data->stats_data) {
-		stats_cfg = common_data->stats_data->stats_cfg_offset;
-		dmi_cfg = common_data->stats_data->dmi_offset_info;
-	} else {
-		CAM_INFO(CAM_ISP, "Stats debug dump cfg not available");
-	}
-
 	val = evt_payload->debug_status_0;
 	CAM_ERR(CAM_ISP, "Bus Violation: debug_status_0 = 0x%x", val);
 
@@ -1504,198 +1400,35 @@ static int cam_vfe_bus_err_bottom_half(void *handler_priv,
 	if (val & 0x0200)
 		CAM_INFO(CAM_ISP, "RAW DUMP violation");
 
-	if (val & 0x0400) {
+	if (val & 0x0400)
 		CAM_INFO(CAM_ISP, "PDAF violation");
-		if (stats_cfg) {
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_PDAF].lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_PDAF].lut.bank_0,
-				dmi_cfg);
-			CAM_INFO(CAM_ISP, "RGN offset cfg 0x%08x",
-
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_PDAF].cfg_offset));
-		}
-	}
 
-	if (val & 0x0800) {
+	if (val & 0x0800)
 		CAM_INFO(CAM_ISP, "STATs HDR BE violation");
-		if (stats_cfg) {
-			CAM_INFO(CAM_ISP,
-				"STATs HDR BE vltn RGN offset cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BE].
-				cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BE].
-				num_cfg));
-		}
-	}
 
-	if (val & 0x01000) {
+	if (val & 0x01000)
 		CAM_INFO(CAM_ISP, "STATs HDR BHIST violation");
-		if (stats_cfg) {
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				lut.bank_0,
-				dmi_cfg);
-
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				lut.bank_1,
-				dmi_cfg);
-
-			CAM_INFO(CAM_ISP, "RGN offset cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_HDR_BHIST].
-				num_cfg));
-		}
-	}
 
 	if (val & 0x02000)
 		CAM_INFO(CAM_ISP, "STATs TINTLESS BG violation");
 
-	if (val & 0x04000) {
+	if (val & 0x04000)
 		CAM_INFO(CAM_ISP, "STATs BF violation");
-		if (stats_cfg) {
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF].lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF].lut.bank_0,
-				dmi_cfg);
-
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF].lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF].lut.bank_1,
-				dmi_cfg);
-
-			CAM_INFO(CAM_ISP, "RGN offset cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BF].cfg_offset));
-		}
-	}
 
-	if (val & 0x08000) {
+	if (val & 0x08000)
 		CAM_INFO(CAM_ISP, "STATs AWB BG UBWC violation");
-		if (stats_cfg) {
-			CAM_INFO(CAM_ISP,
-				"STATs AWB BG UBWC vltn RGN ofst cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_AWB_BG].
-				cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_AWB_BG].
-				num_cfg));
-		}
-	}
 
-	if (val & 0x010000) {
+	if (val & 0x010000)
 		CAM_INFO(CAM_ISP, "STATs BHIST violation");
-		if (stats_cfg) {
-			cam_vfe_bus_dump_dmi_reg(common_data->mem_base,
-				CAM_VFE_BUS_LUT_WORD_SIZE_64,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST].lut.size,
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST].
-				lut.bank_0, dmi_cfg);
-
-			CAM_INFO(CAM_ISP, "RGN offset cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST].
-				cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_BHIST].num_cfg));
-		}
-	}
 
-	if (val & 0x020000) {
+	if (val & 0x020000)
 		CAM_INFO(CAM_ISP, "STATs RS violation");
-		if (stats_cfg) {
-			CAM_INFO(CAM_ISP,
-				"STATs RS violation RGN offset cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_RS].cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_RS].num_cfg));
-		}
-	}
 
-	if (val & 0x040000) {
+	if (val & 0x040000)
 		CAM_INFO(CAM_ISP, "STATs CS violation");
-		if (stats_cfg) {
-			CAM_INFO(CAM_ISP,
-				"STATs CS violation RGN offset cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_CS].cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_CS].num_cfg));
-		}
-	}
 
-	if (val & 0x080000) {
+	if (val & 0x080000)
 		CAM_INFO(CAM_ISP, "STATs IHIST violation");
-		if (stats_cfg) {
-			CAM_INFO(CAM_ISP,
-				"STATs IHIST vltn RGN offset cfg 0x%08x",
-				cam_io_r_mb(common_data->mem_base +
-				stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_IHIST].
-				cfg_offset));
-
-			CAM_INFO(CAM_ISP, "RGN num cfg 0x%08x",
-			cam_io_r_mb(common_data->mem_base +
-					stats_cfg[
-				CAM_VFE_BUS_VER2_VFE_OUT_STATS_IHIST].num_cfg));
-		}
-	}
 
 	if (val & 0x0100000)
 		CAM_INFO(CAM_ISP, "DISP Y 1:1 UBWC violation");
@@ -1808,39 +1541,6 @@ static void cam_vfe_bus_match_comp_grp(
 	*comp_grp = NULL;
 }
 
-static int cam_vfe_bus_get_free_dual_comp_grp(
-	struct cam_vfe_bus_ver2_priv  *ver2_bus_priv,
-	struct cam_isp_resource_node **comp_grp,
-	uint32_t                       comp_grp_local_idx)
-{
-	struct cam_vfe_bus_ver2_comp_grp_data  *rsrc_data = NULL;
-	struct cam_isp_resource_node           *dual_comp_grp_local = NULL;
-	struct cam_isp_resource_node           *dual_comp_grp_local_temp = NULL;
-	int32_t  dual_comp_grp_idx = 0;
-	int rc = -EINVAL;
-
-	dual_comp_grp_idx =
-		cam_vfe_bus_dual_comp_grp_id_convert(comp_grp_local_idx);
-
-	CAM_DBG(CAM_ISP, "dual_comp_grp_idx :%d", dual_comp_grp_idx);
-
-	list_for_each_entry_safe(dual_comp_grp_local, dual_comp_grp_local_temp,
-		&ver2_bus_priv->free_dual_comp_grp, list) {
-		rsrc_data = dual_comp_grp_local->res_priv;
-		CAM_DBG(CAM_ISP, "current grp type : %d expected :%d",
-			rsrc_data->comp_grp_type, dual_comp_grp_idx);
-		if (dual_comp_grp_idx != rsrc_data->comp_grp_type) {
-			continue;
-		} else {
-			list_del_init(&dual_comp_grp_local->list);
-			*comp_grp = dual_comp_grp_local;
-			return 0;
-		}
-	}
-
-	return rc;
-}
-
 static int cam_vfe_bus_acquire_comp_grp(
 	struct cam_vfe_bus_ver2_priv        *ver2_bus_priv,
 	struct cam_isp_out_port_generic_info        *out_port_info,
@@ -1873,15 +1573,9 @@ static int cam_vfe_bus_acquire_comp_grp(
 				CAM_ERR(CAM_ISP, "No Free Composite Group");
 				return -ENODEV;
 			}
-			rc = cam_vfe_bus_get_free_dual_comp_grp(
-				ver2_bus_priv, &comp_grp_local,
-				bus_comp_grp_id);
-			if (rc || !comp_grp_local) {
-				CAM_ERR(CAM_ISP,
-					"failed to acquire dual comp grp for :%d rc :%d",
-					bus_comp_grp_id, rc);
-					return rc;
-			}
+			comp_grp_local = list_first_entry(
+				&ver2_bus_priv->free_dual_comp_grp,
+				struct cam_isp_resource_node, list);
 			rsrc_data = comp_grp_local->res_priv;
 			rc = cam_vfe_bus_ver2_get_intra_client_mask(
 				dual_slave_core,
@@ -2344,8 +2038,6 @@ static int cam_vfe_bus_acquire_vfe_out(void *bus_priv, void *acquire_args,
 
 	rsrc_data = rsrc_node->res_priv;
 	rsrc_data->common_data->event_cb = acq_args->event_cb;
-	rsrc_data->common_data->disable_ubwc_comp =
-		out_acquire_args->disable_ubwc_comp;
 	rsrc_data->priv = acq_args->priv;
 
 	secure_caps = cam_vfe_bus_can_be_secure(rsrc_data->out_type);
@@ -2884,7 +2576,6 @@ static void cam_vfe_bus_update_ubwc_meta_addr(
 	case CAM_CPAS_TITAN_170_V100:
 	case CAM_CPAS_TITAN_170_V110:
 	case CAM_CPAS_TITAN_170_V120:
-	case CAM_CPAS_TITAN_170_V200:
 		ubwc_regs =
 			(struct cam_vfe_bus_ver2_reg_offset_ubwc_client *)regs;
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, *j,
@@ -2960,13 +2651,6 @@ static int cam_vfe_bus_update_ubwc_3_regs(
 	CAM_DBG(CAM_ISP, "WM %d meta stride 0x%x",
 		wm_data->index, reg_val_pair[*j-1]);
 
-	if (wm_data->common_data->disable_ubwc_comp) {
-		wm_data->ubwc_mode_cfg_0 &= ~ubwc_regs->ubwc_comp_en_bit;
-		CAM_DBG(CAM_ISP,
-			"UBWC force disable WM:%d, val= 0x%x",
-			wm_data->index, wm_data->ubwc_mode_cfg_0);
-	}
-
 	CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, *j,
 		ubwc_regs->mode_cfg_0, wm_data->ubwc_mode_cfg_0);
 	CAM_DBG(CAM_ISP, "WM %d ubwc_mode_cfg_0 0x%x",
@@ -3046,13 +2730,6 @@ static int cam_vfe_bus_update_ubwc_legacy_regs(
 	CAM_DBG(CAM_ISP, "WM %d meta stride 0x%x",
 		wm_data->index, reg_val_pair[*j-1]);
 
-	if (wm_data->common_data->disable_ubwc_comp) {
-		wm_data->ubwc_mode_cfg_0 &= ~ubwc_regs->ubwc_comp_en_bit;
-		CAM_DBG(CAM_ISP,
-			"UBWC fore disable WM:%d val= 0x%x",
-			wm_data->index, wm_data->ubwc_mode_cfg_0);
-	}
-
 	CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, *j,
 		ubwc_regs->mode_cfg_0, wm_data->ubwc_mode_cfg_0);
 	CAM_DBG(CAM_ISP, "WM %d ubwc_mode_cfg_0 0x%x",
@@ -3116,7 +2793,6 @@ static int cam_vfe_bus_update_ubwc_regs(
 	case CAM_CPAS_TITAN_170_V100:
 	case CAM_CPAS_TITAN_170_V110:
 	case CAM_CPAS_TITAN_170_V120:
-	case CAM_CPAS_TITAN_170_V200:
 		rc = cam_vfe_bus_update_ubwc_legacy_regs(
 			wm_data, camera_hw_version, reg_val_pair, i, j);
 		break;
@@ -3255,22 +2931,17 @@ static int cam_vfe_bus_update_wm(void *priv, void *cmd_args,
 
 		/* WM Image address */
 		for (k = 0; k < loop_size; k++) {
-			if (wm_data->en_ubwc) {
+			if (wm_data->en_ubwc)
 				CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 					wm_data->hw_regs->image_addr,
 					update_buf->wm_update->image_buf[i] +
 					io_cfg->planes[i].meta_size +
 					k * frame_inc);
-				update_buf->wm_update->image_buf_offset[i] =
-					io_cfg->planes[i].meta_size;
-			} else {
+			else
 				CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 					wm_data->hw_regs->image_addr,
 					update_buf->wm_update->image_buf[i] +
 					wm_data->offset + k * frame_inc);
-				update_buf->wm_update->image_buf_offset[i] =
-					wm_data->offset;
-			}
 			CAM_DBG(CAM_ISP, "WM %d image address 0x%x",
 				wm_data->index, reg_val_pair[j-1]);
 		}
@@ -3844,68 +3515,12 @@ static int __cam_vfe_bus_process_cmd(void *priv,
 	return cam_vfe_bus_process_cmd(priv, cmd_type, cmd_args, arg_size);
 }
 
-int cam_vfe_bus_dump_wm_data(void *priv, void *cmd_args, uint32_t arg_size)
-{
-	struct cam_vfe_bus_ver2_priv  *bus_priv =
-		(struct cam_vfe_bus_ver2_priv  *) priv;
-	struct cam_isp_hw_event_info  *event_info =
-		(struct cam_isp_hw_event_info *)cmd_args;
-	struct cam_isp_resource_node              *rsrc_node = NULL;
-	struct cam_vfe_bus_ver2_vfe_out_data      *rsrc_data = NULL;
-	struct cam_vfe_bus_ver2_wm_resource_data  *wm_data   = NULL;
-	struct cam_vfe_bus_ver2_common_data       *common_data = NULL;
-	int                                        i, wm_idx;
-	enum cam_vfe_bus_ver2_vfe_out_type         vfe_out_res_id;
-	uint32_t                                   addr_status0, addr_status1;
-
-	vfe_out_res_id = cam_vfe_bus_get_out_res_id(event_info->res_id);
-	rsrc_node = &bus_priv->vfe_out[vfe_out_res_id];
-	if (!rsrc_node) {
-		CAM_DBG(CAM_ISP,
-			"Resource with res id %d is null",
-			vfe_out_res_id);
-		return -EINVAL;
-	}
-	rsrc_data = rsrc_node->res_priv;
-	for (i = 0; i < rsrc_data->num_wm; i++) {
-		wm_idx = cam_vfe_bus_get_wm_idx(vfe_out_res_id, i);
-		if (wm_idx < 0 || wm_idx >= bus_priv->num_client) {
-			CAM_ERR(CAM_ISP, "Unsupported VFE out %d",
-				vfe_out_res_id);
-			return -EINVAL;
-		}
-		wm_data = bus_priv->bus_client[wm_idx].res_priv;
-		common_data = rsrc_data->common_data;
-		addr_status0 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->status0);
-		addr_status1 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->status1);
-		CAM_INFO(CAM_ISP,
-			"VFE:%d WM:%d width:%u height:%u stride:%u x_init:%u en_cfg:%u acquired width:%u height:%u",
-			wm_data->common_data->core_index, wm_idx,
-			wm_data->width,
-			wm_data->height,
-			wm_data->stride, wm_data->h_init,
-			wm_data->en_cfg,
-			wm_data->acquired_width,
-			wm_data->acquired_height);
-		CAM_INFO(CAM_ISP,
-			"hw:%d WM:%d current client address:0x%x current frame header addr:0x%x",
-			common_data->hw_intf->hw_idx,
-			wm_data->index,
-			addr_status0,
-			addr_status1);
-	}
-	return 0;
-}
-
 static int cam_vfe_bus_process_cmd(
 	struct cam_isp_resource_node *priv,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
 {
 	int rc = -EINVAL;
 	struct cam_vfe_bus_ver2_priv		 *bus_priv;
-	bool *support_consumed_addr;
 
 	if (!priv || !cmd_args) {
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid input arguments");
@@ -3938,18 +3553,9 @@ static int cam_vfe_bus_process_cmd(
 	case CAM_ISP_HW_CMD_UBWC_UPDATE:
 		rc = cam_vfe_bus_update_ubwc_config(cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_DUMP_BUS_INFO:
-		rc = cam_vfe_bus_dump_wm_data(priv, cmd_args, arg_size);
-		break;
 	case CAM_ISP_HW_CMD_UBWC_UPDATE_V2:
 		rc = cam_vfe_bus_update_ubwc_config_v2(cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_IS_CONSUMED_ADDR_SUPPORT:
-		bus_priv = (struct cam_vfe_bus_ver2_priv *) priv;
-		support_consumed_addr = (bool *)cmd_args;
-		*support_consumed_addr =
-			bus_priv->common_data.support_consumed_addr;
-		break;
 	default:
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid camif process command:%d",
 			cmd_type);
@@ -4011,9 +3617,6 @@ int cam_vfe_bus_ver2_init(
 	bus_priv->common_data.addr_no_sync       =
 		CAM_VFE_BUS_ADDR_NO_SYNC_DEFAULT_VAL;
 	bus_priv->common_data.hw_init            = false;
-	bus_priv->common_data.stats_data         = ver2_hw_info->stats_data;
-	bus_priv->common_data.support_consumed_addr =
-		ver2_hw_info->support_consumed_addr;
 
 	mutex_init(&bus_priv->common_data.bus_mutex);
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.h
index 6f27a40908d0..cac3adf65a93 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver2.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_BUS_VER2_H_
@@ -15,7 +14,6 @@
 enum cam_vfe_bus_ver2_vfe_core_id {
 	CAM_VFE_BUS_VER2_VFE_CORE_0,
 	CAM_VFE_BUS_VER2_VFE_CORE_1,
-	CAM_VFE_BUS_VER2_VFE_CORE_2,
 	CAM_VFE_BUS_VER2_VFE_CORE_MAX,
 };
 
@@ -62,36 +60,6 @@ enum cam_vfe_bus_ver2_vfe_out_type {
 	CAM_VFE_BUS_VER2_VFE_OUT_MAX,
 };
 
-struct cam_vfe_bus_ver2_dmi_lut_bank_info {
-	uint32_t size;
-	uint32_t bank_0;
-	uint32_t bank_1;
-};
-
-struct cam_vfe_bus_ver2_stats_cfg_offset {
-	uint32_t res_index;
-	uint32_t cfg_offset;
-	uint32_t num_cfg;
-	uint32_t cfg_size;
-	uint32_t is_lut;
-	struct cam_vfe_bus_ver2_dmi_lut_bank_info lut;
-};
-
-struct cam_vfe_bus_ver2_dmi_offset_common {
-	uint32_t auto_increment;
-	uint32_t cfg_offset;
-	uint32_t addr_offset;
-	uint32_t data_hi_offset;
-	uint32_t data_lo_offset;
-};
-
-struct cam_vfe_bus_ver2_stats_cfg_info {
-	struct cam_vfe_bus_ver2_dmi_offset_common
-		dmi_offset_info;
-	struct cam_vfe_bus_ver2_stats_cfg_offset
-		stats_cfg_offset[CAM_VFE_BUS_VER2_VFE_OUT_MAX];
-};
-
 /*
  * struct cam_vfe_bus_ver2_reg_offset_common:
  *
@@ -130,7 +98,6 @@ struct cam_vfe_bus_ver2_reg_offset_ubwc_client {
 	uint32_t meta_stride;
 	uint32_t mode_cfg_0;
 	uint32_t bw_limit;
-	uint32_t ubwc_comp_en_bit;
 };
 
 /*
@@ -148,7 +115,6 @@ struct cam_vfe_bus_ver2_reg_offset_ubwc_3_client {
 	uint32_t mode_cfg_0;
 	uint32_t mode_cfg_1;
 	uint32_t bw_limit;
-	uint32_t ubwc_comp_en_bit;
 };
 
 
@@ -201,19 +167,6 @@ struct cam_vfe_bus_ver2_vfe_out_hw_info {
 	uint32_t                            max_height;
 };
 
-/*
- * struct cam_vfe_bus_ver2_reg_data:
- *
- * @Brief:        Holds the bus register data
- */
-
-struct cam_vfe_bus_ver2_reg_data {
-	uint32_t      ubwc_10bit_threshold_lossy_0;
-	uint32_t      ubwc_10bit_threshold_lossy_1;
-	uint32_t      ubwc_8bit_threshold_lossy_0;
-	uint32_t      ubwc_8bit_threshold_lossy_1;
-};
-
 /*
  * struct cam_vfe_bus_ver2_hw_info:
  *
@@ -223,7 +176,6 @@ struct cam_vfe_bus_ver2_reg_data {
  * @bus_client_reg:   Bus client register info
  * @comp_reg_grp:     Composite group register info
  * @vfe_out_hw_info:  VFE output capability
- * @support_consumed_addr: Indicate if bus support consumed address
  */
 struct cam_vfe_bus_ver2_hw_info {
 	struct cam_vfe_bus_ver2_reg_offset_common common_reg;
@@ -235,9 +187,6 @@ struct cam_vfe_bus_ver2_hw_info {
 	uint32_t num_out;
 	struct cam_vfe_bus_ver2_vfe_out_hw_info
 		vfe_out_hw_info[CAM_VFE_BUS_VER2_VFE_OUT_MAX];
-	struct cam_vfe_bus_ver2_reg_data  reg_data;
-	struct cam_vfe_bus_ver2_stats_cfg_info *stats_data;
-	bool support_consumed_addr;
 };
 
 /*
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.c
index 6fe77637e037..cae125315895 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 
@@ -22,10 +21,8 @@
 #include "cam_vfe_soc.h"
 #include "cam_debug_util.h"
 #include "cam_cpas_api.h"
-#include "cam_trace.h"
 
 static const char drv_name[] = "vfe_bus";
-static char rup_controller_name[32] = "";
 
 #define CAM_VFE_BUS_VER3_IRQ_REG0                0
 #define CAM_VFE_BUS_VER3_IRQ_REG1                1
@@ -86,8 +83,6 @@ struct cam_vfe_bus_ver3_common_data {
 	uint32_t                                    comp_done_shift;
 	bool                                        is_lite;
 	bool                                        hw_init;
-	bool                                        disable_ubwc_comp;
-	bool                                        support_consumed_addr;
 	cam_hw_mgr_event_cb_func                    event_cb;
 	int                        rup_irq_handle[CAM_VFE_BUS_VER3_SRC_GRP_MAX];
 };
@@ -131,8 +126,6 @@ struct cam_vfe_bus_ver3_wm_resource_data {
 	uint32_t             ubwc_lossy_threshold_1;
 	uint32_t             ubwc_offset_lossy_variance;
 	uint32_t             ubwc_bandwidth_limit;
-	uint32_t             acquired_width;
-	uint32_t             acquired_height;
 };
 
 struct cam_vfe_bus_ver3_comp_grp_data {
@@ -155,7 +148,6 @@ struct cam_vfe_bus_ver3_vfe_out_data {
 	uint32_t                              out_type;
 	uint32_t                              source_group;
 	struct cam_vfe_bus_ver3_common_data  *common_data;
-	struct cam_vfe_bus_ver3_priv         *bus_priv;
 
 	uint32_t                         num_wm;
 	struct cam_isp_resource_node    *wm_res[PLANE_MAX];
@@ -924,7 +916,6 @@ static int cam_vfe_bus_ver3_handle_rup_top_half(uint32_t evt_id,
 	struct cam_isp_resource_node               *vfe_out = NULL;
 	struct cam_vfe_bus_ver3_vfe_out_data       *rsrc_data = NULL;
 	struct cam_vfe_bus_irq_evt_payload         *evt_payload;
-	uint32_t irq_status;
 
 	vfe_out = th_payload->handler_priv;
 	if (!vfe_out) {
@@ -953,12 +944,6 @@ static int cam_vfe_bus_ver3_handle_rup_top_half(uint32_t evt_id,
 	evt_payload->evt_id  = evt_id;
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
-
-	irq_status =
-		th_payload->evt_status_arr[CAM_IFE_IRQ_BUS_VER3_REG_STATUS0];
-
-	trace_cam_log_event("RUP", "RUP_IRQ", irq_status, 0);
-
 	th_payload->evt_payload_priv = evt_payload;
 
 	return rc;
@@ -1136,8 +1121,6 @@ static int cam_vfe_bus_ver3_acquire_wm(
 
 	rsrc_data->width = out_port_info->width;
 	rsrc_data->height = out_port_info->height;
-	rsrc_data->acquired_width = out_port_info->width;
-	rsrc_data->acquired_height = out_port_info->height;
 	rsrc_data->is_dual = is_dual;
 	/* Set WM offset value to default */
 	rsrc_data->offset  = 0;
@@ -1391,13 +1374,6 @@ static int cam_vfe_bus_ver3_start_wm(struct cam_isp_resource_node *wm_res)
 	if (rsrc_data->en_ubwc) {
 		val = cam_io_r_mb(common_data->mem_base + ubwc_regs->mode_cfg);
 		val |= 0x1;
-		if (rsrc_data->common_data->disable_ubwc_comp) {
-			val &= ~ubwc_regs->ubwc_comp_en_bit;
-			CAM_DBG(CAM_ISP,
-				"UBWC force disable VFE:%d WM:%d val= 0x%x",
-				rsrc_data->common_data->core_index,
-				rsrc_data->index, val);
-		}
 		cam_io_w_mb(val, common_data->mem_base + ubwc_regs->mode_cfg);
 	}
 
@@ -1948,10 +1924,7 @@ static int cam_vfe_bus_ver3_acquire_vfe_out(void *bus_priv, void *acquire_args,
 
 	rsrc_data = rsrc_node->res_priv;
 	rsrc_data->common_data->event_cb = acq_args->event_cb;
-	rsrc_data->common_data->disable_ubwc_comp =
-		out_acquire_args->disable_ubwc_comp;
 	rsrc_data->priv = acq_args->priv;
-	rsrc_data->bus_priv = ver3_bus_priv;
 
 	secure_caps = cam_vfe_bus_ver3_can_be_secure(
 		rsrc_data->out_type);
@@ -2264,8 +2237,6 @@ static int cam_vfe_bus_ver3_handle_vfe_out_done_top_half(uint32_t evt_id,
 	struct cam_isp_resource_node               *vfe_out = NULL;
 	struct cam_vfe_bus_ver3_vfe_out_data       *rsrc_data = NULL;
 	struct cam_vfe_bus_irq_evt_payload         *evt_payload;
-	struct cam_vfe_bus_ver3_comp_grp_data      *resource_data;
-	uint32_t                                    status_0;
 
 	vfe_out = th_payload->handler_priv;
 	if (!vfe_out) {
@@ -2274,7 +2245,6 @@ static int cam_vfe_bus_ver3_handle_vfe_out_done_top_half(uint32_t evt_id,
 	}
 
 	rsrc_data = vfe_out->res_priv;
-	resource_data = rsrc_data->comp_grp->res_priv;
 
 	CAM_DBG(CAM_ISP, "VFE:%d Bus IRQ status_0: 0x%X status_1: 0x%X",
 		rsrc_data->common_data->core_index,
@@ -2303,49 +2273,10 @@ static int cam_vfe_bus_ver3_handle_vfe_out_done_top_half(uint32_t evt_id,
 
 	th_payload->evt_payload_priv = evt_payload;
 
-	status_0 = th_payload->evt_status_arr[CAM_IFE_IRQ_BUS_VER3_REG_STATUS0];
-
-	if (status_0 & BIT(resource_data->comp_grp_type +
-		rsrc_data->common_data->comp_done_shift)) {
-		trace_cam_log_event("bufdone", "bufdone_IRQ",
-			status_0, resource_data->comp_grp_type);
-	}
-
-	if (status_0 & 0x1)
-		trace_cam_log_event("UnexpectedRUP", "RUP_IRQ", status_0, 40);
-
 	CAM_DBG(CAM_ISP, "Exit");
 	return rc;
 }
 
-static uint32_t cam_vfe_bus_ver3_get_last_consumed_addr(
-	struct cam_vfe_bus_ver3_priv *bus_priv,
-	uint32_t res_type)
-{
-	uint32_t                                  val = 0;
-	struct cam_isp_resource_node             *rsrc_node = NULL;
-	struct cam_vfe_bus_ver3_vfe_out_data     *rsrc_data = NULL;
-	struct cam_vfe_bus_ver3_wm_resource_data *wm_rsrc_data = NULL;
-	enum cam_vfe_bus_ver3_vfe_out_type        res_id;
-
-	res_id = cam_vfe_bus_ver3_get_out_res_id(res_type);
-
-	if (res_id >= CAM_VFE_BUS_VER3_VFE_OUT_MAX) {
-		CAM_ERR(CAM_ISP, "invalid res id:%u", res_id);
-		return 0;
-	}
-
-	rsrc_node = &bus_priv->vfe_out[res_id];
-	rsrc_data = rsrc_node->res_priv;
-	wm_rsrc_data = rsrc_data->wm_res[PLANE_Y]->res_priv;
-
-	val = cam_io_r_mb(
-		wm_rsrc_data->common_data->mem_base +
-		wm_rsrc_data->hw_regs->addr_status_0);
-
-	return val;
-}
-
 static int cam_vfe_bus_ver3_handle_vfe_out_done_bottom_half(
 	void                *handler_priv,
 	void                *evt_payload_priv)
@@ -2380,10 +2311,6 @@ static int cam_vfe_bus_ver3_handle_vfe_out_done_bottom_half(
 			rsrc_data->common_data->is_lite);
 		for (i = 0; i < num_out; i++) {
 			evt_info.res_id = out_list[i];
-			evt_info.reg_val =
-				cam_vfe_bus_ver3_get_last_consumed_addr(
-				rsrc_data->bus_priv,
-				evt_info.res_id);
 			if (rsrc_data->common_data->event_cb)
 				rsrc_data->common_data->event_cb(ctx, evt_id,
 					(void *)&evt_info);
@@ -2494,56 +2421,34 @@ static int cam_vfe_bus_ver3_deinit_vfe_out_resource(
 	return 0;
 }
 
-static int cam_vfe_bus_ver3_print_dimensions(
+static void cam_vfe_bus_ver3_print_dimensions(
 	enum cam_vfe_bus_ver3_vfe_out_type         vfe_out_res_id,
+	enum cam_vfe_bus_plane_type                plane,
 	struct cam_vfe_bus_ver3_priv              *bus_priv)
 {
-	struct cam_isp_resource_node              *rsrc_node = NULL;
-	struct cam_vfe_bus_ver3_vfe_out_data      *rsrc_data = NULL;
-	struct cam_vfe_bus_ver3_wm_resource_data  *wm_data   = NULL;
-	struct cam_vfe_bus_ver3_common_data       *common_data = NULL;
-	uint32_t addr_status0, addr_status1, addr_status2, addr_status3;
-	int                                        i, wm_idx;
-
-	rsrc_node = &bus_priv->vfe_out[vfe_out_res_id];
-	rsrc_data = rsrc_node->res_priv;
-	for (i = 0; i < rsrc_data->num_wm; i++) {
-		wm_idx = cam_vfe_bus_ver3_get_wm_idx(vfe_out_res_id, i,
-			bus_priv->common_data.is_lite);
-		if (wm_idx < 0 || wm_idx >= bus_priv->num_client) {
-			CAM_ERR(CAM_ISP, "Unsupported VFE out %d",
-				vfe_out_res_id);
-			return -EINVAL;
-		}
-		wm_data = bus_priv->bus_client[wm_idx].res_priv;
-		common_data = rsrc_data->common_data;
-		addr_status0 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->addr_status_0);
-		addr_status1 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->addr_status_1);
-		addr_status2 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->addr_status_2);
-		addr_status3 = cam_io_r_mb(common_data->mem_base +
-			wm_data->hw_regs->addr_status_3);
-		CAM_INFO(CAM_ISP,
-			"VFE:%d WM:%d width:%u height:%u stride:%u x_init:%u en_cfg:%u acquired width:%u height:%u",
-			wm_data->common_data->core_index, wm_idx,
-			wm_data->width,
-			wm_data->height,
-			wm_data->stride, wm_data->h_init,
-			wm_data->en_cfg,
-			wm_data->acquired_width,
-			wm_data->acquired_height);
-		CAM_INFO(CAM_ISP,
-			"hw:%d WM:%d last consumed address:0x%x last frame addr:0x%x fifo cnt:0x%x current client address:0x%x",
-			common_data->hw_intf->hw_idx,
-			wm_data->index,
-			addr_status0,
-			addr_status1,
-			addr_status2,
-			addr_status3);
+	struct cam_isp_resource_node              *wm_res = NULL;
+	struct cam_vfe_bus_ver3_wm_resource_data  *wm_data = NULL;
+	int                                        wm_idx = 0;
+
+	wm_idx = cam_vfe_bus_ver3_get_wm_idx(vfe_out_res_id, plane,
+		bus_priv->common_data.is_lite);
+
+	if (wm_idx < 0 || wm_idx >= bus_priv->num_client || plane > PLANE_C) {
+		CAM_ERR(CAM_ISP,
+			"Unsupported VFE out_type:0x%X plane:%d wm_idx:%d max_idx:%d",
+			vfe_out_res_id, plane, wm_idx,
+			bus_priv->num_client - 1);
+		return;
 	}
-	return 0;
+
+	wm_res = &bus_priv->bus_client[wm_idx];
+	wm_data = wm_res->res_priv;
+
+	CAM_INFO(CAM_ISP,
+		"VFE:%d WM:%d width:%u height:%u stride:%u x_init:%u en_cfg:%u",
+		wm_data->common_data->core_index, wm_idx, wm_data->width,
+		wm_data->height, wm_data->stride, wm_data->h_init,
+		wm_data->en_cfg);
 }
 
 static int cam_vfe_bus_ver3_handle_bus_irq(uint32_t    evt_id,
@@ -2649,6 +2554,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 					"RDI 0 image size violation");
 				cam_vfe_bus_ver3_print_dimensions(
 					CAM_VFE_BUS_VER3_VFE_OUT_RDI0,
+					PLANE_Y,
 					bus_priv);
 			}
 
@@ -2657,6 +2563,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 					"RDI 1 image size violation");
 				cam_vfe_bus_ver3_print_dimensions(
 					CAM_VFE_BUS_VER3_VFE_OUT_RDI1,
+					PLANE_Y,
 					bus_priv);
 			}
 
@@ -2665,6 +2572,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 					"RDI 2 image size violation");
 				cam_vfe_bus_ver3_print_dimensions(
 					CAM_VFE_BUS_VER3_VFE_OUT_RDI2,
+					PLANE_Y,
 					bus_priv);
 			}
 
@@ -2673,6 +2581,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 					"RDI 3 image size violation");
 				cam_vfe_bus_ver3_print_dimensions(
 					CAM_VFE_BUS_VER3_VFE_OUT_RDI3,
+					PLANE_Y,
 					bus_priv);
 			}
 		}
@@ -2707,6 +2616,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "VID Y 1:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FULL,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2714,6 +2624,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "VID C 1:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FULL,
+				PLANE_C,
 				bus_priv);
 		}
 
@@ -2721,6 +2632,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "VID YC 4:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_DS4,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2728,6 +2640,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "VID YC 16:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_DS16,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2735,6 +2648,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "DISP Y 1:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FULL_DISP,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2742,6 +2656,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "DISP C 1:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FULL_DISP,
+				PLANE_C,
 				bus_priv);
 		}
 
@@ -2749,6 +2664,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "DISP YC 4:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_DS4_DISP,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2756,6 +2672,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "DISP YC 16:1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_DS16_DISP,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2763,6 +2680,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "FD Y image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FD,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2770,6 +2688,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "FD C image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_FD,
+				PLANE_C,
 				bus_priv);
 		}
 
@@ -2778,6 +2697,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			"PIXEL RAW DUMP image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_RAW_DUMP,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2785,6 +2705,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS HDR BE image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_HDR_BE,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2793,6 +2714,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			"STATS HDR BHIST image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_HDR_BHIST,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2801,6 +2723,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			"STATS TINTLESS BG image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_TL_BG,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2808,6 +2731,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS AWB BG image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_AWB_BG,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2815,6 +2739,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS BHIST image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_BHIST,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2822,6 +2747,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS RS image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_RS,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2829,6 +2755,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS CS image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_CS,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2836,6 +2763,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS IHIST image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_IHIST,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2843,6 +2771,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "STATS BAF image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_STATS_BF,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2850,6 +2779,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "PD image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_2PD,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2857,6 +2787,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "LCR image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_LCR,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2864,6 +2795,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "RDI 0 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_RDI0,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2871,6 +2803,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "RDI 1 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_RDI1,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -2878,6 +2811,7 @@ static int cam_vfe_bus_ver3_err_irq_bottom_half(
 			CAM_INFO(CAM_ISP, "RDI 2 image size violation");
 			cam_vfe_bus_ver3_print_dimensions(
 				CAM_VFE_BUS_VER3_VFE_OUT_RDI2,
+				PLANE_Y,
 				bus_priv);
 		}
 
@@ -3024,13 +2958,6 @@ static int cam_vfe_bus_ver3_update_ubwc_regs(
 	CAM_DBG(CAM_ISP, "WM:%d meta stride 0x%X",
 		wm_data->index, reg_val_pair[*j-1]);
 
-	if (wm_data->common_data->disable_ubwc_comp) {
-		wm_data->ubwc_mode_cfg &= ~ubwc_regs->ubwc_comp_en_bit;
-		CAM_DBG(CAM_ISP,
-			"UBWC force WM:%d val= x%x",
-			wm_data->index, wm_data->ubwc_mode_cfg);
-	}
-
 	CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, *j,
 		ubwc_regs->mode_cfg, wm_data->ubwc_mode_cfg);
 	CAM_DBG(CAM_ISP, "WM:%d ubwc_mode_cfg 0x%X",
@@ -3077,9 +3004,9 @@ static int cam_vfe_bus_ver3_update_wm(void *priv, void *cmd_args,
 	struct cam_vfe_bus_ver3_wm_resource_data *wm_data = NULL;
 	struct cam_vfe_bus_ver3_reg_offset_ubwc_client *ubwc_client = NULL;
 	uint32_t *reg_val_pair;
-	uint32_t  i, j, size = 0;
+	uint32_t  i, j, k, size = 0;
 	uint32_t  frame_inc = 0, val;
-	bool frame_header_enable = false;
+	uint32_t loop_size = 0;
 
 	bus_priv = (struct cam_vfe_bus_ver3_priv  *) priv;
 	update_buf =  (struct cam_isp_hw_get_cmd_update *) cmd_args;
@@ -3113,27 +3040,6 @@ static int cam_vfe_bus_ver3_update_wm(void *priv, void *cmd_args,
 		wm_data = vfe_out_data->wm_res[i]->res_priv;
 		ubwc_client = wm_data->hw_regs->ubwc_regs;
 
-		/* Disable frame header in case it was previously enabled */
-		if ((wm_data->en_cfg) & (1 << 2))
-			wm_data->en_cfg &= ~(1 << 2);
-
-		if (update_buf->wm_update->frame_header &&
-			!frame_header_enable) {
-			wm_data->en_cfg |= 1 << 2;
-			frame_header_enable = true;
-			CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-					wm_data->hw_regs->frame_header_addr,
-					update_buf->wm_update->frame_header);
-			CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-					wm_data->hw_regs->frame_header_cfg,
-					update_buf->wm_update->local_id);
-			CAM_DBG(CAM_ISP,
-				"WM: %d en_cfg 0x%x frame_header %pK local_id %u",
-				wm_data->index, wm_data->en_cfg,
-				update_buf->wm_update->frame_header,
-				update_buf->wm_update->local_id);
-		}
-
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 			wm_data->hw_regs->cfg, wm_data->en_cfg);
 		CAM_DBG(CAM_ISP, "WM:%d en_cfg 0x%X",
@@ -3207,32 +3113,35 @@ static int cam_vfe_bus_ver3_update_wm(void *priv, void *cmd_args,
 				wm_data->index, reg_val_pair[j-1]);
 		}
 
+		if ((!bus_priv->common_data.is_lite && wm_data->index > 22) ||
+			bus_priv->common_data.is_lite)
+			loop_size = wm_data->irq_subsample_period + 1;
+		else
+			loop_size = 1;
+
 		/* WM Image address */
+		for (k = 0; k < loop_size; k++) {
+			if (wm_data->en_ubwc)
+				CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
+					wm_data->hw_regs->image_addr,
+					update_buf->wm_update->image_buf[i] +
+					io_cfg->planes[i].meta_size +
+					k * frame_inc);
+			else if (wm_data->en_cfg & (0x3 << 16))
+				CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
+					wm_data->hw_regs->image_addr,
+					(update_buf->wm_update->image_buf[i] +
+					wm_data->offset + k * frame_inc));
+			else
+				CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
+					wm_data->hw_regs->image_addr,
+					(update_buf->wm_update->image_buf[i] +
+					k * frame_inc));
 
-		if (wm_data->en_ubwc) {
-			CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-				wm_data->hw_regs->image_addr,
-				update_buf->wm_update->image_buf[i] +
-				io_cfg->planes[i].meta_size);
-			update_buf->wm_update->image_buf_offset[i] =
-				io_cfg->planes[i].meta_size;
-		} else if (wm_data->en_cfg & (0x3 << 16)) {
-			CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-				wm_data->hw_regs->image_addr,
-				(update_buf->wm_update->image_buf[i] +
-				wm_data->offset));
-			update_buf->wm_update->image_buf_offset[i] =
-				wm_data->offset;
-		} else {
-			CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
-				wm_data->hw_regs->image_addr,
-				update_buf->wm_update->image_buf[i]);
-			update_buf->wm_update->image_buf_offset[i] = 0;
+			CAM_DBG(CAM_ISP, "WM:%d image address 0x%X",
+				wm_data->index, reg_val_pair[j-1]);
 		}
 
-		CAM_DBG(CAM_ISP, "WM:%d image address 0x%X",
-			wm_data->index, reg_val_pair[j-1]);
-
 		CAM_VFE_ADD_REG_VAL_PAIR(reg_val_pair, j,
 			wm_data->hw_regs->frame_incr, frame_inc);
 		CAM_DBG(CAM_ISP, "WM:%d frame_inc %d",
@@ -3756,7 +3665,6 @@ static int cam_vfe_bus_ver3_process_cmd(
 {
 	int rc = -EINVAL;
 	struct cam_vfe_bus_ver3_priv		 *bus_priv;
-	bool *support_consumed_addr;
 
 	if (!priv || !cmd_args) {
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid input arguments");
@@ -3787,31 +3695,12 @@ static int cam_vfe_bus_ver3_process_cmd(
 			bus_priv->error_irq_handle = 0;
 		}
 		break;
-	case CAM_ISP_HW_CMD_DUMP_BUS_INFO: {
-		struct cam_isp_hw_event_info  *event_info;
-		enum cam_vfe_bus_ver3_vfe_out_type vfe_out_res_id;
-
-		event_info =
-			(struct cam_isp_hw_event_info *)cmd_args;
-		bus_priv = (struct cam_vfe_bus_ver3_priv  *) priv;
-		vfe_out_res_id =
-			cam_vfe_bus_ver3_get_out_res_id(event_info->res_id);
-		rc = cam_vfe_bus_ver3_print_dimensions(
-			vfe_out_res_id, bus_priv);
-		break;
-		}
 	case CAM_ISP_HW_CMD_UBWC_UPDATE_V2:
 		rc = cam_vfe_bus_ver3_update_ubwc_config_v2(cmd_args);
 		break;
 	case CAM_ISP_HW_CMD_WM_CONFIG_UPDATE:
 		rc = cam_vfe_bus_ver3_update_wm_config(cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_IS_CONSUMED_ADDR_SUPPORT:
-		bus_priv = (struct cam_vfe_bus_ver3_priv *) priv;
-		support_consumed_addr = (bool *)cmd_args;
-		*support_consumed_addr =
-			bus_priv->common_data.support_consumed_addr;
-		break;
 	default:
 		CAM_ERR_RATE_LIMIT(CAM_ISP, "Invalid camif process command:%d",
 			cmd_type);
@@ -3833,6 +3722,7 @@ int cam_vfe_bus_ver3_init(
 	struct cam_vfe_bus              *vfe_bus_local;
 	struct cam_vfe_bus_ver3_hw_info *ver3_hw_info = bus_hw_info;
 	struct cam_vfe_soc_private      *soc_private = NULL;
+	char rup_controller_name[12] = "";
 
 	CAM_DBG(CAM_ISP, "Enter");
 
@@ -3884,8 +3774,6 @@ int cam_vfe_bus_ver3_init(
 	bus_priv->common_data.hw_init            = false;
 
 	bus_priv->common_data.is_lite = soc_private->is_ife_lite;
-	bus_priv->common_data.support_consumed_addr =
-		ver3_hw_info->support_consumed_addr;
 
 	for (i = 0; i < CAM_VFE_BUS_VER3_SRC_GRP_MAX; i++)
 		bus_priv->common_data.rup_irq_handle[i] = 0;
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.h
index fea8a2cc7827..c5b4ab69fa9f 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_bus/cam_vfe_bus_ver3.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019, 2021 The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 
@@ -114,7 +113,6 @@ struct cam_vfe_bus_ver3_reg_offset_ubwc_client {
 	uint32_t lossy_thresh1;
 	uint32_t off_lossy_var;
 	uint32_t bw_limit;
-	uint32_t ubwc_comp_en_bit;
 };
 
 /*
@@ -168,13 +166,12 @@ struct cam_vfe_bus_ver3_vfe_out_hw_info {
  *
  * @Brief:            HW register info for entire Bus
  *
- * @common_reg:            Common register details
- * @num_client:            Total number of write clients
- * @bus_client_reg:        Bus client register info
- * @vfe_out_hw_info:       VFE output capability
- * @comp_done_shift:       Mask shift for comp done mask
- * @top_irq_shift:         Mask shift for top level BUS WR irq
- * @support_consumed_addr: Indicate if bus support consumed address
+ * @common_reg:       Common register details
+ * @num_client:       Total number of write clients
+ * @bus_client_reg:   Bus client register info
+ * @vfe_out_hw_info:  VFE output capability
+ * @comp_done_shift:  Mask shift for comp done mask
+ * @top_irq_shift:    Mask shift for top level BUS WR irq
  */
 struct cam_vfe_bus_ver3_hw_info {
 	struct cam_vfe_bus_ver3_reg_offset_common common_reg;
@@ -186,7 +183,6 @@ struct cam_vfe_bus_ver3_hw_info {
 		vfe_out_hw_info[CAM_VFE_BUS_VER3_VFE_OUT_MAX];
 	uint32_t comp_done_shift;
 	uint32_t top_irq_shift;
-	bool support_consumed_addr;
 };
 
 /*
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/Makefile b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/Makefile
index 08b95ac27209..2ab4651e4271 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/Makefile
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/Makefile
@@ -4,7 +4,6 @@ ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_utils/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_cdm/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_core/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_cpas/include
-ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_req_mgr/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/include
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/irq_controller
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_isp/isp_hw_mgr/hw_utils/include
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver2.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver2.c
index e4ff7255df5b..9ea8d74a35ca 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver2.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver2.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -36,7 +36,6 @@ struct cam_vfe_mux_camif_lite_data {
 		evt_payload[CAM_VFE_CAMIF_LITE_EVT_MAX];
 	struct list_head                      free_payload_list;
 	spinlock_t                            spin_lock;
-	struct timeval                        error_ts;
 };
 
 static int cam_vfe_camif_lite_get_evt_payload(
@@ -134,12 +133,6 @@ static int cam_vfe_camif_lite_err_irq_top_half(
 	}
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	if (error_flag) {
-		camif_lite_priv->error_ts.tv_sec =
-			evt_payload->ts.mono_time.tv_sec;
-		camif_lite_priv->error_ts.tv_usec =
-			evt_payload->ts.mono_time.tv_usec;
-	}
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
@@ -308,9 +301,6 @@ static int cam_vfe_camif_lite_resource_start(
 		}
 	}
 
-	rsrc_data->error_ts.tv_sec = 0;
-	rsrc_data->error_ts.tv_usec = 0;
-
 	CAM_DBG(CAM_ISP, "Start Camif Lite IFE %d Done",
 		camif_lite_res->hw_intf->hw_idx);
 	return rc;
@@ -415,44 +405,6 @@ static int cam_vfe_camif_lite_handle_irq_top_half(uint32_t evt_id,
 	return rc;
 }
 
-static int cam_vfe_camif_lite_cpas_fifo_levels_reg_dump(
-	struct cam_vfe_mux_camif_lite_data *camif_lite_priv)
-{
-	struct cam_vfe_soc_private *soc_private =
-		camif_lite_priv->soc_info->soc_private;
-	uint32_t  val;
-
-	if (soc_private->cpas_version == CAM_CPAS_TITAN_175_V120 ||
-		soc_private->cpas_version == CAM_CPAS_TITAN_175_V130) {
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x3A20, true, &val);
-		CAM_INFO(CAM_ISP, "IFE0_nRDI_MAXWR_LOW offset 0x3A20 val 0x%x",
-			val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x5420, true, &val);
-		CAM_INFO(CAM_ISP, "IFE1_nRDI_MAXWR_LOW offset 0x5420 val 0x%x",
-			val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x3620, true, &val);
-		CAM_INFO(CAM_ISP,
-			"IFE0123_RDI_WR_MAXWR_LOW offset 0x3620 val 0x%x", val);
-
-	} else if (soc_private->cpas_version < CAM_CPAS_TITAN_175_V120) {
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x420, true, &val);
-		CAM_INFO(CAM_ISP, "IFE02_MAXWR_LOW offset 0x420 val 0x%x", val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x820, true, &val);
-		CAM_INFO(CAM_ISP, "IFE13_MAXWR_LOW offset 0x820 val 0x%x", val);
-	}
-
-	return 0;
-
-}
-
 static int cam_vfe_camif_lite_handle_irq_bottom_half(
 	void                                 *handler_priv,
 	void                                 *evt_payload_priv)
@@ -464,9 +416,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 	struct cam_isp_hw_event_info          evt_info;
 	uint32_t                              irq_status0;
 	uint32_t                              irq_status1;
-	struct cam_hw_soc_info               *soc_info = NULL;
-	struct cam_vfe_soc_private           *soc_private = NULL;
-	struct timespec64                     ts;
 
 	if (!handler_priv || !evt_payload_priv) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -478,9 +427,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 	payload = evt_payload_priv;
 	irq_status0 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS0];
 	irq_status1 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS1];
-	soc_info = camif_lite_priv->soc_info;
-	soc_private =
-		(struct cam_vfe_soc_private *)soc_info->soc_private;
 
 	evt_info.hw_idx   = camif_lite_node->hw_intf->hw_idx;
 	evt_info.res_id   = camif_lite_node->res_id;
@@ -518,27 +464,11 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 		CAM_DBG(CAM_ISP, "VFE:%d CAMIF LITE Received ERROR",
 			evt_info.hw_idx);
 
-		cam_vfe_camif_lite_cpas_fifo_levels_reg_dump(camif_lite_priv);
-
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-		CAM_INFO(CAM_ISP,
-			"ERROR time %lld:%lld",
-			camif_lite_priv->error_ts.tv_sec,
-			camif_lite_priv->error_ts.tv_usec);
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
 		if (camif_lite_priv->event_cb)
 			camif_lite_priv->event_cb(camif_lite_priv->priv,
 				CAM_ISP_HW_EVENT_ERROR, (void *)&evt_info);
 
 		ret = CAM_VFE_IRQ_STATUS_OVERFLOW;
-
-		cam_cpas_log_votes();
-
 	}
 
 	cam_vfe_camif_lite_put_evt_payload(camif_lite_priv, &payload);
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver3.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver3.c
index 100b00b4f40b..bfb17d2145f8 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver3.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_lite_ver3.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -40,10 +40,6 @@ struct cam_vfe_mux_camif_lite_data {
 	uint32_t                                     camif_debug;
 	struct cam_vfe_top_irq_evt_payload
 		evt_payload[CAM_VFE_CAMIF_LITE_EVT_MAX];
-	struct timeval                               sof_ts;
-	struct timeval                               epoch_ts;
-	struct timeval                               eof_ts;
-	struct timeval                               error_ts;
 };
 
 static int cam_vfe_camif_lite_get_evt_payload(
@@ -141,12 +137,6 @@ static int cam_vfe_camif_lite_err_irq_top_half(
 		return rc;
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	if (error_flag) {
-		camif_lite_priv->error_ts.tv_sec =
-			evt_payload->ts.mono_time.tv_sec;
-		camif_lite_priv->error_ts.tv_usec =
-			evt_payload->ts.mono_time.tv_usec;
-	}
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
@@ -303,15 +293,6 @@ static int cam_vfe_camif_lite_resource_start(
 		rsrc_data->mem_base +
 		rsrc_data->camif_lite_reg->lite_epoch_irq);
 
-	rsrc_data->error_ts.tv_sec = 0;
-	rsrc_data->error_ts.tv_usec = 0;
-	rsrc_data->sof_ts.tv_sec = 0;
-	rsrc_data->sof_ts.tv_usec = 0;
-	rsrc_data->epoch_ts.tv_sec = 0;
-	rsrc_data->epoch_ts.tv_usec = 0;
-	rsrc_data->eof_ts.tv_sec = 0;
-	rsrc_data->eof_ts.tv_usec = 0;
-
 skip_core_cfg:
 
 	camif_lite_res->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
@@ -840,7 +821,7 @@ static void cam_vfe_camif_lite_print_status(uint32_t *status,
 	uint32_t violation_mask = 0x3F00, violation_status = 0;
 	uint32_t bus_overflow_status = 0, status_0 = 0, status_2 = 0;
 	struct cam_vfe_soc_private *soc_private = NULL;
-	uint32_t val0, val1, val2, val3;
+	uint32_t val0, val1, val2;
 
 	if (!status) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -878,23 +859,8 @@ static void cam_vfe_camif_lite_print_status(uint32_t *status,
 		if (status_0 & 0x20000000)
 			CAM_INFO(CAM_ISP, "RDI0 OVERFLOW");
 
-		if (status_0 & 0x40000000) {
+		if (status_0 & 0x40000000)
 			CAM_INFO(CAM_ISP, "PD PIPE OVERFLOW");
-			cam_cpas_reg_read(soc_private->cpas_handle,
-				CAM_CPAS_REG_CAMNOC, 0xA20, true, &val0);
-			cam_cpas_reg_read(soc_private->cpas_handle,
-				CAM_CPAS_REG_CAMNOC, 0x1420, true, &val1);
-			cam_cpas_reg_read(soc_private->cpas_handle,
-				CAM_CPAS_REG_CAMNOC, 0x1A20, true, &val2);
-			cam_cpas_reg_read(soc_private->cpas_handle,
-				CAM_CPAS_REG_CAMNOC, 0x1010, true, &val3);
-			CAM_INFO(CAM_ISP, "CAMNOC REG ife_linear: 0x%X",
-				val0);
-			CAM_INFO(CAM_ISP, "ife_rdi_wr: 0x%X", val1);
-			CAM_INFO(CAM_ISP, "ife_ubwc_stats: 0x%X", val2);
-			CAM_INFO(CAM_ISP, "ife_rdi_Rd: 0x%x", val3);
-			cam_cpas_log_votes();
-		}
 	}
 
 	if (err_type == CAM_VFE_IRQ_STATUS_OVERFLOW && bus_overflow_status) {
@@ -922,7 +888,6 @@ static void cam_vfe_camif_lite_print_status(uint32_t *status,
 		CAM_INFO(CAM_ISP,
 			"CAMNOC REG ife_linear: 0x%X ife_rdi_wr: 0x%X ife_ubwc_stats: 0x%X",
 			val0, val1, val2);
-		cam_cpas_log_votes();
 	}
 
 	if (err_type == CAM_VFE_IRQ_STATUS_OVERFLOW && !bus_overflow_status) {
@@ -1097,8 +1062,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 	struct cam_vfe_soc_private *soc_private = NULL;
 	uint32_t irq_status[CAM_IFE_IRQ_REGISTERS_MAX] = {0};
 	int i = 0;
-	uint32_t status_0 = 0;
-	struct timespec64 ts;
 
 	if (!handler_priv || !evt_payload_priv) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -1134,10 +1097,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 		CAM_DBG(CAM_ISP, "VFE:%d CAMIF LITE:%d Received SOF",
 			evt_info.hw_idx, evt_info.res_id);
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
-		camif_lite_priv->sof_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_lite_priv->sof_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
 
 		if (camif_lite_priv->event_cb)
 			camif_lite_priv->event_cb(camif_lite_priv->priv,
@@ -1149,10 +1108,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 		CAM_DBG(CAM_ISP, "VFE:%d CAMIF LITE:%d Received EPOCH",
 			evt_info.hw_idx, evt_info.res_id);
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
-		camif_lite_priv->epoch_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_lite_priv->epoch_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
 
 		if (camif_lite_priv->event_cb)
 			camif_lite_priv->event_cb(camif_lite_priv->priv,
@@ -1164,50 +1119,18 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 		CAM_DBG(CAM_ISP, "VFE:%d CAMIF LITE:%d Received EOF",
 			evt_info.hw_idx, evt_info.res_id);
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
-		camif_lite_priv->eof_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_lite_priv->eof_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
 
 		if (camif_lite_priv->event_cb)
 			camif_lite_priv->event_cb(camif_lite_priv->priv,
 				CAM_ISP_HW_EVENT_EOF, (void *)&evt_info);
 	}
 
-	status_0 = irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS0]
-		& camif_lite_priv->reg_data->error_irq_mask0;
-	if (status_0) {
+	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS0]
+		& camif_lite_priv->reg_data->error_irq_mask0) {
 		CAM_ERR(CAM_ISP, "VFE:%d Overflow",
 			camif_lite_node->hw_intf->hw_idx);
 
 		evt_info.err_type = CAM_VFE_IRQ_STATUS_OVERFLOW;
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-		CAM_INFO(CAM_ISP,
-			"ERROR time %lld:%lld",
-			camif_lite_priv->error_ts.tv_sec,
-			camif_lite_priv->error_ts.tv_usec);
-
-		if (camif_lite_node->rdi_only_ctx)
-			CAM_INFO(CAM_ISP,
-				"SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-				camif_lite_priv->sof_ts.tv_sec,
-				camif_lite_priv->sof_ts.tv_usec,
-				camif_lite_priv->epoch_ts.tv_sec,
-				camif_lite_priv->epoch_ts.tv_usec,
-				camif_lite_priv->eof_ts.tv_sec,
-				camif_lite_priv->eof_ts.tv_usec);
-
-		if (status_0 & 0x8000000)
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_2;
-
-		if (status_0 & 0x10000000)
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_1;
-
-		if (status_0 & 0x20000000)
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_0;
 
 		if (camif_lite_priv->event_cb)
 			camif_lite_priv->event_cb(camif_lite_priv->priv,
@@ -1215,9 +1138,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 
 		ret = CAM_VFE_IRQ_STATUS_OVERFLOW;
 
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
 		cam_vfe_camif_lite_print_status(irq_status, ret,
 			camif_lite_priv);
 
@@ -1237,9 +1157,6 @@ static int cam_vfe_camif_lite_handle_irq_bottom_half(
 
 		ret = CAM_VFE_IRQ_STATUS_VIOLATION;
 
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
 		cam_vfe_camif_lite_print_status(irq_status, ret,
 			camif_lite_priv);
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.c
index 2de3cc5510e9..0ed1c6ede3ce 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -48,12 +48,6 @@ struct cam_vfe_mux_camif_data {
 	bool                               enable_sof_irq_debug;
 	uint32_t                           irq_debug_cnt;
 	uint32_t                           camif_debug;
-	uint32_t                           dual_hw_idx;
-	uint32_t                           is_dual;
-	struct timeval                     sof_ts;
-	struct timeval                     epoch_ts;
-	struct timeval                     eof_ts;
-	struct timeval                     error_ts;
 };
 
 static int cam_vfe_camif_get_evt_payload(
@@ -148,12 +142,6 @@ static int cam_vfe_camif_err_irq_top_half(
 	}
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	if (error_flag) {
-		camif_priv->error_ts.tv_sec =
-			evt_payload->ts.mono_time.tv_sec;
-		camif_priv->error_ts.tv_usec =
-			evt_payload->ts.mono_time.tv_usec;
-	}
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
@@ -268,11 +256,6 @@ int cam_vfe_camif_ver2_acquire_resource(
 	camif_data->last_line   = acquire_data->vfe_in.in_port->line_stop;
 	camif_data->event_cb    = acquire_data->event_cb;
 	camif_data->priv        = acquire_data->priv;
-	camif_data->is_dual     = acquire_data->vfe_in.is_dual;
-
-	if (acquire_data->vfe_in.is_dual)
-		camif_data->dual_hw_idx =
-			acquire_data->vfe_in.dual_hw_idx;
 
 	CAM_DBG(CAM_ISP, "hw id:%d pix_pattern:%d dsp_mode=%d",
 		camif_res->hw_intf->hw_idx,
@@ -303,14 +286,6 @@ static int cam_vfe_camif_resource_init(
 		if (rc)
 			CAM_ERR(CAM_ISP, "failed to enable dsp clk");
 	}
-	camif_data->sof_ts.tv_sec = 0;
-	camif_data->sof_ts.tv_usec = 0;
-	camif_data->epoch_ts.tv_sec = 0;
-	camif_data->epoch_ts.tv_usec = 0;
-	camif_data->eof_ts.tv_sec = 0;
-	camif_data->eof_ts.tv_usec = 0;
-	camif_data->error_ts.tv_sec = 0;
-	camif_data->error_ts.tv_usec = 0;
 
 	return rc;
 }
@@ -353,7 +328,6 @@ static int cam_vfe_camif_resource_start(
 	int                             rc = 0;
 	uint32_t                        err_irq_mask[CAM_IFE_IRQ_REGISTERS_MAX];
 	uint32_t                        irq_mask[CAM_IFE_IRQ_REGISTERS_MAX];
-	uint32_t                        dual_vfe_sync_val;
 	struct cam_vfe_soc_private     *soc_private;
 
 	if (!camif_res) {
@@ -438,12 +412,6 @@ static int cam_vfe_camif_resource_start(
 		break;
 	}
 
-	if (rsrc_data->is_dual && rsrc_data->reg_data->dual_vfe_sync_mask) {
-		dual_vfe_sync_val = (rsrc_data->dual_hw_idx &
-			rsrc_data->reg_data->dual_vfe_sync_mask) + 1;
-		cam_io_w_mb(dual_vfe_sync_val, rsrc_data->mem_base +
-			rsrc_data->camif_reg->dual_vfe_sync);
-	}
 	camif_res->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
 
 	/* Reg Update */
@@ -507,6 +475,7 @@ static int cam_vfe_camif_reg_dump(
 	struct cam_isp_resource_node *camif_res)
 {
 	struct cam_vfe_mux_camif_data *camif_priv;
+	struct cam_vfe_soc_private *soc_private;
 	uint32_t offset, val, wm_idx;
 
 	if (!camif_res) {
@@ -538,6 +507,34 @@ static int cam_vfe_camif_reg_dump(
 		}
 	}
 
+	soc_private = camif_priv->soc_info->soc_private;
+	if (soc_private->cpas_version == CAM_CPAS_TITAN_175_V120 ||
+		soc_private->cpas_version == CAM_CPAS_TITAN_175_V130) {
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x3A20, true, &val);
+		CAM_INFO(CAM_ISP, "IFE0_nRDI_MAXWR_LOW offset 0x3A20 val 0x%x",
+			val);
+
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x5420, true, &val);
+		CAM_INFO(CAM_ISP, "IFE1_nRDI_MAXWR_LOW offset 0x5420 val 0x%x",
+			val);
+
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x3620, true, &val);
+		CAM_INFO(CAM_ISP,
+			"IFE0123_RDI_WR_MAXWR_LOW offset 0x3620 val 0x%x", val);
+
+	} else if (soc_private->cpas_version < CAM_CPAS_TITAN_175_V120) {
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x420, true, &val);
+		CAM_INFO(CAM_ISP, "IFE02_MAXWR_LOW offset 0x420 val 0x%x", val);
+
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x820, true, &val);
+		CAM_INFO(CAM_ISP, "IFE13_MAXWR_LOW offset 0x820 val 0x%x", val);
+	}
+
 	return 0;
 }
 
@@ -614,68 +611,6 @@ static int cam_vfe_camif_sof_irq_debug(
 	return 0;
 }
 
-int cam_vfe_camif_dump_timestamps(
-	struct cam_isp_resource_node *rsrc_node, void *cmd_args)
-{
-	struct cam_vfe_mux_camif_data *camif_priv =
-		(struct cam_vfe_mux_camif_data *)rsrc_node->res_priv;
-
-	CAM_INFO(CAM_ISP,
-		"CAMIF ERROR time %lld:%lld SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-		camif_priv->error_ts.tv_sec,
-		camif_priv->error_ts.tv_usec,
-		camif_priv->sof_ts.tv_sec,
-		camif_priv->sof_ts.tv_usec,
-		camif_priv->epoch_ts.tv_sec,
-		camif_priv->epoch_ts.tv_usec,
-		camif_priv->eof_ts.tv_sec,
-		camif_priv->eof_ts.tv_usec);
-
-	return 0;
-}
-
-static int cam_vfe_camif_irq_reg_dump(
-	struct cam_isp_resource_node *camif_res)
-{
-	struct cam_vfe_mux_camif_data *camif_priv;
-	struct cam_vfe_soc_private *soc_private;
-	int rc = 0;
-
-	if (!camif_res) {
-		CAM_ERR(CAM_ISP, "Error! Invalid input arguments\n");
-		return -EINVAL;
-	}
-
-	if ((camif_res->res_state == CAM_ISP_RESOURCE_STATE_RESERVED) ||
-		(camif_res->res_state == CAM_ISP_RESOURCE_STATE_AVAILABLE)) {
-		CAM_ERR(CAM_ISP, "Error! Invalid state\n");
-		return 0;
-	}
-
-	camif_priv = (struct cam_vfe_mux_camif_data *)camif_res->res_priv;
-	soc_private = camif_priv->soc_info->soc_private;
-
-	CAM_INFO(CAM_ISP,
-		"Core Id =%d Mask reg: offset 0x%x val 0x%x offset 0x%x val 0x%x",
-		camif_priv->hw_intf->hw_idx,
-		camif_priv->common_reg->irq_mask_0,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_mask_0),
-		camif_priv->common_reg->irq_mask_1,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_mask_1));
-	CAM_INFO(CAM_ISP,
-		"Core Id =%d Status reg: offset 0x%x val 0x%x offset 0x%x val 0x%x",
-		camif_priv->hw_intf->hw_idx,
-		camif_priv->common_reg->irq_status_0,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_status_0),
-		camif_priv->common_reg->irq_status_1,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_status_1));
-	return rc;
-}
-
 static int cam_vfe_camif_process_cmd(struct cam_isp_resource_node *rsrc_node,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
 {
@@ -700,17 +635,6 @@ static int cam_vfe_camif_process_cmd(struct cam_isp_resource_node *rsrc_node,
 			(struct cam_vfe_mux_camif_data *)rsrc_node->res_priv;
 		camif_priv->camif_debug = *((uint32_t *)cmd_args);
 		break;
-	case CAM_ISP_HW_CMD_CAMIF_DATA:
-		rc = cam_vfe_camif_dump_timestamps(rsrc_node, cmd_args);
-	case CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP:
-		rc = cam_vfe_camif_irq_reg_dump(rsrc_node);
-		break;
-	case CAM_ISP_HW_CMD_QUERY_REGSPACE_DATA:
-		camif_priv = (struct cam_vfe_mux_camif_data *)
-			rsrc_node->res_priv;
-		*((struct cam_hw_soc_info **)cmd_args) = camif_priv->soc_info;
-		rc = 0;
-		break;
 	default:
 		CAM_ERR(CAM_ISP,
 			"unsupported process command:%d", cmd_type);
@@ -763,12 +687,9 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 	struct cam_vfe_mux_camif_data        *camif_priv;
 	struct cam_vfe_top_irq_evt_payload *payload;
 	struct cam_isp_hw_event_info          evt_info;
-	struct cam_hw_soc_info               *soc_info = NULL;
-	struct cam_vfe_soc_private           *soc_private = NULL;
 	uint32_t                              irq_status0;
 	uint32_t                              irq_status1;
 	uint32_t                              val;
-	struct timespec64                     ts;
 
 	if (!handler_priv || !evt_payload_priv) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -781,9 +702,6 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 	irq_status0 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS0];
 	irq_status1 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS1];
 
-	soc_info = camif_priv->soc_info;
-	soc_private = (struct cam_vfe_soc_private *)soc_info->soc_private;
-
 	evt_info.hw_idx   = camif_node->hw_intf->hw_idx;
 	evt_info.res_id   = camif_node->res_id;
 	evt_info.res_type = camif_node->res_type;
@@ -791,20 +709,6 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 	CAM_DBG(CAM_ISP, "irq_status_0 = 0x%x irq_status_1 = 0x%x",
 		irq_status0, irq_status1);
 
-	if (irq_status0 & camif_priv->reg_data->eof_irq_mask) {
-		CAM_DBG(CAM_ISP, "Received EOF");
-		camif_priv->eof_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_priv->eof_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
-
-		if (camif_priv->event_cb)
-			camif_priv->event_cb(camif_priv->priv,
-				CAM_ISP_HW_EVENT_EOF, (void *)&evt_info);
-
-		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
-	}
-
 	if (irq_status0 & camif_priv->reg_data->sof_irq_mask) {
 		if ((camif_priv->enable_sof_irq_debug) &&
 			(camif_priv->irq_debug_cnt <=
@@ -818,13 +722,8 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 					false;
 				camif_priv->irq_debug_cnt = 0;
 			}
-		} else {
+		} else
 			CAM_DBG(CAM_ISP, "Received SOF");
-			camif_priv->sof_ts.tv_sec =
-				payload->ts.mono_time.tv_sec;
-			camif_priv->sof_ts.tv_usec =
-				payload->ts.mono_time.tv_usec;
-		}
 
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
@@ -833,6 +732,16 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
 	}
 
+	if (irq_status0 & camif_priv->reg_data->epoch0_irq_mask) {
+		CAM_DBG(CAM_ISP, "Received EPOCH");
+
+		if (camif_priv->event_cb)
+			camif_priv->event_cb(camif_priv->priv,
+				CAM_ISP_HW_EVENT_EPOCH, (void *)&evt_info);
+
+		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
+	}
+
 	if (irq_status0 & camif_priv->reg_data->reg_update_irq_mask) {
 		CAM_DBG(CAM_ISP, "Received REG_UPDATE_ACK");
 
@@ -843,16 +752,12 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
 	}
 
-	if (irq_status0 & camif_priv->reg_data->epoch0_irq_mask) {
-		CAM_DBG(CAM_ISP, "Received EPOCH");
-		camif_priv->epoch_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_priv->epoch_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
+	if (irq_status0 & camif_priv->reg_data->eof_irq_mask) {
+		CAM_DBG(CAM_ISP, "Received EOF");
 
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
-				CAM_ISP_HW_EVENT_EPOCH, (void *)&evt_info);
+				CAM_ISP_HW_EVENT_EOF, (void *)&evt_info);
 
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
 	}
@@ -860,37 +765,14 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 	if (irq_status0 & camif_priv->reg_data->error_irq_mask0) {
 		CAM_DBG(CAM_ISP, "Received ERROR");
 
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
 				CAM_ISP_HW_EVENT_ERROR, (void *)&evt_info);
 
-		CAM_INFO(CAM_ISP,
-			"SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-			camif_priv->sof_ts.tv_sec,
-			camif_priv->sof_ts.tv_usec,
-			camif_priv->epoch_ts.tv_sec,
-			camif_priv->epoch_ts.tv_usec,
-			camif_priv->eof_ts.tv_sec,
-			camif_priv->eof_ts.tv_usec);
-
 		CAM_INFO(CAM_ISP, "Violation status = %x",
 			payload->irq_reg_val[2]);
 
 		ret = CAM_VFE_IRQ_STATUS_OVERFLOW;
-
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
-		cam_cpas_get_camnoc_fifo_fill_level_info(
-			soc_private->cpas_version,
-			soc_private->cpas_handle);
-		cam_cpas_log_votes();
-
 		if (camif_priv->camif_debug & CAMIF_DEBUG_ENABLE_REG_DUMP)
 			cam_vfe_camif_reg_dump(camif_node->res_priv);
 	}
@@ -898,34 +780,14 @@ static int cam_vfe_camif_handle_irq_bottom_half(void *handler_priv,
 	if (irq_status1 & camif_priv->reg_data->error_irq_mask1) {
 		CAM_DBG(CAM_ISP, "Received ERROR");
 
-		CAM_INFO(CAM_ISP,
-			"SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-			camif_priv->sof_ts.tv_sec,
-			camif_priv->sof_ts.tv_usec,
-			camif_priv->epoch_ts.tv_sec,
-			camif_priv->epoch_ts.tv_usec,
-			camif_priv->eof_ts.tv_sec,
-			camif_priv->eof_ts.tv_usec);
-		ktime_get_boottime_ts64(&ts);
-
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
 				CAM_ISP_HW_EVENT_ERROR, (void *)&evt_info);
 
-		CAM_INFO(CAM_ISP,
-			"curr mono time sec %lld.%lld Violation status = %x",
-			ts.tv_sec, ts.tv_nsec/1000, payload->irq_reg_val[2]);
+		CAM_INFO(CAM_ISP, "Violation status = %x",
+			payload->irq_reg_val[2]);
 
 		ret = CAM_VFE_IRQ_STATUS_OVERFLOW;
-
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
-		cam_cpas_get_camnoc_fifo_fill_level_info(
-			soc_private->cpas_version,
-			soc_private->cpas_handle);
-		cam_cpas_log_votes();
-
 		if (camif_priv->camif_debug & CAMIF_DEBUG_ENABLE_REG_DUMP)
 			cam_vfe_camif_reg_dump(camif_node->res_priv);
 	}
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.h
index 26522594b97b..f071a0627bbc 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver2.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_CAMIF_VER2_H_
@@ -22,7 +22,6 @@ struct cam_vfe_camif_ver2_reg {
 	uint32_t     reg_update_cmd;
 	uint32_t     vfe_diag_config;
 	uint32_t     vfe_diag_sensor_status;
-	uint32_t     dual_vfe_sync;
 };
 
 struct cam_vfe_camif_reg_data {
@@ -63,7 +62,6 @@ struct cam_vfe_camif_reg_data {
 	uint32_t     subscribe_irq_mask1;
 
 	uint32_t     enable_diagnostic_hw;
-	uint32_t     dual_vfe_sync_mask;
 };
 
 struct cam_vfe_camif_ver2_hw_info {
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.c
index 5523177a6999..12cdcb19f2c0 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -19,7 +18,6 @@
 #include "cam_debug_util.h"
 #include "cam_cdm_util.h"
 #include "cam_cpas_api.h"
-#include "cam_trace.h"
 
 #define CAM_VFE_CAMIF_IRQ_SOF_DEBUG_CNT_MAX 2
 
@@ -54,12 +52,6 @@ struct cam_vfe_mux_camif_ver3_data {
 	uint32_t                           camif_debug;
 	uint32_t                           horizontal_bin;
 	uint32_t                           qcfa_bin;
-	bool                               is_fe_enabled;
-	bool                               is_offline;
-	struct timeval                     sof_ts;
-	struct timeval                     epoch_ts;
-	struct timeval                     eof_ts;
-	struct timeval                     error_ts;
 };
 
 static int cam_vfe_camif_ver3_get_evt_payload(
@@ -145,12 +137,6 @@ static int cam_vfe_camif_ver3_err_irq_top_half(
 		return rc;
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	if (error_flag) {
-		camif_priv->error_ts.tv_sec =
-			evt_payload->ts.mono_time.tv_sec;
-		camif_priv->error_ts.tv_usec =
-			evt_payload->ts.mono_time.tv_usec;
-	}
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
@@ -260,20 +246,18 @@ int cam_vfe_camif_ver3_acquire_resource(
 		return rc;
 	}
 
-	camif_data->sync_mode      = acquire_data->vfe_in.sync_mode;
-	camif_data->pix_pattern    = acquire_data->vfe_in.in_port->test_pattern;
-	camif_data->dsp_mode       = acquire_data->vfe_in.in_port->dsp_mode;
-	camif_data->first_pixel    = acquire_data->vfe_in.in_port->left_start;
-	camif_data->last_pixel     = acquire_data->vfe_in.in_port->left_stop;
-	camif_data->first_line     = acquire_data->vfe_in.in_port->line_start;
-	camif_data->last_line      = acquire_data->vfe_in.in_port->line_stop;
-	camif_data->is_fe_enabled  = acquire_data->vfe_in.is_fe_enabled;
-	camif_data->is_offline     = acquire_data->vfe_in.is_offline;
-	camif_data->event_cb       = acquire_data->event_cb;
-	camif_data->priv           = acquire_data->priv;
-	camif_data->qcfa_bin       = acquire_data->vfe_in.in_port->qcfa_bin;
+	camif_data->sync_mode   = acquire_data->vfe_in.sync_mode;
+	camif_data->pix_pattern = acquire_data->vfe_in.in_port->test_pattern;
+	camif_data->dsp_mode    = acquire_data->vfe_in.in_port->dsp_mode;
+	camif_data->first_pixel = acquire_data->vfe_in.in_port->left_start;
+	camif_data->last_pixel  = acquire_data->vfe_in.in_port->left_stop;
+	camif_data->first_line  = acquire_data->vfe_in.in_port->line_start;
+	camif_data->last_line   = acquire_data->vfe_in.in_port->line_stop;
 	camif_data->horizontal_bin =
 		acquire_data->vfe_in.in_port->horizontal_bin;
+	camif_data->qcfa_bin    = acquire_data->vfe_in.in_port->qcfa_bin;
+	camif_data->event_cb    = acquire_data->event_cb;
+	camif_data->priv        = acquire_data->priv;
 
 	CAM_DBG(CAM_ISP, "VFE:%d CAMIF pix_pattern:%d dsp_mode=%d",
 		camif_res->hw_intf->hw_idx,
@@ -307,14 +291,20 @@ static int cam_vfe_camif_ver3_resource_init(
 			CAM_ERR(CAM_ISP,
 				"failed to enable dsp clk, rc = %d", rc);
 	}
-	camif_data->sof_ts.tv_sec = 0;
-	camif_data->sof_ts.tv_usec = 0;
-	camif_data->epoch_ts.tv_sec = 0;
-	camif_data->epoch_ts.tv_usec = 0;
-	camif_data->eof_ts.tv_sec = 0;
-	camif_data->eof_ts.tv_usec = 0;
-	camif_data->error_ts.tv_sec = 0;
-	camif_data->error_ts.tv_usec = 0;
+
+	/* All auto clock gating disabled by default */
+	CAM_INFO(CAM_ISP, "overriding clock gating");
+	cam_io_w_mb(0xFFFFFFFF, camif_data->mem_base +
+		camif_data->common_reg->core_cgc_ovd_0);
+
+	cam_io_w_mb(0xFF, camif_data->mem_base +
+		camif_data->common_reg->core_cgc_ovd_1);
+
+	cam_io_w_mb(0x1, camif_data->mem_base +
+		camif_data->common_reg->ahb_cgc_ovd);
+
+	cam_io_w_mb(0x1, camif_data->mem_base +
+		camif_data->common_reg->noc_cgc_ovd);
 
 	return rc;
 }
@@ -429,14 +419,6 @@ static int cam_vfe_camif_ver3_resource_start(
 	val |= (rsrc_data->cam_common_cfg.input_mux_sel_pp & 0x3) <<
 		CAM_SHIFT_TOP_CORE_CFG_INPUTMUX_PP;
 
-	if (rsrc_data->is_fe_enabled && !rsrc_data->is_offline)
-		val |= 0x2 << rsrc_data->reg_data->operating_mode_shift;
-	else
-		val |= 0x1 << rsrc_data->reg_data->operating_mode_shift;
-
-	CAM_DBG(CAM_ISP, "VFE:%d TOP core_cfg: 0x%X",
-		camif_res->hw_intf->hw_idx, val);
-
 	cam_io_w_mb(val, rsrc_data->mem_base +
 		rsrc_data->common_reg->core_cfg_0);
 
@@ -472,14 +454,11 @@ static int cam_vfe_camif_ver3_resource_start(
 	camif_res->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
 
 	/* Reg Update */
-	if (!rsrc_data->is_offline) {
-		cam_io_w_mb(rsrc_data->reg_data->reg_update_cmd_data,
-			rsrc_data->mem_base +
-			rsrc_data->camif_reg->reg_update_cmd);
-		CAM_DBG(CAM_ISP, "VFE:%d CAMIF RUP val:0x%X",
-			camif_res->hw_intf->hw_idx,
-			rsrc_data->reg_data->reg_update_cmd_data);
-	}
+	cam_io_w_mb(rsrc_data->reg_data->reg_update_cmd_data,
+		rsrc_data->mem_base + rsrc_data->camif_reg->reg_update_cmd);
+	CAM_DBG(CAM_ISP, "VFE:%d CAMIF RUP val:0x%X",
+		camif_res->hw_intf->hw_idx,
+		rsrc_data->reg_data->reg_update_cmd_data);
 
 	/* disable sof irq debug flag */
 	rsrc_data->enable_sof_irq_debug = false;
@@ -523,9 +502,6 @@ static int cam_vfe_camif_ver3_resource_start(
 
 	irq_mask[CAM_IFE_IRQ_CAMIF_REG_STATUS1] =
 		rsrc_data->reg_data->sof_irq_mask;
-	if (rsrc_data->cam_common_cfg.input_mux_sel_pp & 0x3)
-		irq_mask[CAM_IFE_IRQ_CAMIF_REG_STATUS0] =
-			rsrc_data->reg_data->frame_id_irq_mask;
 
 	if (!rsrc_data->sof_irq_handle) {
 		rsrc_data->sof_irq_handle = cam_irq_controller_subscribe_irq(
@@ -622,18 +598,6 @@ static int cam_vfe_camif_ver3_reg_dump(
 		CAM_INFO(CAM_ISP, "offset 0x%X value 0x%X", offset, val);
 	}
 
-	CAM_INFO(CAM_ISP, "IFE:%d BUS RD", camif_res->hw_intf->hw_idx);
-	for (offset = 0xA800; offset <= 0xA89C; offset += 0x4) {
-		val = cam_soc_util_r(camif_priv->soc_info, 0, offset);
-		CAM_INFO(CAM_ISP, "offset 0x%X value 0x%X", offset, val);
-		if (offset == 0xA838)
-			offset = 0xA844;
-		if (offset == 0xA864)
-			offset = 0xA874;
-		if (offset == 0xA878)
-			offset = 0xA87C;
-	}
-
 	CAM_INFO(CAM_ISP, "IFE:%d BUS WR", camif_res->hw_intf->hw_idx);
 	for (offset = 0xAA00; offset <= 0xAADC; offset += 0x4) {
 		val = cam_soc_util_r(camif_priv->soc_info, 0, offset);
@@ -765,74 +729,6 @@ static int cam_vfe_camif_ver3_sof_irq_debug(
 	return 0;
 }
 
-int cam_vfe_camif_ver3_dump_timestamps(
-	struct cam_isp_resource_node *rsrc_node, void *cmd_args)
-{
-	struct cam_vfe_mux_camif_ver3_data *camif_priv =
-		(struct cam_vfe_mux_camif_ver3_data *)rsrc_node->res_priv;
-
-	CAM_INFO(CAM_ISP,
-		"CAMIF ERROR time %lld:%lld SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-		camif_priv->error_ts.tv_sec,
-		camif_priv->error_ts.tv_usec,
-		camif_priv->sof_ts.tv_sec,
-		camif_priv->sof_ts.tv_usec,
-		camif_priv->epoch_ts.tv_sec,
-		camif_priv->epoch_ts.tv_usec,
-		camif_priv->eof_ts.tv_sec,
-		camif_priv->eof_ts.tv_usec);
-
-	return 0;
-}
-
-static int cam_vfe_camif_ver3_irq_reg_dump(
-	struct cam_isp_resource_node *camif_res)
-{
-	struct cam_vfe_mux_camif_ver3_data *camif_priv;
-	struct cam_vfe_soc_private *soc_private;
-	int rc = 0;
-
-	if (!camif_res) {
-		CAM_ERR(CAM_ISP, "Error! Invalid input arguments\n");
-		return -EINVAL;
-	}
-
-	if ((camif_res->res_state == CAM_ISP_RESOURCE_STATE_RESERVED) ||
-		(camif_res->res_state == CAM_ISP_RESOURCE_STATE_AVAILABLE)) {
-		CAM_ERR(CAM_ISP, "Error! Invalid state\n");
-		return 0;
-	}
-
-	camif_priv = (struct cam_vfe_mux_camif_ver3_data *)camif_res->res_priv;
-	soc_private = camif_priv->soc_info->soc_private;
-
-	CAM_INFO(CAM_ISP,
-		"Core Id =%d Mask reg: offset 0x%x val 0x%x offset 0x%x val 0x%x  offset 0x%x val 0x%x",
-		camif_priv->hw_intf->hw_idx,
-		camif_priv->common_reg->irq_mask_0,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_mask_0),
-		camif_priv->common_reg->irq_mask_1,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_mask_1),
-		camif_priv->common_reg->irq_mask_2,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_mask_2));
-
-	CAM_INFO(CAM_ISP,
-		"Core Id =%d Status reg: offset 0x%x val 0x%x offset 0x%x val 0x%x offset 0x%x val 0x%x",
-		camif_priv->common_reg->irq_status_0,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_status_0),
-		camif_priv->common_reg->irq_status_1,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_status_1),
-		camif_priv->common_reg->irq_status_2,
-		cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->irq_status_2));
-	return rc;
-}
-
 static int cam_vfe_camif_ver3_process_cmd(
 	struct cam_isp_resource_node *rsrc_node,
 	uint32_t cmd_type, void *cmd_args, uint32_t arg_size)
@@ -869,11 +765,6 @@ static int cam_vfe_camif_ver3_process_cmd(
 		*((struct cam_hw_soc_info **)cmd_args) = camif_priv->soc_info;
 		rc = 0;
 		break;
-	case CAM_ISP_HW_CMD_CAMIF_DATA:
-		rc = cam_vfe_camif_ver3_dump_timestamps(rsrc_node, cmd_args);
-	case CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP:
-		rc = cam_vfe_camif_ver3_irq_reg_dump(rsrc_node);
-		break;
 	default:
 		CAM_ERR(CAM_ISP,
 			"unsupported process command:%d", cmd_type);
@@ -939,6 +830,7 @@ static void cam_vfe_camif_ver3_print_status(uint32_t *status,
 	uint32_t violation_mask = 0x3F, module_id = 0;
 	uint32_t bus_overflow_status = 0, status_0 = 0, status_2 = 0;
 	struct cam_vfe_soc_private *soc_private;
+	uint32_t val0, val1, val2;
 
 	if (!status) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -1025,12 +917,15 @@ static void cam_vfe_camif_ver3_print_status(uint32_t *status,
 			CAM_INFO(CAM_ISP, "PDAF BUS OVERFLOW");
 
 		soc_private = camif_priv->soc_info->soc_private;
-
-		cam_cpas_get_camnoc_fifo_fill_level_info(
-			soc_private->cpas_version,
-			soc_private->cpas_handle);
-
-		cam_cpas_log_votes();
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0xA20, true, &val0);
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x1420, true, &val1);
+		cam_cpas_reg_read(soc_private->cpas_handle,
+			CAM_CPAS_REG_CAMNOC, 0x1A20, true, &val2);
+		CAM_INFO(CAM_ISP,
+			"CAMNOC REG ife_linear: 0x%X ife_rdi_wr: 0x%X ife_ubwc_stats: 0x%X",
+			val0, val1, val2);
 		return;
 	}
 
@@ -1291,44 +1186,12 @@ static int cam_vfe_camif_ver3_handle_irq_top_half(uint32_t evt_id,
 	}
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	evt_payload->reg_val = 0;
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
 
-	/* Read frame_id meta at every epoch if custom hw is enabled */
-	if (evt_payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
-		& camif_priv->reg_data->epoch0_irq_mask) {
-		if ((camif_priv->common_reg->custom_frame_idx) &&
-			(camif_priv->cam_common_cfg.input_mux_sel_pp & 0x3))
-			evt_payload->reg_val = cam_io_r_mb(
-			camif_priv->mem_base +
-			camif_priv->common_reg->custom_frame_idx);
-	}
-
 	th_payload->evt_payload_priv = evt_payload;
 
-	if (th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
-			& camif_priv->reg_data->sof_irq_mask) {
-		trace_cam_log_event("SOF", "TOP_HALF",
-		th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1],
-		camif_node->hw_intf->hw_idx);
-	}
-
-	if (th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
-			& camif_priv->reg_data->epoch0_irq_mask) {
-		trace_cam_log_event("EPOCH0", "TOP_HALF",
-		th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1],
-		camif_node->hw_intf->hw_idx);
-	}
-
-	if (th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
-			& camif_priv->reg_data->eof_irq_mask) {
-		trace_cam_log_event("EOF", "TOP_HALF",
-		th_payload->evt_status_arr[CAM_IFE_IRQ_CAMIF_REG_STATUS1],
-		camif_node->hw_intf->hw_idx);
-	}
-
 	CAM_DBG(CAM_ISP, "Exit");
 	return rc;
 }
@@ -1341,11 +1204,7 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 	struct cam_vfe_mux_camif_ver3_data *camif_priv;
 	struct cam_vfe_top_irq_evt_payload *payload;
 	struct cam_isp_hw_event_info evt_info;
-	struct cam_hw_soc_info *soc_info = NULL;
-	struct cam_vfe_soc_private *soc_private = NULL;
 	uint32_t irq_status[CAM_IFE_IRQ_REGISTERS_MAX] = {0};
-	struct timespec64 ts;
-	uint32_t val = 0;
 	int i = 0;
 
 	if (!handler_priv || !evt_payload_priv) {
@@ -1359,17 +1218,12 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 	camif_priv = camif_node->res_priv;
 	payload = evt_payload_priv;
 
-	soc_info = camif_priv->soc_info;
-	soc_private =
-		(struct cam_vfe_soc_private *)soc_info->soc_private;
-
 	for (i = 0; i < CAM_IFE_IRQ_REGISTERS_MAX; i++)
 		irq_status[i] = payload->irq_reg_val[i];
 
 	evt_info.hw_idx   = camif_node->hw_intf->hw_idx;
 	evt_info.res_id   = camif_node->res_id;
 	evt_info.res_type = camif_node->res_type;
-	evt_info.reg_val = 0;
 
 	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
 		& camif_priv->reg_data->sof_irq_mask) {
@@ -1386,14 +1240,9 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 					false;
 				camif_priv->irq_debug_cnt = 0;
 			}
-		} else {
+		} else
 			CAM_DBG(CAM_ISP, "VFE:%d Received SOF",
 				evt_info.hw_idx);
-			camif_priv->sof_ts.tv_sec =
-				payload->ts.mono_time.tv_sec;
-			camif_priv->sof_ts.tv_usec =
-				payload->ts.mono_time.tv_usec;
-			}
 
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
@@ -1405,11 +1254,6 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
 		& camif_priv->reg_data->epoch0_irq_mask) {
 		CAM_DBG(CAM_ISP, "VFE:%d Received EPOCH", evt_info.hw_idx);
-		evt_info.reg_val = payload->reg_val;
-		camif_priv->epoch_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_priv->epoch_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
 
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
@@ -1421,10 +1265,6 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS1]
 		& camif_priv->reg_data->eof_irq_mask) {
 		CAM_DBG(CAM_ISP, "VFE:%d Received EOF", evt_info.hw_idx);
-		camif_priv->eof_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		camif_priv->eof_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
 
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
@@ -1437,68 +1277,27 @@ static int cam_vfe_camif_ver3_handle_irq_bottom_half(void *handler_priv,
 		& camif_priv->reg_data->error_irq_mask0) {
 		CAM_ERR(CAM_ISP, "VFE:%d Overflow", evt_info.hw_idx);
 
-		CAM_INFO(CAM_ISP,
-			"SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-			camif_priv->sof_ts.tv_sec,
-			camif_priv->sof_ts.tv_usec,
-			camif_priv->epoch_ts.tv_sec,
-			camif_priv->epoch_ts.tv_usec,
-			camif_priv->eof_ts.tv_sec,
-			camif_priv->eof_ts.tv_usec);
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
 				CAM_ISP_HW_EVENT_ERROR, (void *)&evt_info);
 
 		ret = CAM_VFE_IRQ_STATUS_OVERFLOW;
 
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
 		cam_vfe_camif_ver3_print_status(irq_status, ret, camif_priv);
 
 		if (camif_priv->camif_debug & CAMIF_DEBUG_ENABLE_REG_DUMP)
 			cam_vfe_camif_ver3_reg_dump(camif_node);
 	}
 
-	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS0]
-		& camif_priv->reg_data->frame_id_irq_mask) {
-		val = cam_io_r_mb(camif_priv->mem_base +
-			camif_priv->common_reg->custom_frame_idx);
-		CAM_DBG(CAM_ISP,
-			"VFE:%d Frame id change to: %u", evt_info.hw_idx,
-			val);
-	}
-
 	if (irq_status[CAM_IFE_IRQ_CAMIF_REG_STATUS2]) {
 		CAM_ERR(CAM_ISP, "VFE:%d Violation", evt_info.hw_idx);
 
-		CAM_INFO(CAM_ISP,
-			"SOF %lld:%lld EPOCH %lld:%lld EOF %lld:%lld",
-			camif_priv->sof_ts.tv_sec,
-			camif_priv->sof_ts.tv_usec,
-			camif_priv->epoch_ts.tv_sec,
-			camif_priv->epoch_ts.tv_usec,
-			camif_priv->eof_ts.tv_sec,
-			camif_priv->eof_ts.tv_usec);
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-
 		if (camif_priv->event_cb)
 			camif_priv->event_cb(camif_priv->priv,
 				CAM_ISP_HW_EVENT_ERROR, (void *)&evt_info);
 
 		ret = CAM_VFE_IRQ_STATUS_VIOLATION;
 
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-
 		cam_vfe_camif_ver3_print_status(irq_status, ret, camif_priv);
 
 		if (camif_priv->camif_debug & CAMIF_DEBUG_ENABLE_REG_DUMP)
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.h
index 303a9e5b0a6a..40d8e40ae852 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_camif_ver3.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_CAMIF_VER3_H_
@@ -52,7 +52,6 @@ struct cam_vfe_camif_ver3_reg_data {
 	uint32_t     error_irq_mask0;
 	uint32_t     error_irq_mask2;
 	uint32_t     subscribe_irq_mask1;
-	uint32_t     frame_id_irq_mask;
 
 	uint32_t     enable_diagnostic_hw;
 	uint32_t     pp_camif_cfg_en_shift;
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.c
index b932c83b46d0..7aaacde775f4 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -14,7 +14,6 @@
 #include "cam_cdm_util.h"
 #include "cam_irq_controller.h"
 #include "cam_tasklet_util.h"
-#include "cam_cpas_api.h"
 
 struct cam_vfe_mux_rdi_data {
 	void __iomem                                *mem_base;
@@ -22,9 +21,7 @@ struct cam_vfe_mux_rdi_data {
 	struct cam_vfe_top_ver2_reg_offset_common   *common_reg;
 	struct cam_vfe_rdi_ver2_reg                 *rdi_reg;
 	struct cam_vfe_rdi_common_reg_data          *rdi_common_reg_data;
-	struct cam_vfe_rdi_overflow_status          *rdi_irq_status;
 	struct cam_vfe_rdi_reg_data                 *reg_data;
-	struct cam_hw_soc_info                      *soc_info;
 
 	cam_hw_mgr_event_cb_func              event_cb;
 	void                                 *priv;
@@ -36,8 +33,6 @@ struct cam_vfe_mux_rdi_data {
 	spinlock_t                            spin_lock;
 
 	enum cam_isp_hw_sync_mode          sync_mode;
-	struct timeval                     sof_ts;
-	struct timeval                     error_ts;
 };
 
 static int cam_vfe_rdi_get_evt_payload(
@@ -86,44 +81,6 @@ static int cam_vfe_rdi_put_evt_payload(
 	return 0;
 }
 
-static int cam_vfe_rdi_cpas_reg_dump(
-struct cam_vfe_mux_rdi_data *rdi_priv)
-{
-	struct cam_vfe_soc_private *soc_private =
-		rdi_priv->soc_info->soc_private;
-	uint32_t  val;
-
-	if (soc_private->cpas_version == CAM_CPAS_TITAN_175_V120 ||
-		soc_private->cpas_version == CAM_CPAS_TITAN_175_V130) {
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x3A20, true, &val);
-		CAM_INFO(CAM_ISP, "IFE0_nRDI_MAXWR_LOW offset 0x3A20 val 0x%x",
-			val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x5420, true, &val);
-		CAM_INFO(CAM_ISP, "IFE1_nRDI_MAXWR_LOW offset 0x5420 val 0x%x",
-			val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x3620, true, &val);
-		CAM_INFO(CAM_ISP,
-			"IFE0123_RDI_WR_MAXWR_LOW offset 0x3620 val 0x%x", val);
-
-	} else if (soc_private->cpas_version < CAM_CPAS_TITAN_175_V120) {
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x420, true, &val);
-		CAM_INFO(CAM_ISP, "IFE02_MAXWR_LOW offset 0x420 val 0x%x", val);
-
-		cam_cpas_reg_read(soc_private->cpas_handle,
-			CAM_CPAS_REG_CAMNOC, 0x820, true, &val);
-		CAM_INFO(CAM_ISP, "IFE13_MAXWR_LOW offset 0x820 val 0x%x", val);
-	}
-
-	return 0;
-
-}
-
 static int cam_vfe_rdi_err_irq_top_half(
 	uint32_t                               evt_id,
 	struct cam_irq_th_payload             *th_payload)
@@ -167,12 +124,6 @@ static int cam_vfe_rdi_err_irq_top_half(
 	}
 
 	cam_isp_hw_get_timestamp(&evt_payload->ts);
-	if (error_flag) {
-		rdi_priv->error_ts.tv_sec =
-			evt_payload->ts.mono_time.tv_sec;
-		rdi_priv->error_ts.tv_usec =
-			evt_payload->ts.mono_time.tv_usec;
-	}
 
 	for (i = 0; i < th_payload->num_registers; i++)
 		evt_payload->irq_reg_val[i] = th_payload->evt_status_arr[i];
@@ -261,7 +212,7 @@ static int cam_vfe_rdi_resource_start(
 	struct cam_vfe_mux_rdi_data   *rsrc_data;
 	int                            rc = 0;
 	uint32_t                       err_irq_mask[CAM_IFE_IRQ_REGISTERS_MAX];
-	uint32_t                 rdi_irq_mask[CAM_IFE_IRQ_REGISTERS_MAX] = {0};
+	uint32_t                       irq_mask[CAM_IFE_IRQ_REGISTERS_MAX];
 
 	if (!rdi_res) {
 		CAM_ERR(CAM_ISP, "Error! Invalid input arguments");
@@ -279,6 +230,10 @@ static int cam_vfe_rdi_resource_start(
 		rsrc_data->rdi_common_reg_data->error_irq_mask0;
 	err_irq_mask[CAM_IFE_IRQ_CAMIF_REG_STATUS1] =
 		rsrc_data->rdi_common_reg_data->error_irq_mask1;
+	irq_mask[CAM_IFE_IRQ_CAMIF_REG_STATUS0] =
+		rsrc_data->rdi_common_reg_data->subscribe_irq_mask0;
+	irq_mask[CAM_IFE_IRQ_CAMIF_REG_STATUS1] =
+		rsrc_data->rdi_common_reg_data->subscribe_irq_mask1;
 
 	rdi_res->res_state = CAM_ISP_RESOURCE_STATE_STREAMING;
 
@@ -306,19 +261,11 @@ static int cam_vfe_rdi_resource_start(
 	if (!rdi_res->rdi_only_ctx)
 		goto end;
 
-	rdi_irq_mask[0] =
-		(rsrc_data->reg_data->reg_update_irq_mask |
-			rsrc_data->reg_data->sof_irq_mask);
-
-	CAM_DBG(CAM_ISP, "RDI%d irq_mask 0x%x",
-		rdi_res->res_id - CAM_ISP_HW_VFE_IN_RDI0,
-		rdi_irq_mask[0]);
-
 	if (!rsrc_data->irq_handle) {
 		rsrc_data->irq_handle = cam_irq_controller_subscribe_irq(
 			rsrc_data->vfe_irq_controller,
 			CAM_IRQ_PRIORITY_1,
-			rdi_irq_mask,
+			irq_mask,
 			rdi_res,
 			rdi_res->top_half_handler,
 			rdi_res->bottom_half_handler,
@@ -331,11 +278,6 @@ static int cam_vfe_rdi_resource_start(
 		}
 	}
 
-	rsrc_data->sof_ts.tv_sec = 0;
-	rsrc_data->sof_ts.tv_usec = 0;
-	rsrc_data->error_ts.tv_sec = 0;
-	rsrc_data->error_ts.tv_usec = 0;
-
 	CAM_DBG(CAM_ISP, "Start RDI %d",
 		rdi_res->res_id - CAM_ISP_HW_VFE_IN_RDI0);
 end:
@@ -446,11 +388,6 @@ static int cam_vfe_rdi_handle_irq_bottom_half(void *handler_priv,
 	struct cam_vfe_top_irq_evt_payload  *payload;
 	struct cam_isp_hw_event_info         evt_info;
 	uint32_t                             irq_status0;
-	uint32_t                             irq_status1;
-	uint32_t                             irq_rdi_status;
-	struct cam_hw_soc_info              *soc_info = NULL;
-	struct cam_vfe_soc_private          *soc_private = NULL;
-	struct timespec64                    ts;
 
 	if (!handler_priv || !evt_payload_priv) {
 		CAM_ERR(CAM_ISP, "Invalid params");
@@ -460,12 +397,8 @@ static int cam_vfe_rdi_handle_irq_bottom_half(void *handler_priv,
 	rdi_node = handler_priv;
 	rdi_priv = rdi_node->res_priv;
 	payload = evt_payload_priv;
-	soc_info = rdi_priv->soc_info;
-	soc_private =
-		(struct cam_vfe_soc_private *)soc_info->soc_private;
 
 	irq_status0 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS0];
-	irq_status1 = payload->irq_reg_val[CAM_IFE_IRQ_CAMIF_REG_STATUS1];
 
 	evt_info.hw_idx   = rdi_node->hw_intf->hw_idx;
 	evt_info.res_id   = rdi_node->res_id;
@@ -475,10 +408,7 @@ static int cam_vfe_rdi_handle_irq_bottom_half(void *handler_priv,
 
 	if (irq_status0 & rdi_priv->reg_data->sof_irq_mask) {
 		CAM_DBG(CAM_ISP, "Received SOF");
-		rdi_priv->sof_ts.tv_sec =
-			payload->ts.mono_time.tv_sec;
-		rdi_priv->sof_ts.tv_usec =
-			payload->ts.mono_time.tv_usec;
+
 		if (rdi_priv->event_cb)
 			rdi_priv->event_cb(rdi_priv->priv,
 				CAM_ISP_HW_EVENT_SOF, (void *)&evt_info);
@@ -496,57 +426,6 @@ static int cam_vfe_rdi_handle_irq_bottom_half(void *handler_priv,
 		ret = CAM_VFE_IRQ_STATUS_SUCCESS;
 	}
 
-	if (!rdi_priv->rdi_irq_status)
-		goto end;
-
-	irq_rdi_status =
-		(irq_status1 &
-		rdi_priv->rdi_irq_status->rdi_overflow_mask);
-	if (irq_rdi_status) {
-		ktime_get_boottime_ts64(&ts);
-		CAM_INFO(CAM_ISP,
-			"current monotonic time stamp seconds %lld:%lld",
-			ts.tv_sec, ts.tv_nsec/1000);
-
-		cam_vfe_rdi_cpas_reg_dump(rdi_priv);
-
-		CAM_INFO(CAM_ISP, "ife_clk_src:%lld",
-			soc_private->ife_clk_src);
-		CAM_INFO(CAM_ISP,
-			"ERROR time %lld:%lld SOF %lld:%lld",
-			rdi_priv->error_ts.tv_sec,
-			rdi_priv->error_ts.tv_usec,
-			rdi_priv->sof_ts.tv_sec,
-			rdi_priv->sof_ts.tv_usec);
-
-		if (irq_rdi_status &
-			rdi_priv->rdi_irq_status->rdi0_overflow_mask) {
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_0;
-			}
-		else if (irq_rdi_status &
-			rdi_priv->rdi_irq_status->rdi1_overflow_mask) {
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_1;
-			}
-		else if (irq_rdi_status &
-			rdi_priv->rdi_irq_status->rdi2_overflow_mask) {
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_2;
-			}
-		else if (irq_rdi_status &
-			rdi_priv->rdi_irq_status->rdi3_overflow_mask) {
-			evt_info.res_id = CAM_ISP_IFE_OUT_RES_RDI_3;
-			}
-
-		if (rdi_priv->event_cb)
-			rdi_priv->event_cb(rdi_priv->priv,
-			CAM_ISP_HW_EVENT_ERROR,
-			(void *)&evt_info);
-
-		cam_cpas_get_camnoc_fifo_fill_level_info(
-			soc_private->cpas_version,
-			soc_private->cpas_handle);
-		cam_cpas_log_votes();
-	}
-end:
 	cam_vfe_rdi_put_evt_payload(rdi_priv, &payload);
 	CAM_DBG(CAM_ISP, "returing status = %d", ret);
 	return ret;
@@ -578,8 +457,6 @@ int cam_vfe_rdi_ver2_init(
 	rdi_priv->rdi_reg    = rdi_info->rdi_reg;
 	rdi_priv->vfe_irq_controller  = vfe_irq_controller;
 	rdi_priv->rdi_common_reg_data = rdi_info->common_reg_data;
-	rdi_priv->soc_info = soc_info;
-	rdi_priv->rdi_irq_status = rdi_info->rdi_irq_status;
 
 	switch (rdi_node->res_id) {
 	case CAM_ISP_HW_VFE_IN_RDI0:
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.h
index 70a2cb756cea..c570e84a011c 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_rdi.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_RDI_H_
@@ -17,14 +17,6 @@ struct cam_vfe_rdi_ver2_reg {
 	uint32_t     reg_update_cmd;
 };
 
-struct cam_vfe_rdi_overflow_status {
-	uint32_t    rdi0_overflow_mask;
-	uint32_t    rdi1_overflow_mask;
-	uint32_t    rdi2_overflow_mask;
-	uint32_t    rdi3_overflow_mask;
-	uint32_t    rdi_overflow_mask;
-};
-
 struct cam_vfe_rdi_common_reg_data {
 	uint32_t     subscribe_irq_mask0;
 	uint32_t     subscribe_irq_mask1;
@@ -43,7 +35,6 @@ struct cam_vfe_rdi_ver2_hw_info {
 	struct cam_vfe_top_ver2_reg_offset_common  *common_reg;
 	struct cam_vfe_rdi_ver2_reg                *rdi_reg;
 	struct cam_vfe_rdi_common_reg_data         *common_reg_data;
-	struct cam_vfe_rdi_overflow_status         *rdi_irq_status;
 	struct cam_vfe_rdi_reg_data  *reg_data[CAM_VFE_RDI_VER2_MAX];
 };
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_common.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_common.h
index 55607b6d886f..03be713e6068 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_common.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_common.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_TOP_COMMON_H_
@@ -13,10 +13,6 @@
 #include "cam_vfe_hw_intf.h"
 #include "cam_vfe_soc.h"
 
-#define CAM_VFE_TOP_MAX_REG_DUMP_ENTRIES 70
-
-#define CAM_VFE_TOP_MAX_LUT_DUMP_ENTRIES 6
-
 struct cam_vfe_top_priv_common {
 	struct cam_isp_resource_node    mux_rsrc[CAM_VFE_TOP_MUX_MAX];
 	uint32_t                        num_mux;
@@ -30,30 +26,6 @@ struct cam_vfe_top_priv_common {
 	enum cam_vfe_bw_control_action  axi_vote_control[CAM_VFE_TOP_MUX_MAX];
 };
 
-struct cam_vfe_top_reg_dump_entry {
-	uint32_t reg_dump_start;
-	uint32_t reg_dump_end;
-};
-
-struct cam_vfe_top_lut_dump_entry {
-	uint32_t lut_word_size;
-	uint32_t lut_bank_sel;
-	uint32_t lut_addr_size;
-};
-
-struct cam_vfe_top_dump_data {
-	uint32_t num_reg_dump_entries;
-	uint32_t num_lut_dump_entries;
-	uint32_t dmi_cfg;
-	uint32_t dmi_addr;
-	uint32_t dmi_data_path_hi;
-	uint32_t dmi_data_path_lo;
-	struct cam_vfe_top_reg_dump_entry
-		reg_entry[CAM_VFE_TOP_MAX_REG_DUMP_ENTRIES];
-	struct cam_vfe_top_lut_dump_entry
-		lut_entry[CAM_VFE_TOP_MAX_LUT_DUMP_ENTRIES];
-};
-
 int cam_vfe_top_set_axi_bw_vote(struct cam_vfe_soc_private *soc_private,
 	struct cam_vfe_top_priv_common *top_common, bool start_stop);
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.c
index c34398f0b361..c5225c540722 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -19,7 +19,6 @@ struct cam_vfe_top_ver2_common_data {
 	struct cam_hw_soc_info                     *soc_info;
 	struct cam_hw_intf                         *hw_intf;
 	struct cam_vfe_top_ver2_reg_offset_common  *common_reg;
-	struct cam_vfe_top_dump_data               *dump_data;
 };
 
 struct cam_vfe_top_ver2_priv {
@@ -28,9 +27,6 @@ struct cam_vfe_top_ver2_priv {
 	unsigned long                       req_clk_rate[
 						CAM_VFE_TOP_MUX_MAX];
 	struct cam_vfe_top_priv_common      top_common;
-	uint32_t                            num_pix_rsrc;
-	uint32_t                            num_pd_rsrc;
-	uint32_t                            num_rdi_rsrc;
 };
 
 static int cam_vfe_top_mux_get_base(struct cam_vfe_top_ver2_priv *top_priv,
@@ -86,11 +82,8 @@ static int cam_vfe_top_set_hw_clk_rate(
 	struct cam_hw_soc_info        *soc_info = NULL;
 	int                            i, rc = 0;
 	unsigned long                  max_clk_rate = 0;
-	struct cam_vfe_soc_private    *soc_private = NULL;
 
 	soc_info = top_priv->common_data.soc_info;
-	soc_private =
-		(struct cam_vfe_soc_private *)soc_info->soc_private;
 
 	for (i = 0; i < top_priv->top_common.num_mux; i++) {
 		if (top_priv->req_clk_rate[i] > max_clk_rate)
@@ -102,7 +95,7 @@ static int cam_vfe_top_set_hw_clk_rate(
 	CAM_DBG(CAM_PERF, "VFE: Clock name=%s idx=%d clk=%llu",
 		soc_info->clk_name[soc_info->src_clk_idx],
 		soc_info->src_clk_idx, max_clk_rate);
-	soc_private->ife_clk_src = max_clk_rate;
+
 	rc = cam_soc_util_set_src_clk_rate(soc_info, max_clk_rate);
 
 	if (!rc)
@@ -185,166 +178,12 @@ static int cam_vfe_top_mux_get_reg_update(
 	return -EINVAL;
 }
 
-static int cam_vfe_top_get_data(
-	struct cam_vfe_top_ver2_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_isp_resource_node  *res = cmd_args;
-
-	if (res->process_cmd)
-		return res->process_cmd(res,
-			CAM_ISP_HW_CMD_CAMIF_DATA, cmd_args, arg_size);
-
-	return -EINVAL;
-}
-
 int cam_vfe_top_get_hw_caps(void *device_priv,
 	void *get_hw_cap_args, uint32_t arg_size)
 {
 	return -EPERM;
 }
 
-static int cam_vfe_hw_dump(
-	struct cam_vfe_top_ver2_priv *top_priv,
-	void *cmd_args,
-	uint32_t arg_size)
-{
-	int                                i, j;
-	uint8_t                           *dst;
-	uint32_t                           reg_start_offset;
-	uint32_t                           reg_dump_size = 0;
-	uint32_t                           lut_dump_size = 0;
-	uint32_t                           val;
-	uint32_t                           num_reg;
-	void __iomem                      *reg_base;
-	uint32_t                          *addr, *start;
-	size_t                             remain_len;
-	uint32_t                           min_len;
-	struct cam_hw_soc_info            *soc_info;
-	struct cam_vfe_top_dump_data      *dump_data;
-	struct cam_isp_hw_dump_header     *hdr;
-	struct cam_isp_hw_dump_args       *dump_args =
-		(struct cam_isp_hw_dump_args *)cmd_args;
-
-	if (!dump_args) {
-		CAM_ERR(CAM_ISP, "Invalid args");
-		return -EINVAL;
-	}
-	if (!dump_args->cpu_addr || !dump_args->buf_len) {
-		CAM_ERR(CAM_ISP,
-			"Invalid params %pK %zu",
-			(void *)dump_args->cpu_addr,
-			dump_args->buf_len);
-		return -EINVAL;
-	}
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_ISP,
-			"Dump offset overshoot offset %zu buf_len %zu",
-			dump_args->offset, dump_args->buf_len);
-		return -ENOSPC;
-	}
-
-	dump_data = top_priv->common_data.dump_data;
-
-	if (!dump_data) {
-		CAM_ERR(CAM_ISP, "Dump data not available");
-		return -EINVAL;
-	}
-
-	soc_info = top_priv->common_data.soc_info;
-
-	/*Dump registers */
-	for (i = 0; i < dump_data->num_reg_dump_entries; i++)
-		reg_dump_size += (dump_data->reg_entry[i].reg_dump_end -
-			dump_data->reg_entry[i].reg_dump_start);
-	/*
-	 * We dump the offset as well, so the total size dumped becomes
-	 * multiplied by 2
-	 */
-	reg_dump_size *= 2;
-	for (i = 0; i < dump_data->num_lut_dump_entries; i++)
-		lut_dump_size += ((dump_data->lut_entry[i].lut_addr_size) *
-			(dump_data->lut_entry[i].lut_word_size/8));
-
-	/*Minimum len comprises of:
-	 * soc_index
-	 * lut_dump_size + reg_dump_size + sizeof dump_header +
-	 * (num_lut_dump_entries--> represents number of banks)
-	 */
-	min_len = sizeof(uint32_t) + lut_dump_size + reg_dump_size +
-		sizeof(struct cam_isp_hw_dump_header) +
-		(dump_data->num_lut_dump_entries * sizeof(uint32_t));
-	remain_len = dump_args->buf_len - dump_args->offset;
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_ISP, "Dump buffer exhaust remain %zu, min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_isp_hw_dump_header *)dst;
-	hdr->word_size = sizeof(uint32_t);
-	scnprintf(hdr->tag, CAM_ISP_HW_DUMP_TAG_MAX_LEN, "VFE_REG:");
-	addr = (uint32_t *)(dst + sizeof(struct cam_isp_hw_dump_header));
-	start = addr;
-	*addr++ = soc_info->index;
-	for (i = 0; i < dump_data->num_reg_dump_entries; i++) {
-		num_reg  = (dump_data->reg_entry[i].reg_dump_end -
-			dump_data->reg_entry[i].reg_dump_start)/4;
-		reg_start_offset = dump_data->reg_entry[i].reg_dump_start;
-		reg_base = soc_info->reg_map[0].mem_base + reg_start_offset;
-		for (j = 0; j < num_reg; j++) {
-			addr[0] = soc_info->mem_block[0]->start +
-				reg_start_offset + (j*4);
-			addr[1] = cam_io_r(reg_base + (j*4));
-			addr += 2;
-		}
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset +=  hdr->size +
-		sizeof(struct cam_isp_hw_dump_header);
-
-	/*dump LUT*/
-	for (i = 0; i < dump_data->num_lut_dump_entries; i++) {
-
-		dst = (char *)dump_args->cpu_addr + dump_args->offset;
-		hdr = (struct cam_isp_hw_dump_header *)dst;
-		scnprintf(hdr->tag, CAM_ISP_HW_DUMP_TAG_MAX_LEN, "LUT_REG:");
-		hdr->word_size = dump_data->lut_entry[i].lut_word_size/8;
-		addr = (uint32_t *)(dst +
-			sizeof(struct cam_isp_hw_dump_header));
-		start = addr;
-		*addr++ = dump_data->lut_entry[i].lut_bank_sel;
-		val = 0x100 |  dump_data->lut_entry[i].lut_bank_sel;
-		cam_io_w_mb(val, soc_info->reg_map[0].mem_base +
-			dump_data->dmi_cfg);
-		cam_io_w_mb(0, soc_info->reg_map[0].mem_base +
-			dump_data->dmi_addr);
-		for (j = 0; j < dump_data->lut_entry[i].lut_addr_size;
-			j++) {
-			if (dump_data->lut_entry[i].lut_word_size == 64) {
-				addr[0] = cam_io_r(
-					soc_info->reg_map[0].mem_base +
-					dump_data->dmi_data_path_lo);
-				addr[1] = cam_io_r(
-					soc_info->reg_map[0].mem_base +
-					dump_data->dmi_data_path_hi);
-				addr += 2;
-			} else {
-				*addr = cam_io_r(
-					soc_info->reg_map[0].mem_base +
-					dump_data->dmi_data_path_lo);
-				addr++;
-			}
-		}
-		hdr->size = hdr->word_size * (addr - start);
-		dump_args->offset +=  hdr->size +
-			sizeof(struct cam_isp_hw_dump_header);
-	}
-	CAM_DBG(CAM_ISP, "offset %zu", dump_args->offset);
-	return 0;
-}
-
 int cam_vfe_top_init_hw(void *device_priv,
 	void *init_hw_args, uint32_t arg_size)
 {
@@ -413,6 +252,7 @@ int cam_vfe_top_reserve(void *device_priv,
 	args = (struct cam_vfe_acquire_args *)reserve_args;
 	acquire_args = &args->vfe_in;
 
+
 	for (i = 0; i < top_priv->top_common.num_mux; i++) {
 		if (top_priv->top_common.mux_rsrc[i].res_id ==
 			acquire_args->res_id &&
@@ -487,10 +327,6 @@ int cam_vfe_top_release(void *device_priv,
 	top_priv = (struct cam_vfe_top_ver2_priv   *)device_priv;
 	mux_res = (struct cam_isp_resource_node *)release_args;
 
-	top_priv->num_pix_rsrc = 0;
-	top_priv->num_pd_rsrc = 0;
-	top_priv->num_rdi_rsrc = 0;
-
 	CAM_DBG(CAM_ISP, "Resource in state %d", mux_res->res_state);
 	if (mux_res->res_state < CAM_ISP_RESOURCE_STATE_RESERVED) {
 		CAM_ERR(CAM_ISP, "Error! Resource in Invalid res_state :%d",
@@ -565,8 +401,6 @@ int cam_vfe_top_stop(void *device_priv,
 	struct cam_vfe_top_ver2_priv            *top_priv;
 	struct cam_isp_resource_node            *mux_res;
 	struct cam_hw_info                      *hw_info = NULL;
-	struct cam_hw_soc_info                  *soc_info = NULL;
-	struct cam_vfe_soc_private              *soc_private = NULL;
 	int i, rc = 0;
 
 	if (!device_priv || !stop_args) {
@@ -577,8 +411,6 @@ int cam_vfe_top_stop(void *device_priv,
 	top_priv = (struct cam_vfe_top_ver2_priv   *)device_priv;
 	mux_res = (struct cam_isp_resource_node *)stop_args;
 	hw_info = (struct cam_hw_info  *)mux_res->hw_intf->hw_priv;
-	soc_info = top_priv->common_data.soc_info;
-	soc_private = soc_info->soc_private;
 
 	if ((mux_res->res_id == CAM_ISP_HW_VFE_IN_CAMIF) ||
 		(mux_res->res_id == CAM_ISP_HW_VFE_IN_PDLIB) ||
@@ -609,7 +441,7 @@ int cam_vfe_top_stop(void *device_priv,
 			}
 		}
 	}
-	soc_private->ife_clk_src = 0;
+
 	return rc;
 }
 
@@ -625,80 +457,6 @@ int cam_vfe_top_write(void *device_priv,
 	return -EPERM;
 }
 
-int cam_vfe_top_query(struct cam_vfe_top_ver2_priv *top_priv,
-		void *cmd_args, uint32_t arg_size)
-{
-	int rc = 0;
-	struct cam_isp_hw_cmd_query     *vfe_query;
-	struct cam_hw_soc_info          *soc_info = NULL;
-	struct cam_vfe_soc_private      *soc_private = NULL;
-
-	if (!top_priv || !cmd_args) {
-		CAM_ERR(CAM_ISP, "Error! Invalid arguments");
-		return -EINVAL;
-	}
-
-	soc_info = top_priv->common_data.soc_info;
-	soc_private = soc_info->soc_private;
-	vfe_query = (struct cam_isp_hw_cmd_query *)cmd_args;
-
-	if (!soc_private) {
-		CAM_ERR(CAM_ISP, "Error soc_private NULL");
-		return -EINVAL;
-	}
-
-	switch (vfe_query->query_cmd) {
-	case CAM_ISP_HW_CMD_QUERY_DSP_MODE:
-		if (soc_private->dsp_disabled)
-			rc = -EINVAL;
-		break;
-	default:
-		rc = -EINVAL;
-		CAM_ERR(CAM_ISP, "Error, Invalid cmd:%d", vfe_query->query_cmd);
-		break;
-	}
-	return rc;
-}
-
-static int cam_vfe_get_irq_register_dump(
-	struct cam_vfe_top_ver2_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_isp_hw_get_cmd_update  *cmd_update = cmd_args;
-
-	if (cmd_update->res->process_cmd)
-		cmd_update->res->process_cmd(cmd_update->res,
-			CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP, cmd_args,
-			arg_size);
-	return 0;
-}
-
-static int cam_vfe_set_num_of_acquired_resource(
-	struct cam_vfe_top_ver2_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_vfe_num_of_acquired_resources *num_rsrc = cmd_args;
-
-	top_priv->num_pix_rsrc = num_rsrc->num_pix_rsrc;
-	top_priv->num_pd_rsrc = num_rsrc->num_pd_rsrc;
-	top_priv->num_rdi_rsrc = num_rsrc->num_rdi_rsrc;
-
-	return 0;
-}
-
-static int cam_vfe_get_num_of_acquired_resource(
-	struct cam_vfe_top_ver2_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_vfe_num_of_acquired_resources *num_rsrc = cmd_args;
-
-	num_rsrc->num_pix_rsrc = top_priv->num_pix_rsrc;
-	num_rsrc->num_pd_rsrc = top_priv->num_pd_rsrc;
-	num_rsrc->num_rdi_rsrc = top_priv->num_rdi_rsrc;
-
-	return 0;
-}
-
 int cam_vfe_top_process_cmd(void *device_priv, uint32_t cmd_type,
 	void *cmd_args, uint32_t arg_size)
 {
@@ -727,10 +485,6 @@ int cam_vfe_top_process_cmd(void *device_priv, uint32_t cmd_type,
 		rc = cam_vfe_top_mux_get_reg_update(top_priv, cmd_args,
 			arg_size);
 		break;
-	case CAM_ISP_HW_CMD_CAMIF_DATA:
-		rc = cam_vfe_top_get_data(top_priv, cmd_args,
-			arg_size);
-		break;
 	case CAM_ISP_HW_CMD_CLOCK_UPDATE:
 		rc = cam_vfe_top_clock_update(top_priv, cmd_args,
 			arg_size);
@@ -751,25 +505,6 @@ int cam_vfe_top_process_cmd(void *device_priv, uint32_t cmd_type,
 		rc = cam_vfe_top_bw_control(soc_private, &top_priv->top_common,
 			cmd_args, arg_size);
 		break;
-	case CAM_ISP_HW_CMD_DUMP_HW:
-		rc = cam_vfe_hw_dump(top_priv,
-			cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_QUERY:
-		rc = cam_vfe_top_query(top_priv, cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP:
-		rc = cam_vfe_get_irq_register_dump(top_priv,
-			cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_SET_NUM_OF_ACQUIRED_RESOURCE:
-		rc = cam_vfe_set_num_of_acquired_resource(top_priv,
-			cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_GET_NUM_OF_ACQUIRED_RESOURCE:
-		rc = cam_vfe_get_num_of_acquired_resource(top_priv,
-			cmd_args, arg_size);
-		break;
 	default:
 		rc = -EINVAL;
 		CAM_ERR(CAM_ISP, "Error! Invalid cmd:%d", cmd_type);
@@ -892,7 +627,6 @@ int cam_vfe_top_ver2_init(
 	top_priv->common_data.hw_intf      = hw_intf;
 	top_priv->top_common.hw_idx        = hw_intf->hw_idx;
 	top_priv->common_data.common_reg   = ver2_hw_info->common_reg;
-	top_priv->common_data.dump_data    = ver2_hw_info->dump_data;
 
 	return rc;
 
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.h
index b4a657227497..961bf954aaa1 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver2.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_TOP_VER2_H_
@@ -41,10 +41,6 @@ struct cam_vfe_top_ver2_reg_offset_common {
 	uint32_t three_D_cfg;
 	uint32_t violation_status;
 	uint32_t reg_update_cmd;
-	uint32_t irq_mask_0;
-	uint32_t irq_mask_1;
-	uint32_t irq_status_0;
-	uint32_t irq_status_1;
 };
 
 struct cam_vfe_top_ver2_hw_info {
@@ -53,7 +49,6 @@ struct cam_vfe_top_ver2_hw_info {
 	struct cam_vfe_camif_lite_ver2_hw_info      camif_lite_hw_info;
 	struct cam_vfe_rdi_ver2_hw_info             rdi_hw_info;
 	struct cam_vfe_fe_ver1_hw_info              fe_hw_info;
-	struct cam_vfe_top_dump_data               *dump_data;
 	uint32_t                                    num_mux;
 	uint32_t mux_type[CAM_VFE_TOP_MUX_MAX];
 };
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.c b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.c
index 8e5248fa9b11..743950bd01bc 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.c
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/slab.h>
@@ -12,10 +12,10 @@
 #include "cam_debug_util.h"
 #include "cam_vfe_soc.h"
 
-#define CAM_VFE_HW_RESET_HW_AND_REG_VAL       0x00000001
-#define CAM_VFE_HW_RESET_HW_VAL               0x00010000
+#define CAM_VFE_HW_RESET_HW_AND_REG_VAL       0x00000003
+#define CAM_VFE_HW_RESET_HW_VAL               0x007F0000
 #define CAM_VFE_LITE_HW_RESET_AND_REG_VAL     0x00000002
-#define CAM_VFE_LITE_HW_RESET_HW_VAL          0x00000001
+#define CAM_VFE_LITE_HW_RESET_HW_VAL          0x0000003D
 
 struct cam_vfe_top_ver3_common_data {
 	struct cam_hw_soc_info                     *soc_info;
@@ -29,9 +29,6 @@ struct cam_vfe_top_ver3_priv {
 	unsigned long                       req_clk_rate[
 						CAM_VFE_TOP_MUX_MAX];
 	struct cam_vfe_top_priv_common      top_common;
-	uint32_t                            num_pix_rsrc;
-	uint32_t                            num_pd_rsrc;
-	uint32_t                            num_rdi_rsrc;
 };
 
 static int cam_vfe_top_ver3_mux_get_base(struct cam_vfe_top_ver3_priv *top_priv,
@@ -119,9 +116,6 @@ static int cam_vfe_top_ver3_set_hw_clk_rate(
 			rc = 0;
 			goto end;
 		}
-
-		soc_private->ife_clk_src = max_clk_rate;
-
 		ahb_vote.type = CAM_VOTE_ABSOLUTE;
 		ahb_vote.vote.level = clk_lvl;
 		cam_cpas_update_ahb_vote(soc_private->cpas_handle, &ahb_vote);
@@ -218,19 +212,6 @@ static int cam_vfe_top_ver3_mux_get_reg_update(
 	return -EINVAL;
 }
 
-static int cam_vfe_top_ver3_get_data(
-	struct cam_vfe_top_ver3_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_isp_resource_node  *res = cmd_args;
-
-	if (res->process_cmd)
-		return res->process_cmd(res,
-			CAM_ISP_HW_CMD_CAMIF_DATA, cmd_args, arg_size);
-
-	return -EINVAL;
-}
-
 int cam_vfe_top_ver3_get_hw_caps(void *device_priv,
 	void *get_hw_cap_args, uint32_t arg_size)
 {
@@ -241,24 +222,9 @@ int cam_vfe_top_ver3_init_hw(void *device_priv,
 	void *init_hw_args, uint32_t arg_size)
 {
 	struct cam_vfe_top_ver3_priv   *top_priv = device_priv;
-	struct cam_vfe_top_ver3_common_data common_data = top_priv->common_data;
 
 	top_priv->hw_clk_rate = 0;
 
-	/* Disable clock gating at IFE top */
-	CAM_INFO(CAM_ISP, "Disable clock gating at IFE top");
-	cam_soc_util_w_mb(common_data.soc_info, VFE_CORE_BASE_IDX,
-		common_data.common_reg->core_cgc_ovd_0, 0xFFFFFFFF);
-
-	cam_soc_util_w_mb(common_data.soc_info, VFE_CORE_BASE_IDX,
-		common_data.common_reg->core_cgc_ovd_1, 0xFF);
-
-	cam_soc_util_w_mb(common_data.soc_info, VFE_CORE_BASE_IDX,
-		common_data.common_reg->ahb_cgc_ovd, 0x1);
-
-	cam_soc_util_w_mb(common_data.soc_info, VFE_CORE_BASE_IDX,
-		common_data.common_reg->noc_cgc_ovd, 0x1);
-
 	return 0;
 }
 
@@ -300,6 +266,11 @@ int cam_vfe_top_ver3_reset(void *device_priv,
 			reset_reg_val = CAM_VFE_LITE_HW_RESET_HW_VAL;
 		break;
 	}
+	/* override due to hw limitation */
+	if (!soc_private->is_ife_lite)
+		reset_reg_val = CAM_VFE_HW_RESET_HW_AND_REG_VAL;
+	else
+		reset_reg_val = CAM_VFE_LITE_HW_RESET_AND_REG_VAL;
 
 	CAM_DBG(CAM_ISP, "reset reg value: 0x%x", reset_reg_val);
 
@@ -406,10 +377,6 @@ int cam_vfe_top_ver3_release(void *device_priv,
 	top_priv = (struct cam_vfe_top_ver3_priv   *)device_priv;
 	mux_res = (struct cam_isp_resource_node *)release_args;
 
-	top_priv->num_pix_rsrc = 0;
-	top_priv->num_pd_rsrc = 0;
-	top_priv->num_rdi_rsrc = 0;
-
 	CAM_DBG(CAM_ISP, "Resource in state %d", mux_res->res_state);
 	if (mux_res->res_state < CAM_ISP_RESOURCE_STATE_RESERVED) {
 		CAM_ERR(CAM_ISP, "Error, Resource in Invalid res_state :%d",
@@ -484,8 +451,6 @@ int cam_vfe_top_ver3_stop(void *device_priv,
 	struct cam_vfe_top_ver3_priv            *top_priv;
 	struct cam_isp_resource_node            *mux_res;
 	struct cam_hw_info                      *hw_info = NULL;
-	struct cam_hw_soc_info                  *soc_info = NULL;
-	struct cam_vfe_soc_private              *soc_private = NULL;
 	int i, rc = 0;
 
 	if (!device_priv || !stop_args) {
@@ -496,8 +461,6 @@ int cam_vfe_top_ver3_stop(void *device_priv,
 	top_priv = (struct cam_vfe_top_ver3_priv   *)device_priv;
 	mux_res = (struct cam_isp_resource_node *)stop_args;
 	hw_info = (struct cam_hw_info  *)mux_res->hw_intf->hw_priv;
-	soc_info = top_priv->common_data.soc_info;
-	soc_private = soc_info->soc_private;
 
 	if (mux_res->res_id < CAM_ISP_HW_VFE_IN_MAX) {
 		rc = mux_res->stop(mux_res);
@@ -520,7 +483,6 @@ int cam_vfe_top_ver3_stop(void *device_priv,
 		}
 	}
 
-	soc_private->ife_clk_src = 0;
 	return rc;
 }
 
@@ -536,80 +498,6 @@ int cam_vfe_top_ver3_write(void *device_priv,
 	return -EPERM;
 }
 
-int cam_vfe_top_ver3_query(struct cam_vfe_top_ver3_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	int rc = 0;
-	struct cam_isp_hw_cmd_query     *vfe_query;
-	struct cam_hw_soc_info          *soc_info = NULL;
-	struct cam_vfe_soc_private      *soc_private = NULL;
-
-	if (!top_priv || !cmd_args) {
-		CAM_ERR(CAM_ISP, "Error, Invalid arguments");
-		return -EINVAL;
-	}
-
-	soc_info = top_priv->common_data.soc_info;
-	soc_private = soc_info->soc_private;
-	vfe_query = (struct cam_isp_hw_cmd_query *)cmd_args;
-
-	if (!soc_private) {
-		CAM_ERR(CAM_ISP, "Error soc_private NULL");
-		return -EINVAL;
-	}
-
-	switch (vfe_query->query_cmd) {
-	case CAM_ISP_HW_CMD_QUERY_DSP_MODE:
-		if (soc_private->dsp_disabled)
-			rc = -EINVAL;
-		break;
-	default:
-		rc = -EINVAL;
-		CAM_ERR(CAM_ISP, "Error, Invalid cmd:%d", vfe_query->query_cmd);
-		break;
-	}
-	return rc;
-}
-
-static int cam_vfe_top_ver3_get_irq_register_dump(
-	struct cam_vfe_top_ver3_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_isp_hw_get_cmd_update  *cmd_update = cmd_args;
-
-	if (cmd_update->res->process_cmd)
-		cmd_update->res->process_cmd(cmd_update->res,
-			CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP, cmd_args,
-			arg_size);
-	return 0;
-}
-
-static int cam_vfe_top_ver3_set_num_of_acquired_resource(
-	struct cam_vfe_top_ver3_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_vfe_num_of_acquired_resources *num_rsrc = cmd_args;
-
-	top_priv->num_pix_rsrc = num_rsrc->num_pix_rsrc;
-	top_priv->num_pd_rsrc = num_rsrc->num_pd_rsrc;
-	top_priv->num_rdi_rsrc = num_rsrc->num_rdi_rsrc;
-
-	return 0;
-}
-
-static int cam_vfe_top_ver3_get_num_of_acquired_resource(
-	struct cam_vfe_top_ver3_priv *top_priv,
-	void *cmd_args, uint32_t arg_size)
-{
-	struct cam_vfe_num_of_acquired_resources *num_rsrc = cmd_args;
-
-	num_rsrc->num_pix_rsrc = top_priv->num_pix_rsrc;
-	num_rsrc->num_pd_rsrc = top_priv->num_pd_rsrc;
-	num_rsrc->num_rdi_rsrc = top_priv->num_rdi_rsrc;
-
-	return 0;
-}
-
 int cam_vfe_top_ver3_process_cmd(void *device_priv, uint32_t cmd_type,
 	void *cmd_args, uint32_t arg_size)
 {
@@ -640,10 +528,6 @@ int cam_vfe_top_ver3_process_cmd(void *device_priv, uint32_t cmd_type,
 		rc = cam_vfe_top_ver3_mux_get_reg_update(top_priv, cmd_args,
 			arg_size);
 		break;
-	case CAM_ISP_HW_CMD_CAMIF_DATA:
-		rc = cam_vfe_top_ver3_get_data(top_priv, cmd_args,
-			arg_size);
-		break;
 	case CAM_ISP_HW_CMD_CLOCK_UPDATE:
 		rc = cam_vfe_top_ver3_clock_update(top_priv, cmd_args,
 			arg_size);
@@ -667,21 +551,6 @@ int cam_vfe_top_ver3_process_cmd(void *device_priv, uint32_t cmd_type,
 	case CAM_ISP_HW_CMD_CORE_CONFIG:
 		rc = cam_vfe_core_config_control(top_priv, cmd_args, arg_size);
 		break;
-	case CAM_ISP_HW_CMD_QUERY:
-		rc = cam_vfe_top_ver3_query(top_priv, cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_GET_IRQ_REGISTER_DUMP:
-		rc = cam_vfe_top_ver3_get_irq_register_dump(top_priv,
-			cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_SET_NUM_OF_ACQUIRED_RESOURCE:
-		rc = cam_vfe_top_ver3_set_num_of_acquired_resource(top_priv,
-			cmd_args, arg_size);
-		break;
-	case CAM_ISP_HW_CMD_GET_NUM_OF_ACQUIRED_RESOURCE:
-		rc = cam_vfe_top_ver3_get_num_of_acquired_resource(top_priv,
-			cmd_args, arg_size);
-		break;
 	default:
 		rc = -EINVAL;
 		CAM_ERR(CAM_ISP, "Error, Invalid cmd:%d", cmd_type);
diff --git a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.h b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.h
index c4c5725cab73..14c96097cdf6 100644
--- a/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.h
+++ b/techpack/camera/drivers/cam_isp/isp_hw_mgr/isp_hw/vfe_hw/vfe_top/cam_vfe_top_ver3.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_VFE_TOP_VER3_H_
@@ -38,16 +38,10 @@ struct cam_vfe_top_ver3_reg_offset_common {
 	uint32_t bus_cgc_ovd;
 	uint32_t core_cfg_0;
 	uint32_t core_cfg_1;
-	uint32_t irq_mask_0;
-	uint32_t irq_mask_1;
-	uint32_t irq_mask_2;
-	uint32_t irq_status_0;
-	uint32_t irq_status_1;
-	uint32_t irq_status_2;
 	uint32_t reg_update_cmd;
 	uint32_t trigger_cdm_events;
 	uint32_t violation_status;
-	uint32_t custom_frame_idx;
+	uint32_t sbi_frame_idx;
 	uint32_t dsp_status;
 	uint32_t diag_config;
 	uint32_t diag_sensor_status_0;
diff --git a/techpack/camera/drivers/cam_jpeg/cam_jpeg_context.c b/techpack/camera/drivers/cam_jpeg/cam_jpeg_context.c
index b28f8b667239..b16a9dfed011 100644
--- a/techpack/camera/drivers/cam_jpeg/cam_jpeg_context.c
+++ b/techpack/camera/drivers/cam_jpeg/cam_jpeg_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/debugfs.h>
@@ -83,19 +83,6 @@ static int __cam_jpeg_ctx_release_dev_in_acquired(struct cam_context *ctx,
 	return rc;
 }
 
-static int __cam_jpeg_ctx_dump_dev_in_acquired(
-	struct cam_context      *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int rc;
-
-	rc = cam_context_dump_dev_to_hw(ctx, cmd);
-	if (rc)
-		CAM_ERR(CAM_JPEG, "Failed to dump device, rc=%d", rc);
-
-	return rc;
-}
-
 static int __cam_jpeg_ctx_flush_dev_in_acquired(struct cam_context *ctx,
 	struct cam_flush_dev_cmd *cmd)
 {
@@ -158,7 +145,6 @@ static struct cam_ctx_ops
 			.config_dev = __cam_jpeg_ctx_config_dev_in_acquired,
 			.stop_dev = __cam_jpeg_ctx_stop_dev_in_acquired,
 			.flush_dev = __cam_jpeg_ctx_flush_dev_in_acquired,
-			.dump_dev = __cam_jpeg_ctx_dump_dev_in_acquired,
 		},
 		.crm_ops = { },
 		.irq_ops = __cam_jpeg_ctx_handle_buf_done_in_acquired,
diff --git a/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.c b/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.c
index b123ebe8059a..0a68ce997283 100644
--- a/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.c
+++ b/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.c
@@ -49,12 +49,10 @@ static const struct of_device_id cam_jpeg_dt_match[] = {
 static int cam_jpeg_subdev_open(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
 
 	mutex_lock(&g_jpeg_dev.jpeg_mutex);
 	g_jpeg_dev.open_cnt++;
 	mutex_unlock(&g_jpeg_dev.jpeg_mutex);
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
 
 	return 0;
 }
@@ -99,7 +97,7 @@ static int cam_jpeg_dev_remove(struct platform_device *pdev)
 	int rc;
 	int i;
 
-	for (i = 0; i < CAM_JPEG_CTX_MAX; i++) {
+	for (i = 0; i < CAM_CTX_MAX; i++) {
 		rc = cam_jpeg_context_deinit(&g_jpeg_dev.ctx_jpeg[i]);
 		if (rc)
 			CAM_ERR(CAM_JPEG, "JPEG context %d deinit failed %d",
@@ -137,7 +135,7 @@ static int cam_jpeg_dev_probe(struct platform_device *pdev)
 		goto unregister;
 	}
 
-	for (i = 0; i < CAM_JPEG_CTX_MAX; i++) {
+	for (i = 0; i < CAM_CTX_MAX; i++) {
 		rc = cam_jpeg_context_init(&g_jpeg_dev.ctx_jpeg[i],
 			&g_jpeg_dev.ctx[i],
 			&node->hw_mgr_intf,
@@ -149,7 +147,7 @@ static int cam_jpeg_dev_probe(struct platform_device *pdev)
 		}
 	}
 
-	rc = cam_node_init(node, &hw_mgr_intf, g_jpeg_dev.ctx, CAM_JPEG_CTX_MAX,
+	rc = cam_node_init(node, &hw_mgr_intf, g_jpeg_dev.ctx, CAM_CTX_MAX,
 		CAM_JPEG_DEV_NAME);
 	if (rc) {
 		CAM_ERR(CAM_JPEG, "JPEG node init failed %d", rc);
diff --git a/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.h b/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.h
index d07a1f94b425..4961527de1a7 100644
--- a/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.h
+++ b/techpack/camera/drivers/cam_jpeg/cam_jpeg_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_JPEG_DEV_H_
@@ -24,8 +24,8 @@
 struct cam_jpeg_dev {
 	struct cam_subdev sd;
 	struct cam_node *node;
-	struct cam_context ctx[CAM_JPEG_CTX_MAX];
-	struct cam_jpeg_context ctx_jpeg[CAM_JPEG_CTX_MAX];
+	struct cam_context ctx[CAM_CTX_MAX];
+	struct cam_jpeg_context ctx_jpeg[CAM_CTX_MAX];
 	struct mutex jpeg_mutex;
 	int32_t open_cnt;
 };
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.c b/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.c
index e30033d1169b..09b4b8d3e0f6 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.c
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/uaccess.h>
@@ -177,9 +177,7 @@ static int cam_jpeg_mgr_process_irq(void *priv, void *data)
 		PTR_TO_U64(p_cfg_req->hw_cfg_args.priv);
 	ctx_data->ctxt_event_cb(ctx_data->context_priv, 0, &buf_data);
 
-	mutex_lock(&g_jpeg_hw_mgr.hw_mgr_mutex);
 	list_add_tail(&p_cfg_req->list, &hw_mgr->free_req_list);
-	mutex_unlock(&g_jpeg_hw_mgr.hw_mgr_mutex);
 	return rc;
 }
 
@@ -484,7 +482,6 @@ static int cam_jpeg_mgr_process_cmd(void *priv, void *data)
 			rc);
 		goto end_callcb;
 	}
-	p_cfg_req->submit_timestamp = ktime_get();
 
 	mutex_unlock(&hw_mgr->hw_mgr_mutex);
 	return rc;
@@ -728,12 +725,10 @@ static int cam_jpeg_mgr_prepare_hw_update(void *hw_mgr_priv,
 	}
 
 	if ((packet->num_cmd_buf > 5) || !packet->num_patches ||
-		!packet->num_io_configs ||
-		(packet->num_io_configs > CAM_JPEG_IMAGE_MAX)) {
-		CAM_ERR(CAM_JPEG,
-			"wrong number of cmd/patch/io_configs info: %u %u %u",
-			packet->num_cmd_buf, packet->num_patches,
-			packet->num_io_configs);
+		!packet->num_io_configs) {
+		CAM_ERR(CAM_JPEG, "wrong number of cmd/patch info: %u %u",
+			packet->num_cmd_buf,
+			packet->num_patches);
 		return -EINVAL;
 	}
 
@@ -1287,16 +1282,6 @@ static int cam_jpeg_mgr_get_hw_caps(void *hw_mgr_priv, void *hw_caps_args)
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_jpeg_command_queue(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
-static void cam_req_mgr_process_workq_jpeg_message_queue(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 static int cam_jpeg_setup_workqs(void)
 {
 	int rc, i;
@@ -1305,8 +1290,7 @@ static int cam_jpeg_setup_workqs(void)
 		"jpeg_command_queue",
 		CAM_JPEG_WORKQ_NUM_TASK,
 		&g_jpeg_hw_mgr.work_process_frame,
-		CRM_WORKQ_USAGE_NON_IRQ, 0, false,
-		cam_req_mgr_process_workq_jpeg_command_queue);
+		CRM_WORKQ_USAGE_NON_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_JPEG, "unable to create a worker %d", rc);
 		goto work_process_frame_failed;
@@ -1316,8 +1300,7 @@ static int cam_jpeg_setup_workqs(void)
 		"jpeg_message_queue",
 		CAM_JPEG_WORKQ_NUM_TASK,
 		&g_jpeg_hw_mgr.work_process_irq_cb,
-		CRM_WORKQ_USAGE_IRQ, 0, false,
-		cam_req_mgr_process_workq_jpeg_message_queue);
+		CRM_WORKQ_USAGE_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_JPEG, "unable to create a worker %d", rc);
 		goto work_process_irq_cb_failed;
@@ -1501,143 +1484,6 @@ static int cam_jpeg_init_devices(struct device_node *of_node,
 	return rc;
 }
 
-static int cam_jpeg_mgr_hw_dump(void *hw_mgr_priv, void *dump_hw_args)
-{
-	int                             rc;
-	uint8_t                        *dst;
-	ktime_t                         cur_time;
-	size_t                          remain_len;
-	uint32_t                        min_len;
-	uint32_t                        dev_type;
-	uint64_t                        diff;
-	uint64_t                       *addr, *start;
-	struct timespec64               cur_ts;
-	struct timespec64               req_ts;
-	struct cam_jpeg_hw_mgr         *hw_mgr;
-	struct cam_hw_dump_args        *dump_args;
-	struct cam_jpeg_hw_cfg_req     *p_cfg_req;
-	struct cam_jpeg_hw_ctx_data    *ctx_data;
-	struct cam_jpeg_hw_dump_args    jpeg_dump_args;
-	struct cam_jpeg_hw_dump_header *hdr;
-
-	if (!hw_mgr_priv || !dump_hw_args) {
-		CAM_ERR(CAM_JPEG, "Invalid args %pK %pK",
-			hw_mgr_priv, dump_hw_args);
-		return -EINVAL;
-	}
-
-	hw_mgr = hw_mgr_priv;
-	dump_args = (struct cam_hw_dump_args *)dump_hw_args;
-	ctx_data = (struct cam_jpeg_hw_ctx_data *)dump_args->ctxt_to_hw_map;
-
-	if (!ctx_data) {
-		CAM_ERR(CAM_JPEG, "Invalid context");
-		return -EINVAL;
-	}
-
-	mutex_lock(&hw_mgr->hw_mgr_mutex);
-
-	if (!ctx_data->in_use) {
-		CAM_ERR(CAM_JPEG, "ctx is not in use");
-		mutex_unlock(&hw_mgr->hw_mgr_mutex);
-		return -EINVAL;
-	}
-
-	dev_type = ctx_data->jpeg_dev_acquire_info.dev_type;
-
-	if (true == hw_mgr->device_in_use[dev_type][0]) {
-		p_cfg_req = hw_mgr->dev_hw_cfg_args[dev_type][0];
-		if (p_cfg_req  && p_cfg_req->req_id ==
-			    (uintptr_t)dump_args->request_id)
-			goto hw_dump;
-	}
-
-	mutex_unlock(&hw_mgr->hw_mgr_mutex);
-	return 0;
-
-hw_dump:
-	cur_time = ktime_get();
-	diff = ktime_us_delta(cur_time, p_cfg_req->submit_timestamp);
-	cur_ts = ktime_to_timespec64(cur_time);
-	req_ts = ktime_to_timespec64(p_cfg_req->submit_timestamp);
-
-	if (diff < CAM_JPEG_RESPONSE_TIME_THRESHOLD) {
-		CAM_INFO(CAM_JPEG,
-			"No error req %lld %ld:%06ld %ld:%06ld",
-			dump_args->request_id,
-			req_ts.tv_sec,
-			req_ts.tv_nsec/NSEC_PER_USEC,
-			cur_ts.tv_sec,
-			cur_ts.tv_nsec/NSEC_PER_USEC);
-		mutex_unlock(&hw_mgr->hw_mgr_mutex);
-		return 0;
-	}
-
-	CAM_INFO(CAM_JPEG,
-		"Error req %lld %ld:%06ld %ld:%06ld",
-		dump_args->request_id,
-		req_ts.tv_sec,
-		req_ts.tv_nsec/NSEC_PER_USEC,
-		cur_ts.tv_sec,
-		cur_ts.tv_nsec/NSEC_PER_USEC);
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&jpeg_dump_args.cpu_addr, &jpeg_dump_args.buf_len);
-	if (rc) {
-		CAM_ERR(CAM_JPEG, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		mutex_unlock(&hw_mgr->hw_mgr_mutex);
-		return -rc;
-	}
-
-	if (jpeg_dump_args.buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_JPEG, "dump offset overshoot len %zu offset %zu",
-			jpeg_dump_args.buf_len, dump_args->offset);
-		mutex_unlock(&hw_mgr->hw_mgr_mutex);
-		return -ENOSPC;
-	}
-
-	remain_len = jpeg_dump_args.buf_len - dump_args->offset;
-	min_len = sizeof(struct cam_jpeg_hw_dump_header) +
-			(CAM_JPEG_HW_DUMP_NUM_WORDS * sizeof(uint64_t));
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_JPEG, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		mutex_unlock(&hw_mgr->hw_mgr_mutex);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)jpeg_dump_args.cpu_addr + dump_args->offset;
-	hdr = (struct cam_jpeg_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_JPEG_HW_DUMP_TAG_MAX_LEN,
-		"JPEG_REQ:");
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst + sizeof(struct cam_jpeg_hw_dump_header));
-	start = addr;
-	*addr++ = dump_args->request_id;
-	*addr++ = req_ts.tv_sec;
-	*addr++ = req_ts.tv_nsec/NSEC_PER_USEC;
-	*addr++ = cur_ts.tv_sec;
-	*addr++ = cur_ts.tv_nsec/NSEC_PER_USEC;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_jpeg_hw_dump_header);
-	jpeg_dump_args.request_id = dump_args->request_id;
-	jpeg_dump_args.offset = dump_args->offset;
-
-	if (hw_mgr->devices[dev_type][0]->hw_ops.process_cmd) {
-		rc = hw_mgr->devices[dev_type][0]->hw_ops.process_cmd(
-			hw_mgr->devices[dev_type][0]->hw_priv,
-			CAM_JPEG_CMD_HW_DUMP,
-			&jpeg_dump_args, sizeof(jpeg_dump_args));
-	}
-
-	mutex_unlock(&hw_mgr->hw_mgr_mutex);
-	CAM_DBG(CAM_JPEG, "Offset before %u after %u",
-		dump_args->offset, jpeg_dump_args.offset);
-	dump_args->offset = jpeg_dump_args.offset;
-	return rc;
-}
-
 static int cam_jpeg_mgr_cmd(void *hw_mgr_priv, void *cmd_args)
 {
 	int rc = 0;
@@ -1691,7 +1537,6 @@ int cam_jpeg_hw_mgr_init(struct device_node *of_node, uint64_t *hw_mgr_hdl,
 	hw_mgr_intf->hw_flush = cam_jpeg_mgr_hw_flush;
 	hw_mgr_intf->hw_stop = cam_jpeg_mgr_hw_stop;
 	hw_mgr_intf->hw_cmd = cam_jpeg_mgr_cmd;
-	hw_mgr_intf->hw_dump = cam_jpeg_mgr_hw_dump;
 
 	mutex_init(&g_jpeg_hw_mgr.hw_mgr_mutex);
 	spin_lock_init(&g_jpeg_hw_mgr.hw_mgr_lock);
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.h b/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.h
index 3a00e424ebc9..e482c11a82bd 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.h
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/cam_jpeg_hw_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_JPEG_HW_MGR_H
@@ -21,12 +21,6 @@
 #define CAM_JPEG_WORKQ_TASK_MSG_TYPE 2
 #define CAM_JPEG_HW_CFG_Q_MAX        50
 
-/*
- * Response time threshold in ms beyond which a request is not expected
- * to be with JPEG hw
- */
-#define CAM_JPEG_RESPONSE_TIME_THRESHOLD   100000
-
 /**
  * struct cam_jpeg_process_frame_work_data_t
  *
@@ -75,14 +69,12 @@ struct cam_jpeg_hw_cdm_info_t {
  * @hw_cfg_args: Hw config args
  * @dev_type: Dev type for cfg request
  * @req_id: Request Id
- * @submit_timestamp: Timestamp of submitting request
  */
 struct cam_jpeg_hw_cfg_req {
 	struct list_head list;
 	struct cam_hw_config_args hw_cfg_args;
 	uint32_t dev_type;
 	uintptr_t req_id;
-	ktime_t    submit_timestamp;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_intf.h b/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_intf.h
index df552c4d04cf..1b93547fdf25 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_intf.h
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_JPEG_HW_INTF_H
@@ -8,6 +8,7 @@
 
 #include "cam_cpas_api.h"
 
+#define CAM_JPEG_CTX_MAX              8
 #define CAM_JPEG_DEV_PER_TYPE_MAX     1
 
 #define CAM_JPEG_CMD_BUF_MAX_SIZE     128
@@ -15,9 +16,6 @@
 
 #define JPEG_VOTE                     640000000
 
-#define CAM_JPEG_HW_DUMP_TAG_MAX_LEN 32
-#define CAM_JPEG_HW_DUMP_NUM_WORDS   5
-
 enum cam_jpeg_hw_type {
 	CAM_JPEG_DEV_ENC,
 	CAM_JPEG_DEV_DMA,
@@ -30,23 +28,9 @@ struct cam_jpeg_set_irq_cb {
 	uint32_t b_set_cb;
 };
 
-struct cam_jpeg_hw_dump_args {
-	uint64_t  request_id;
-	uintptr_t cpu_addr;
-	size_t    offset;
-	size_t    buf_len;
-};
-
-struct cam_jpeg_hw_dump_header {
-	uint8_t     tag[CAM_JPEG_HW_DUMP_TAG_MAX_LEN];
-	uint64_t    size;
-	uint32_t    word_size;
-};
-
 enum cam_jpeg_cmd_type {
 	CAM_JPEG_CMD_CDM_CFG,
 	CAM_JPEG_CMD_SET_IRQ_CB,
-	CAM_JPEG_CMD_HW_DUMP,
 	CAM_JPEG_CMD_MAX,
 };
 
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_mgr_intf.h b/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_mgr_intf.h
index b83a308f7d78..30c51f7cfcfd 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_mgr_intf.h
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/include/cam_jpeg_hw_mgr_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_JPEG_HW_MGR_INTF_H
@@ -10,8 +10,6 @@
 #include <media/cam_jpeg.h>
 #include <media/cam_defs.h>
 
-#define CAM_JPEG_CTX_MAX        16
-
 int cam_jpeg_hw_mgr_init(struct device_node *of_node,
 	uint64_t *hw_mgr_hdl, int *iommu_hdl);
 
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/cam_jpeg_enc_hw_info_ver_4_2_0.h b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/cam_jpeg_enc_hw_info_ver_4_2_0.h
index b75998bc586c..e610a9e7ee03 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/cam_jpeg_enc_hw_info_ver_4_2_0.h
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/cam_jpeg_enc_hw_info_ver_4_2_0.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_JPEG_ENC_HW_INFO_TITAN170_H
@@ -66,10 +66,6 @@ static struct cam_jpeg_enc_device_hw_info cam_jpeg_enc_hw_info = {
 		.resetdone = CAM_JPEG_HW_MASK_COMP_RESET_ACK,
 		.iserror = CAM_JPEG_HW_MASK_COMP_ERR,
 		.stopdone = CAM_JPEG_HW_IRQ_STATUS_STOP_DONE_MASK,
-	},
-	.reg_dump = {
-		.start_offset = 0x0,
-		.end_offset = 0x33C,
 	}
 };
 
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.c b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.c
index c0cfbe7a76e4..4830bf58e89e 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.c
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/of.h>
@@ -42,7 +42,6 @@ int cam_jpeg_enc_init_hw(void *device_priv,
 	struct cam_jpeg_enc_device_core_info *core_info = NULL;
 	struct cam_ahb_vote ahb_vote;
 	struct cam_axi_vote axi_vote = {0};
-	unsigned long flags;
 	int rc;
 
 	if (!device_priv) {
@@ -93,9 +92,6 @@ int cam_jpeg_enc_init_hw(void *device_priv,
 		CAM_ERR(CAM_JPEG, "soc enable is failed %d", rc);
 		goto soc_failed;
 	}
-	spin_lock_irqsave(&jpeg_enc_dev->hw_lock, flags);
-	jpeg_enc_dev->hw_state = CAM_HW_STATE_POWER_UP;
-	spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
 
 	mutex_unlock(&core_info->core_mutex);
 
@@ -116,7 +112,6 @@ int cam_jpeg_enc_deinit_hw(void *device_priv,
 	struct cam_hw_info *jpeg_enc_dev = device_priv;
 	struct cam_hw_soc_info *soc_info = NULL;
 	struct cam_jpeg_enc_device_core_info *core_info = NULL;
-	unsigned long flags;
 	int rc;
 
 	if (!device_priv) {
@@ -146,9 +141,6 @@ int cam_jpeg_enc_deinit_hw(void *device_priv,
 		return -EFAULT;
 	}
 
-	spin_lock_irqsave(&jpeg_enc_dev->hw_lock, flags);
-	jpeg_enc_dev->hw_state = CAM_HW_STATE_POWER_DOWN;
-	spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
 	rc = cam_jpeg_enc_disable_soc_resources(soc_info);
 	if (rc)
 		CAM_ERR(CAM_JPEG, "soc disable failed %d", rc);
@@ -182,19 +174,12 @@ irqreturn_t cam_jpeg_enc_irq(int irq_num, void *data)
 	hw_info = core_info->jpeg_enc_hw_info;
 	mem_base = soc_info->reg_map[0].mem_base;
 
-	spin_lock(&jpeg_enc_dev->hw_lock);
-	if (jpeg_enc_dev->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_ERR(CAM_JPEG, "JPEG HW is in off state");
-		spin_unlock(&jpeg_enc_dev->hw_lock);
-		return IRQ_HANDLED;
-	}
 	irq_status = cam_io_r_mb(mem_base +
 		core_info->jpeg_enc_hw_info->reg_offset.int_status);
 
 	cam_io_w_mb(irq_status,
 		soc_info->reg_map[0].mem_base +
 		core_info->jpeg_enc_hw_info->reg_offset.int_clr);
-	spin_unlock(&jpeg_enc_dev->hw_lock);
 
 	CAM_DBG(CAM_JPEG, "irq_num %d  irq_status = %x , core_state %d",
 		irq_num, irq_status, core_info->core_state);
@@ -270,7 +255,6 @@ int cam_jpeg_enc_reset_hw(void *data,
 	struct cam_jpeg_enc_device_hw_info *hw_info = NULL;
 	void __iomem *mem_base;
 	unsigned long rem_jiffies;
-	unsigned long flags;
 
 	if (!jpeg_enc_dev) {
 		CAM_ERR(CAM_JPEG, "Invalid args");
@@ -284,23 +268,17 @@ int cam_jpeg_enc_reset_hw(void *data,
 	mem_base = soc_info->reg_map[0].mem_base;
 
 	mutex_lock(&core_info->core_mutex);
-	spin_lock_irqsave(&jpeg_enc_dev->hw_lock, flags);
-	if (jpeg_enc_dev->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_ERR(CAM_JPEG, "JPEG HW is in off state");
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
-		mutex_unlock(&core_info->core_mutex);
-		return -EINVAL;
-	}
+	spin_lock(&jpeg_enc_dev->hw_lock);
 	if (core_info->core_state == CAM_JPEG_ENC_CORE_RESETTING) {
 		CAM_ERR(CAM_JPEG, "alrady resetting");
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
+		spin_unlock(&jpeg_enc_dev->hw_lock);
 		mutex_unlock(&core_info->core_mutex);
 		return 0;
 	}
 
 	reinit_completion(&jpeg_enc_dev->hw_complete);
 	core_info->core_state = CAM_JPEG_ENC_CORE_RESETTING;
-	spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
+	spin_unlock(&jpeg_enc_dev->hw_lock);
 
 	cam_io_w_mb(hw_info->reg_val.int_mask_disable_all,
 		mem_base + hw_info->reg_offset.int_mask);
@@ -330,7 +308,6 @@ int cam_jpeg_enc_start_hw(void *data,
 	struct cam_hw_soc_info *soc_info = NULL;
 	struct cam_jpeg_enc_device_hw_info *hw_info = NULL;
 	void __iomem *mem_base;
-	unsigned long flags;
 
 	if (!jpeg_enc_dev) {
 		CAM_ERR(CAM_JPEG, "Invalid args");
@@ -343,18 +320,10 @@ int cam_jpeg_enc_start_hw(void *data,
 	hw_info = core_info->jpeg_enc_hw_info;
 	mem_base = soc_info->reg_map[0].mem_base;
 
-	spin_lock_irqsave(&jpeg_enc_dev->hw_lock, flags);
-	if (jpeg_enc_dev->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_ERR(CAM_JPEG, "JPEG HW is in off state");
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
-		return -EINVAL;
-	}
 	if (core_info->core_state != CAM_JPEG_ENC_CORE_READY) {
-		CAM_ERR(CAM_JPEG, "Error not ready: %d", core_info->core_state);
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
+		CAM_ERR(CAM_JPEG, "Error not ready");
 		return -EINVAL;
 	}
-	spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
 
 	cam_io_w_mb(hw_info->reg_val.hw_cmd_start,
 		mem_base + hw_info->reg_offset.hw_cmd);
@@ -371,7 +340,6 @@ int cam_jpeg_enc_stop_hw(void *data,
 	struct cam_jpeg_enc_device_hw_info *hw_info = NULL;
 	void __iomem *mem_base;
 	unsigned long rem_jiffies;
-	unsigned long flags;
 
 	if (!jpeg_enc_dev) {
 		CAM_ERR(CAM_JPEG, "Invalid args");
@@ -384,23 +352,17 @@ int cam_jpeg_enc_stop_hw(void *data,
 	mem_base = soc_info->reg_map[0].mem_base;
 
 	mutex_lock(&core_info->core_mutex);
-	spin_lock_irqsave(&jpeg_enc_dev->hw_lock, flags);
-	if (jpeg_enc_dev->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_ERR(CAM_JPEG, "JPEG HW is in off state");
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
-		mutex_unlock(&core_info->core_mutex);
-		return -EINVAL;
-	}
+	spin_lock(&jpeg_enc_dev->hw_lock);
 	if (core_info->core_state == CAM_JPEG_ENC_CORE_ABORTING) {
 		CAM_ERR(CAM_JPEG, "alrady stopping");
-		spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
+		spin_unlock(&jpeg_enc_dev->hw_lock);
 		mutex_unlock(&core_info->core_mutex);
 		return 0;
 	}
 
 	reinit_completion(&jpeg_enc_dev->hw_complete);
 	core_info->core_state = CAM_JPEG_ENC_CORE_ABORTING;
-	spin_unlock_irqrestore(&jpeg_enc_dev->hw_lock, flags);
+	spin_unlock(&jpeg_enc_dev->hw_lock);
 
 	cam_io_w_mb(hw_info->reg_val.hw_cmd_stop,
 		mem_base + hw_info->reg_offset.hw_cmd);
@@ -416,81 +378,6 @@ int cam_jpeg_enc_stop_hw(void *data,
 	return 0;
 }
 
-int cam_jpeg_enc_hw_dump(
-	struct cam_hw_info           *jpeg_enc_dev,
-	struct cam_jpeg_hw_dump_args *dump_args)
-{
-
-	int                                   i;
-	uint8_t                              *dst;
-	uint32_t                             *addr, *start;
-	uint32_t                              num_reg, min_len;
-	uint32_t                              reg_start_offset;
-	size_t                                remain_len;
-	struct cam_hw_soc_info               *soc_info;
-	struct cam_jpeg_hw_dump_header       *hdr;
-	struct cam_jpeg_enc_device_hw_info   *hw_info;
-	struct cam_jpeg_enc_device_core_info *core_info;
-
-	soc_info = &jpeg_enc_dev->soc_info;
-	core_info = (struct cam_jpeg_enc_device_core_info *)
-		jpeg_enc_dev->core_info;
-	hw_info = core_info->jpeg_enc_hw_info;
-	mutex_lock(&core_info->core_mutex);
-	spin_lock(&jpeg_enc_dev->hw_lock);
-
-	if (jpeg_enc_dev->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_ERR(CAM_JPEG, "JPEG HW is in off state");
-		spin_unlock(&jpeg_enc_dev->hw_lock);
-		mutex_unlock(&core_info->core_mutex);
-		return -EINVAL;
-	}
-
-	spin_unlock(&jpeg_enc_dev->hw_lock);
-
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_JPEG, "dump buffer overshoot %zu %zu",
-			dump_args->buf_len, dump_args->offset);
-		mutex_unlock(&core_info->core_mutex);
-		return -ENOSPC;
-	}
-
-	remain_len = dump_args->buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_jpeg_hw_dump_header) +
-		    soc_info->reg_map[0].size + sizeof(uint32_t);
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_JPEG, "dump buffer exhaust %zu %u",
-			remain_len, min_len);
-		mutex_unlock(&core_info->core_mutex);
-		return -ENOSPC;
-	}
-
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_jpeg_hw_dump_header *)dst;
-	snprintf(hdr->tag, CAM_JPEG_HW_DUMP_TAG_MAX_LEN,
-		"JPEG_REG:");
-	hdr->word_size = sizeof(uint32_t);
-	addr = (uint32_t *)(dst + sizeof(struct cam_jpeg_hw_dump_header));
-	start = addr;
-	*addr++ = soc_info->index;
-	num_reg = (hw_info->reg_dump.end_offset -
-		hw_info->reg_dump.start_offset)/4;
-	reg_start_offset = hw_info->reg_dump.start_offset;
-	for (i = 0; i < num_reg; i++) {
-		*addr++ = soc_info->mem_block[0]->start +
-			reg_start_offset + i*4;
-		*addr++ = cam_io_r(soc_info->reg_map[0].mem_base + (i*4));
-	}
-
-	mutex_unlock(&core_info->core_mutex);
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_jpeg_hw_dump_header);
-	CAM_DBG(CAM_JPEG, "offset %zu", dump_args->offset);
-
-	return 0;
-}
-
 int cam_jpeg_enc_process_cmd(void *device_priv, uint32_t cmd_type,
 	void *cmd_args, uint32_t arg_size)
 {
@@ -531,12 +418,6 @@ int cam_jpeg_enc_process_cmd(void *device_priv, uint32_t cmd_type,
 		rc = 0;
 		break;
 	}
-	case CAM_JPEG_CMD_HW_DUMP:
-	{
-		rc = cam_jpeg_enc_hw_dump(jpeg_enc_dev,
-			cmd_args);
-		break;
-	}
 	default:
 		rc = -EINVAL;
 		break;
diff --git a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.h b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.h
index ca83dccb193f..df9341c90c77 100644
--- a/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.h
+++ b/techpack/camera/drivers/cam_jpeg/jpeg_hw/jpeg_enc_hw/jpeg_enc_core.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef CAM_JPEG_ENC_CORE_H
@@ -39,16 +39,10 @@ struct cam_jpeg_enc_int_status {
 	uint32_t stopdone;
 };
 
-struct cam_jpeg_enc_reg_dump {
-	uint32_t start_offset;
-	uint32_t end_offset;
-};
-
 struct cam_jpeg_enc_device_hw_info {
 	struct cam_jpeg_enc_reg_offsets reg_offset;
 	struct cam_jpeg_enc_regval reg_val;
 	struct cam_jpeg_enc_int_status int_status;
-	struct cam_jpeg_enc_reg_dump reg_dump;
 };
 
 enum cam_jpeg_enc_core_state {
diff --git a/techpack/camera/drivers/cam_log/cam_log.c b/techpack/camera/drivers/cam_log/cam_log.c
new file mode 100644
index 000000000000..df83976a1284
--- /dev/null
+++ b/techpack/camera/drivers/cam_log/cam_log.c
@@ -0,0 +1,194 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#define DEBUG
+#define pr_fmt(fmt)     KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/ktime.h>
+#include <linux/timer.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#include <linux/poll.h>
+#include "cam_log.h"
+
+/*device name after register in charater*/
+#define CAMLOG_DEV_NAME      "camlog"
+
+static struct camlog_dev camlogdev;
+
+static long cameralog_ioctl(struct file *filp, unsigned int cmd,
+    unsigned long arg)
+{
+    pr_debug(" cameralog_ioctl!\n");
+    return 0;
+}
+
+static int cameralog_open(struct inode *inode, struct file *filp)
+{
+    pr_debug(" cameralog_open!\n");
+    return 0;
+}
+
+/**
+*
+* @return Number of bytes read.
+*/
+static ssize_t cameralog_read(struct file *fp, char __user *buff,
+    size_t length, loff_t *ppos)
+{
+    ssize_t bytes_read = 0;
+    int ret = 0;
+    bool has_message = false;
+    struct camlog_dev *camlog_dev = &camlogdev;
+
+    if ( strlen(camlog_dev->m_camlog_message) )
+    {
+        sprintf(camlog_dev->m_camlog_message, "%s\n", camlog_dev->m_camlog_message);
+        has_message = true;
+    } else {
+        has_message = false;
+        strcpy(camlog_dev->m_camlog_message,"\n");
+    }
+    mutex_lock(&camlog_dev->camlog_message_lock);
+
+    ret = copy_to_user(buff, camlog_dev->m_camlog_message,
+                    strlen(camlog_dev->m_camlog_message));
+
+    mutex_unlock(&camlog_dev->camlog_message_lock);
+
+    if ((ret == 0) && has_message)
+    {
+         bytes_read = strlen(camlog_dev->m_camlog_message);
+    }
+
+    memset(camlog_dev->m_camlog_message, 0 , strlen(camlog_dev->m_camlog_message));
+
+    return bytes_read;
+}
+
+void camlog_send_message(void){
+
+    pr_debug (" camlog_send_message ss  \n");
+}
+EXPORT_SYMBOL(camlog_send_message);
+
+/**
+*
+* @return number of bytes actually written
+*/
+static ssize_t cameralog_write(struct file *fp, const char *buff,
+    size_t length, loff_t *ppos)
+{
+    int ret = 0;
+    ssize_t bytes_read = 0;
+    struct camlog_dev *camlog_dev = &camlogdev;
+
+    mutex_lock(&camlog_dev->camlog_message_lock);
+
+    ret = copy_from_user(camlog_dev->m_camlog_message, buff,
+                                length);
+    if (0 == ret)
+    {
+        bytes_read = strlen(camlog_dev->m_camlog_message);
+    }
+
+    mutex_unlock(&camlog_dev->camlog_message_lock);
+
+    wake_up_interruptible(&camlog_dev->camlog_is_not_empty);
+
+    return bytes_read;
+}
+
+static int cameralog_release(struct inode *inode, struct file *filp)
+{
+    struct camlog_dev *camlog_dev = &camlogdev;
+    pr_debug(" cameralog_release!\n");
+    wake_up_interruptible(&camlog_dev->camlog_is_not_empty);
+    return 0;
+}
+
+static unsigned int cameralog_poll(struct file *file,
+    struct poll_table_struct *poll_table)
+{
+    unsigned int mask = 0;
+    struct camlog_dev *camlog_dev = &camlogdev;
+    poll_wait(file, &camlog_dev->camlog_is_not_empty, poll_table);
+
+    if (strlen(camlog_dev->m_camlog_message))
+    {
+        mask = POLLIN | POLLRDNORM;
+    }
+
+    return mask;
+}
+
+static const struct file_operations cameralog_fops =
+{
+    .owner = THIS_MODULE,
+    .unlocked_ioctl = cameralog_ioctl,
+    .open = cameralog_open,
+    .release = cameralog_release,
+    .poll = cameralog_poll,
+    .read = cameralog_read,
+    .write=cameralog_write,
+};
+
+static struct class *camlog_class;
+static unsigned int camlog_major;
+static int __init cameralog_init(void)
+{
+    struct device *device;
+    struct camlog_dev *camlog_dev = &camlogdev;
+    camlog_major = register_chrdev(0, CAMLOG_DEV_NAME, &cameralog_fops);
+    camlog_class=class_create(THIS_MODULE, CAMLOG_DEV_NAME);
+    if (IS_ERR(camlog_class)) {
+         unregister_chrdev(camlog_major,  CAMLOG_DEV_NAME);
+        pr_warn("Failed to create class.\n");
+        return PTR_ERR(camlog_class);
+    }
+    camlog_dev->devt = MKDEV(camlog_major, 0);
+    device = device_create(camlog_class, NULL, camlog_dev->devt,
+                NULL, CAMLOG_DEV_NAME);
+
+    if (IS_ERR(device)) {
+        pr_err("error while trying to create %s\n",CAMLOG_DEV_NAME);
+        return -EINVAL;
+    }
+    mutex_init(&camlog_dev->camlog_message_lock);
+    init_waitqueue_head(&camlog_dev->camlog_is_not_empty);
+
+    return 0;
+}
+
+module_init(cameralog_init);
+
+static void __exit cameralog_exit(void)
+{
+    struct camlog_dev *camlog_dev = &camlogdev;
+    device_destroy(camlog_class, camlog_dev->devt);
+    class_destroy(camlog_class);
+    unregister_chrdev(camlog_major, CAMLOG_DEV_NAME);
+}
+
+module_exit(cameralog_exit);
+
+MODULE_DESCRIPTION("camera log device driver");
+MODULE_LICENSE("GPL v2");
diff --git a/techpack/camera/drivers/cam_log/cam_log.h b/techpack/camera/drivers/cam_log/cam_log.h
new file mode 100644
index 000000000000..55730370a9c1
--- /dev/null
+++ b/techpack/camera/drivers/cam_log/cam_log.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
+ */
+#ifndef _CAM_LOG_H_
+#define _CAM_LOG_H_
+
+#include <linux/types.h>
+#include <linux/kfifo.h>
+#include <linux/wait.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+
+struct camlog_dev {
+    dev_t devt;
+    uint8_t m_camlog_message[1024];
+    struct mutex camlog_message_lock;
+    wait_queue_head_t camlog_is_not_empty;
+};
+void camlog_send_message(void);
+
+#endif /* _CAM_LOG_H_ */
diff --git a/techpack/camera/drivers/cam_lrme/cam_lrme_context.c b/techpack/camera/drivers/cam_lrme/cam_lrme_context.c
index 857aab9dd476..fa544c7a089e 100644
--- a/techpack/camera/drivers/cam_lrme/cam_lrme_context.c
+++ b/techpack/camera/drivers/cam_lrme/cam_lrme_context.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -86,21 +86,6 @@ static int __cam_lrme_ctx_config_dev_in_activated(struct cam_context *ctx,
 	return rc;
 }
 
-static int __cam_lrme_ctx_dump_dev_in_activated(
-	struct cam_context      *ctx,
-	struct cam_dump_req_cmd *cmd)
-{
-	int rc = 0;
-
-	CAM_DBG(CAM_LRME, "Enter ctx %d", ctx->ctx_id);
-
-	rc = cam_context_dump_dev_to_hw(ctx, cmd);
-	if (rc)
-		CAM_ERR(CAM_LRME, "Failed to dump device");
-
-	return rc;
-}
-
 static int __cam_lrme_ctx_flush_dev_in_activated(struct cam_context *ctx,
 	struct cam_flush_dev_cmd *cmd)
 {
@@ -214,7 +199,6 @@ static struct cam_ctx_ops
 			.release_dev = __cam_lrme_ctx_release_dev_in_activated,
 			.stop_dev = __cam_lrme_ctx_stop_dev_in_activated,
 			.flush_dev = __cam_lrme_ctx_flush_dev_in_activated,
-			.dump_dev = __cam_lrme_ctx_dump_dev_in_activated,
 		},
 		.crm_ops = {},
 		.irq_ops = __cam_lrme_ctx_handle_irq_in_activated,
diff --git a/techpack/camera/drivers/cam_lrme/cam_lrme_dev.c b/techpack/camera/drivers/cam_lrme/cam_lrme_dev.c
index 656a4dbd726b..7c09f2b435f5 100644
--- a/techpack/camera/drivers/cam_lrme/cam_lrme_dev.c
+++ b/techpack/camera/drivers/cam_lrme/cam_lrme_dev.c
@@ -58,12 +58,9 @@ static int cam_lrme_dev_open(struct v4l2_subdev *sd,
 {
 	struct cam_lrme_dev *lrme_dev = g_lrme_dev;
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_LOCK);
-
 	if (!lrme_dev) {
 		CAM_ERR(CAM_LRME,
 			"LRME Dev not initialized, dev=%pK", lrme_dev);
-		cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
 		return -ENODEV;
 	}
 
@@ -71,8 +68,6 @@ static int cam_lrme_dev_open(struct v4l2_subdev *sd,
 	lrme_dev->open_cnt++;
 	mutex_unlock(&lrme_dev->lock);
 
-	cam_req_mgr_rwsem_read_op(CAM_SUBDEV_UNLOCK);
-
 	return 0;
 }
 
diff --git a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/cam_lrme_hw_mgr.c b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/cam_lrme_hw_mgr.c
index a054d5f84709..40700bbce9e0 100644
--- a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/cam_lrme_hw_mgr.c
+++ b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/cam_lrme_hw_mgr.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -649,50 +649,6 @@ static int cam_lrme_mgr_hw_release(void *hw_mgr_priv, void *hw_release_args)
 	return rc;
 }
 
-static int cam_lrme_mgr_hw_dump(void *hw_mgr_priv, void *hw_dump_args)
-{
-	struct cam_hw_dump_args *dump_args = hw_dump_args;
-	struct cam_lrme_hw_mgr *hw_mgr = hw_mgr_priv;
-	struct cam_lrme_device *hw_device;
-	int rc = 0;
-	uint32_t device_index;
-	struct cam_lrme_hw_dump_args lrme_dump_args;
-
-	device_index = CAM_LRME_DECODE_DEVICE_INDEX(dump_args->ctxt_to_hw_map);
-	if (device_index >= hw_mgr->device_count) {
-		CAM_ERR(CAM_LRME, "Invalid device index %d", device_index);
-		return -EPERM;
-	}
-
-	CAM_DBG(CAM_LRME, "Start device index %d", device_index);
-
-	rc = cam_lrme_mgr_util_get_device(hw_mgr, device_index, &hw_device);
-	if (rc) {
-		CAM_ERR(CAM_LRME, "Failed to get hw device");
-		return rc;
-	}
-	rc  = cam_mem_get_cpu_buf(dump_args->buf_handle,
-		&lrme_dump_args.cpu_addr,
-		&lrme_dump_args.buf_len);
-	if (rc) {
-		CAM_ERR(CAM_LRME, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		return rc;
-	}
-	lrme_dump_args.offset =  dump_args->offset;
-	lrme_dump_args.request_id = dump_args->request_id;
-
-	rc = hw_device->hw_intf.hw_ops.process_cmd(
-		hw_device->hw_intf.hw_priv,
-		CAM_LRME_HW_CMD_DUMP,
-		&lrme_dump_args,
-		sizeof(struct cam_lrme_hw_dump_args));
-	CAM_DBG(CAM_LRME, "Offset before %zu after %zu",
-		dump_args->offset, lrme_dump_args.offset);
-	dump_args->offset = lrme_dump_args.offset;
-	return rc;
-}
-
 static int cam_lrme_mgr_hw_flush(void *hw_mgr_priv, void *hw_flush_args)
 {	int rc = 0, i;
 	struct cam_lrme_hw_mgr *hw_mgr = hw_mgr_priv;
@@ -1041,11 +997,6 @@ static int cam_lrme_mgr_create_debugfs_entry(void)
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_cam_lrme_device_submit_worker(
-	struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
 
 int cam_lrme_mgr_register_device(
 	struct cam_hw_intf *lrme_hw_intf,
@@ -1073,8 +1024,8 @@ int cam_lrme_mgr_register_device(
 	CAM_DBG(CAM_LRME, "Create submit workq for %s", buf);
 	rc = cam_req_mgr_workq_create(buf,
 		CAM_LRME_WORKQ_NUM_TASK,
-		&hw_device->work, CRM_WORKQ_USAGE_NON_IRQ, 0, true,
-		cam_req_mgr_process_workq_cam_lrme_device_submit_worker);
+		&hw_device->work, CRM_WORKQ_USAGE_NON_IRQ,
+		0);
 	if (rc) {
 		CAM_ERR(CAM_LRME,
 			"Unable to create a worker, rc=%d", rc);
@@ -1196,7 +1147,6 @@ int cam_lrme_hw_mgr_init(struct cam_hw_mgr_intf *hw_mgr_intf,
 	hw_mgr_intf->hw_flush = cam_lrme_mgr_hw_flush;
 
 	g_lrme_hw_mgr.event_cb = cam_lrme_dev_buf_done_cb;
-	hw_mgr_intf->hw_dump = cam_lrme_mgr_hw_dump;
 
 	cam_lrme_mgr_create_debugfs_entry();
 
diff --git a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.c b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.c
index 64eee9326938..b736708fa99d 100644
--- a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.c
+++ b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.c
@@ -1,9 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
-#include <linux/timer.h>
 #include "cam_lrme_hw_core.h"
 #include "cam_lrme_hw_soc.h"
 #include "cam_smmu_api.h"
@@ -22,159 +21,6 @@ static void cam_lrme_dump_registers(void __iomem *base)
 	cam_io_dump(base, 0x900, (0x928 - 0x900) / 0x4);
 }
 
-static int  cam_lrme_dump_regs_to_buf(
-	struct cam_lrme_frame_request *req,
-	struct cam_hw_info *lrme_hw,
-	struct cam_lrme_hw_dump_args *dump_args)
-{
-	int                             i;
-	uint8_t                        *dst;
-	uint32_t                       *addr, *start;
-	uint32_t                        num_reg, min_len;
-	size_t                          remain_len;
-	struct cam_hw_soc_info         *soc_info;
-	struct cam_lrme_hw_dump_header *hdr;
-
-	if (!lrme_hw || !req || !dump_args) {
-		CAM_ERR(CAM_LRME, "Invalid params %pK, %pK, %pK",
-			lrme_hw, req, dump_args);
-		return -EINVAL;
-	}
-	soc_info = &lrme_hw->soc_info;
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_LRME, "dump buffer overshoot len %zu offset %zu",
-			dump_args->buf_len, dump_args->offset);
-		return -ENOSPC;
-	}
-	remain_len = dump_args->buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_lrme_hw_dump_header) +
-		    soc_info->reg_map[0].size + sizeof(uint32_t);
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_LRME, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		return -ENOSPC;
-	}
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_lrme_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_LRME_HW_DUMP_TAG_MAX_LEN,
-		"LRME_REG:");
-	hdr->word_size = sizeof(uint32_t);
-	addr = (uint32_t *)(dst + sizeof(struct cam_lrme_hw_dump_header));
-	start = addr;
-	*addr++ = soc_info->index;
-	num_reg = soc_info->reg_map[0].size/4;
-	for (i = 0; i < num_reg; i++) {
-		*addr++ = soc_info->mem_block[0]->start + (i*4);
-		*addr++ = cam_io_r(soc_info->reg_map[0].mem_base + (i*4));
-	}
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_lrme_hw_dump_header);
-	CAM_DBG(CAM_LRME, "offset %zu", dump_args->offset);
-	return 0;
-}
-
-static int cam_lrme_hw_dump(
-	struct cam_hw_info           *lrme_hw,
-	struct cam_lrme_hw_dump_args *dump_args)
-{
-	uint8_t                        *dst;
-	ktime_t                         cur_time;
-	size_t                          remain_len;
-	uint32_t                        min_len;
-	uint64_t                        diff;
-	uint64_t                       *addr, *start;
-	struct timespec64               cur_ts;
-	struct timespec64               req_ts;
-	struct cam_lrme_core           *lrme_core;
-	struct cam_lrme_frame_request  *req = NULL;
-	struct cam_lrme_hw_dump_header *hdr;
-
-	mutex_lock(&lrme_hw->hw_mutex);
-	if (lrme_hw->hw_state == CAM_HW_STATE_POWER_DOWN) {
-		CAM_DBG(CAM_LRME, "LRME HW is in off state");
-		mutex_unlock(&lrme_hw->hw_mutex);
-		return 0;
-	}
-
-	lrme_core = (struct cam_lrme_core *)lrme_hw->core_info;
-
-	if (lrme_core->req_submit &&
-		lrme_core->req_submit->req_id == dump_args->request_id)
-		req = lrme_core->req_submit;
-	else if (lrme_core->req_proc &&
-		lrme_core->req_proc->req_id == dump_args->request_id)
-		req = lrme_core->req_proc;
-
-	if (!req) {
-		CAM_DBG(CAM_LRME, "LRME req %lld not with hw",
-			dump_args->request_id);
-		mutex_unlock(&lrme_hw->hw_mutex);
-		return 0;
-	}
-
-	cur_time = ktime_get();
-	diff = ktime_us_delta(cur_time, req->submit_timestamp);
-	cur_ts = ktime_to_timespec64(cur_time);
-	req_ts = ktime_to_timespec64(req->submit_timestamp);
-
-	if (diff < CAM_LRME_RESPONSE_TIME_THRESHOLD) {
-		CAM_INFO(CAM_LRME, "No error req %lld %ld:%06ld %ld:%06ld",
-			dump_args->request_id,
-			req_ts.tv_sec,
-			req_ts.tv_nsec/NSEC_PER_USEC,
-			cur_ts.tv_sec,
-			cur_ts.tv_nsec/NSEC_PER_USEC);
-		mutex_unlock(&lrme_hw->hw_mutex);
-		return 0;
-	}
-
-	CAM_INFO(CAM_LRME, "Error req %lld %ld:%06ld %ld:%06ld",
-		dump_args->request_id,
-		req_ts.tv_sec,
-		req_ts.tv_nsec/NSEC_PER_USEC,
-		cur_ts.tv_sec,
-		cur_ts.tv_nsec/NSEC_PER_USEC);
-
-	if (dump_args->buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_LRME, "dump buffer overshoot len %zu offset %zu",
-			dump_args->buf_len, dump_args->offset);
-		mutex_unlock(&lrme_hw->hw_mutex);
-		return 0;
-	}
-
-	remain_len = dump_args->buf_len - dump_args->offset;
-	min_len =  sizeof(struct cam_lrme_hw_dump_header) +
-		    (CAM_LRME_HW_DUMP_NUM_WORDS * sizeof(uint64_t));
-
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_LRME, "dump buffer exhaust remain %zu min %u",
-			remain_len, min_len);
-		mutex_unlock(&lrme_hw->hw_mutex);
-		return 0;
-	}
-
-	dst = (uint8_t *)dump_args->cpu_addr + dump_args->offset;
-	hdr = (struct cam_lrme_hw_dump_header *)dst;
-	scnprintf(hdr->tag, CAM_LRME_HW_DUMP_TAG_MAX_LEN,
-		"LRME_REQ:");
-	hdr->word_size = sizeof(uint64_t);
-	addr = (uint64_t *)(dst + sizeof(struct cam_lrme_hw_dump_header));
-	start = addr;
-	*addr++ = req->req_id;
-	*addr++ = req_ts.tv_sec;
-	*addr++ = req_ts.tv_nsec/NSEC_PER_USEC;
-	*addr++ = cur_ts.tv_sec;
-	*addr++ = cur_ts.tv_nsec/NSEC_PER_USEC;
-	hdr->size = hdr->word_size * (addr - start);
-	dump_args->offset += hdr->size +
-		sizeof(struct cam_lrme_hw_dump_header);
-	cam_lrme_dump_regs_to_buf(req, lrme_hw, dump_args);
-	mutex_unlock(&lrme_hw->hw_mutex);
-	return 0;
-}
-
 static void cam_lrme_cdm_write_reg_val_pair(uint32_t *buffer,
 	uint32_t *index, uint32_t reg_offset, uint32_t reg_value)
 {
@@ -1111,8 +957,6 @@ int cam_lrme_hw_submit_req(void *hw_priv, void *hw_submit_args,
 		goto error;
 	}
 
-	frame_req->submit_timestamp = ktime_get();
-
 	switch (lrme_core->state) {
 	case CAM_LRME_CORE_STATE_PROCESSING:
 		lrme_core->state = CAM_LRME_CORE_STATE_REQ_PROC_PEND;
@@ -1422,12 +1266,6 @@ int cam_lrme_hw_process_cmd(void *hw_priv, uint32_t cmd_type,
 		break;
 	}
 
-	case CAM_LRME_HW_CMD_DUMP: {
-		struct cam_lrme_hw_dump_args *dump_args =
-		   (struct cam_lrme_hw_dump_args *)cmd_args;
-		rc = cam_lrme_hw_dump(lrme_hw, dump_args);
-		break;
-		}
 	default:
 		break;
 	}
diff --git a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.h b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.h
index 4c9386c9f046..accb5a8b5827 100644
--- a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.h
+++ b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_core.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_LRME_HW_CORE_H_
@@ -35,10 +35,6 @@
 
 #define CAM_LRME_MAX_REG_PAIR_NUM 60
 
-#define CAM_LRME_RESPONSE_TIME_THRESHOLD 100000
-#define CAM_LRME_HW_DUMP_TAG_MAX_LEN     32
-#define CAM_LRME_HW_DUMP_NUM_WORDS       5
-
 /**
  * enum cam_lrme_irq_set
  *
@@ -436,20 +432,6 @@ struct cam_lrme_hw_info {
 	struct cam_lrme_titan_reg titan_reg;
 };
 
-/**
- * struct cam_lrme_hw_dump_header : LRME hw dump header
- *
- * @tag       : LRME hw dump header tag
- * @size      : Size of data
- * @word_size : size of each word
- */
-
-struct cam_lrme_hw_dump_header {
-	uint8_t     tag[CAM_LRME_HW_DUMP_TAG_MAX_LEN];
-	uint64_t    size;
-	uint32_t    word_size;
-};
-
 int cam_lrme_hw_process_irq(void *priv, void *data);
 int cam_lrme_hw_submit_req(void *hw_priv, void *hw_submit_args,
 	uint32_t arg_size);
diff --git a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_dev.c b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_dev.c
index d22c9c65ca70..4e2609648b30 100644
--- a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_dev.c
+++ b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/platform_device.h>
@@ -76,11 +76,6 @@ static int cam_lrme_hw_dev_util_cdm_acquire(struct cam_lrme_core *lrme_core,
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_cam_lrme_hw_worker(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 static int cam_lrme_hw_dev_probe(struct platform_device *pdev)
 {
 	struct cam_hw_info *lrme_hw;
@@ -118,8 +113,7 @@ static int cam_lrme_hw_dev_probe(struct platform_device *pdev)
 
 	rc = cam_req_mgr_workq_create("cam_lrme_hw_worker",
 		CAM_LRME_HW_WORKQ_NUM_TASK,
-		&lrme_core->work, CRM_WORKQ_USAGE_IRQ, 0, false,
-		cam_req_mgr_process_workq_cam_lrme_hw_worker);
+		&lrme_core->work, CRM_WORKQ_USAGE_IRQ, 0);
 	if (rc) {
 		CAM_ERR(CAM_LRME, "Unable to create a workq, rc=%d", rc);
 		goto free_memory;
diff --git a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_intf.h b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_intf.h
index cd4d64b18f67..b74d53700419 100644
--- a/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_intf.h
+++ b/techpack/camera/drivers/cam_lrme/lrme_hw_mgr/lrme_hw/cam_lrme_hw_intf.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_LRME_HW_INTF_H_
@@ -59,14 +59,12 @@ enum cam_lrme_cb_type {
  * @CAM_LRME_HW_CMD_REGISTER_CB       : register HW manager callback
  * @CAM_LRME_HW_CMD_SUBMIT            : Submit frame to HW
  * @CAM_LRME_HW_CMD_DUMP_REGISTER     : dump register values
- * @CAM_LRME_HW_CMD_DUMP              : dump register values to buffer
  */
 enum cam_lrme_hw_cmd_type {
 	CAM_LRME_HW_CMD_PREPARE_HW_UPDATE,
 	CAM_LRME_HW_CMD_REGISTER_CB,
 	CAM_LRME_HW_CMD_SUBMIT,
 	CAM_LRME_HW_CMD_DUMP_REGISTER,
-	CAM_LRME_HW_CMD_DUMP,
 };
 
 /**
@@ -89,7 +87,6 @@ enum cam_lrme_hw_reset_type {
  * @hw_device             : Pointer to HW device
  * @hw_update_entries     : List of hw_update_entries
  * @num_hw_update_entries : number of hw_update_entries
- * @submit_timestamp      : timestamp of submitting request with hw
  */
 struct cam_lrme_frame_request {
 	struct list_head           frame_list;
@@ -98,7 +95,6 @@ struct cam_lrme_frame_request {
 	struct cam_lrme_device    *hw_device;
 	struct cam_hw_update_entry hw_update_entries[CAM_LRME_MAX_HW_ENTRIES];
 	uint32_t                   num_hw_update_entries;
-	ktime_t                    submit_timestamp;
 };
 
 /**
@@ -196,19 +192,4 @@ struct cam_lrme_hw_submit_args {
 	struct cam_lrme_frame_request *frame_req;
 };
 
-/**
- * struct cam_lrme_hw_dump_args : Args for dump request
- *
- * @request_id   : Issue request id
- * @cpu_addr     : start address of the target buffer
- * @offset       : offset of the buffer
- * @buf_len      : Length of target buffer
- */
-struct cam_lrme_hw_dump_args {
-	uint64_t  request_id;
-	uintptr_t cpu_addr;
-	size_t    offset;
-	size_t    buf_len;
-};
-
 #endif /* _CAM_LRME_HW_INTF_H_ */
diff --git a/techpack/camera/drivers/cam_req_mgr/Makefile b/techpack/camera/drivers/cam_req_mgr/Makefile
index 8ecc89ffd8bb..50599d879255 100644
--- a/techpack/camera/drivers/cam_req_mgr/Makefile
+++ b/techpack/camera/drivers/cam_req_mgr/Makefile
@@ -4,7 +4,7 @@ ccflags-y += -I$(srctree)/techpack/camera/include/uapi
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_core
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_smmu/
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_utils
-ccflags-y += -I$(srctree)/
+ccflags-y += -I$(src)
 
 obj-$(CONFIG_SPECTRA_CAMERA) += cam_req_mgr_core.o\
 				cam_req_mgr_dev.o \
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.c b/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.c
index b62679206242..17b669c23f8f 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2020 The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -11,14 +10,11 @@
 #include <linux/slab.h>
 #include <linux/ion_kernel.h>
 #include <linux/dma-buf.h>
-#include <linux/debugfs.h>
 
 #include "cam_req_mgr_util.h"
 #include "cam_mem_mgr.h"
 #include "cam_smmu_api.h"
 #include "cam_debug_util.h"
-#include "cam_trace.h"
-#include "cam_common_util.h"
 
 static struct cam_mem_table tbl;
 static atomic_t cam_mem_mgr_state = ATOMIC_INIT(CAM_MEM_MGR_UNINITIALIZED);
@@ -120,29 +116,6 @@ static int cam_mem_util_unmap_cpu_va(struct dma_buf *dmabuf,
 	return rc;
 }
 
-static int cam_mem_mgr_create_debug_fs(void)
-{
-	tbl.dentry = debugfs_create_dir("camera_memmgr", NULL);
-	if (!tbl.dentry) {
-		CAM_ERR(CAM_MEM, "failed to create dentry");
-		return -ENOMEM;
-	}
-
-	if (!debugfs_create_bool("alloc_profile_enable",
-		0644,
-		tbl.dentry,
-		&tbl.alloc_profile_enable)) {
-		CAM_ERR(CAM_MEM,
-			"failed to create alloc_profile_enable");
-		goto err;
-	}
-
-	return 0;
-err:
-	debugfs_remove_recursive(tbl.dentry);
-	return -ENOMEM;
-}
-
 int cam_mem_mgr_init(void)
 {
 	int i;
@@ -168,8 +141,6 @@ int cam_mem_mgr_init(void)
 
 	atomic_set(&cam_mem_mgr_state, CAM_MEM_MGR_INITIALIZED);
 
-	cam_mem_mgr_create_debug_fs();
-
 	return 0;
 }
 
@@ -178,22 +149,18 @@ static int32_t cam_mem_get_slot(void)
 	int32_t idx;
 
 	mutex_lock(&tbl.m_lock);
-	if (tbl.bitmap) {
-		idx = find_first_zero_bit(tbl.bitmap, tbl.bits);
-		if (idx >= CAM_MEM_BUFQ_MAX || idx <= 0) {
-			mutex_unlock(&tbl.m_lock);
-			return -ENOMEM;
-		}
-
-		set_bit(idx, tbl.bitmap);
-		tbl.bufq[idx].active = true;
-		mutex_init(&tbl.bufq[idx].q_lock);
+	idx = find_first_zero_bit(tbl.bitmap, tbl.bits);
+	if (idx >= CAM_MEM_BUFQ_MAX || idx <= 0) {
 		mutex_unlock(&tbl.m_lock);
-		return idx;
+		return -ENOMEM;
 	}
 
+	set_bit(idx, tbl.bitmap);
+	tbl.bufq[idx].active = true;
+	mutex_init(&tbl.bufq[idx].q_lock);
 	mutex_unlock(&tbl.m_lock);
-	return -EINVAL;
+
+	return idx;
 }
 
 static void cam_mem_put_slot(int32_t idx)
@@ -408,17 +375,12 @@ static int cam_mem_util_get_dma_buf_fd(size_t len,
 {
 	struct dma_buf *dmabuf = NULL;
 	int rc = 0;
-	struct timespec64 ts1, ts2;
-	long microsec = 0;
 
 	if (!buf || !fd) {
 		CAM_ERR(CAM_MEM, "Invalid params, buf=%pK, fd=%pK", buf, fd);
 		return -EINVAL;
 	}
 
-	if (tbl.alloc_profile_enable)
-		CAM_GET_TIMESTAMP(ts1);
-
 	*buf = ion_alloc(len, heap_id_mask, flags);
 	if (IS_ERR_OR_NULL(*buf))
 		return -ENOMEM;
@@ -441,13 +403,6 @@ static int cam_mem_util_get_dma_buf_fd(size_t len,
 		rc = -EINVAL;
 	}
 
-	if (tbl.alloc_profile_enable) {
-		CAM_GET_TIMESTAMP(ts2);
-		CAM_GET_TIMESTAMP_DIFF_IN_MICRO(ts1, ts2, microsec);
-		trace_cam_log_event("IONAllocProfile", "size and time in micro",
-			len, microsec);
-	}
-
 	return rc;
 
 get_fd_fail:
@@ -601,10 +556,12 @@ static int cam_mem_util_map_hw_va(uint32_t flags,
 	return rc;
 multi_map_fail:
 	if (flags & CAM_MEM_FLAG_PROTECTED_MODE)
-		for (--i; i > 0; i--)
+		for (--i; i >= 0; i--)
 			cam_smmu_unmap_stage2_iova(mmu_hdls[i], fd);
 	else
-		for (--i; i > 0; i--)
+		// MI change i>0 to i>=0
+		// when i = 1 mean mmu_hdls[0] has map, and it need unmap
+		for (--i; i >= 0; i--)
 			cam_smmu_unmap_user_iova(mmu_hdls[i],
 				fd,
 				CAM_SMMU_REGION_IO);
@@ -658,7 +615,6 @@ int cam_mem_mgr_alloc_and_map(struct cam_mem_mgr_alloc_cmd *cmd)
 		goto slot_fail;
 	}
 
-	mutex_lock(&tbl.m_lock);
 	if ((cmd->flags & CAM_MEM_FLAG_HW_READ_WRITE) ||
 		(cmd->flags & CAM_MEM_FLAG_HW_SHARED_ACCESS) ||
 		(cmd->flags & CAM_MEM_FLAG_PROTECTED_MODE)) {
@@ -685,14 +641,12 @@ int cam_mem_mgr_alloc_and_map(struct cam_mem_mgr_alloc_cmd *cmd)
 
 		if (rc) {
 			CAM_ERR(CAM_MEM,
-				"Failed in map_hw_va, len=%llu, flags=0x%x, fd=%d, region=%d, num_hdl=%d, rc=%d",
-				len, cmd->flags, fd, region,
-				cmd->num_hdl, rc);
-			mutex_unlock(&tbl.m_lock);
+				"Failed in map_hw_va, flags=0x%x, fd=%d, region=%d, num_hdl=%d, rc=%d",
+				cmd->flags, fd, region, cmd->num_hdl, rc);
 			goto map_hw_fail;
 		}
 	}
-	mutex_unlock(&tbl.m_lock);
+
 	mutex_lock(&tbl.bufq[idx].q_lock);
 	tbl.bufq[idx].fd = fd;
 	tbl.bufq[idx].dma_buf = NULL;
@@ -713,7 +667,7 @@ int cam_mem_mgr_alloc_and_map(struct cam_mem_mgr_alloc_cmd *cmd)
 	tbl.bufq[idx].kmdvaddr = kvaddr;
 	tbl.bufq[idx].vaddr = hw_vaddr;
 	tbl.bufq[idx].dma_buf = dmabuf;
-	tbl.bufq[idx].len = len;
+	tbl.bufq[idx].len = cmd->len;
 	tbl.bufq[idx].num_hdl = cmd->num_hdl;
 	memcpy(tbl.bufq[idx].hdls, cmd->mmu_hdls,
 		sizeof(int32_t) * cmd->num_hdl);
@@ -737,6 +691,9 @@ int cam_mem_mgr_alloc_and_map(struct cam_mem_mgr_alloc_cmd *cmd)
 	cam_mem_put_slot(idx);
 slot_fail:
 	dma_buf_put(dmabuf);
+	// xiaomi add
+	fput(dmabuf->file);
+	put_unused_fd(fd);
 	return rc;
 }
 
@@ -776,7 +733,6 @@ int cam_mem_mgr_map(struct cam_mem_mgr_map_cmd *cmd)
 		return -EINVAL;
 	}
 
-	mutex_lock(&tbl.m_lock);
 	if ((cmd->flags & CAM_MEM_FLAG_HW_READ_WRITE) ||
 		(cmd->flags & CAM_MEM_FLAG_PROTECTED_MODE)) {
 		rc = cam_mem_util_map_hw_va(cmd->flags,
@@ -791,11 +747,9 @@ int cam_mem_mgr_map(struct cam_mem_mgr_map_cmd *cmd)
 				"Failed in map_hw_va, flags=0x%x, fd=%d, region=%d, num_hdl=%d, rc=%d",
 				cmd->flags, cmd->fd, CAM_SMMU_REGION_IO,
 				cmd->num_hdl, rc);
-			mutex_unlock(&tbl.m_lock);
 			goto map_fail;
 		}
 	}
-	mutex_unlock(&tbl.m_lock);
 
 	idx = cam_mem_get_slot();
 	if (idx < 0) {
@@ -862,7 +816,7 @@ static int cam_mem_util_unmap_hw_va(int32_t idx,
 	fd = tbl.bufq[idx].fd;
 
 	CAM_DBG(CAM_MEM,
-		"unmap_hw_va : idx=%d, fd=%x, flags=0x%x, num_hdls=%d, client=%d",
+		"unmap_hw_va : idx=%d, fd=%d, flags=0x%x, num_hdls=%d, client=%d",
 		idx, fd, flags, num_hdls, client);
 
 	if (flags & CAM_MEM_FLAG_PROTECTED_MODE) {
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.h b/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.h
index b9e42b62d52f..c8f8f55436c3 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_mem_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_MEM_MGR_H_
@@ -11,7 +11,7 @@
 #include <media/cam_req_mgr.h>
 #include "cam_mem_mgr_api.h"
 
-#define CAM_MEM_BUFQ_MAX 1024
+#define CAM_MEM_BUFQ_MAX 1536
 
 /* Enum for possible mem mgr states */
 enum cam_mem_mgr_state {
@@ -65,16 +65,12 @@ struct cam_mem_buf_queue {
  * @bitmap: bitmap of the mem mgr utility
  * @bits: max bits of the utility
  * @bufq: array of buffers
- * @dentry: Debugfs entry
- * @alloc_profile_enable: Whether to enable alloc profiling
  */
 struct cam_mem_table {
 	struct mutex m_lock;
 	void *bitmap;
 	size_t bits;
 	struct cam_mem_buf_queue bufq[CAM_MEM_BUFQ_MAX];
-	struct dentry *dentry;
-	bool alloc_profile_enable;
 };
 
 /**
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.c
index 24cc6537b5b4..3a3a711eaba5 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -41,16 +40,12 @@ void cam_req_mgr_core_link_reset(struct cam_req_mgr_core_link *link)
 	link->open_req_cnt = 0;
 	link->last_flush_id = 0;
 	link->initial_sync_req = -1;
-	link->dual_trigger = false;
-	link->trigger_cnt[0] = 0;
-	link->trigger_cnt[1] = 0;
 	link->in_msync_mode = false;
 	link->retry_cnt = 0;
 	link->is_shutdown = false;
 	link->initial_skip = true;
 	link->sof_timestamp = 0;
 	link->prev_sof_timestamp = 0;
-	link->skip_wd_validation = false;
 	link->last_applied_jiffies = 0;
 }
 
@@ -227,12 +222,6 @@ static int __cam_req_mgr_notify_error_on_link(
 	struct cam_req_mgr_message       msg;
 	int rc = 0, pd;
 
-	if (!link || !dev) {
-		CAM_ERR(CAM_CRM, "Invalid Arguments link: 0x%x dev: 0x%x!",
-			link, dev);
-		return -EINVAL;
-	}
-
 	session = (struct cam_req_mgr_core_session *)link->parent;
 
 	pd = dev->dev_info.p_delay;
@@ -530,13 +519,6 @@ static void __cam_req_mgr_validate_crm_wd_timer(
 	int next_frame_timeout = 0, current_frame_timeout = 0;
 	struct cam_req_mgr_req_queue *in_q = link->req.in_q;
 
-	if (link->skip_wd_validation) {
-		CAM_DBG(CAM_CRM,
-			"skipping modifying wd timer for first frame after streamon");
-		link->skip_wd_validation = false;
-		return;
-	}
-
 	idx = in_q->rd_idx;
 	__cam_req_mgr_dec_idx(
 		&idx, (link->max_delay - 1),
@@ -554,41 +536,35 @@ static void __cam_req_mgr_validate_crm_wd_timer(
 	CAM_DBG(CAM_CRM,
 		"rd_idx: %d idx: %d current_frame_timeout: %d ms",
 		in_q->rd_idx, idx, current_frame_timeout);
-
-	spin_lock_bh(&link->link_state_spin_lock);
-	if (link->watchdog) {
+	if (link->watchdog == NULL) {
+		CAM_ERR(CAM_CRM, "watchdog == null,link:%p", link);
+	} else {
 		if ((next_frame_timeout + CAM_REQ_MGR_WATCHDOG_TIMEOUT) >
 			link->watchdog->expires) {
 			CAM_DBG(CAM_CRM,
 				"Modifying wd timer expiry from %d ms to %d ms",
 				link->watchdog->expires,
-				(next_frame_timeout +
-				 CAM_REQ_MGR_WATCHDOG_TIMEOUT));
+				(next_frame_timeout + CAM_REQ_MGR_WATCHDOG_TIMEOUT));
 			crm_timer_modify(link->watchdog,
 				next_frame_timeout +
 				CAM_REQ_MGR_WATCHDOG_TIMEOUT);
 		} else if (current_frame_timeout) {
 			CAM_DBG(CAM_CRM,
-				"Reset wd timer to frame from %d ms to %d ms",
+				"Reset wd timer to current frame from %d ms to %d ms",
 				link->watchdog->expires,
-				(current_frame_timeout +
-				 CAM_REQ_MGR_WATCHDOG_TIMEOUT));
+				(current_frame_timeout + CAM_REQ_MGR_WATCHDOG_TIMEOUT));
 			crm_timer_modify(link->watchdog,
 				current_frame_timeout +
 				CAM_REQ_MGR_WATCHDOG_TIMEOUT);
-		} else if (!next_frame_timeout && (link->watchdog->expires >
-			CAM_REQ_MGR_WATCHDOG_TIMEOUT)) {
+		} else if (link->watchdog->expires >
+			CAM_REQ_MGR_WATCHDOG_TIMEOUT) {
 			CAM_DBG(CAM_CRM,
 				"Reset wd timer to default from %d ms to %d ms",
-				link->watchdog->expires,
-				CAM_REQ_MGR_WATCHDOG_TIMEOUT);
+				link->watchdog->expires, CAM_REQ_MGR_WATCHDOG_TIMEOUT);
 			crm_timer_modify(link->watchdog,
 				CAM_REQ_MGR_WATCHDOG_TIMEOUT);
 		}
-	} else {
-		CAM_WARN(CAM_CRM, "Watchdog timer exited already");
 	}
-	spin_unlock_bh(&link->link_state_spin_lock);
 }
 
 /**
@@ -679,11 +655,6 @@ static int __cam_req_mgr_send_req(struct cam_req_mgr_core_link *link,
 
 	apply_req.link_hdl = link->link_hdl;
 	apply_req.report_if_bubble = 0;
-	apply_req.re_apply = false;
-	if (link->retry_cnt > 0) {
-		if (g_crm_core_dev->recovery_on_apply_fail)
-			apply_req.re_apply = true;
-	}
 
 	for (i = 0; i < link->num_devs; i++) {
 		dev = &link->l_dev[i];
@@ -716,10 +687,8 @@ static int __cam_req_mgr_send_req(struct cam_req_mgr_core_link *link,
 		apply_req.trigger_point = trigger;
 		if (dev->ops && dev->ops->apply_req) {
 			rc = dev->ops->apply_req(&apply_req);
-			if (rc) {
-				*failed_dev = dev;
+			if (rc)
 				return rc;
-			}
 			CAM_DBG(CAM_REQ,
 				"SEND: link_hdl: %x pd: %d req_id %lld",
 				link->link_hdl, pd, apply_req.request_id);
@@ -1142,7 +1111,6 @@ static int __cam_req_mgr_check_sync_req_is_ready(
 	int64_t req_id = 0, sync_req_id = 0;
 	int sync_slot_idx = 0, sync_rd_idx = 0, rc = 0;
 	int32_t sync_num_slots = 0;
-	int32_t max_idx_diff;
 	uint64_t sync_frame_duration = 0;
 	uint64_t sof_timestamp_delta = 0;
 	uint64_t master_slave_diff = 0;
@@ -1246,20 +1214,12 @@ static int __cam_req_mgr_check_sync_req_is_ready(
 		return -EAGAIN;
 	}
 
-	/*
-	 * When the status of sync rd slot is APPLIED,
-	 * the maximum diff between sync_slot_idx and
-	 * sync_rd_idx is 1, since the next processed
-	 * req maybe the request in (sync_rd_idx + 1)th
-	 * slot.
-	 */
-	max_idx_diff =
-		(sync_rd_slot->status == CRM_SLOT_STATUS_REQ_APPLIED) ? 1 : 0;
-
 	if ((sync_link->req.in_q->slot[sync_slot_idx].status !=
 		CRM_SLOT_STATUS_REQ_APPLIED) &&
 		(((sync_slot_idx - sync_rd_idx + sync_num_slots) %
-		sync_num_slots) > max_idx_diff)) {
+		sync_num_slots) >= 1) &&
+		(sync_rd_slot->status !=
+		CRM_SLOT_STATUS_REQ_APPLIED)) {
 		CAM_DBG(CAM_CRM,
 			"Req: %lld [other link] not next req to be applied on link: %x",
 			req_id, sync_link->link_hdl);
@@ -1362,7 +1322,83 @@ static int __cam_req_mgr_check_sync_req_is_ready(
 
 	return 0;
 }
+ /**
+ * __cam_req_mgr_check_peer_req_is_applied()
+ *
+ * @brief    : Check whether peer req is applied
+ * @link     : pointer to link whose input queue and req tbl are
+ *             traversed through
+ * @idx      : slot idx
+ * @return   : true means the req is applied, others not applied
+ *
+ */
+static bool __cam_req_mgr_check_peer_req_is_applied(
+	struct cam_req_mgr_core_link *link,
+	int32_t idx)
+{
+	bool applied = true;
+	int64_t req_id;
+	int sync_slot_idx = 0;
+	struct cam_req_mgr_core_link *sync_link;
+	struct cam_req_mgr_slot *slot, *sync_slot;
+	struct cam_req_mgr_req_queue *in_q;
+
+	if (idx < 0)
+		return true;
+
+	slot = &link->req.in_q->slot[idx];
+	req_id = slot->req_id;
+	in_q = link->req.in_q;
+
+	CAM_DBG(CAM_REQ,
+		"Check Req[%lld] idx %d req_status %d link_hdl %x is applied in peer link",
+		req_id, idx, slot->status, link->link_hdl);
+
+	if (slot->sync_mode == CAM_REQ_MGR_SYNC_MODE_NO_SYNC) {
+		applied = true;
+		goto end;
+	}
+
+	sync_link = link->sync_link;
+
+	if (!sync_link)
+		applied &= true;
+
+	in_q = sync_link->req.in_q;
+	if (!in_q) {
+		CAM_DBG(CAM_CRM, "Link hdl %x in_q is NULL",
+			sync_link->link_hdl);
+		applied &= true;
+	}
+
+	sync_slot_idx = __cam_req_mgr_find_slot_for_req(
+		sync_link->req.in_q, req_id);
+
+	if ((sync_slot_idx < 0) ||
+		(sync_slot_idx >= MAX_REQ_SLOTS)) {
+		CAM_DBG(CAM_CRM,
+			"Can't find req:%lld from peer link, idx:%d",
+			req_id, sync_slot_idx);
+		applied &= true;
+	}
 
+	sync_slot = &in_q->slot[sync_slot_idx];
+
+	if (sync_slot->status == CRM_SLOT_STATUS_REQ_APPLIED)
+		applied &= true;
+	else
+		applied &= false;
+	CAM_DBG(CAM_CRM,
+		"link:%x idx:%d status:%d applied:%d",
+		sync_link->link_hdl, sync_slot_idx, sync_slot->status, applied);
+
+end:
+	CAM_DBG(CAM_REQ,
+		"Check Req[%lld] idx %d applied:%d",
+		req_id, idx, link->link_hdl, applied);
+
+	return applied;
+}
 /**
  * __cam_req_mgr_process_req()
  *
@@ -1466,9 +1502,21 @@ static int __cam_req_mgr_process_req(struct cam_req_mgr_core_link *link,
 
 			rc = __cam_req_mgr_inject_delay(link->req.l_tbl,
 				slot->idx);
-			if (!rc)
-				rc = __cam_req_mgr_check_link_is_ready(link,
-					slot->idx, false);
+			if (!rc) {
+				if (in_q->slot[in_q->rd_idx].req_id != -1){
+					rc = __cam_req_mgr_check_peer_req_is_applied(
+						link, in_q->last_applied_idx);
+
+					if (rc)
+						rc = __cam_req_mgr_check_link_is_ready(
+							link, slot->idx, false);
+					else
+						rc = -EINVAL;
+				}
+				else
+					rc = __cam_req_mgr_check_link_is_ready(link,
+						slot->idx, false);
+			}
 		}
 
 		if (rc < 0) {
@@ -1492,12 +1540,6 @@ static int __cam_req_mgr_process_req(struct cam_req_mgr_core_link *link,
 				rc = -EPERM;
 			}
 			spin_unlock_bh(&link->link_state_spin_lock);
-			/*
-			 * Update wd timer so in next frame if the request
-			 * packet is available request can be applied, SOF
-			 * freeze will hit otherwise.
-			 */
-			__cam_req_mgr_validate_crm_wd_timer(link);
 			goto error;
 		}
 	}
@@ -1525,11 +1567,7 @@ static int __cam_req_mgr_process_req(struct cam_req_mgr_core_link *link,
 				__cam_req_mgr_notify_error_on_link(link, dev);
 				link->retry_cnt = 0;
 			}
-		} else
-			CAM_WARN(CAM_CRM,
-				"workqueue congestion, last applied idx:%d rd idx:%d",
-				in_q->last_applied_idx,
-				in_q->rd_idx);
+		}
 	} else {
 		if (link->retry_cnt)
 			link->retry_cnt = 0;
@@ -1587,7 +1625,6 @@ static int __cam_req_mgr_process_req(struct cam_req_mgr_core_link *link,
 	 */
 	if (trigger == CAM_TRIGGER_POINT_SOF)
 		link->last_applied_jiffies = jiffies;
-
 	mutex_unlock(&session->lock);
 	return rc;
 error:
@@ -1794,14 +1831,6 @@ static int __cam_req_mgr_process_sof_freeze(void *priv, void *data)
 	link = (struct cam_req_mgr_core_link *)priv;
 	session = (struct cam_req_mgr_core_session *)link->parent;
 
-	spin_lock_bh(&link->link_state_spin_lock);
-	if ((link->watchdog) && (link->watchdog->pause_timer)) {
-		CAM_INFO(CAM_CRM, "Watchdog Paused");
-		spin_unlock_bh(&link->link_state_spin_lock);
-		return rc;
-	}
-	spin_unlock_bh(&link->link_state_spin_lock);
-
 	CAM_ERR(CAM_CRM, "SOF freeze for session %d link 0x%x",
 		session->session_hdl, link->link_hdl);
 
@@ -1846,6 +1875,9 @@ static void __cam_req_mgr_sof_freeze(struct timer_list *timer_data)
 
 	link = (struct cam_req_mgr_core_link *)timer->parent;
 
+	if (link->watchdog->pause_timer)
+		return;
+
 	task = cam_req_mgr_workq_get_task(link->workq);
 	if (!task) {
 		CAM_ERR(CAM_CRM, "No empty task");
@@ -1887,13 +1919,10 @@ static int __cam_req_mgr_create_subdevs(
  *
  */
 static void __cam_req_mgr_destroy_subdev(
-	struct cam_req_mgr_connected_device **l_device)
+	struct cam_req_mgr_connected_device *l_device)
 {
-	CAM_DBG(CAM_CRM, "*l_device %pK", *l_device);
-	if (*(l_device) != NULL) {
-		kfree(*(l_device));
-		*l_device = NULL;
-	}
+	kfree(l_device);
+	l_device = NULL;
 }
 
 /**
@@ -1987,6 +2016,8 @@ static struct cam_req_mgr_core_link *__cam_req_mgr_reserve_link(
 		if (!atomic_cmpxchg(&g_links[i].is_used, 0, 1)) {
 			link = &g_links[i];
 			CAM_DBG(CAM_CRM, "alloc link index %d", i);
+			CAM_DBG(CAM_CRM, "__cam_req_mgr_reserve_link :%p",
+				link);
 			cam_req_mgr_core_link_reset(link);
 			break;
 		}
@@ -2057,6 +2088,7 @@ static void __cam_req_mgr_free_link(struct cam_req_mgr_core_link *link)
 	link->req.in_q = NULL;
 	i = link - g_links;
 	CAM_DBG(CAM_CRM, "free link index %d", i);
+	CAM_DBG(CAM_CRM, "__cam_req_mgr_free_link :%p", link);
 	cam_req_mgr_core_link_reset(link);
 	atomic_set(&g_links[i].is_used, 0);
 }
@@ -2272,6 +2304,7 @@ int cam_req_mgr_process_sched_req(void *priv, void *data)
 	slot->sync_mode = sched_req->sync_mode;
 	slot->skip_idx = 0;
 	slot->recover = sched_req->bubble_enable;
+
 	if (sched_req->additional_timeout < 0) {
 		CAM_WARN(CAM_CRM,
 			"Requested timeout is invalid [%dms]",
@@ -2411,35 +2444,6 @@ int cam_req_mgr_process_add_req(void *priv, void *data)
 	return rc;
 }
 
-/**
- * __cam_req_mgr_apply_on_bubble()
- *
- * @brief    : This API tries to apply settings to the device
- *             with highest pd on the bubbled frame
- * @link     : link information.
- * @err_info : contains information about frame_id, trigger etc.
- *
- */
-void __cam_req_mgr_apply_on_bubble(
-	struct cam_req_mgr_core_link    *link,
-	struct cam_req_mgr_error_notify *err_info)
-{
-	int rc = 0;
-	struct cam_req_mgr_trigger_notify trigger_data;
-
-	trigger_data.dev_hdl = err_info->dev_hdl;
-	trigger_data.frame_id = err_info->frame_id;
-	trigger_data.link_hdl = err_info->link_hdl;
-	trigger_data.sof_timestamp_val =
-		err_info->sof_timestamp_val;
-	trigger_data.trigger = err_info->trigger;
-
-	rc = __cam_req_mgr_process_req(link, &trigger_data);
-	if (rc)
-		CAM_ERR(CAM_CRM,
-			"Failed to apply request on bubbled frame");
-}
-
 /**
  * cam_req_mgr_process_error()
  *
@@ -2530,7 +2534,6 @@ int cam_req_mgr_process_error(void *priv, void *data)
 			link->state = CAM_CRM_LINK_STATE_ERR;
 			spin_unlock_bh(&link->link_state_spin_lock);
 			link->open_req_cnt++;
-			__cam_req_mgr_apply_on_bubble(link, err_info);
 		}
 	}
 	mutex_unlock(&link->req.lock);
@@ -2621,14 +2624,6 @@ static int cam_req_mgr_process_trigger(void *priv, void *data)
 		link->link_hdl, in_q->rd_idx, in_q->slot[in_q->rd_idx].status);
 
 	spin_lock_bh(&link->link_state_spin_lock);
-
-	if (link->state < CAM_CRM_LINK_STATE_READY) {
-		CAM_WARN(CAM_CRM, "invalid link state:%d", link->state);
-		spin_unlock_bh(&link->link_state_spin_lock);
-		rc = -EPERM;
-		goto release_lock;
-	}
-
 	if (link->state == CAM_CRM_LINK_STATE_ERR)
 		CAM_WARN(CAM_CRM, "Error recovery idx %d status %d",
 			in_q->rd_idx,
@@ -2651,8 +2646,6 @@ static int cam_req_mgr_process_trigger(void *priv, void *data)
 			CAM_DBG(CAM_REQ,
 				"No pending req to apply to lower pd devices");
 			rc = 0;
-			__cam_req_mgr_inc_idx(&in_q->rd_idx,
-				1, in_q->num_slots);
 			goto release_lock;
 		}
 		__cam_req_mgr_inc_idx(&in_q->rd_idx, 1, in_q->num_slots);
@@ -2834,33 +2827,6 @@ static int cam_req_mgr_cb_notify_err(
 	return rc;
 }
 
-static int __cam_req_mgr_check_for_dual_trigger(
-	struct cam_req_mgr_core_link    *link)
-{
-	int rc  = -EAGAIN;
-
-	if (link->trigger_cnt[0] == link->trigger_cnt[1]) {
-		link->trigger_cnt[0] = 0;
-		link->trigger_cnt[1] = 0;
-		rc = 0;
-		return rc;
-	}
-
-	if ((link->trigger_cnt[0] &&
-		(link->trigger_cnt[0] - link->trigger_cnt[1] > 1)) ||
-		(link->trigger_cnt[1] &&
-		(link->trigger_cnt[1] - link->trigger_cnt[0] > 1))) {
-
-		CAM_ERR(CAM_CRM,
-			"One of the devices could not generate trigger");
-		return rc;
-	}
-
-	CAM_DBG(CAM_CRM, "Only one device has generated trigger");
-
-	return rc;
-}
-
 /**
  * cam_req_mgr_cb_notify_timer()
  *
@@ -2897,10 +2863,12 @@ static int cam_req_mgr_cb_notify_timer(
 		rc = -EPERM;
 		goto end;
 	}
-	if ((link->watchdog) && (!timer_data->state))
-		link->watchdog->pause_timer = true;
 	spin_unlock_bh(&link->link_state_spin_lock);
 
+
+	if (!timer_data->state)
+		link->watchdog->pause_timer = true;
+
 end:
 	return rc;
 }
@@ -2979,7 +2947,7 @@ static int cam_req_mgr_cb_notify_stop(
 static int cam_req_mgr_cb_notify_trigger(
 	struct cam_req_mgr_trigger_notify *trigger_data)
 {
-	int32_t                          rc = 0, trigger_id = 0;
+	int                              rc = 0;
 	struct crm_workq_task           *task = NULL;
 	struct cam_req_mgr_core_link    *link = NULL;
 	struct cam_req_mgr_trigger_notify   *notify_trigger;
@@ -2999,8 +2967,6 @@ static int cam_req_mgr_cb_notify_trigger(
 		goto end;
 	}
 
-	trigger_id = trigger_data->trigger_id;
-
 	spin_lock_bh(&link->link_state_spin_lock);
 	if (link->state < CAM_CRM_LINK_STATE_READY) {
 		CAM_WARN(CAM_CRM, "invalid link state:%d", link->state);
@@ -3009,26 +2975,9 @@ static int cam_req_mgr_cb_notify_trigger(
 		goto end;
 	}
 
-	if ((link->watchdog) && (link->watchdog->pause_timer))
+	if (link->watchdog->pause_timer)
 		link->watchdog->pause_timer = false;
 
-	if (link->dual_trigger) {
-		if ((trigger_id >= 0) && (trigger_id <
-			CAM_REQ_MGR_MAX_TRIGGERS)) {
-			link->trigger_cnt[trigger_id]++;
-			rc = __cam_req_mgr_check_for_dual_trigger(link);
-			if (rc) {
-				spin_unlock_bh(&link->link_state_spin_lock);
-				goto end;
-			}
-		} else {
-			CAM_ERR(CAM_CRM, "trigger_id invalid %d", trigger_id);
-			rc = -EINVAL;
-			spin_unlock_bh(&link->link_state_spin_lock);
-			goto end;
-		}
-	}
-
 	crm_timer_reset(link->watchdog);
 	spin_unlock_bh(&link->link_state_spin_lock);
 
@@ -3083,18 +3032,16 @@ static int __cam_req_mgr_setup_link_info(struct cam_req_mgr_core_link *link,
 	struct cam_req_mgr_req_tbl             *pd_tbl;
 	enum cam_pipeline_delay                 max_delay;
 	uint32_t                                subscribe_event = 0;
-	uint32_t num_trigger_devices = 0;
 	if (link_info->version == VERSION_1) {
 		if (link_info->u.link_info_v1.num_devices >
 			CAM_REQ_MGR_MAX_HANDLES)
 			return -EPERM;
-	}
+		}
 	else if (link_info->version == VERSION_2) {
 		if (link_info->u.link_info_v2.num_devices >
 			CAM_REQ_MGR_MAX_HANDLES_V2)
 			return -EPERM;
-	}
-
+		}
 	mutex_init(&link->req.lock);
 	CAM_DBG(CAM_CRM, "LOCK_DBG in_q lock %pK", &link->req.lock);
 	link->req.num_tbl = 0;
@@ -3174,17 +3121,6 @@ static int __cam_req_mgr_setup_link_info(struct cam_req_mgr_core_link *link,
 
 			subscribe_event |= (uint32_t)dev->dev_info.trigger;
 		}
-
-		if (dev->dev_info.trigger_on)
-			num_trigger_devices++;
-	}
-
-	if (num_trigger_devices > CAM_REQ_MGR_MAX_TRIGGERS) {
-		CAM_ERR(CAM_CRM,
-			"Unsupported number of trigger devices %u",
-			num_trigger_devices);
-		rc = -EINVAL;
-		goto error;
 	}
 
 	link->subscribe_event = subscribe_event;
@@ -3193,10 +3129,7 @@ static int __cam_req_mgr_setup_link_info(struct cam_req_mgr_core_link *link,
 	link_data.crm_cb = &cam_req_mgr_ops;
 	link_data.max_delay = max_delay;
 	link_data.subscribe_event = subscribe_event;
-	if (num_trigger_devices == CAM_REQ_MGR_MAX_TRIGGERS)
-		link->dual_trigger = true;
 
-	num_trigger_devices = 0;
 	for (i = 0; i < num_devices; i++) {
 		dev = &link->l_dev[i];
 
@@ -3236,12 +3169,6 @@ static int __cam_req_mgr_setup_link_info(struct cam_req_mgr_core_link *link,
 		CAM_DBG(CAM_CRM, "dev_bit %u name %s pd %u mask %d",
 			dev->dev_bit, dev->dev_info.name, pd_tbl->pd,
 			pd_tbl->dev_mask);
-		link_data.trigger_id = -1;
-		if ((dev->dev_info.trigger_on) && (link->dual_trigger)) {
-			link_data.trigger_id = num_trigger_devices;
-			num_trigger_devices++;
-		}
-
 		/* Communicate with dev to establish the link */
 		dev->ops->link_setup(&link_data);
 
@@ -3332,19 +3259,16 @@ static int __cam_req_mgr_unlink(struct cam_req_mgr_core_link *link)
 	}
 
 	mutex_lock(&link->lock);
-
 	/* Destroy workq of link */
 	cam_req_mgr_workq_destroy(&link->workq);
-	spin_lock_bh(&link->link_state_spin_lock);
 	/* Destroy timer of link */
 	crm_timer_exit(&link->watchdog);
-	spin_unlock_bh(&link->link_state_spin_lock);
 
 	/* Cleanup request tables and unlink devices */
 	__cam_req_mgr_destroy_link_info(link);
-	/* Free memory holding data of linked devs */
 
-	__cam_req_mgr_destroy_subdev(&link->l_dev);
+	/* Free memory holding data of linked devs */
+	__cam_req_mgr_destroy_subdev(link->l_dev);
 
 	/* Destroy the link handle */
 	rc = cam_destroy_device_hdl(link->link_hdl);
@@ -3375,12 +3299,8 @@ int cam_req_mgr_destroy_session(
 	mutex_lock(&g_crm_core_dev->crm_lock);
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(ses_info->session_hdl);
-	if (!cam_session ||
-		(cam_session->session_hdl != ses_info->session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses:%s ses_info->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(cam_session), ses_info->session_hdl,
-			(!cam_session) ? CAM_REQ_MGR_DEFAULT_HDL_VAL :
-					 cam_session->session_hdl);
+	if (!cam_session) {
+		CAM_ERR(CAM_CRM, "failed to get session priv");
 		rc = -ENOENT;
 		goto end;
 
@@ -3416,11 +3336,6 @@ int cam_req_mgr_destroy_session(
 	return rc;
 }
 
-static void cam_req_mgr_process_workq_link_worker(struct work_struct *w)
-{
-	cam_req_mgr_process_workq(w);
-}
-
 int cam_req_mgr_link(struct cam_req_mgr_ver_info *link_info)
 {
 	int                                     rc = 0;
@@ -3445,13 +3360,8 @@ int cam_req_mgr_link(struct cam_req_mgr_ver_info *link_info)
 	/* session hdl's priv data is cam session struct */
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(link_info->u.link_info_v1.session_hdl);
-	if (!cam_session || (cam_session->session_hdl !=
-				link_info->u.link_info_v1.session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses:%s link_info->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(cam_session),
-			link_info->u.link_info_v1.session_hdl,
-			(!cam_session) ? CAM_REQ_MGR_DEFAULT_HDL_VAL :
-					 cam_session->session_hdl);
+	if (!cam_session) {
+		CAM_DBG(CAM_CRM, "NULL pointer");
 		mutex_unlock(&g_crm_core_dev->crm_lock);
 		return -EINVAL;
 	}
@@ -3504,8 +3414,7 @@ int cam_req_mgr_link(struct cam_req_mgr_ver_info *link_info)
 		link_info->u.link_info_v1.session_hdl, link->link_hdl);
 	wq_flag = CAM_WORKQ_FLAG_HIGH_PRIORITY | CAM_WORKQ_FLAG_SERIAL;
 	rc = cam_req_mgr_workq_create(buf, CRM_WORKQ_NUM_TASKS,
-		&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag, false,
-		cam_req_mgr_process_workq_link_worker);
+		&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag);
 	if (rc < 0) {
 		CAM_ERR(CAM_CRM, "FATAL: unable to create worker");
 		__cam_req_mgr_destroy_link_info(link);
@@ -3524,7 +3433,7 @@ int cam_req_mgr_link(struct cam_req_mgr_ver_info *link_info)
 	mutex_unlock(&g_crm_core_dev->crm_lock);
 	return rc;
 setup_failed:
-	__cam_req_mgr_destroy_subdev(&link->l_dev);
+	__cam_req_mgr_destroy_subdev(link->l_dev);
 create_subdev_failed:
 	cam_destroy_device_hdl(link->link_hdl);
 	link_info->u.link_info_v1.link_hdl = -1;
@@ -3560,13 +3469,8 @@ int cam_req_mgr_link_v2(struct cam_req_mgr_ver_info *link_info)
 	/* session hdl's priv data is cam session struct */
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(link_info->u.link_info_v2.session_hdl);
-	if (!cam_session || (cam_session->session_hdl !=
-				link_info->u.link_info_v2.session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses:%s link_info->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(cam_session),
-			link_info->u.link_info_v2.session_hdl,
-			(!cam_session) ? CAM_REQ_MGR_DEFAULT_HDL_VAL :
-					 cam_session->session_hdl);
+	if (!cam_session) {
+		CAM_DBG(CAM_CRM, "NULL pointer");
 		mutex_unlock(&g_crm_core_dev->crm_lock);
 		return -EINVAL;
 	}
@@ -3619,8 +3523,7 @@ int cam_req_mgr_link_v2(struct cam_req_mgr_ver_info *link_info)
 		link_info->u.link_info_v2.session_hdl, link->link_hdl);
 	wq_flag = CAM_WORKQ_FLAG_HIGH_PRIORITY | CAM_WORKQ_FLAG_SERIAL;
 	rc = cam_req_mgr_workq_create(buf, CRM_WORKQ_NUM_TASKS,
-		&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag, false,
-		cam_req_mgr_process_workq_link_worker);
+		&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag);
 	if (rc < 0) {
 		CAM_ERR(CAM_CRM, "FATAL: unable to create worker");
 		__cam_req_mgr_destroy_link_info(link);
@@ -3639,7 +3542,7 @@ int cam_req_mgr_link_v2(struct cam_req_mgr_ver_info *link_info)
 	mutex_unlock(&g_crm_core_dev->crm_lock);
 	return rc;
 setup_failed:
-	__cam_req_mgr_destroy_subdev(&link->l_dev);
+	__cam_req_mgr_destroy_subdev(link->l_dev);
 create_subdev_failed:
 	cam_destroy_device_hdl(link->link_hdl);
 	link_info->u.link_info_v2.link_hdl = -1;
@@ -3668,23 +3571,16 @@ int cam_req_mgr_unlink(struct cam_req_mgr_unlink_info *unlink_info)
 	/* session hdl's priv data is cam session struct */
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(unlink_info->session_hdl);
-	if (!cam_session ||
-		(cam_session->session_hdl != unlink_info->session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses:%s unlink->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(cam_session),
-			unlink_info->session_hdl,
-			(!cam_session) ? CAM_REQ_MGR_DEFAULT_HDL_VAL :
-					 cam_session->session_hdl);
+	if (!cam_session) {
+		CAM_ERR(CAM_CRM, "NULL pointer");
 		mutex_unlock(&g_crm_core_dev->crm_lock);
 		return -EINVAL;
 	}
 
 	/* link hdl's priv data is core_link struct */
 	link = cam_get_device_priv(unlink_info->link_hdl);
-	if (!link || (link->link_hdl != unlink_info->link_hdl)) {
-		CAM_ERR(CAM_CRM, "link:%s unlink->lnk_hdl:%x link->lnk_hdl:%x",
-			CAM_IS_NULL_TO_STR(link), unlink_info->link_hdl,
-			(!link) ? CAM_REQ_MGR_DEFAULT_HDL_VAL : link->link_hdl);
+	if (!link) {
+		CAM_ERR(CAM_CRM, "NULL pointer");
 		rc = -EINVAL;
 		goto done;
 	}
@@ -3716,10 +3612,8 @@ int cam_req_mgr_schedule_request(
 	mutex_lock(&g_crm_core_dev->crm_lock);
 	link = (struct cam_req_mgr_core_link *)
 		cam_get_device_priv(sched_req->link_hdl);
-	if (!link || (link->link_hdl != sched_req->link_hdl)) {
-		CAM_ERR(CAM_CRM, "lnk:%s schd_req->lnk_hdl:%x lnk->lnk_hdl:%x",
-			CAM_IS_NULL_TO_STR(link), sched_req->link_hdl,
-			(!link) ? CAM_REQ_MGR_DEFAULT_HDL_VAL : link->link_hdl);
+	if (!link) {
+		CAM_DBG(CAM_CRM, "link ptr NULL %x", sched_req->link_hdl);
 		rc = -EINVAL;
 		goto end;
 	}
@@ -3830,12 +3724,8 @@ int cam_req_mgr_sync_config(
 	/* session hdl's priv data is cam session struct */
 	cam_session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(sync_info->session_hdl);
-	if (!cam_session ||
-		(cam_session->session_hdl != sync_info->session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses:%s sync_info->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(cam_session), sync_info->session_hdl,
-			(!cam_session) ?
-			CAM_REQ_MGR_DEFAULT_HDL_VAL : cam_session->session_hdl);
+	if (!cam_session) {
+		CAM_ERR(CAM_CRM, "NULL pointer");
 		mutex_unlock(&g_crm_core_dev->crm_lock);
 		return -EINVAL;
 	}
@@ -3847,21 +3737,15 @@ int cam_req_mgr_sync_config(
 
 	/* only two links existing per session in dual cam use case*/
 	link1 = cam_get_device_priv(sync_info->link_hdls[0]);
-	if (!link1 || (link1->link_hdl != sync_info->link_hdls[0])) {
-		CAM_ERR(CAM_CRM, "lnk:%s sync_info->lnk_hdl[0]:%x lnk1_hdl:%x",
-			CAM_IS_NULL_TO_STR(link1), sync_info->link_hdls[0],
-			(!link1) ?
-			CAM_REQ_MGR_DEFAULT_HDL_VAL : link1->link_hdl);
+	if (!link1) {
+		CAM_ERR(CAM_CRM, "link1 NULL pointer");
 		rc = -EINVAL;
 		goto done;
 	}
 
 	link2 = cam_get_device_priv(sync_info->link_hdls[1]);
-	if (!link2 || (link2->link_hdl != sync_info->link_hdls[1])) {
-		CAM_ERR(CAM_CRM, "lnk:%s sync_info->lnk_hdl[1]:%x lnk2_hdl:%x",
-			CAM_IS_NULL_TO_STR(link2), sync_info->link_hdls[1],
-			(!link2) ?
-			CAM_REQ_MGR_DEFAULT_HDL_VAL : link2->link_hdl);
+	if (!link2) {
+		CAM_ERR(CAM_CRM, "link2 NULL pointer");
 		rc = -EINVAL;
 		goto done;
 	}
@@ -3931,11 +3815,8 @@ int cam_req_mgr_flush_requests(
 	/* session hdl's priv data is cam session struct */
 	session = (struct cam_req_mgr_core_session *)
 		cam_get_device_priv(flush_info->session_hdl);
-	if (!session || (session->session_hdl != flush_info->session_hdl)) {
-		CAM_ERR(CAM_CRM, "ses: %s flush->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(session), flush_info->session_hdl,
-			(!session) ?
-			CAM_REQ_MGR_DEFAULT_HDL_VAL : session->session_hdl);
+	if (!session) {
+		CAM_ERR(CAM_CRM, "Invalid session %x", flush_info->session_hdl);
 		rc = -EINVAL;
 		goto end;
 	}
@@ -3947,10 +3828,8 @@ int cam_req_mgr_flush_requests(
 
 	link = (struct cam_req_mgr_core_link *)
 		cam_get_device_priv(flush_info->link_hdl);
-	if (!link || (link->link_hdl != flush_info->link_hdl)) {
-		CAM_ERR(CAM_CRM, "link:%s flush->link_hdl:%x link->link_hdl:%x",
-			CAM_IS_NULL_TO_STR(link), flush_info->link_hdl,
-			(!link) ? CAM_REQ_MGR_DEFAULT_HDL_VAL : link->link_hdl);
+	if (!link) {
+		CAM_DBG(CAM_CRM, "link ptr NULL %x", flush_info->link_hdl);
 		rc = -EINVAL;
 		goto end;
 	}
@@ -3988,7 +3867,6 @@ int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control)
 
 	struct cam_req_mgr_connected_device *dev = NULL;
 	struct cam_req_mgr_link_evt_data     evt_data;
-	int                                init_timeout = 0;
 
 	if (!control) {
 		CAM_ERR(CAM_CRM, "Control command is NULL");
@@ -4008,28 +3886,19 @@ int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control)
 	for (i = 0; i < control->num_links; i++) {
 		link = (struct cam_req_mgr_core_link *)
 			cam_get_device_priv(control->link_hdls[i]);
-		if (!link || (link->link_hdl != control->link_hdls[i])) {
-			CAM_ERR(CAM_CRM,
-				"link:%s control->lnk_hdl:%x link->lnk_hdl:%x",
-				CAM_IS_NULL_TO_STR(link), control->link_hdls[i],
-				(!link) ?
-				CAM_REQ_MGR_DEFAULT_HDL_VAL : link->link_hdl);
+		if (!link) {
+			CAM_ERR(CAM_CRM, "Link(%d) is NULL on session 0x%x",
+				i, control->session_hdl);
 			rc = -EINVAL;
 			break;
 		}
 
 		mutex_lock(&link->lock);
 		if (control->ops == CAM_REQ_MGR_LINK_ACTIVATE) {
-			spin_lock_bh(&link->link_state_spin_lock);
-			link->state = CAM_CRM_LINK_STATE_READY;
-			spin_unlock_bh(&link->link_state_spin_lock);
-			if (control->init_timeout[i])
-				link->skip_wd_validation = true;
-			init_timeout = (2 * control->init_timeout[i]);
 			/* Start SOF watchdog timer */
 			rc = crm_timer_init(&link->watchdog,
-				(init_timeout + CAM_REQ_MGR_WATCHDOG_TIMEOUT),
-				link, &__cam_req_mgr_sof_freeze);
+				CAM_REQ_MGR_WATCHDOG_TIMEOUT, link,
+				&__cam_req_mgr_sof_freeze);
 			if (rc < 0) {
 				CAM_ERR(CAM_CRM,
 					"SOF timer start fails: link=0x%x",
@@ -4047,6 +3916,10 @@ int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control)
 					dev->ops->process_evt(&evt_data);
 			}
 		} else if (control->ops == CAM_REQ_MGR_LINK_DEACTIVATE) {
+			/* Destroy SOF watchdog timer */
+			spin_lock_bh(&link->link_state_spin_lock);
+			crm_timer_exit(&link->watchdog);
+			spin_unlock_bh(&link->link_state_spin_lock);
 			/* notify nodes */
 			for (j = 0; j < link->num_devs; j++) {
 				dev = &link->l_dev[j];
@@ -4057,12 +3930,6 @@ int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control)
 				if (dev->ops && dev->ops->process_evt)
 					dev->ops->process_evt(&evt_data);
 			}
-			/* Destroy SOF watchdog timer */
-			spin_lock_bh(&link->link_state_spin_lock);
-			link->state = CAM_CRM_LINK_STATE_IDLE;
-			link->skip_wd_validation = false;
-			crm_timer_exit(&link->watchdog);
-			spin_unlock_bh(&link->link_state_spin_lock);
 		} else {
 			CAM_ERR(CAM_CRM, "Invalid link control command");
 			rc = -EINVAL;
@@ -4074,70 +3941,6 @@ int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control)
 	return rc;
 }
 
-int cam_req_mgr_dump_request(struct cam_dump_req_cmd *dump_req)
-{
-	int                                  rc = 0;
-	int                                  i;
-	struct cam_req_mgr_dump_info         info;
-	struct cam_req_mgr_core_link        *link = NULL;
-	struct cam_req_mgr_core_session     *session = NULL;
-	struct cam_req_mgr_connected_device *device = NULL;
-
-	if (!dump_req) {
-		CAM_ERR(CAM_CRM, "dump req is NULL");
-		return -EFAULT;
-	}
-
-	mutex_lock(&g_crm_core_dev->crm_lock);
-	/* session hdl's priv data is cam session struct */
-	session = (struct cam_req_mgr_core_session *)
-	    cam_get_device_priv(dump_req->session_handle);
-	if (!session || (session->session_hdl != dump_req->session_handle)) {
-		CAM_ERR(CAM_CRM, "ses:%s dump_req->ses_hdl:%x ses->ses_hdl:%x",
-			CAM_IS_NULL_TO_STR(session), dump_req->session_handle,
-			(!session) ?
-			CAM_REQ_MGR_DEFAULT_HDL_VAL : session->session_hdl);
-		rc = -EINVAL;
-		goto end;
-	}
-	if (session->num_links <= 0) {
-		CAM_WARN(CAM_CRM, "No active links in session %x",
-			dump_req->session_handle);
-		goto end;
-	}
-
-	link = (struct cam_req_mgr_core_link *)
-		cam_get_device_priv(dump_req->link_hdl);
-	if (!link || (link->link_hdl != dump_req->link_hdl)) {
-		CAM_ERR(CAM_CRM, "link:%s dump->link_hdl:%x link->link_hdl:%x",
-			CAM_IS_NULL_TO_STR(link), dump_req->link_hdl,
-			(!link) ? CAM_REQ_MGR_DEFAULT_HDL_VAL : link->link_hdl);
-		rc = -EINVAL;
-		goto end;
-	}
-	info.offset = dump_req->offset;
-	for (i = 0; i < link->num_devs; i++) {
-		device = &link->l_dev[i];
-		info.link_hdl = dump_req->link_hdl;
-		info.dev_hdl = device->dev_hdl;
-		info.req_id = dump_req->issue_req_id;
-		info.buf_handle = dump_req->buf_handle;
-		info.error_type = dump_req->error_type;
-		if (device->ops && device->ops->dump_req) {
-			rc = device->ops->dump_req(&info);
-			if (rc)
-				CAM_ERR(CAM_REQ,
-					"Fail dump req %llu dev %d rc %d",
-					info.req_id, device->dev_hdl, rc);
-		}
-	}
-	dump_req->offset = info.offset;
-	CAM_INFO(CAM_REQ, "req %llu, offset %zu",
-		dump_req->issue_req_id, dump_req->offset);
-end:
-	mutex_unlock(&g_crm_core_dev->crm_lock);
-	return 0;
-}
 
 int cam_req_mgr_core_device_init(void)
 {
@@ -4162,6 +3965,7 @@ int cam_req_mgr_core_device_init(void)
 		mutex_init(&g_links[i].lock);
 		spin_lock_init(&g_links[i].link_state_spin_lock);
 		atomic_set(&g_links[i].is_used, 0);
+		CAM_DBG(CAM_CRM, "cam_req_mgr_core_device_init: %p",&g_links[i]);
 		cam_req_mgr_core_link_reset(&g_links[i]);
 	}
 	return 0;
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.h b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.h
index 1be2f4cd1a38..9c0a093dd865 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_core.h
@@ -1,7 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 #ifndef _CAM_REQ_MGR_CORE_H_
 #define _CAM_REQ_MGR_CORE_H_
@@ -14,11 +13,10 @@
 #define CAM_REQ_MGR_MAX_LINKED_DEV     16
 #define MAX_REQ_SLOTS                  48
 
-#define CAM_REQ_MGR_WATCHDOG_TIMEOUT       5000
+#define CAM_REQ_MGR_WATCHDOG_TIMEOUT       3000
 #define CAM_REQ_MGR_WATCHDOG_TIMEOUT_MAX   50000
 #define CAM_REQ_MGR_SCHED_REQ_TIMEOUT      1000
 #define CAM_REQ_MGR_SIMULATE_SCHED_REQ     30
-#define CAM_REQ_MGR_DEFAULT_HDL_VAL        0
 
 #define FORCE_DISABLE_RECOVERY  2
 #define FORCE_ENABLE_RECOVERY   1
@@ -33,15 +31,15 @@
 
 #define SYNC_LINK_SOF_CNT_MAX_LMT 1
 
-#define MAXIMUM_LINKS_PER_SESSION  7
+#define MAXIMUM_LINKS_PER_SESSION  4
 
-#define MAXIMUM_RETRY_ATTEMPTS 2
+#define MAXIMUM_RETRY_ATTEMPTS 3
 
 #define MINIMUM_WORKQUEUE_SCHED_TIME_IN_MS 5
 
+
 #define VERSION_1  1
 #define VERSION_2  2
-#define CAM_REQ_MGR_MAX_TRIGGERS   2
 
 /**
  * enum crm_workq_task_type
@@ -350,11 +348,6 @@ struct cam_req_mgr_connected_device {
  *                         as part of shutdown.
  * @sof_timestamp_value  : SOF timestamp value
  * @prev_sof_timestamp   : Previous SOF timestamp value
- * @dual_trigger         : Links needs to wait for two triggers prior to
- *                         applying the settings
- * @trigger_cnt          : trigger count value per device initiating the trigger
- * @skip_wd_validation   : skip initial frames crm_wd_timer validation in the
- *                         case of long exposure use case
  * @last_applied_jiffies : Record the jiffies of last applied req
  */
 struct cam_req_mgr_core_link {
@@ -386,9 +379,6 @@ struct cam_req_mgr_core_link {
 	bool                                 is_shutdown;
 	uint64_t                             sof_timestamp;
 	uint64_t                             prev_sof_timestamp;
-	bool                                 dual_trigger;
-	uint32_t    trigger_cnt[CAM_REQ_MGR_MAX_TRIGGERS];
-	bool                                 skip_wd_validation;
 	uint64_t                             last_applied_jiffies;
 };
 
@@ -423,12 +413,10 @@ struct cam_req_mgr_core_session {
  * - Core camera request manager data struct
  * @session_head : list head holding sessions
  * @crm_lock     : mutex lock to protect session creation & destruction
- * @recovery_on_apply_fail : Recovery on apply failure using debugfs.
  */
 struct cam_req_mgr_core_device {
 	struct list_head             session_head;
 	struct mutex                 crm_lock;
-	bool                         recovery_on_apply_fail;
 };
 
 /**
@@ -522,10 +510,4 @@ void cam_req_mgr_handle_core_shutdown(void);
  */
 int cam_req_mgr_link_control(struct cam_req_mgr_link_control *control);
 
-/**
- * cam_req_mgr_dump_request()
- * @brief:   Dumps the request information
- * @dump_req: Dump request
- */
-int cam_req_mgr_dump_request(struct cam_dump_req_cmd *dump_req);
 #endif
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_debug.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_debug.c
index db6bec704370..6b428c41c1b0 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_debug.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_debug.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_req_mgr_debug.h"
@@ -128,12 +128,5 @@ int cam_req_mgr_debug_register(struct cam_req_mgr_core_device *core_dev)
 		debugfs_root, core_dev, &bubble_recovery))
 		return -ENOMEM;
 
-	if (!debugfs_create_bool("recovery_on_apply_fail",
-		0644,
-		debugfs_root,
-		&core_dev->recovery_on_apply_fail)) {
-		return -ENOMEM;
-	}
-
 	return 0;
 }
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.c
index f3b3b19a8c4c..e5fb7be0ff61 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.c
@@ -1,25 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>
-#include <linux/highmem.h>
-#include <linux/types.h>
-#include <linux/rwsem.h>
-
-#include <mm/slab.h>
-
 #include <media/v4l2-fh.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-event.h>
 #include <media/v4l2-ioctl.h>
 #include <media/cam_req_mgr.h>
 #include <media/cam_defs.h>
-
 #include "cam_req_mgr_dev.h"
 #include "cam_req_mgr_util.h"
 #include "cam_req_mgr_core.h"
@@ -27,14 +19,13 @@
 #include "cam_mem_mgr.h"
 #include "cam_debug_util.h"
 #include "cam_common_util.h"
+#include <linux/slub_def.h>
 
-#define CAM_REQ_MGR_EVENT_MAX 100
+#define CAM_REQ_MGR_EVENT_MAX 120
 
 static struct cam_req_mgr_device g_dev;
 struct kmem_cache *g_cam_req_mgr_timer_cachep;
 
-DECLARE_RWSEM(rwsem_lock);
-
 static int cam_media_device_setup(struct device *dev)
 {
 	int rc;
@@ -100,28 +91,10 @@ static void cam_v4l2_device_cleanup(void)
 	g_dev.v4l2_dev = NULL;
 }
 
-void cam_req_mgr_rwsem_read_op(enum cam_subdev_rwsem lock)
-{
-	if (lock == CAM_SUBDEV_LOCK)
-		down_read(&rwsem_lock);
-	else if (lock == CAM_SUBDEV_UNLOCK)
-		up_read(&rwsem_lock);
-}
-
-static void cam_req_mgr_rwsem_write_op(enum cam_subdev_rwsem lock)
-{
-	if (lock == CAM_SUBDEV_LOCK)
-		down_write(&rwsem_lock);
-	else if (lock == CAM_SUBDEV_UNLOCK)
-		up_write(&rwsem_lock);
-}
-
 static int cam_req_mgr_open(struct file *filep)
 {
 	int rc;
 
-	cam_req_mgr_rwsem_write_op(CAM_SUBDEV_LOCK);
-
 	mutex_lock(&g_dev.cam_lock);
 	if (g_dev.open_cnt >= 1) {
 		rc = -EALREADY;
@@ -139,7 +112,6 @@ static int cam_req_mgr_open(struct file *filep)
 	spin_unlock_bh(&g_dev.cam_eventq_lock);
 
 	g_dev.open_cnt++;
-	CAM_DBG(CAM_CRM, " CRM open cnt %d", g_dev.open_cnt);
 	rc = cam_mem_mgr_init();
 	if (rc) {
 		g_dev.open_cnt--;
@@ -148,14 +120,12 @@ static int cam_req_mgr_open(struct file *filep)
 	}
 
 	mutex_unlock(&g_dev.cam_lock);
-	cam_req_mgr_rwsem_write_op(CAM_SUBDEV_UNLOCK);
 	return rc;
 
 mem_mgr_init_fail:
 	v4l2_fh_release(filep);
 end:
 	mutex_unlock(&g_dev.cam_lock);
-	cam_req_mgr_rwsem_write_op(CAM_SUBDEV_UNLOCK);
 	return rc;
 }
 
@@ -182,26 +152,14 @@ static int cam_req_mgr_close(struct file *filep)
 	struct v4l2_subdev_fh *subdev_fh = to_v4l2_subdev_fh(vfh);
 
 	CAM_WARN(CAM_CRM,
-		"release invoked associated userspace process has died, open_cnt: %d",
-		g_dev.open_cnt);
-
-	cam_req_mgr_rwsem_write_op(CAM_SUBDEV_LOCK);
-
+		"release invoked associated userspace process has died");
 	mutex_lock(&g_dev.cam_lock);
+
 	if (g_dev.open_cnt <= 0) {
 		mutex_unlock(&g_dev.cam_lock);
-		cam_req_mgr_rwsem_write_op(CAM_SUBDEV_UNLOCK);
 		return -EINVAL;
 	}
 
-	g_dev.open_cnt--;
-	CAM_DBG(CAM_CRM, "CRM open_cnt %d", g_dev.open_cnt);
-
-	if (g_dev.open_cnt > 0) {
-		mutex_unlock(&g_dev.cam_lock);
-		return 0;
-	}
-
 	cam_req_mgr_handle_core_shutdown();
 
 	list_for_each_entry(sd, &g_dev.v4l2_dev->subdevs, list) {
@@ -214,6 +172,7 @@ static int cam_req_mgr_close(struct file *filep)
 		}
 	}
 
+	g_dev.open_cnt--;
 	v4l2_fh_release(filep);
 
 	spin_lock_bh(&g_dev.cam_eventq_lock);
@@ -224,8 +183,6 @@ static int cam_req_mgr_close(struct file *filep)
 	cam_mem_mgr_deinit();
 	mutex_unlock(&g_dev.cam_lock);
 
-	cam_req_mgr_rwsem_write_op(CAM_SUBDEV_UNLOCK);
-
 	return 0;
 }
 
@@ -562,30 +519,6 @@ static long cam_private_ioctl(struct file *file, void *fh,
 			rc = -EINVAL;
 		}
 		break;
-	case CAM_REQ_MGR_REQUEST_DUMP: {
-		struct cam_dump_req_cmd cmd;
-
-		if (k_ioctl->size != sizeof(cmd))
-			return -EINVAL;
-
-		if (copy_from_user(&cmd,
-			u64_to_user_ptr(k_ioctl->handle),
-			sizeof(struct cam_dump_req_cmd))) {
-			rc = -EFAULT;
-			break;
-		}
-		rc = cam_req_mgr_dump_request(&cmd);
-		if (rc) {
-			CAM_ERR(CAM_CORE, "dump fail for dev %d req %llu rc %d",
-				cmd.dev_handle, cmd.issue_req_id, rc);
-			break;
-		}
-		if (copy_to_user(
-			u64_to_user_ptr(k_ioctl->handle),
-			&cmd, sizeof(struct cam_dump_req_cmd)))
-			rc = -EFAULT;
-		}
-		break;
 	default:
 		return -ENOIOCTLCMD;
 	}
@@ -674,41 +607,6 @@ void cam_register_subdev_fops(struct v4l2_file_operations *fops)
 }
 EXPORT_SYMBOL(cam_register_subdev_fops);
 
-void cam_subdev_notify_message(u32 subdev_type,
-	enum cam_subdev_message_type_t message_type,
-	uint32_t data)
-{
-	struct v4l2_subdev *sd = NULL;
-	struct cam_subdev *csd = NULL;
-
-	list_for_each_entry(sd, &g_dev.v4l2_dev->subdevs, list) {
-		if (sd->entity.function == subdev_type) {
-			csd = container_of(sd, struct cam_subdev, sd);
-			if (csd->msg_cb != NULL)
-				csd->msg_cb(sd, message_type, data);
-		}
-	}
-}
-EXPORT_SYMBOL(cam_subdev_notify_message);
-
-bool cam_req_mgr_is_open(void)
-{
-	bool crm_status = false;
-
-	mutex_lock(&g_dev.cam_lock);
-	crm_status = g_dev.open_cnt ? true : false;
-	mutex_unlock(&g_dev.cam_lock);
-
-	return crm_status;
-}
-EXPORT_SYMBOL(cam_req_mgr_is_open);
-
-bool cam_req_mgr_is_shutdown(void)
-{
-	return g_dev.shutdown_state;
-}
-EXPORT_SYMBOL(cam_req_mgr_is_shutdown);
-
 int cam_register_subdev(struct cam_subdev *csd)
 {
 	struct v4l2_subdev *sd;
@@ -737,7 +635,7 @@ int cam_register_subdev(struct cam_subdev *csd)
 	sd = &csd->sd;
 	v4l2_subdev_init(sd, csd->ops);
 	sd->internal_ops = csd->internal_ops;
-	snprintf(sd->name, V4L2_SUBDEV_NAME_SIZE, "%s", csd->name);
+	snprintf(sd->name, ARRAY_SIZE(sd->name), csd->name);
 	v4l2_set_subdevdata(sd, csd->token);
 
 	sd->flags = csd->sd_flags;
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.h b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.h
index ccf4854a03d2..48ad09ce5ee2 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_dev.h
@@ -19,7 +19,6 @@
  * @cam_lock: per file handle lock
  * @cam_eventq: event queue
  * @cam_eventq_lock: lock for event queue
- * @shutdown_state: shutdown state
  */
 struct cam_req_mgr_device {
 	struct video_device *video;
@@ -32,7 +31,6 @@ struct cam_req_mgr_device {
 	struct mutex cam_lock;
 	struct v4l2_fh  *cam_eventq;
 	spinlock_t cam_eventq_lock;
-	bool shutdown_state;
 };
 
 #define CAM_REQ_MGR_GET_PAYLOAD_PTR(ev, type)        \
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_interface.h b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_interface.h
index 899d8ed70cb0..4963d647feda 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_interface.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_interface.h
@@ -21,7 +21,6 @@ struct cam_req_mgr_core_dev_link_setup;
 struct cam_req_mgr_apply_request;
 struct cam_req_mgr_flush_request;
 struct cam_req_mgr_link_evt_data;
-struct cam_req_mgr_dump_info;
 
 #define SKIP_NEXT_FRAME 0x100
 
@@ -50,7 +49,6 @@ typedef int (*cam_req_mgr_notify_stop)(struct cam_req_mgr_notify_stop *);
  * @cam_req_mgr_apply_req   : CRM asks device to apply certain request id.
  * @cam_req_mgr_flush_req   : Flush or cancel request
  * cam_req_mgr_process_evt  : generic events
- * @cam_req_mgr_dump_req    : dump request
  */
 typedef int (*cam_req_mgr_get_dev_info) (struct cam_req_mgr_device_info *);
 typedef int (*cam_req_mgr_link_setup)(
@@ -58,7 +56,6 @@ typedef int (*cam_req_mgr_link_setup)(
 typedef int (*cam_req_mgr_apply_req)(struct cam_req_mgr_apply_request *);
 typedef int (*cam_req_mgr_flush_req)(struct cam_req_mgr_flush_request *);
 typedef int (*cam_req_mgr_process_evt)(struct cam_req_mgr_link_evt_data *);
-typedef int (*cam_req_mgr_dump_req)(struct cam_req_mgr_dump_info *);
 
 /**
  * @brief          : cam_req_mgr_crm_cb - func table
@@ -84,7 +81,6 @@ struct cam_req_mgr_crm_cb {
  * @apply_req    : payload to apply request id on a device linked
  * @flush_req    : payload to flush request
  * @process_evt  : payload to generic event
- * @dump_req     : payload to dump request
  */
 struct cam_req_mgr_kmd_ops {
 	cam_req_mgr_get_dev_info     get_dev_info;
@@ -92,7 +88,6 @@ struct cam_req_mgr_kmd_ops {
 	cam_req_mgr_apply_req        apply_req;
 	cam_req_mgr_flush_req        flush_req;
 	cam_req_mgr_process_evt      process_evt;
-	cam_req_mgr_dump_req         dump_req;
 };
 
 /**
@@ -204,14 +199,13 @@ enum cam_req_mgr_link_evt_type {
 
 /**
  * struct cam_req_mgr_trigger_notify
- * @link_hdl  : link identifier
- * @dev_hdl   : device handle which has sent this req id
- * @frame_id  : frame id for internal tracking
- * @trigger   : trigger point of this notification, CRM will send apply
+ * @link_hdl : link identifier
+ * @dev_hdl  : device handle which has sent this req id
+ * @frame_id : frame id for internal tracking
+ * @trigger  : trigger point of this notification, CRM will send apply
  * only to the devices which subscribe to this point.
  * @sof_timestamp_val: Captured time stamp value at sof hw event
- * @req_id    : req id which returned buf_done
- * @trigger_id: ID to differentiate between the trigger devices
+ * @req_id   : req id which returned buf_done
  */
 struct cam_req_mgr_trigger_notify {
 	int32_t  link_hdl;
@@ -220,7 +214,6 @@ struct cam_req_mgr_trigger_notify {
 	uint32_t trigger;
 	uint64_t sof_timestamp_val;
 	uint64_t req_id;
-	int32_t  trigger_id;
 };
 
 /**
@@ -241,18 +234,13 @@ struct cam_req_mgr_timer_notify {
  * @link_hdl : link identifier
  * @dev_hdl  : device handle which has sent this req id
  * @req_id   : req id which hit error
- * @frame_id : frame id for internal tracking
- * @trigger  : trigger point of this notification, CRM will send apply
- * @sof_timestamp_val : Captured time stamp value at sof hw event
  * @error    : what error device hit while processing this req
  */
 struct cam_req_mgr_error_notify {
 	int32_t  link_hdl;
 	int32_t  dev_hdl;
 	uint64_t req_id;
-	int64_t  frame_id;
 	uint32_t trigger;
-	uint64_t sof_timestamp_val;
 	enum cam_req_mgr_device_error error;
 };
 
@@ -286,12 +274,12 @@ struct cam_req_mgr_notify_stop {
 /* CRM to KMD devices */
 /**
  * struct cam_req_mgr_device_info
- * @dev_hdl    : Input_param : device handle for reference
- * @name       : link link or unlink
- * @dev_id     : device id info
- * @p_delay    : delay between time settings applied and take effect
- * @trigger    : Trigger point for the client
- * @trigger_on : This device provides trigger
+ * @dev_hdl : Input_param : device handle for reference
+ * @name    : link link or unlink
+ * @dev_id  : device id info
+ * @p_delay : delay between time settings applied and take effect
+ * @trigger : Trigger point for the client
+ *
  */
 struct cam_req_mgr_device_info {
 	int32_t                     dev_hdl;
@@ -299,7 +287,6 @@ struct cam_req_mgr_device_info {
 	enum cam_req_mgr_device_id  dev_id;
 	enum cam_pipeline_delay     p_delay;
 	uint32_t                    trigger;
-	bool                        trigger_on;
 };
 
 /**
@@ -310,7 +297,7 @@ struct cam_req_mgr_device_info {
  * @max_delay       : max pipeline delay on this link
  * @crm_cb          : callback funcs to communicate with req mgr
  * @subscribe_event : the mask of trigger points this link subscribes
- * @trigger_id      : Unique ID provided to the triggering device
+ *
  */
 struct cam_req_mgr_core_dev_link_setup {
 	int32_t                    link_enable;
@@ -319,7 +306,6 @@ struct cam_req_mgr_core_dev_link_setup {
 	enum cam_pipeline_delay    max_delay;
 	struct cam_req_mgr_crm_cb *crm_cb;
 	uint32_t                   subscribe_event;
-	int32_t                    trigger_id;
 };
 
 /**
@@ -329,7 +315,6 @@ struct cam_req_mgr_core_dev_link_setup {
  * @request_id       : request id settings to apply
  * @report_if_bubble : report to crm if failure in applying
  * @trigger_point    : the trigger point of this apply
- * @re_apply         : to skip re_apply for buf_done request
  *
  */
 struct cam_req_mgr_apply_request {
@@ -338,7 +323,6 @@ struct cam_req_mgr_apply_request {
 	uint64_t   request_id;
 	int32_t    report_if_bubble;
 	uint32_t   trigger_point;
-	bool       re_apply;
 };
 
 /**
@@ -383,23 +367,4 @@ struct cam_req_mgr_send_request {
 	int32_t    link_hdl;
 	struct cam_req_mgr_req_queue *in_q;
 };
-
-/**
- * struct cam_req_mgr_dump_info
- * @req_id      : request id to dump
- * @offset      : offset of buffer
- * @error_type  : error type
- * @buf_handle  : buf handle
- * @link_hdl    : link identifier
- * @dev_hdl     : device handle for cross check
- *
- */
-struct cam_req_mgr_dump_info {
-	uint64_t    req_id;
-	size_t      offset;
-	uint32_t    error_type;
-	uint32_t    buf_handle;
-	int32_t     link_hdl;
-	int32_t     dev_hdl;
-};
 #endif
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.c
index eb2a6d599b0f..ba44534fa48d 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.c
@@ -1,13 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_req_mgr_timer.h"
 #include "cam_debug_util.h"
 
-extern struct kmem_cache *g_cam_req_mgr_timer_cachep;
-
 void crm_timer_reset(struct cam_req_mgr_timer *crm_timer)
 {
 	if (!crm_timer)
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.h b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.h
index d2e20498df9a..be200f1b2693 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_timer.h
@@ -62,4 +62,5 @@ int crm_timer_init(struct cam_req_mgr_timer **timer,
  */
 void crm_timer_exit(struct cam_req_mgr_timer **timer);
 
+extern struct kmem_cache *g_cam_req_mgr_timer_cachep;
 #endif
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_util.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_util.c
index 77bec80006be..5ffb737ef88d 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_util.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_util.c
@@ -14,11 +14,11 @@
 #include <media/cam_req_mgr.h>
 #include "cam_req_mgr_util.h"
 #include "cam_debug_util.h"
-#include "cam_subdev.h"
 
 static struct cam_req_mgr_util_hdl_tbl *hdl_tbl;
 static DEFINE_SPINLOCK(hdl_tbl_lock);
 
+static hdl_count = 0;
 int cam_req_mgr_util_init(void)
 {
 	int rc = 0;
@@ -53,7 +53,7 @@ int cam_req_mgr_util_init(void)
 		goto bitmap_alloc_fail;
 	}
 	hdl_tbl->bits = bitmap_size * BITS_PER_BYTE;
-
+        hdl_count = 0;
 	return rc;
 
 bitmap_alloc_fail:
@@ -77,6 +77,7 @@ int cam_req_mgr_util_deinit(void)
 	hdl_tbl->bitmap = NULL;
 	kfree(hdl_tbl);
 	hdl_tbl = NULL;
+	hdl_count = 0;
 	spin_unlock_bh(&hdl_tbl_lock);
 
 	return 0;
@@ -103,6 +104,7 @@ int cam_req_mgr_util_free_hdls(void)
 		}
 	}
 	bitmap_zero(hdl_tbl->bitmap, CAM_REQ_MGR_MAX_HANDLES_V2);
+	hdl_count = 0;
 	spin_unlock_bh(&hdl_tbl_lock);
 
 	return 0;
@@ -114,11 +116,13 @@ static int32_t cam_get_free_handle_index(void)
 
 	idx = find_first_zero_bit(hdl_tbl->bitmap, hdl_tbl->bits);
 
-	if (idx >= CAM_REQ_MGR_MAX_HANDLES_V2 || idx < 0)
+	if (idx >= CAM_REQ_MGR_MAX_HANDLES_V2 || idx < 0) {
+		CAM_ERR(CAM_CRM, "wuchi Hdl tbl count is %d", hdl_count);
 		return -ENOSR;
+	}
 
 	set_bit(idx, hdl_tbl->bitmap);
-
+	hdl_count++;
 	return idx;
 }
 
@@ -160,14 +164,6 @@ int32_t cam_create_device_hdl(struct cam_create_dev_hdl *hdl_data)
 	int idx;
 	int rand = 0;
 	int32_t handle;
-	bool crm_active;
-
-	crm_active = cam_req_mgr_is_open();
-	if (!crm_active) {
-		CAM_ERR(CAM_ICP, "CRM is not ACTIVE");
-		spin_unlock_bh(&hdl_tbl_lock);
-		return -EINVAL;
-	}
 
 	spin_lock_bh(&hdl_tbl_lock);
 	if (!hdl_tbl) {
@@ -322,6 +318,7 @@ static int cam_destroy_hdl(int32_t dev_hdl, int dev_hdl_type)
 	hdl_tbl->hdl[idx].ops   = NULL;
 	hdl_tbl->hdl[idx].priv  = NULL;
 	clear_bit(idx, hdl_tbl->bitmap);
+	hdl_count--;
 	spin_unlock_bh(&hdl_tbl_lock);
 
 	return 0;
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.c b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.c
index 7b62b859550a..e12ae3f78de7 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.c
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_req_mgr_workq.h"
@@ -172,7 +172,7 @@ int cam_req_mgr_workq_enqueue_task(struct crm_workq_task *task,
 
 int cam_req_mgr_workq_create(char *name, int32_t num_tasks,
 	struct cam_req_mgr_core_workq **workq, enum crm_workq_context in_irq,
-	int flags, bool is_static_payload, void (*func)(struct work_struct *w))
+	int flags)
 {
 	int32_t i, wq_flags = 0, max_active_tasks = 0;
 	struct crm_workq_task  *task;
@@ -202,7 +202,7 @@ int cam_req_mgr_workq_create(char *name, int32_t num_tasks,
 		}
 
 		/* Workq attributes initialization */
-		INIT_WORK(&crm_workq->work, func);
+		INIT_WORK(&crm_workq->work, cam_req_mgr_process_workq);
 		spin_lock_init(&crm_workq->lock_bh);
 		CAM_DBG(CAM_CRM, "LOCK_DBG workq %s lock %pK",
 			name, &crm_workq->lock_bh);
@@ -214,7 +214,6 @@ int cam_req_mgr_workq_create(char *name, int32_t num_tasks,
 			INIT_LIST_HEAD(&crm_workq->task.process_head[i]);
 		INIT_LIST_HEAD(&crm_workq->task.empty_head);
 		crm_workq->in_irq = in_irq;
-		crm_workq->is_static_payload = is_static_payload;
 		crm_workq->task.num_task = num_tasks;
 		crm_workq->task.pool = kcalloc(crm_workq->task.num_task,
 				sizeof(struct crm_workq_task), GFP_KERNEL);
@@ -259,10 +258,8 @@ void cam_req_mgr_workq_destroy(struct cam_req_mgr_core_workq **crm_workq)
 		}
 
 		/* Destroy workq payload data */
-		if (!((*crm_workq)->is_static_payload)) {
-			kfree((*crm_workq)->task.pool[0].payload);
-			(*crm_workq)->task.pool[0].payload = NULL;
-		}
+		kfree((*crm_workq)->task.pool[0].payload);
+		(*crm_workq)->task.pool[0].payload = NULL;
 		kfree((*crm_workq)->task.pool);
 		kfree(*crm_workq);
 		*crm_workq = NULL;
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.h b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.h
index 60a967701254..f938710b69ae 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_req_mgr_workq.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_REQ_MGR_WORKQ_H_
@@ -70,7 +70,6 @@ struct crm_workq_task {
  * task -
  * @lock_bh    : lock for task structs
  * @in_irq     : set true if workque can be used in irq context
- * @is_static_payload : set true if payload is statically allocated
  * @free_cnt   : num of free/available tasks
  * @empty_head : list  head of available taska which can be used
  *               or acquired in order to enqueue a task to workq
@@ -83,7 +82,6 @@ struct cam_req_mgr_core_workq {
 	struct workqueue_struct   *job;
 	spinlock_t                 lock_bh;
 	uint32_t                   in_irq;
-	bool                       is_static_payload;
 
 	/* tasks */
 	struct {
@@ -98,12 +96,6 @@ struct cam_req_mgr_core_workq {
 	} task;
 };
 
-/**
- * cam_req_mgr_process_workq() - main loop handling
- * @w: workqueue task pointer
- */
-void cam_req_mgr_process_workq(struct work_struct *w);
-
 /**
  * cam_req_mgr_workq_create()
  * @brief    : create a workqueue
@@ -114,14 +106,12 @@ void cam_req_mgr_process_workq(struct work_struct *w);
  * @in_irq   : Set to one if workq might be used in irq context
  * @flags    : Bitwise OR of Flags for workq behavior.
  *             e.g. CAM_REQ_MGR_WORKQ_HIGH_PRIORITY | CAM_REQ_MGR_WORKQ_SERIAL
- * @is_static_payload : set to true if payload is statically allocated.
- * @func     : function pointer for cam_req_mgr_process_workq wrapper function
  * This function will allocate and create workqueue and pass
  * the workq pointer to caller.
  */
 int cam_req_mgr_workq_create(char *name, int32_t num_tasks,
 	struct cam_req_mgr_core_workq **workq, enum crm_workq_context in_irq,
-	int flags, bool is_static_payload, void (*func)(struct work_struct *w));
+	int flags);
 
 /**
  * cam_req_mgr_workq_destroy()
diff --git a/techpack/camera/drivers/cam_req_mgr/cam_subdev.h b/techpack/camera/drivers/cam_req_mgr/cam_subdev.h
index b4e5580c1b49..385643d5e532 100644
--- a/techpack/camera/drivers/cam_req_mgr/cam_subdev.h
+++ b/techpack/camera/drivers/cam_req_mgr/cam_subdev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_SUBDEV_H_
@@ -16,15 +16,6 @@
 
 #define CAM_SUBDEVICE_EVENT_MAX 30
 
-enum cam_subdev_message_type_t {
-	CAM_SUBDEV_MESSAGE_IRQ_ERR = 0x1
-};
-
-enum cam_subdev_rwsem {
-	CAM_SUBDEV_LOCK = 1,
-	CAM_SUBDEV_UNLOCK,
-};
-
 /**
  * struct cam_subdev - describes a camera sub-device
  *
@@ -43,7 +34,6 @@ enum cam_subdev_rwsem {
  * @ent_function:          Media entity function type. Can be:
  *                             %CAM_IFE_DEVICE_TYPE - identifies as IFE device.
  *                             %CAM_ICP_DEVICE_TYPE - identifies as ICP device.
- * @msg_cb:                Pointer to the callback function to dump PHY status.
  *
  * Each instance of a subdev driver should create this struct, either
  * stand-alone or embedded in a larger struct. This structure should be
@@ -59,26 +49,8 @@ struct cam_subdev {
 	u32                                    sd_flags;
 	void                                  *token;
 	u32                                    ent_function;
-	void                                  (*msg_cb)(
-				struct v4l2_subdev *sd,
-				enum cam_subdev_message_type_t msg_type,
-				uint32_t data);
 };
 
-/**
-  * cam_subdev_notify_message()
-  *
-  * @brief:  Notify message to a subdevs of specific type
-  *
-  * @subdev_type:           Subdev type
-  * @message_type:          message type
-  * @data:                  data to be delivered.
-  *
-  */
-void cam_subdev_notify_message(u32 subdev_type,
-	enum cam_subdev_message_type_t message_type,
-	uint32_t data);
-
 /**
  * cam_subdev_probe()
  *
@@ -133,28 +105,4 @@ int cam_register_subdev(struct cam_subdev *sd);
  */
 int cam_unregister_subdev(struct cam_subdev *sd);
 
-/**
- * cam_req_mgr_rwsem_read_op()
- *
- * @brief : API to acquire read semaphore lock to platform framework.
- *
- * @lock  : value indicates to lock or unlock the read lock
- */
-void cam_req_mgr_rwsem_read_op(enum cam_subdev_rwsem lock);
-
-/**
- * cam_req_mgr_is_open()
- *
- * @brief:    This common utility function returns the crm active status
- *
- */
-bool  cam_req_mgr_is_open(void);
-
-/**
- * cam_req_mgr_is_shutdown()
- *
- * @brief:    This common utility function returns the shutdown state
- */
-bool cam_req_mgr_is_shutdown(void);
-
 #endif /* _CAM_SUBDEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_core.c b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_core.c
index 8ee158472765..a514e999ffbb 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_core.c
@@ -554,7 +554,7 @@ int32_t cam_actuator_i2c_pkt_parse(struct cam_actuator_ctrl_t *a_ctrl,
 				rc = cam_sensor_i2c_command_parser(
 					&a_ctrl->io_master_info,
 					i2c_reg_settings,
-					&cmd_desc[i], 1, NULL);
+					&cmd_desc[i], 1);
 				if (rc < 0) {
 					CAM_ERR(CAM_ACTUATOR,
 					"Failed:parse init settings: %d",
@@ -612,7 +612,7 @@ int32_t cam_actuator_i2c_pkt_parse(struct cam_actuator_ctrl_t *a_ctrl,
 		rc = cam_sensor_i2c_command_parser(
 			&a_ctrl->io_master_info,
 			i2c_reg_settings,
-			cmd_desc, 1, NULL);
+			cmd_desc, 1);
 		if (rc < 0) {
 			CAM_ERR(CAM_ACTUATOR,
 				"Auto move lens parsing failed: %d", rc);
@@ -643,7 +643,7 @@ int32_t cam_actuator_i2c_pkt_parse(struct cam_actuator_ctrl_t *a_ctrl,
 		rc = cam_sensor_i2c_command_parser(
 			&a_ctrl->io_master_info,
 			i2c_reg_settings,
-			cmd_desc, 1, NULL);
+			cmd_desc, 1);
 		if (rc < 0) {
 			CAM_ERR(CAM_ACTUATOR,
 				"Manual move lens parsing failed: %d", rc);
@@ -662,68 +662,6 @@ int32_t cam_actuator_i2c_pkt_parse(struct cam_actuator_ctrl_t *a_ctrl,
 		}
 		cam_actuator_update_req_mgr(a_ctrl, csl_packet);
 		break;
-	case CAM_ACTUATOR_PACKET_OPCODE_READ: {
-		struct cam_buf_io_cfg *io_cfg;
-		struct i2c_settings_array i2c_read_settings;
-
-		if (a_ctrl->cam_act_state < CAM_ACTUATOR_CONFIG) {
-			rc = -EINVAL;
-			CAM_WARN(CAM_ACTUATOR,
-				"Not in right state to read actuator: %d",
-				a_ctrl->cam_act_state);
-			goto end;
-		}
-		CAM_DBG(CAM_ACTUATOR, "number of I/O configs: %d:",
-			csl_packet->num_io_configs);
-		if (csl_packet->num_io_configs == 0) {
-			CAM_ERR(CAM_ACTUATOR, "No I/O configs to process");
-			rc = -EINVAL;
-			goto end;
-		}
-
-		INIT_LIST_HEAD(&(i2c_read_settings.list_head));
-
-		io_cfg = (struct cam_buf_io_cfg *) ((uint8_t *)
-			&csl_packet->payload +
-			csl_packet->io_configs_offset);
-
-		if (io_cfg == NULL) {
-			CAM_ERR(CAM_ACTUATOR, "I/O config is invalid(NULL)");
-			rc = -EINVAL;
-			goto end;
-		}
-
-		offset = (uint32_t *)&csl_packet->payload;
-		offset += (csl_packet->cmd_buf_offset / sizeof(uint32_t));
-		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
-		i2c_read_settings.is_settings_valid = 1;
-		i2c_read_settings.request_id = 0;
-		rc = cam_sensor_i2c_command_parser(&a_ctrl->io_master_info,
-			&i2c_read_settings,
-			cmd_desc, 1, io_cfg);
-		if (rc < 0) {
-			CAM_ERR(CAM_ACTUATOR,
-				"actuator read pkt parsing failed: %d", rc);
-			goto end;
-		}
-
-		rc = cam_sensor_i2c_read_data(
-			&i2c_read_settings,
-			&a_ctrl->io_master_info);
-		if (rc < 0) {
-			CAM_ERR(CAM_ACTUATOR, "cannot read data, rc:%d", rc);
-			delete_request(&i2c_read_settings);
-			goto end;
-		}
-
-		rc = delete_request(&i2c_read_settings);
-		if (rc < 0) {
-			CAM_ERR(CAM_ACTUATOR,
-				"Failed in deleting the read settings");
-			goto end;
-		}
-		break;
-		}
 	default:
 		CAM_ERR(CAM_ACTUATOR, "Wrong Opcode: %d",
 			csl_packet->header.op_code & 0xFFFFFF);
@@ -825,11 +763,6 @@ int32_t cam_actuator_driver_cmd(struct cam_actuator_ctrl_t *a_ctrl,
 
 		actuator_acq_dev.device_handle =
 			cam_create_device_hdl(&bridge_params);
-		if (actuator_acq_dev.device_handle <= 0) {
-			rc = -EFAULT;
-			CAM_ERR(CAM_ACTUATOR, "Can not create device handle");
-			goto release_mutex;
-		}
 		a_ctrl->bridge_intf.device_hdl = actuator_acq_dev.device_handle;
 		a_ctrl->bridge_intf.session_hdl =
 			actuator_acq_dev.session_handle;
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.c
index 0da40d3613a1..46bd99fc9e29 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_actuator_dev.h"
@@ -72,25 +72,6 @@ static long cam_actuator_init_subdev_do_ioctl(struct v4l2_subdev *sd,
 }
 #endif
 
-static int cam_actuator_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct cam_actuator_ctrl_t *a_ctrl =
-		v4l2_get_subdevdata(sd);
-
-	if (!a_ctrl) {
-		CAM_ERR(CAM_ACTUATOR, "a_ctrl ptr is NULL");
-		return -EINVAL;
-	}
-
-	mutex_lock(&(a_ctrl->actuator_mutex));
-	a_ctrl->open_cnt++;
-	CAM_DBG(CAM_ACTUATOR, "actuator_dev open count %d", a_ctrl->open_cnt);
-	mutex_unlock(&(a_ctrl->actuator_mutex));
-
-	return 0;
-}
-
 static int cam_actuator_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -103,14 +84,7 @@ static int cam_actuator_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&(a_ctrl->actuator_mutex));
-	if (a_ctrl->open_cnt <= 0) {
-		mutex_unlock(&(a_ctrl->actuator_mutex));
-		return -EINVAL;
-	}
-	a_ctrl->open_cnt--;
-	CAM_DBG(CAM_ACTUATOR, "actuator_dev open count %d", a_ctrl->open_cnt);
-	if (a_ctrl->open_cnt == 0)
-		cam_actuator_shutdown(a_ctrl);
+	cam_actuator_shutdown(a_ctrl);
 	mutex_unlock(&(a_ctrl->actuator_mutex));
 
 	return 0;
@@ -128,7 +102,6 @@ static struct v4l2_subdev_ops cam_actuator_subdev_ops = {
 };
 
 static const struct v4l2_subdev_internal_ops cam_actuator_internal_ops = {
-	.open  = cam_actuator_subdev_open,
 	.close = cam_actuator_subdev_close,
 };
 
@@ -237,7 +210,6 @@ static int32_t cam_actuator_driver_i2c_probe(struct i2c_client *client,
 		cam_actuator_apply_request;
 	a_ctrl->last_flush_req = 0;
 	a_ctrl->cam_act_state = CAM_ACTUATOR_INIT;
-	a_ctrl->open_cnt = 0;
 
 	return rc;
 
@@ -400,7 +372,6 @@ static int32_t cam_actuator_driver_platform_probe(
 
 	platform_set_drvdata(pdev, a_ctrl);
 	a_ctrl->cam_act_state = CAM_ACTUATOR_INIT;
-	a_ctrl->open_cnt = 0;
 
 	return rc;
 
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.h
index 2837cd85c9d4..e4bfaed4414f 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_actuator/cam_actuator_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 
@@ -115,7 +115,6 @@ struct cam_actuator_ctrl_t {
 	struct cam_actuator_query_cap act_info;
 	struct intf_params bridge_intf;
 	uint32_t last_flush_req;
-	uint32_t open_cnt;
 };
 
 #endif /* _CAM_ACTUATOR_DEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c
old mode 100644
new mode 100755
index f0f91289887f..947cdbfdc2d5
--- a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_core.c
@@ -7,6 +7,10 @@
 #include "cam_cci_core.h"
 #include "cam_cci_dev.h"
 
+
+static int disable_optmz;
+module_param(disable_optmz, int, 0644);
+
 static int32_t cam_cci_convert_type_to_num_bytes(
 	enum camera_sensor_i2c_type type)
 {
@@ -26,7 +30,7 @@ static int32_t cam_cci_convert_type_to_num_bytes(
 		num_bytes = 4;
 		break;
 	default:
-		CAM_ERR(CAM_CCI, "Wrong Sensor I2c Type: %d", type);
+		CAM_ERR(CAM_CCI, "failed: %d", type);
 		num_bytes = 0;
 		break;
 	}
@@ -192,9 +196,6 @@ static void cam_cci_dump_registers(struct cci_device *cci_dev,
 	uint32_t reg_offset = 0;
 	void __iomem *base = cci_dev->soc_info.reg_map[0].mem_base;
 
-	CAM_INFO(CAM_CCI, "**** CCI:%d register dump ****",
-		cci_dev->soc_info->index);
-
 	/* CCI Top Registers */
 	CAM_INFO(CAM_CCI, "****CCI TOP Registers ****");
 	for (i = 0; i < DEBUG_TOP_REG_COUNT; i++) {
@@ -208,9 +209,6 @@ static void cam_cci_dump_registers(struct cci_device *cci_dev,
 	CAM_INFO(CAM_CCI, "****CCI MASTER %d Registers ****",
 		master);
 	for (i = 0; i < DEBUG_MASTER_REG_COUNT; i++) {
-		if ((i * 4) == 0x18)
-			continue;
-
 		reg_offset = DEBUG_MASTER_REG_START + master*0x100 + i * 4;
 		read_val = cam_io_r_mb(base + reg_offset);
 		CAM_INFO(CAM_CCI, "offset = 0x%X value = 0x%X",
@@ -450,11 +448,11 @@ static int32_t cam_cci_calc_cmd_len(struct cci_device *cci_dev,
 	 struct cam_sensor_i2c_reg_array *i2c_cmd, uint32_t *pack)
 {
 	uint8_t i;
+	struct cam_sensor_i2c_reg_array *cmd = i2c_cmd;
 	uint32_t len = 0;
 	uint8_t data_len = 0, addr_len = 0;
 	uint8_t pack_max_len;
 	struct cam_sensor_i2c_reg_setting *msg;
-	struct cam_sensor_i2c_reg_array *cmd = i2c_cmd;
 	uint32_t size = cmd_size;
 
 	if (!cci_dev || !c_ctrl) {
@@ -476,22 +474,27 @@ static int32_t cam_cci_calc_cmd_len(struct cci_device *cci_dev,
 		len = data_len + addr_len;
 		pack_max_len = size < (cci_dev->payload_size-len) ?
 			size : (cci_dev->payload_size-len);
-		for (i = 0; i < pack_max_len;) {
-			if (cmd->delay || ((cmd - i2c_cmd) >= (cmd_size - 1)))
-				break;
-			if (cmd->reg_addr + 1 ==
-				(cmd+1)->reg_addr) {
-				len += data_len;
-				if (len > cci_dev->payload_size) {
-					len = len - data_len;
+		/* xiaomi add a flag to disable this optimization*/
+		if ((!c_ctrl->cci_info->disable_optmz) && (!disable_optmz))
+		{
+			CAM_DBG(CAM_CCI, "enable writing optimization for 0x%02X", c_ctrl->cci_info->sid<<1);
+			for (i = 0; i < pack_max_len;) {
+				if (cmd->delay || ((cmd - i2c_cmd) >= (cmd_size - 1)))
+					break;
+				if (cmd->reg_addr + 1 ==
+					(cmd+1)->reg_addr) {
+					len += data_len;
+					if (len > cci_dev->payload_size) {
+						len = len - data_len;
+						break;
+					}
+					(*pack)++;
+				} else {
 					break;
 				}
-				(*pack)++;
-			} else {
-				break;
+				i += data_len;
+				cmd++;
 			}
-			i += data_len;
-			cmd++;
 		}
 	}
 
@@ -575,42 +578,19 @@ static int32_t cam_cci_set_clk_param(struct cci_device *cci_dev,
 	struct cam_cci_clk_params_t *clk_params = NULL;
 	enum cci_i2c_master_t master = c_ctrl->cci_info->cci_i2c_master;
 	enum i2c_freq_mode i2c_freq_mode = c_ctrl->cci_info->i2c_freq_mode;
-	void __iomem *base = cci_dev->soc_info.reg_map[0].mem_base;
-	struct cam_cci_master_info *cci_master =
-		&cci_dev->cci_master_info[master];
+	struct cam_hw_soc_info *soc_info =
+		&cci_dev->soc_info;
+	void __iomem *base = soc_info->reg_map[0].mem_base;
 
 	if ((i2c_freq_mode >= I2C_MAX_MODES) || (i2c_freq_mode < 0)) {
 		CAM_ERR(CAM_CCI, "invalid i2c_freq_mode = %d", i2c_freq_mode);
 		return -EINVAL;
 	}
-	/*
-	 * If no change in i2c freq, then acquire semaphore only for the first
-	 * i2c transaction to indicate I2C transaction is in progress, else
-	 * always try to acquire semaphore, to make sure that no other I2C
-	 * transaction is in progress.
-	 */
-	mutex_lock(&cci_master->mutex);
-	if (i2c_freq_mode == cci_dev->i2c_freq_mode[master]) {
-		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d", master,
-			i2c_freq_mode);
-		spin_lock(&cci_master->freq_cnt_lock);
-		if (cci_master->freq_ref_cnt == 0)
-			down(&cci_master->master_sem);
-		cci_master->freq_ref_cnt++;
-		spin_unlock(&cci_master->freq_cnt_lock);
-		mutex_unlock(&cci_master->mutex);
-		return 0;
-	}
-	CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
-		master, cci_dev->i2c_freq_mode[master], i2c_freq_mode);
-	down(&cci_master->master_sem);
-
-	spin_lock(&cci_master->freq_cnt_lock);
-	cci_master->freq_ref_cnt++;
-	spin_unlock(&cci_master->freq_cnt_lock);
 
 	clk_params = &cci_dev->cci_clk_params[i2c_freq_mode];
 
+	if (cci_dev->i2c_freq_mode[master] == i2c_freq_mode)
+		return 0;
 	if (master == MASTER_0) {
 		cam_io_w_mb(clk_params->hw_thigh << 16 |
 			clk_params->hw_tlow,
@@ -644,7 +624,6 @@ static int32_t cam_cci_set_clk_param(struct cci_device *cci_dev,
 	}
 	cci_dev->i2c_freq_mode[master] = i2c_freq_mode;
 
-	mutex_unlock(&cci_master->mutex);
 	return 0;
 }
 
@@ -923,19 +902,42 @@ static int32_t cam_cci_burst_read(struct v4l2_subdev *sd,
 		return -EINVAL;
 	}
 
+	soc_info = &cci_dev->soc_info;
+	base = soc_info->reg_map[0].mem_base;
+
+	mutex_lock(&cci_dev->cci_master_info[master].mutex);
+	if (cci_dev->cci_master_info[master].is_first_req) {
+		cci_dev->cci_master_info[master].is_first_req = false;
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else if (c_ctrl->cci_info->i2c_freq_mode
+		!= cci_dev->i2c_freq_mode[master]) {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+		cci_dev->cci_master_info[master].freq_ref_cnt++;
+		spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
+	}
+
 	/* Set the I2C Frequency */
 	rc = cam_cci_set_clk_param(cci_dev, c_ctrl);
 	if (rc < 0) {
 		CAM_ERR(CAM_CCI, "cam_cci_set_clk_param failed rc = %d", rc);
-		return rc;
+		mutex_unlock(&cci_dev->cci_master_info[master].mutex);
+		goto rel_master;
 	}
+	mutex_unlock(&cci_dev->cci_master_info[master].mutex);
 
 	mutex_lock(&cci_dev->cci_master_info[master].mutex_q[queue]);
 	reinit_completion(&cci_dev->cci_master_info[master].report_q[queue]);
-
-	soc_info = &cci_dev->soc_info;
-	base = soc_info->reg_map[0].mem_base;
-
 	/*
 	 * Call validate queue to make sure queue is empty before starting.
 	 * If this call fails, don't proceed with i2c_read call. This is to
@@ -1147,11 +1149,13 @@ static int32_t cam_cci_burst_read(struct v4l2_subdev *sd,
 
 rel_mutex_q:
 	mutex_unlock(&cci_dev->cci_master_info[master].mutex_q[queue]);
-
-	spin_lock(&cci_dev->cci_master_info[master].freq_cnt_lock);
-	if (--cci_dev->cci_master_info[master].freq_ref_cnt == 0)
+rel_master:
+	spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+	if (cci_dev->cci_master_info[master].freq_ref_cnt == 0)
 		up(&cci_dev->cci_master_info[master].master_sem);
-	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt_lock);
+	else
+		cci_dev->cci_master_info[master].freq_ref_cnt--;
+	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
 	return rc;
 }
 
@@ -1176,24 +1180,46 @@ static int32_t cam_cci_read(struct v4l2_subdev *sd,
 
 	if (c_ctrl->cci_info->cci_i2c_master >= MASTER_MAX
 		|| c_ctrl->cci_info->cci_i2c_master < 0) {
-		CAM_ERR(CAM_CCI, "Invalid I2C master addr:%d",
-			c_ctrl->cci_info->cci_i2c_master);
+		CAM_ERR(CAM_CCI, "Invalid I2C master addr");
 		return -EINVAL;
 	}
 
+	soc_info = &cci_dev->soc_info;
+	base = soc_info->reg_map[0].mem_base;
+
+	mutex_lock(&cci_dev->cci_master_info[master].mutex);
+	if (cci_dev->cci_master_info[master].is_first_req) {
+		cci_dev->cci_master_info[master].is_first_req = false;
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else if (c_ctrl->cci_info->i2c_freq_mode
+		!= cci_dev->i2c_freq_mode[master]) {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+		cci_dev->cci_master_info[master].freq_ref_cnt++;
+		spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
+	}
+
 	/* Set the I2C Frequency */
 	rc = cam_cci_set_clk_param(cci_dev, c_ctrl);
 	if (rc < 0) {
+		mutex_unlock(&cci_dev->cci_master_info[master].mutex);
 		CAM_ERR(CAM_CCI, "cam_cci_set_clk_param failed rc = %d", rc);
-		return rc;
+		goto rel_master;
 	}
+	mutex_unlock(&cci_dev->cci_master_info[master].mutex);
 
 	mutex_lock(&cci_dev->cci_master_info[master].mutex_q[queue]);
 	reinit_completion(&cci_dev->cci_master_info[master].report_q[queue]);
-
-	soc_info = &cci_dev->soc_info;
-	base = soc_info->reg_map[0].mem_base;
-
 	/*
 	 * Call validate queue to make sure queue is empty before starting.
 	 * If this call fails, don't proceed with i2c_read call. This is to
@@ -1343,11 +1369,13 @@ static int32_t cam_cci_read(struct v4l2_subdev *sd,
 	}
 rel_mutex_q:
 	mutex_unlock(&cci_dev->cci_master_info[master].mutex_q[queue]);
-
-	spin_lock(&cci_dev->cci_master_info[master].freq_cnt_lock);
-	if (--cci_dev->cci_master_info[master].freq_ref_cnt == 0)
+rel_master:
+	spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+	if (cci_dev->cci_master_info[master].freq_ref_cnt == 0)
 		up(&cci_dev->cci_master_info[master].master_sem);
-	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt_lock);
+	else
+		cci_dev->cci_master_info[master].freq_ref_cnt--;
+	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
 	return rc;
 }
 
@@ -1371,12 +1399,37 @@ static int32_t cam_cci_i2c_write(struct v4l2_subdev *sd,
 		c_ctrl->cci_info->sid, c_ctrl->cci_info->retries,
 		c_ctrl->cci_info->id_map);
 
+	mutex_lock(&cci_dev->cci_master_info[master].mutex);
+	if (cci_dev->cci_master_info[master].is_first_req) {
+		cci_dev->cci_master_info[master].is_first_req = false;
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else if (c_ctrl->cci_info->i2c_freq_mode
+		!= cci_dev->i2c_freq_mode[master]) {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		down(&cci_dev->cci_master_info[master].master_sem);
+	} else {
+		CAM_DBG(CAM_CCI, "Master: %d, curr_freq: %d, req_freq: %d",
+			master, cci_dev->i2c_freq_mode[master],
+			c_ctrl->cci_info->i2c_freq_mode);
+		spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+		cci_dev->cci_master_info[master].freq_ref_cnt++;
+		spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
+	}
+
 	/* Set the I2C Frequency */
 	rc = cam_cci_set_clk_param(cci_dev, c_ctrl);
 	if (rc < 0) {
 		CAM_ERR(CAM_CCI, "cam_cci_set_clk_param failed rc = %d", rc);
-		return rc;
+		mutex_unlock(&cci_dev->cci_master_info[master].mutex);
+		goto ERROR;
 	}
+	mutex_unlock(&cci_dev->cci_master_info[master].mutex);
+
 	reinit_completion(&cci_dev->cci_master_info[master].report_q[queue]);
 	/*
 	 * Call validate queue to make sure queue is empty before starting.
@@ -1402,10 +1455,12 @@ static int32_t cam_cci_i2c_write(struct v4l2_subdev *sd,
 	}
 
 ERROR:
-	spin_lock(&cci_dev->cci_master_info[master].freq_cnt_lock);
-	if (--cci_dev->cci_master_info[master].freq_ref_cnt == 0)
+	spin_lock(&cci_dev->cci_master_info[master].freq_cnt);
+	if (cci_dev->cci_master_info[master].freq_ref_cnt == 0)
 		up(&cci_dev->cci_master_info[master].master_sem);
-	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt_lock);
+	else
+		cci_dev->cci_master_info[master].freq_ref_cnt--;
+	spin_unlock(&cci_dev->cci_master_info[master].freq_cnt);
 	return rc;
 }
 
@@ -1538,10 +1593,8 @@ static int32_t cam_cci_read_bytes(struct v4l2_subdev *sd,
 	 * THRESHOLD irq's, we reinit the threshold wait before
 	 * we load the burst read cmd.
 	 */
-	mutex_lock(&cci_dev->cci_master_info[master].mutex_q[QUEUE_1]);
 	reinit_completion(&cci_dev->cci_master_info[master].rd_done);
 	reinit_completion(&cci_dev->cci_master_info[master].th_complete);
-	mutex_unlock(&cci_dev->cci_master_info[master].mutex_q[QUEUE_1]);
 
 	CAM_DBG(CAM_CCI, "Bytes to read %u", read_bytes);
 	do {
@@ -1596,15 +1649,14 @@ static int32_t cam_cci_i2c_set_sync_prms(struct v4l2_subdev *sd,
 	return rc;
 }
 
-static int32_t cam_cci_release(struct v4l2_subdev *sd,
-	enum cci_i2c_master_t master)
+static int32_t cam_cci_release(struct v4l2_subdev *sd)
 {
 	uint8_t rc = 0;
 	struct cci_device *cci_dev;
 
 	cci_dev = v4l2_get_subdevdata(sd);
 
-	rc = cam_cci_soc_release(cci_dev, master);
+	rc = cam_cci_soc_release(cci_dev);
 	if (rc < 0) {
 		CAM_ERR(CAM_CCI, "Failed in releasing the cci: %d", rc);
 		return rc;
@@ -1715,11 +1767,21 @@ int32_t cam_cci_core_cfg(struct v4l2_subdev *sd,
 		break;
 	case MSM_CCI_RELEASE:
 		mutex_lock(&cci_dev->init_mutex);
-		rc = cam_cci_release(sd, master);
+		rc = cam_cci_release(sd);
 		mutex_unlock(&cci_dev->init_mutex);
 		break;
 	case MSM_CCI_I2C_READ:
+		mutex_lock(&cci_dev->init_mutex);
 		rc = cam_cci_read_bytes(sd, cci_ctrl);
+		/* Added by qudao1@xiaomi.com */
+		if (rc < 0) {
+			CAM_ERR(CAM_CCI, "cam cci err %d , read, slav 0x%x on dev/master %d/%d",
+				rc, cci_ctrl->cci_info->sid << 1,
+				cci_ctrl->cci_info->cci_device,
+				cci_ctrl->cci_info->cci_i2c_master);
+		}
+		mutex_unlock(&cci_dev->init_mutex);
+		/* End of Added by qudao1@xiaomi.com */
 		break;
 	case MSM_CCI_I2C_WRITE:
 	case MSM_CCI_I2C_WRITE_SEQ:
@@ -1727,7 +1789,18 @@ int32_t cam_cci_core_cfg(struct v4l2_subdev *sd,
 	case MSM_CCI_I2C_WRITE_SYNC:
 	case MSM_CCI_I2C_WRITE_ASYNC:
 	case MSM_CCI_I2C_WRITE_SYNC_BLOCK:
+		mutex_lock(&cci_dev->init_mutex);
 		rc = cam_cci_write(sd, cci_ctrl);
+		/* Added by qudao1@xiaomi.com */
+		if (rc < 0) {
+			CAM_ERR(CAM_CCI, "cam cci err %d , write type %d , slav 0x%x on dev/master %d/%d",
+				rc, cci_ctrl->cmd,
+				cci_ctrl->cci_info->sid << 1,
+				cci_ctrl->cci_info->cci_device,
+				cci_ctrl->cci_info->cci_i2c_master);
+		}
+		mutex_unlock(&cci_dev->init_mutex);
+		/* End of Added by qudao1@xiaomi.com */
 		break;
 	case MSM_CCI_GPIO_WRITE:
 		break;
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.c
index c949608d183e..855fe5e68573 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.c
@@ -429,7 +429,8 @@ static int cam_cci_platform_probe(struct platform_device *pdev)
 		sizeof(new_cci_dev->device_name));
 	new_cci_dev->v4l2_dev_str.name =
 		new_cci_dev->device_name;
-	new_cci_dev->v4l2_dev_str.sd_flags = V4L2_SUBDEV_FL_HAS_EVENTS;
+	new_cci_dev->v4l2_dev_str.sd_flags =
+		(V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS);
 	new_cci_dev->v4l2_dev_str.ent_function =
 		CAM_CCI_DEVICE_TYPE;
 	new_cci_dev->v4l2_dev_str.token =
@@ -468,16 +469,13 @@ static int cam_cci_platform_probe(struct platform_device *pdev)
 	rc = cam_cpas_register_client(&cpas_parms);
 	if (rc) {
 		CAM_ERR(CAM_CCI, "CPAS registration failed");
-		goto cci_unregister_subdev;
+		goto cci_no_resource;
 	}
 	CAM_DBG(CAM_CCI, "CPAS registration successful handle=%d",
 		cpas_parms.client_handle);
 	new_cci_dev->cpas_handle = cpas_parms.client_handle;
 
 	return rc;
-
-cci_unregister_subdev:
-	cam_unregister_subdev(&(new_cci_dev->v4l2_dev_str));
 cci_no_resource:
 	kfree(new_cci_dev);
 	return rc;
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.h
index 1aee97cf4ee4..4b09ff84b968 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CCI_DEV_H_
@@ -39,6 +39,7 @@
 
 #define CCI_TIMEOUT msecs_to_jiffies(1500)
 
+#define NUM_MASTERS 2
 #define NUM_QUEUES 2
 
 #define CCI_PINCTRL_STATE_DEFAULT "cci_default"
@@ -121,7 +122,7 @@ struct cam_cci_i2c_queue_info {
 };
 
 struct cam_cci_master_info {
-	int32_t status;
+	uint32_t status;
 	atomic_t q_free[NUM_QUEUES];
 	uint8_t q_lock[NUM_QUEUES];
 	uint8_t reset_pending;
@@ -133,10 +134,10 @@ struct cam_cci_master_info {
 	struct completion report_q[NUM_QUEUES];
 	atomic_t done_pending[NUM_QUEUES];
 	spinlock_t lock_q[NUM_QUEUES];
+	spinlock_t freq_cnt;
 	struct semaphore master_sem;
-	spinlock_t freq_cnt_lock;
+	bool is_first_req;
 	uint16_t freq_ref_cnt;
-	bool is_initilized;
 };
 
 struct cam_cci_clk_params_t {
@@ -171,7 +172,6 @@ enum cam_cci_state_t {
  * @cci_clk_info:               CCI clock information
  * @cam_cci_i2c_queue_info:     CCI queue information
  * @i2c_freq_mode:              I2C frequency of operations
- * @master_active_slave:        Number of active/connected slaves for master
  * @cci_clk_params:             CCI hw clk params
  * @cci_gpio_tbl:               CCI GPIO table
  * @cci_gpio_tbl_size:          GPIO table size
@@ -204,10 +204,9 @@ struct cci_device {
 	uint8_t ref_count;
 	enum cam_cci_state_t cci_state;
 	struct cam_cci_i2c_queue_info
-		cci_i2c_queue_info[MASTER_MAX][NUM_QUEUES];
-	struct cam_cci_master_info cci_master_info[MASTER_MAX];
-	enum i2c_freq_mode i2c_freq_mode[MASTER_MAX];
-	uint8_t master_active_slave[MASTER_MAX];
+		cci_i2c_queue_info[NUM_MASTERS][NUM_QUEUES];
+	struct cam_cci_master_info cci_master_info[NUM_MASTERS];
+	enum i2c_freq_mode i2c_freq_mode[NUM_MASTERS];
 	struct cam_cci_clk_params_t cci_clk_params[I2C_MAX_MODES];
 	struct msm_pinctrl_info cci_pinctrl;
 	uint8_t cci_pinctrl_status;
@@ -272,6 +271,7 @@ struct cam_sensor_cci_client {
 	uint16_t retries;
 	uint16_t id_map;
 	uint16_t cci_device;
+	uint16_t disable_optmz; //xiaomi add the flag to disable CCI optimization
 };
 
 struct cam_cci_ctrl {
@@ -299,6 +299,6 @@ irqreturn_t cam_cci_irq(int irq_num, void *data);
 struct v4l2_subdev *cam_cci_get_subdev(int cci_dev_index);
 
 #define VIDIOC_MSM_CCI_CFG \
-	_IOWR('V', BASE_VIDIOC_PRIVATE + 23, struct cam_cci_ctrl)
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 23, struct cam_cci_ctrl *)
 
 #endif /* _CAM_CCI_DEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.c b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.c
index 10f274c907eb..ff74be5eb9f9 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.c
@@ -1,85 +1,15 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_cci_dev.h"
 #include "cam_cci_core.h"
 
-static int cam_cci_init_master(struct cci_device *cci_dev,
-	enum cci_i2c_master_t master)
-{
-	int i = 0, rc = 0;
-	void __iomem *base = NULL;
-	struct cam_hw_soc_info *soc_info = NULL;
-	uint32_t max_queue_0_size = 0, max_queue_1_size = 0;
-
-	soc_info = &cci_dev->soc_info;
-	base = soc_info->reg_map[0].mem_base;
-
-	max_queue_0_size = CCI_I2C_QUEUE_0_SIZE;
-	max_queue_1_size = CCI_I2C_QUEUE_1_SIZE;
-
-	cci_dev->master_active_slave[master]++;
-	if (!cci_dev->cci_master_info[master].is_initilized) {
-		/* Re-initialize the completion */
-		reinit_completion(
-		&cci_dev->cci_master_info[master].reset_complete);
-		reinit_completion(&cci_dev->cci_master_info[master].rd_done);
-
-		/* reinit the reports for the queue */
-		for (i = 0; i < NUM_QUEUES; i++)
-			reinit_completion(
-			&cci_dev->cci_master_info[master].report_q[i]);
-
-		/* Set reset pending flag to true */
-		cci_dev->cci_master_info[master].reset_pending = true;
-		cci_dev->cci_master_info[master].status = 0;
-		if (cci_dev->ref_count == 1) {
-			cam_io_w_mb(CCI_RESET_CMD_RMSK,
-				base + CCI_RESET_CMD_ADDR);
-			cam_io_w_mb(0x1, base + CCI_RESET_CMD_ADDR);
-		} else {
-			cam_io_w_mb((master == MASTER_0) ?
-				CCI_M0_RESET_RMSK : CCI_M1_RESET_RMSK,
-				base + CCI_RESET_CMD_ADDR);
-		}
-		if (!wait_for_completion_timeout(
-			&cci_dev->cci_master_info[master].reset_complete,
-			CCI_TIMEOUT)) {
-			CAM_ERR(CAM_CCI,
-				"Failed: reset complete timeout for master: %d",
-				master);
-			rc = -ETIMEDOUT;
-			cci_dev->master_active_slave[master]--;
-			return rc;
-		}
-
-		flush_workqueue(cci_dev->write_wq[master]);
-
-		/* Setting up the queue size for master */
-		cci_dev->cci_i2c_queue_info[master][QUEUE_0].max_queue_size
-					= max_queue_0_size;
-		cci_dev->cci_i2c_queue_info[master][QUEUE_1].max_queue_size
-					= max_queue_1_size;
-
-		CAM_DBG(CAM_CCI, "CCI Master[%d] :: Q0: %d Q1: %d", master,
-			cci_dev->cci_i2c_queue_info[master][QUEUE_0]
-				.max_queue_size,
-			cci_dev->cci_i2c_queue_info[master][QUEUE_1]
-				.max_queue_size);
-
-		cci_dev->cci_master_info[master].status = 0;
-		cci_dev->cci_master_info[master].is_initilized = true;
-	}
-
-	return 0;
-}
-
 int cam_cci_init(struct v4l2_subdev *sd,
 	struct cam_cci_ctrl *c_ctrl)
 {
-	uint8_t i = 0;
+	uint8_t i = 0, j = 0;
 	int32_t rc = 0;
 	struct cci_device *cci_dev;
 	enum cci_i2c_master_t master = c_ctrl->cci_info->cci_i2c_master;
@@ -90,8 +20,7 @@ int cam_cci_init(struct v4l2_subdev *sd,
 
 	cci_dev = v4l2_get_subdevdata(sd);
 	if (!cci_dev || !c_ctrl) {
-		CAM_ERR(CAM_CCI,
-			"failed: invalid params cci_dev:%pK, c_ctrl:%pK",
+		CAM_ERR(CAM_CCI, "failed: invalid params %pK %pK",
 			cci_dev, c_ctrl);
 		rc = -EINVAL;
 		return rc;
@@ -101,89 +30,150 @@ int cam_cci_init(struct v4l2_subdev *sd,
 	base = soc_info->reg_map[0].mem_base;
 
 	if (!soc_info || !base) {
-		CAM_ERR(CAM_CCI,
-			"failed: invalid params soc_info:%pK, base:%pK",
+		CAM_ERR(CAM_CCI, "failed: invalid params %pK %pK",
 			soc_info, base);
 		rc = -EINVAL;
 		return rc;
 	}
 
-	if (master >= MASTER_MAX || master < 0) {
-		CAM_ERR(CAM_CCI, "Incorrect Master: %d", master);
-		return -EINVAL;
-	}
-
-	if (!cci_dev->write_wq[master]) {
-		CAM_ERR(CAM_CCI, "Null memory for write wq[:%d]", master);
-		rc = -ENOMEM;
-		return rc;
-	}
+	CAM_DBG(CAM_CCI, "Base address %pK", base);
 
 	if (cci_dev->ref_count++) {
-		rc = cam_cci_init_master(cci_dev, master);
-		if (rc) {
-			CAM_ERR(CAM_CCI, "Failed to init: Master: %d: rc: %d",
-				master, rc);
-			cci_dev->ref_count--;
+		CAM_DBG(CAM_CCI, "ref_count %d", cci_dev->ref_count);
+		CAM_DBG(CAM_CCI, "master %d", master);
+		if (master < MASTER_MAX && master >= 0) {
+			mutex_lock(&cci_dev->cci_master_info[master].mutex);
+			flush_workqueue(cci_dev->write_wq[master]);
+			/* Re-initialize the completion */
+			reinit_completion(
+			&cci_dev->cci_master_info[master].reset_complete);
+			reinit_completion(
+			&cci_dev->cci_master_info[master].rd_done);
+			for (i = 0; i < NUM_QUEUES; i++)
+				reinit_completion(
+				&cci_dev->cci_master_info[master].report_q[i]);
+			/* Set reset pending flag to true */
+			cci_dev->cci_master_info[master].reset_pending = true;
+			cci_dev->cci_master_info[master].status = 0;
+			/* Set proper mask to RESET CMD address */
+			if (master == MASTER_0)
+				cam_io_w_mb(CCI_M0_RESET_RMSK,
+					base + CCI_RESET_CMD_ADDR);
+			else
+				cam_io_w_mb(CCI_M1_RESET_RMSK,
+					base + CCI_RESET_CMD_ADDR);
+			/* wait for reset done irq */
+			rc = wait_for_completion_timeout(
+			&cci_dev->cci_master_info[master].reset_complete,
+				CCI_TIMEOUT);
+			if (rc <= 0)
+				CAM_ERR(CAM_CCI, "wait failed %d", rc);
+			cci_dev->cci_master_info[master].status = 0;
+			mutex_unlock(&cci_dev->cci_master_info[master].mutex);
 		}
-		CAM_DBG(CAM_CCI, "ref_count %d, master: %d",
-			cci_dev->ref_count, master);
-		return rc;
+		return 0;
 	}
 
 	ahb_vote.type = CAM_VOTE_ABSOLUTE;
 	ahb_vote.vote.level = CAM_LOWSVS_VOTE;
 	axi_vote.num_paths = 1;
-	axi_vote.axi_path[0].path_data_type = CAM_AXI_PATH_DATA_ALL;
-	axi_vote.axi_path[0].transac_type = CAM_AXI_TRANSACTION_WRITE;
-	axi_vote.axi_path[0].camnoc_bw = CAM_CPAS_DEFAULT_AXI_BW;
-	axi_vote.axi_path[0].mnoc_ab_bw = CAM_CPAS_DEFAULT_AXI_BW;
-	axi_vote.axi_path[0].mnoc_ib_bw = CAM_CPAS_DEFAULT_AXI_BW;
-
-	rc = cam_cpas_start(cci_dev->cpas_handle, &ahb_vote, &axi_vote);
-	if (rc) {
-		CAM_ERR(CAM_CCI, "CPAS start failed rc= %d", rc);
-		return rc;
-	}
+	axi_vote.axi_path[0].path_data_type =
+		CAM_AXI_PATH_DATA_ALL;
+	axi_vote.axi_path[0].transac_type =
+		CAM_AXI_TRANSACTION_WRITE;
+	axi_vote.axi_path[0].camnoc_bw =
+		CAM_CPAS_DEFAULT_AXI_BW;
+	axi_vote.axi_path[0].mnoc_ab_bw =
+		CAM_CPAS_DEFAULT_AXI_BW;
+	axi_vote.axi_path[0].mnoc_ib_bw =
+		CAM_CPAS_DEFAULT_AXI_BW;
+
+	rc = cam_cpas_start(cci_dev->cpas_handle,
+		&ahb_vote, &axi_vote);
+	if (rc != 0)
+		CAM_ERR(CAM_CCI, "CPAS start failed");
 
 	cam_cci_get_clk_rates(cci_dev, c_ctrl);
 
+	/* Re-initialize the completion */
+	reinit_completion(&cci_dev->cci_master_info[master].reset_complete);
+	reinit_completion(&cci_dev->cci_master_info[master].rd_done);
+	for (i = 0; i < NUM_QUEUES; i++)
+		reinit_completion(
+			&cci_dev->cci_master_info[master].report_q[i]);
+
 	/* Enable Regulators and IRQ*/
 	rc = cam_soc_util_enable_platform_resource(soc_info, true,
 		CAM_LOWSVS_VOTE, true);
 	if (rc < 0) {
-		CAM_DBG(CAM_CCI, "request platform resources failed, rc: %d",
-			rc);
+		CAM_DBG(CAM_CCI, "request platform resources failed");
 		goto platform_enable_failed;
 	}
 
-	cci_dev->hw_version = cam_io_r_mb(base + CCI_HW_VERSION_ADDR);
+	cci_dev->hw_version = cam_io_r_mb(base +
+		CCI_HW_VERSION_ADDR);
 	CAM_DBG(CAM_CCI, "hw_version = 0x%x", cci_dev->hw_version);
 
-	cci_dev->payload_size = MSM_CCI_WRITE_DATA_PAYLOAD_SIZE_11;
+	cci_dev->payload_size =
+		MSM_CCI_WRITE_DATA_PAYLOAD_SIZE_11;
 	cci_dev->support_seq_write = 1;
 
-	rc = cam_cci_init_master(cci_dev, master);
-	if (rc) {
-		CAM_ERR(CAM_CCI, "Failed to init: Master: %d, rc: %d",
-			master, rc);
-		goto reset_complete_failed;
+	for (i = 0; i < NUM_MASTERS; i++) {
+		for (j = 0; j < NUM_QUEUES; j++) {
+			if (j == QUEUE_0)
+				cci_dev->cci_i2c_queue_info[i][j].max_queue_size
+					= CCI_I2C_QUEUE_0_SIZE;
+			else
+				cci_dev->cci_i2c_queue_info[i][j].max_queue_size
+					= CCI_I2C_QUEUE_1_SIZE;
+
+			CAM_DBG(CAM_CCI, "CCI Master[%d] :: Q0 : %d Q1 : %d", i,
+			cci_dev->cci_i2c_queue_info[i][j].max_queue_size,
+			cci_dev->cci_i2c_queue_info[i][j].max_queue_size);
+		}
 	}
 
+	cci_dev->cci_master_info[master].reset_pending = true;
+	cci_dev->cci_master_info[master].status = 0;
+	cam_io_w_mb(CCI_RESET_CMD_RMSK, base +
+			CCI_RESET_CMD_ADDR);
+	cam_io_w_mb(0x1, base + CCI_RESET_CMD_ADDR);
+	rc = wait_for_completion_timeout(
+		&cci_dev->cci_master_info[master].reset_complete,
+		CCI_TIMEOUT);
+	if (rc <= 0) {
+		CAM_ERR(CAM_CCI, "wait_for_completion_timeout");
+		if (rc == 0)
+			rc = -ETIMEDOUT;
+		goto reset_complete_failed;
+	}
 	for (i = 0; i < MASTER_MAX; i++)
 		cci_dev->i2c_freq_mode[i] = I2C_MAX_MODES;
-
-	cam_io_w_mb(CCI_IRQ_MASK_0_RMSK, base + CCI_IRQ_MASK_0_ADDR);
-	cam_io_w_mb(CCI_IRQ_MASK_0_RMSK, base + CCI_IRQ_CLEAR_0_ADDR);
-	cam_io_w_mb(CCI_IRQ_MASK_1_RMSK, base + CCI_IRQ_MASK_1_ADDR);
-	cam_io_w_mb(CCI_IRQ_MASK_1_RMSK, base + CCI_IRQ_CLEAR_1_ADDR);
+	cam_io_w_mb(CCI_IRQ_MASK_0_RMSK,
+		base + CCI_IRQ_MASK_0_ADDR);
+	cam_io_w_mb(CCI_IRQ_MASK_0_RMSK,
+		base + CCI_IRQ_CLEAR_0_ADDR);
+	cam_io_w_mb(CCI_IRQ_MASK_1_RMSK,
+		base + CCI_IRQ_MASK_1_ADDR);
+	cam_io_w_mb(CCI_IRQ_MASK_1_RMSK,
+		base + CCI_IRQ_CLEAR_1_ADDR);
 	cam_io_w_mb(0x1, base + CCI_IRQ_GLOBAL_CLEAR_CMD_ADDR);
 
+	for (i = 0; i < MASTER_MAX; i++) {
+		if (!cci_dev->write_wq[i]) {
+			CAM_ERR(CAM_CCI, "Failed to flush write wq");
+			rc = -ENOMEM;
+			goto reset_complete_failed;
+		} else {
+			flush_workqueue(cci_dev->write_wq[i]);
+		}
+	}
+
 	/* Set RD FIFO threshold for M0 & M1 */
 	cam_io_w_mb(CCI_I2C_RD_THRESHOLD_VALUE,
-			base + CCI_I2C_M0_RD_THRESHOLD_ADDR);
+		base + CCI_I2C_M0_RD_THRESHOLD_ADDR);
 	cam_io_w_mb(CCI_I2C_RD_THRESHOLD_VALUE,
-			base + CCI_I2C_M1_RD_THRESHOLD_ADDR);
+		base + CCI_I2C_M1_RD_THRESHOLD_ADDR);
 
 	cci_dev->cci_state = CCI_STATE_ENABLED;
 
@@ -191,6 +181,7 @@ int cam_cci_init(struct v4l2_subdev *sd,
 
 reset_complete_failed:
 	cam_soc_util_disable_platform_resource(soc_info, 1, 1);
+
 platform_enable_failed:
 	cci_dev->ref_count--;
 	cam_cpas_stop(cci_dev->cpas_handle);
@@ -210,13 +201,12 @@ static void cam_cci_init_cci_params(struct cci_device *new_cci_dev)
 {
 	uint8_t i = 0, j = 0;
 
-	for (i = 0; i < MASTER_MAX; i++) {
+	for (i = 0; i < NUM_MASTERS; i++) {
 		new_cci_dev->cci_master_info[i].status = 0;
-		new_cci_dev->cci_master_info[i].is_initilized = false;
-		new_cci_dev->cci_master_info[i].freq_ref_cnt = 0;
+		new_cci_dev->cci_master_info[i].is_first_req = true;
 		mutex_init(&new_cci_dev->cci_master_info[i].mutex);
 		sema_init(&new_cci_dev->cci_master_info[i].master_sem, 1);
-		spin_lock_init(&new_cci_dev->cci_master_info[i].freq_cnt_lock);
+		spin_lock_init(&new_cci_dev->cci_master_info[i].freq_cnt);
 		init_completion(
 			&new_cci_dev->cci_master_info[i].reset_complete);
 		init_completion(
@@ -392,38 +382,27 @@ int cam_cci_parse_dt_info(struct platform_device *pdev,
 	return 0;
 }
 
-int cam_cci_soc_release(struct cci_device *cci_dev,
-	enum cci_i2c_master_t master)
+int cam_cci_soc_release(struct cci_device *cci_dev)
 {
 	uint8_t i = 0, rc = 0;
-	struct cam_hw_soc_info *soc_info = &cci_dev->soc_info;
+	struct cam_hw_soc_info *soc_info =
+		&cci_dev->soc_info;
 
-	if (!cci_dev->ref_count || cci_dev->cci_state != CCI_STATE_ENABLED ||
-			!cci_dev->master_active_slave[master]) {
-		CAM_ERR(CAM_CCI,
-			"invalid cci_dev_ref count %u | cci state %d | master_ref_count %u",
-			cci_dev->ref_count, cci_dev->cci_state,
-			cci_dev->master_active_slave[master]);
+	if (!cci_dev->ref_count || cci_dev->cci_state != CCI_STATE_ENABLED) {
+		CAM_ERR(CAM_CCI, "invalid ref count %d / cci state %d",
+			cci_dev->ref_count, cci_dev->cci_state);
 		return -EINVAL;
 	}
-
-	if (!(--cci_dev->master_active_slave[master])) {
-		cci_dev->cci_master_info[master].is_initilized = false;
-		CAM_DBG(CAM_CCI,
-			"All submodules are released for master: %d", master);
-	}
-
 	if (--cci_dev->ref_count) {
-		CAM_DBG(CAM_CCI, "Submodule release: Ref_count: %d",
-			cci_dev->ref_count);
+		CAM_DBG(CAM_CCI, "ref_count Exit %d", cci_dev->ref_count);
 		return 0;
 	}
-
-	for (i = 0; i < MASTER_MAX; i++) {
+	for (i = 0; i < MASTER_MAX; i++)
 		if (cci_dev->write_wq[i])
 			flush_workqueue(cci_dev->write_wq[i]);
+
+	for (i = 0; i < MASTER_MAX; i++)
 		cci_dev->i2c_freq_mode[i] = I2C_MAX_MODES;
-	}
 
 	rc = cam_soc_util_disable_platform_resource(soc_info, true, true);
 	if (rc) {
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.h b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.h
index de1b20e6a74a..f0cdfe822cd3 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_cci/cam_cci_soc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CCI_SOC_H_
@@ -23,8 +23,7 @@ int cam_cci_init(struct v4l2_subdev *sd,
  *
  * This API releases the CCI and its SOC resources
  */
-int cam_cci_soc_release(struct cci_device *cci_dev,
-	enum cci_i2c_master_t master);
+int cam_cci_soc_release(struct cci_device *cci_dev);
 
 /**
  * @pdev: Platform device
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_core.c b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
index b4ebae694ef3..e4dea8ecd9ab 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -23,8 +23,6 @@
 #define LANE_MASK_2PH 0x1F
 #define LANE_MASK_3PH 0x7
 
-#define SKEW_CAL_MASK 0x2
-
 static int csiphy_dump;
 module_param(csiphy_dump, int, 0644);
 
@@ -33,14 +31,14 @@ static int cam_csiphy_notify_secure_mode(struct csiphy_device *csiphy_dev,
 {
 	struct scm_desc desc = {0};
 
-	if (offset >= CSIPHY_MAX_INSTANCES_PER_PHY) {
+	if (offset >= CSIPHY_MAX_INSTANCES) {
 		CAM_ERR(CAM_CSIPHY, "Invalid CSIPHY offset");
 		return -EINVAL;
 	}
 
 	desc.arginfo = SCM_ARGS(2, SCM_VAL, SCM_VAL);
 	desc.args[0] = protect;
-	desc.args[1] = csiphy_dev->csiphy_info[offset].csiphy_cpas_cp_reg_mask;
+	desc.args[1] = csiphy_dev->csiphy_cpas_cp_reg_mask[offset];
 
 	if (scm_call2(SCM_SIP_FNID(SCM_SVC_CAMERASS, SECURE_SYSCALL_ID_2),
 		&desc)) {
@@ -55,21 +53,17 @@ int32_t cam_csiphy_get_instance_offset(
 	struct csiphy_device *csiphy_dev,
 	int32_t dev_handle)
 {
-	int32_t i = 0;
+	int32_t i;
 
-	if ((csiphy_dev->acquire_count >
-		csiphy_dev->session_max_device_support) ||
-		(csiphy_dev->acquire_count < 0)) {
-		CAM_ERR(CAM_CSIPHY,
-			"Invalid acquire count: %d, Max supported device for session: %u",
-			csiphy_dev->acquire_count,
-			csiphy_dev->session_max_device_support);
+	if (csiphy_dev->acquire_count >
+		CSIPHY_MAX_INSTANCES) {
+		CAM_ERR(CAM_CSIPHY, "Invalid acquire count");
 		return -EINVAL;
 	}
 
 	for (i = 0; i < csiphy_dev->acquire_count; i++) {
 		if (dev_handle ==
-			csiphy_dev->csiphy_info[i].hdl_data.device_hdl)
+			csiphy_dev->bridge_intf.device_hdl[i])
 			break;
 	}
 
@@ -109,114 +103,57 @@ void cam_csiphy_reset(struct csiphy_device *csiphy_dev)
 }
 
 int32_t cam_csiphy_update_secure_info(
-	struct csiphy_device *csiphy_dev, int32_t index)
+	struct csiphy_device *csiphy_dev,
+	struct cam_csiphy_info  *cam_cmd_csiphy_info,
+	struct cam_config_dev_cmd *cfg_dev)
 {
-	uint32_t adj_lane_mask = 0;
-	uint16_t lane_assign = 0;
-	uint8_t lane_cnt = 0;
+	uint32_t clock_lane, adj_lane_mask, temp;
+	int32_t offset;
 
-	lane_assign = csiphy_dev->csiphy_info[index].lane_assign;
-	lane_cnt = csiphy_dev->csiphy_info[index].lane_cnt;
+	if (csiphy_dev->acquire_count >=
+		CSIPHY_MAX_INSTANCES) {
+		CAM_ERR(CAM_CSIPHY, "Invalid acquire count");
+		return -EINVAL;
+	}
 
-	while (lane_cnt--) {
-		if ((lane_assign & 0xF) == 0x0)
-			adj_lane_mask |= 0x1;
-		else
-			adj_lane_mask |= (1 << (lane_assign & 0xF));
+	offset = cam_csiphy_get_instance_offset(csiphy_dev,
+		cfg_dev->dev_handle);
+	if (offset < 0 || offset >= CSIPHY_MAX_INSTANCES) {
+		CAM_ERR(CAM_CSIPHY, "Invalid offset");
+		return -EINVAL;
+	}
 
-		lane_assign >>= 4;
-		}
+	if (cam_cmd_csiphy_info->combo_mode)
+		clock_lane =
+			csiphy_dev->ctrl_reg->csiphy_reg.csiphy_2ph_combo_ck_ln;
+	else
+		clock_lane =
+			csiphy_dev->ctrl_reg->csiphy_reg.csiphy_2ph_clock_lane;
+
+	adj_lane_mask = cam_cmd_csiphy_info->lane_mask & LANE_MASK_2PH &
+		~clock_lane;
+	temp = adj_lane_mask & (clock_lane - 1);
+	adj_lane_mask =
+		((adj_lane_mask & (~(clock_lane - 1))) >> 1) | temp;
 
-	/* Logic to identify the secure bit */
-	csiphy_dev->csiphy_info[index].csiphy_cpas_cp_reg_mask =
+	if (cam_cmd_csiphy_info->csiphy_3phase)
+		adj_lane_mask = cam_cmd_csiphy_info->lane_mask & LANE_MASK_3PH;
+
+	csiphy_dev->csiphy_info.secure_mode[offset] = 1;
+
+	csiphy_dev->csiphy_cpas_cp_reg_mask[offset] =
 		adj_lane_mask << (csiphy_dev->soc_info.index *
 		(CAM_CSIPHY_MAX_DPHY_LANES + CAM_CSIPHY_MAX_CPHY_LANES) +
-		(!csiphy_dev->csiphy_info[index].csiphy_3phase) *
+		(!cam_cmd_csiphy_info->csiphy_3phase) *
 		(CAM_CSIPHY_MAX_CPHY_LANES));
 
-	CAM_DBG(CAM_CSIPHY, "csi phy idx:%d, cp_reg_mask:0x%lx",
-		csiphy_dev->soc_info.index,
-		csiphy_dev->csiphy_info[index].csiphy_cpas_cp_reg_mask);
-
 	return 0;
 }
 
-static int cam_csiphy_get_lane_enable(
-	struct csiphy_device *csiphy, int index, uint32_t *lane_enable)
-{
-	uint32_t lane_select = 0;
-	uint16_t lane_assign = csiphy->csiphy_info[index].lane_assign;
-	uint8_t lane_cnt = csiphy->csiphy_info[index].lane_cnt;
-	int rc = 0;
-
-	while (lane_cnt--) {
-		if (csiphy->csiphy_info[index].csiphy_3phase) {
-			switch (lane_assign & 0xF) {
-			case 0x0:
-				lane_select |= CPHY_LANE_0;
-				break;
-			case 0x1:
-				lane_select |= CPHY_LANE_1;
-				break;
-			case 0x2:
-				lane_select |= CPHY_LANE_2;
-				break;
-			default:
-				CAM_ERR(CAM_CSIPHY,
-					"Wrong lane configuration for CPHY : %d",
-					lane_assign);
-				*lane_enable = 0;
-				return -EINVAL;
-			}
-		} else {
-			switch (lane_assign & 0xF) {
-			case 0x0:
-				lane_select |= DPHY_LANE_0;
-				lane_select |= DPHY_CLK_LN;
-				break;
-			case 0x1:
-				lane_select |= DPHY_LANE_1;
-				lane_select |= DPHY_CLK_LN;
-				break;
-			case 0x2:
-				lane_select |= DPHY_LANE_2;
-				if (csiphy->combo_mode)
-					lane_select |= DPHY_LANE_3;
-				else
-					lane_select |= DPHY_CLK_LN;
-				break;
-			case 0x3:
-				if (csiphy->combo_mode) {
-					CAM_ERR(CAM_CSIPHY,
-						"Wrong lane configuration for DPHYCombo: %d",
-						lane_assign);
-					*lane_enable = 0;
-					return -EINVAL;
-				}
-				lane_select |= DPHY_LANE_3;
-				lane_select |= DPHY_CLK_LN;
-				break;
-			default:
-				CAM_ERR(CAM_CSIPHY,
-					"Wrong lane configuration for DPHY: %d",
-					lane_assign);
-				*lane_enable = 0;
-				return -EINVAL;
-			}
-		}
-		lane_assign >>= 4;
-	}
-
-	CAM_DBG(CAM_CSIPHY, "Lane_enable: 0x%x", lane_enable);
-	*lane_enable = lane_select;
-
-	return rc;
-}
-
 int32_t cam_cmd_buf_parser(struct csiphy_device *csiphy_dev,
 	struct cam_config_dev_cmd *cfg_dev)
 {
-	int                      rc = 0;
+	int32_t                 rc = 0;
 	uintptr_t                generic_ptr;
 	uintptr_t                generic_pkt_ptr;
 	struct cam_packet       *csl_packet = NULL;
@@ -225,8 +162,6 @@ int32_t cam_cmd_buf_parser(struct csiphy_device *csiphy_dev,
 	struct cam_csiphy_info  *cam_cmd_csiphy_info = NULL;
 	size_t                  len;
 	size_t                  remain_len;
-	int                     index;
-	uint32_t                lane_enable = 0;
 
 	if (!cfg_dev || !csiphy_dev) {
 		CAM_ERR(CAM_CSIPHY, "Invalid Args");
@@ -285,82 +220,28 @@ int32_t cam_cmd_buf_parser(struct csiphy_device *csiphy_dev,
 	cmd_buf += cmd_desc->offset / 4;
 	cam_cmd_csiphy_info = (struct cam_csiphy_info *)cmd_buf;
 
-	index = cam_csiphy_get_instance_offset(csiphy_dev, cfg_dev->dev_handle);
-	if (index < 0 || index  >= csiphy_dev->session_max_device_support) {
-		CAM_ERR(CAM_CSIPHY, "index is invalid: %d", index);
-		return -EINVAL;
-	}
-
-	csiphy_dev->csiphy_info[index].lane_cnt = cam_cmd_csiphy_info->lane_cnt;
-	csiphy_dev->csiphy_info[index].lane_assign =
-		cam_cmd_csiphy_info->lane_assign;
-
-	csiphy_dev->csiphy_info[index].settle_time =
-		cam_cmd_csiphy_info->settle_time;
-	csiphy_dev->csiphy_info[index].data_rate =
-		cam_cmd_csiphy_info->data_rate;
-	csiphy_dev->csiphy_info[index].secure_mode =
-		cam_cmd_csiphy_info->secure_mode;
-	csiphy_dev->csiphy_info[index].mipi_flags =
-		cam_cmd_csiphy_info->mipi_flags;
-	csiphy_dev->csiphy_info[index].csiphy_3phase =
+	csiphy_dev->config_count++;
+	csiphy_dev->csiphy_info.lane_cnt += cam_cmd_csiphy_info->lane_cnt;
+	csiphy_dev->csiphy_info.lane_mask |= cam_cmd_csiphy_info->lane_mask;
+	csiphy_dev->csiphy_info.csiphy_3phase =
 		cam_cmd_csiphy_info->csiphy_3phase;
-
-	rc = cam_csiphy_get_lane_enable(csiphy_dev, index, &lane_enable);
-	if (rc) {
-		CAM_ERR(CAM_CSIPHY, "Wrong lane configuration: %d",
-			csiphy_dev->csiphy_info[index].lane_assign);
-		if (csiphy_dev->combo_mode) {
-			CAM_DBG(CAM_CSIPHY,
-				"Resetting error to zero for other devices to configure");
-			rc = 0;
-		}
-		lane_enable = 0;
-		csiphy_dev->csiphy_info[index].lane_enable = lane_enable;
-		goto reset_settings;
+	csiphy_dev->csiphy_info.combo_mode |= cam_cmd_csiphy_info->combo_mode;
+	if (cam_cmd_csiphy_info->combo_mode == 1) {
+		csiphy_dev->csiphy_info.settle_time_combo_sensor =
+			cam_cmd_csiphy_info->settle_time;
+		csiphy_dev->csiphy_info.data_rate_combo_sensor =
+			cam_cmd_csiphy_info->data_rate;
+	} else {
+		csiphy_dev->csiphy_info.settle_time =
+			cam_cmd_csiphy_info->settle_time;
+		csiphy_dev->csiphy_info.data_rate =
+			cam_cmd_csiphy_info->data_rate;
 	}
 
-	csiphy_dev->csiphy_info[index].lane_enable = lane_enable;
 
 	if (cam_cmd_csiphy_info->secure_mode == 1)
 		cam_csiphy_update_secure_info(csiphy_dev,
-			index);
-
-	csiphy_dev->config_count++;
-
-	CAM_DBG(CAM_CSIPHY,
-		"phy version:%d, phy_idx: %d",
-		csiphy_dev->hw_version,
-		csiphy_dev->soc_info.index);
-	CAM_DBG(CAM_CSIPHY,
-		"phy_idx: %d, 3phase:%d, combo mode:%d, secure mode:%d",
-		csiphy_dev->soc_info.index,
-		csiphy_dev->csiphy_info[index].csiphy_3phase,
-		csiphy_dev->combo_mode,
-		cam_cmd_csiphy_info->secure_mode);
-	CAM_DBG(CAM_CSIPHY,
-		"lane_cnt: 0x%x, lane_assign: 0x%x, lane_enable: 0x%x",
-		csiphy_dev->csiphy_info[index].lane_cnt,
-		csiphy_dev->csiphy_info[index].lane_assign,
-		csiphy_dev->csiphy_info[index].lane_enable);
-
-	CAM_DBG(CAM_CSIPHY,
-		"settle time:%llu, datarate:%llu, mipi flags: 0x%x",
-		csiphy_dev->csiphy_info[index].settle_time,
-		csiphy_dev->csiphy_info[index].data_rate,
-		csiphy_dev->csiphy_info[index].mipi_flags);
-
-	return rc;
-
-reset_settings:
-	csiphy_dev->csiphy_info[index].lane_cnt = 0;
-	csiphy_dev->csiphy_info[index].lane_assign = 0;
-	csiphy_dev->csiphy_info[index].lane_enable = 0;
-	csiphy_dev->csiphy_info[index].settle_time = 0;
-	csiphy_dev->csiphy_info[index].data_rate = 0;
-	csiphy_dev->csiphy_info[index].mipi_flags = 0;
-	csiphy_dev->csiphy_info[index].secure_mode = 0;
-	csiphy_dev->csiphy_info[index].hdl_data.device_hdl = -1;
+			cam_cmd_csiphy_info, cfg_dev);
 
 	return rc;
 }
@@ -378,8 +259,7 @@ void cam_csiphy_cphy_irq_config(struct csiphy_device *csiphy_dev)
 			csiphy_dev->ctrl_reg->csiphy_irq_reg[i].reg_addr);
 }
 
-static void cam_csiphy_cphy_data_rate_config(
-	struct csiphy_device *csiphy_device, int32_t idx)
+void cam_csiphy_cphy_data_rate_config(struct csiphy_device *csiphy_device)
 {
 	int i = 0, j = 0;
 	uint64_t phy_data_rate = 0;
@@ -395,7 +275,7 @@ static void cam_csiphy_cphy_data_rate_config(
 		return;
 	}
 
-	phy_data_rate = csiphy_device->csiphy_info[idx].data_rate;
+	phy_data_rate = csiphy_device->csiphy_info.data_rate;
 	csiphybase =
 		csiphy_device->soc_info.reg_map[0].mem_base;
 	settings_table =
@@ -488,100 +368,78 @@ irqreturn_t cam_csiphy_irq(int irq_num, void *data)
 	return IRQ_HANDLED;
 }
 
-int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
-	int32_t dev_handle)
+int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev)
 {
 	int32_t      rc = 0;
-	uint32_t     lane_enable = 0;
-	uint32_t     size = 0;
-	uint16_t     i = 0, cfg_size = 0;
-	uint16_t     lane_assign = 0;
-	uint8_t      lane_cnt;
-	int          max_lanes = 0;
+	uint32_t     lane_enable = 0, mask = 1, size = 0;
+	uint16_t     lane_mask = 0, i = 0, cfg_size = 0, temp = 0;
+	uint8_t      lane_cnt, lane_pos = 0;
 	uint16_t     settle_cnt = 0;
 	uint64_t     intermediate_var;
-	uint8_t      skew_cal_enable = 0;
-	uint8_t      lane_pos = 0;
-	int          index;
 	void __iomem *csiphybase;
 	struct csiphy_reg_t *csiphy_common_reg = NULL;
 	struct csiphy_reg_t (*reg_array)[MAX_SETTINGS_PER_LANE];
-	bool         is_3phase = false;
+
+	lane_cnt = csiphy_dev->csiphy_info.lane_cnt;
 	csiphybase = csiphy_dev->soc_info.reg_map[0].mem_base;
 
-	CAM_DBG(CAM_CSIPHY, "ENTER");
 	if (!csiphybase) {
 		CAM_ERR(CAM_CSIPHY, "csiphybase NULL");
 		return -EINVAL;
 	}
 
-	index = cam_csiphy_get_instance_offset(csiphy_dev, dev_handle);
-	if (index < 0 || index >= csiphy_dev->session_max_device_support) {
-		CAM_ERR(CAM_CSIPHY, "index is invalid: %d", index);
-		return -EINVAL;
-	}
-
-	CAM_DBG(CAM_CSIPHY,
-		"Index: %d: expected dev_hdl: 0x%x : derived dev_hdl: 0x%x",
-			index, dev_handle,
-			csiphy_dev->csiphy_info[index].hdl_data.device_hdl);
-	csiphy_dev->num_irq_registers = 11;
-
-	if (csiphy_dev->csiphy_info[index].csiphy_3phase)
-		is_3phase = true;
-
-	if (csiphy_dev->combo_mode) {
-		if (is_3phase) {
-			if (csiphy_dev->ctrl_reg->csiphy_2ph_3ph_mode_reg) {
-				reg_array = csiphy_dev->ctrl_reg
-					->csiphy_2ph_3ph_mode_reg;
-			} else {
-				CAM_WARN(CAM_CSIPHY,
-					"CPHY combo mode reg settings not found");
+	if (!csiphy_dev->csiphy_info.csiphy_3phase) {
+		if (csiphy_dev->csiphy_info.combo_mode == 1)
+			reg_array =
+				csiphy_dev->ctrl_reg->csiphy_2ph_combo_mode_reg;
+		else
+			reg_array =
+				csiphy_dev->ctrl_reg->csiphy_2ph_reg;
+		csiphy_dev->num_irq_registers = 11;
+		cfg_size =
+		csiphy_dev->ctrl_reg->csiphy_reg.csiphy_2ph_config_array_size;
+
+		lane_mask = csiphy_dev->csiphy_info.lane_mask & LANE_MASK_2PH;
+		for (i = 0; i < MAX_DPHY_DATA_LN; i++) {
+			if (mask == 0x2) {
+				if (lane_mask & mask)
+					lane_enable |= 0x80;
+				i--;
+			} else if (lane_mask & mask) {
+				lane_enable |= 0x1 << (i<<1);
+			}
+			mask <<= 1;
+		}
+	} else {
+		if (csiphy_dev->csiphy_info.combo_mode == 1) {
+			if (csiphy_dev->ctrl_reg->csiphy_2ph_3ph_mode_reg)
+				reg_array =
+				csiphy_dev->ctrl_reg->csiphy_2ph_3ph_mode_reg;
+			else {
 				reg_array =
 					csiphy_dev->ctrl_reg->csiphy_3ph_reg;
+				CAM_ERR(CAM_CSIPHY,
+					"Unsupported configuration, Falling back to CPHY mode");
 			}
-			cfg_size = csiphy_dev->ctrl_reg->csiphy_reg
-				.csiphy_3ph_config_array_size;
-			max_lanes = CAM_CSIPHY_MAX_CPHY_LANES;
-		} else {
-			/* DPHY combo mode*/
-			if (csiphy_dev->ctrl_reg->csiphy_2ph_combo_mode_reg) {
-				reg_array = csiphy_dev
-					->ctrl_reg->csiphy_2ph_combo_mode_reg;
-			} else {
-				CAM_WARN(CAM_CSIPHY,
-					"DPHY combo mode reg settings not found");
-				reg_array = csiphy_dev
-					->ctrl_reg->csiphy_2ph_reg;
-			}
-			cfg_size = csiphy_dev->ctrl_reg->csiphy_reg
-					.csiphy_2ph_config_array_size;
-			max_lanes = MAX_LANES;
-		}
+		} else
+			reg_array =
+				csiphy_dev->ctrl_reg->csiphy_3ph_reg;
+		csiphy_dev->num_irq_registers = 11;
+		cfg_size =
+		csiphy_dev->ctrl_reg->csiphy_reg.csiphy_3ph_config_array_size;
 
-		skew_cal_enable = csiphy_dev->csiphy_info[index].mipi_flags &
-			SKEW_CAL_MASK;
-	} else {
-		/* for CPHY(3Phase) or DPHY(2Phase) Non combe mode selection */
-		if (is_3phase) {
-			reg_array = csiphy_dev->ctrl_reg->csiphy_3ph_reg;
-			max_lanes = CAM_CSIPHY_MAX_CPHY_LANES;
-			cfg_size = csiphy_dev->ctrl_reg->csiphy_reg
-				.csiphy_3ph_config_array_size;
-		} else {
-			reg_array = csiphy_dev->ctrl_reg->csiphy_2ph_reg;
-			cfg_size = csiphy_dev->ctrl_reg->csiphy_reg
-				.csiphy_2ph_config_array_size;
-			max_lanes = MAX_LANES;
+		lane_mask = csiphy_dev->csiphy_info.lane_mask & LANE_MASK_3PH;
+		mask = lane_mask;
+		while (mask != 0) {
+			temp = (i << 1)+1;
+			lane_enable |= ((mask & 0x1) << temp);
+			mask >>= 1;
+			i++;
 		}
 	}
 
-	lane_cnt = csiphy_dev->csiphy_info[index].lane_cnt;
-	lane_assign = csiphy_dev->csiphy_info[index].lane_assign;
-	lane_enable = csiphy_dev->csiphy_info[index].lane_enable;
-
 	size = csiphy_dev->ctrl_reg->csiphy_reg.csiphy_common_array_size;
+
 	for (i = 0; i < size; i++) {
 		csiphy_common_reg = &csiphy_dev->ctrl_reg->csiphy_common_reg[i];
 		switch (csiphy_common_reg->csiphy_param_type) {
@@ -598,7 +456,7 @@ int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
 				csiphy_common_reg->delay * 1000 + 10);
 			break;
 		case CSIPHY_2PH_REGS:
-			if (!is_3phase) {
+			if (!csiphy_dev->csiphy_info.csiphy_3phase) {
 				cam_io_w_mb(csiphy_common_reg->reg_data,
 					csiphybase +
 					csiphy_common_reg->reg_addr);
@@ -607,7 +465,7 @@ int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
 			}
 			break;
 		case CSIPHY_3PH_REGS:
-			if (is_3phase) {
+			if (csiphy_dev->csiphy_info.csiphy_3phase) {
 				cam_io_w_mb(csiphy_common_reg->reg_data,
 					csiphybase +
 					csiphy_common_reg->reg_addr);
@@ -620,12 +478,23 @@ int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
 		}
 	}
 
-	intermediate_var = csiphy_dev->csiphy_info[index].settle_time;
-	do_div(intermediate_var, 200000000);
-	settle_cnt = intermediate_var;
+	while (lane_mask) {
+		if (!(lane_mask & 0x1)) {
+			lane_pos++;
+			lane_mask >>= 1;
+			continue;
+		}
 
-	for (lane_pos = 0; lane_pos < max_lanes; lane_pos++) {
-		CAM_DBG(CAM_CSIPHY, "lane_pos: %d is configuring", lane_pos);
+		intermediate_var = csiphy_dev->csiphy_info.settle_time;
+		do_div(intermediate_var, 200000000);
+		settle_cnt = intermediate_var;
+		if (csiphy_dev->csiphy_info.combo_mode == 1 &&
+			(lane_pos >= 3)) {
+			intermediate_var =
+			csiphy_dev->csiphy_info.settle_time_combo_sensor;
+			do_div(intermediate_var, 200000000);
+			settle_cnt = intermediate_var;
+		}
 		for (i = 0; i < cfg_size; i++) {
 			switch (reg_array[lane_pos][i].csiphy_param_type) {
 			case CSIPHY_LANE_ENABLE:
@@ -648,12 +517,6 @@ int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
 					csiphybase +
 					reg_array[lane_pos][i].reg_addr);
 			break;
-			case CSIPHY_SKEW_CAL:
-			if (skew_cal_enable)
-				cam_io_w_mb(reg_array[lane_pos][i].reg_data,
-					csiphybase +
-					reg_array[lane_pos][i].reg_addr);
-			break;
 			default:
 				CAM_DBG(CAM_CSIPHY, "Do Nothing");
 			break;
@@ -663,10 +526,12 @@ int32_t cam_csiphy_config_dev(struct csiphy_device *csiphy_dev,
 					reg_array[lane_pos][i].delay*1000 + 10);
 			}
 		}
+		lane_mask >>= 1;
+		lane_pos++;
 	}
 
-	if (csiphy_dev->csiphy_info[index].csiphy_3phase)
-		cam_csiphy_cphy_data_rate_config(csiphy_dev, index);
+	if (csiphy_dev->csiphy_info.csiphy_3phase)
+		cam_csiphy_cphy_data_rate_config(csiphy_dev);
 
 	cam_csiphy_cphy_irq_config(csiphy_dev);
 
@@ -681,31 +546,19 @@ void cam_csiphy_shutdown(struct csiphy_device *csiphy_dev)
 	if (csiphy_dev->csiphy_state == CAM_CSIPHY_INIT)
 		return;
 
-	if (!csiphy_dev->acquire_count)
-		return;
-
-	if (csiphy_dev->acquire_count >= CSIPHY_MAX_INSTANCES_PER_PHY) {
-		CAM_WARN(CAM_CSIPHY, "acquire count is invalid: %u",
-			csiphy_dev->acquire_count);
-		csiphy_dev->acquire_count =
-			CSIPHY_MAX_INSTANCES_PER_PHY;
-	}
-
 	if (csiphy_dev->csiphy_state == CAM_CSIPHY_START) {
 		soc_info = &csiphy_dev->soc_info;
 
 		for (i = 0; i < csiphy_dev->acquire_count; i++) {
-			if (csiphy_dev->csiphy_info[i].secure_mode)
+			if (csiphy_dev->csiphy_info.secure_mode[i])
 				cam_csiphy_notify_secure_mode(
 					csiphy_dev,
 					CAM_SECURE_MODE_NON_SECURE, i);
 
-			csiphy_dev->csiphy_info[i].secure_mode =
+			csiphy_dev->csiphy_info.secure_mode[i] =
 				CAM_SECURE_MODE_NON_SECURE;
 
-			csiphy_dev->csiphy_info[i].csiphy_cpas_cp_reg_mask = 0;
-			csiphy_dev->csiphy_info[i].settle_time = 0;
-			csiphy_dev->csiphy_info[i].data_rate = 0;
+			csiphy_dev->csiphy_cpas_cp_reg_mask[i] = 0;
 		}
 
 		cam_csiphy_reset(csiphy_dev);
@@ -716,18 +569,22 @@ void cam_csiphy_shutdown(struct csiphy_device *csiphy_dev)
 	}
 
 	if (csiphy_dev->csiphy_state == CAM_CSIPHY_ACQUIRE) {
-		for (i = 0; i < csiphy_dev->acquire_count; i++) {
-			if (csiphy_dev->csiphy_info[i].hdl_data.device_hdl
-				!= -1)
-				cam_destroy_device_hdl(
-				csiphy_dev->csiphy_info[i]
-				.hdl_data.device_hdl);
-			csiphy_dev->csiphy_info[i].hdl_data.device_hdl = -1;
-		csiphy_dev->csiphy_info[i].hdl_data.session_hdl = -1;
-		}
+		if (csiphy_dev->bridge_intf.device_hdl[0] != -1)
+			cam_destroy_device_hdl(
+				csiphy_dev->bridge_intf.device_hdl[0]);
+		if (csiphy_dev->bridge_intf.device_hdl[1] != -1)
+			cam_destroy_device_hdl(
+				csiphy_dev->bridge_intf.device_hdl[1]);
+		csiphy_dev->bridge_intf.device_hdl[0] = -1;
+		csiphy_dev->bridge_intf.device_hdl[1] = -1;
+		csiphy_dev->bridge_intf.link_hdl[0] = -1;
+		csiphy_dev->bridge_intf.link_hdl[1] = -1;
+		csiphy_dev->bridge_intf.session_hdl[0] = -1;
+		csiphy_dev->bridge_intf.session_hdl[1] = -1;
 	}
 
 	csiphy_dev->ref_count = 0;
+	csiphy_dev->is_acquired_dev_combo_mode = 0;
 	csiphy_dev->acquire_count = 0;
 	csiphy_dev->start_dev_count = 0;
 	csiphy_dev->csiphy_state = CAM_CSIPHY_INIT;
@@ -738,7 +595,6 @@ static int32_t cam_csiphy_external_cmd(struct csiphy_device *csiphy_dev,
 {
 	struct cam_csiphy_info cam_cmd_csiphy_info;
 	int32_t rc = 0;
-	int32_t  index = -1;
 
 	if (copy_from_user(&cam_cmd_csiphy_info,
 		u64_to_user_ptr(p_submit_cmd->packet_handle),
@@ -746,91 +602,37 @@ static int32_t cam_csiphy_external_cmd(struct csiphy_device *csiphy_dev,
 		CAM_ERR(CAM_CSIPHY, "failed to copy cam_csiphy_info\n");
 		rc = -EFAULT;
 	} else {
-		index = cam_csiphy_get_instance_offset(csiphy_dev,
-			p_submit_cmd->dev_handle);
-		if (index < 0 ||
-			index >= csiphy_dev->session_max_device_support) {
-			CAM_ERR(CAM_CSIPHY, "index is invalid: %d", index);
-			return -EINVAL;
-		}
-
-		csiphy_dev->csiphy_info[index].lane_cnt =
+		csiphy_dev->csiphy_info.lane_cnt =
+			cam_cmd_csiphy_info.lane_cnt;
+		csiphy_dev->csiphy_info.lane_cnt =
 			cam_cmd_csiphy_info.lane_cnt;
-		csiphy_dev->csiphy_info[index].lane_assign =
-			cam_cmd_csiphy_info.lane_assign;
-		csiphy_dev->csiphy_info[index].csiphy_3phase =
+		csiphy_dev->csiphy_info.lane_mask =
+			cam_cmd_csiphy_info.lane_mask;
+		csiphy_dev->csiphy_info.csiphy_3phase =
 			cam_cmd_csiphy_info.csiphy_3phase;
-		csiphy_dev->combo_mode =
+		csiphy_dev->csiphy_info.combo_mode =
 			cam_cmd_csiphy_info.combo_mode;
-		csiphy_dev->csiphy_info[index].settle_time =
+		csiphy_dev->csiphy_info.settle_time =
 			cam_cmd_csiphy_info.settle_time;
-		csiphy_dev->csiphy_info[index].data_rate =
+		csiphy_dev->csiphy_info.data_rate =
 			cam_cmd_csiphy_info.data_rate;
 		CAM_DBG(CAM_CSIPHY,
-			"%s CONFIG_DEV_EXT settle_time= %lld lane_cnt=%d",
+			"%s CONFIG_DEV_EXT settle_time= %lld lane_cnt=%d lane_mask=0x%x",
 			__func__,
-			csiphy_dev->csiphy_info[index].settle_time,
-			csiphy_dev->csiphy_info[index].lane_cnt);
+			csiphy_dev->csiphy_info.settle_time,
+			csiphy_dev->csiphy_info.lane_cnt,
+			csiphy_dev->csiphy_info.lane_mask);
 	}
 
 	return rc;
 }
 
-static int cam_csiphy_update_lane(
-	struct csiphy_device *csiphy, int index, bool enable)
-{
-	int i = 0;
-	uint32_t lane_enable = 0;
-	uint32_t size = 0;
-	uint16_t lane_assign;
-	void __iomem *base_address;
-	struct csiphy_reg_t *csiphy_common_reg = NULL;
-
-	base_address = csiphy->soc_info.reg_map[0].mem_base;
-	size = csiphy->ctrl_reg->csiphy_reg.csiphy_common_array_size;
-
-	for (i = 0; i < size; i++) {
-		csiphy_common_reg = &csiphy->ctrl_reg->csiphy_common_reg[i];
-		switch (csiphy_common_reg->csiphy_param_type) {
-		case CSIPHY_LANE_ENABLE:
-			CAM_DBG(CAM_CSIPHY, "LANE_ENABLE: %d", lane_enable);
-			lane_enable = cam_io_r(base_address +
-				csiphy_common_reg->reg_addr);
-			break;
-		}
-	}
-
-	lane_assign = csiphy->csiphy_info[index].lane_assign;
-
-	if (enable)
-		lane_enable |= csiphy->csiphy_info[index].lane_enable;
-	else
-		lane_enable &= ~csiphy->csiphy_info[index].lane_enable;
-
-	CAM_DBG(CAM_CSIPHY, "lane_assign: 0x%x, lane_enable: 0x%x",
-		lane_assign, lane_enable);
-	for (i = 0; i < size; i++) {
-		csiphy_common_reg = &csiphy->ctrl_reg->csiphy_common_reg[i];
-		switch (csiphy_common_reg->csiphy_param_type) {
-		case CSIPHY_LANE_ENABLE:
-			CAM_DBG(CAM_CSIPHY, "LANE_ENABLE: %d", lane_enable);
-			cam_io_w_mb(lane_enable,
-				base_address + csiphy_common_reg->reg_addr);
-			if (csiphy_common_reg->delay)
-				usleep_range(csiphy_common_reg->delay,
-					csiphy_common_reg->delay + 5);
-			break;
-		}
-	}
-
-	return 0;
-}
-
 int32_t cam_csiphy_core_cfg(void *phy_dev,
 			void *arg)
 {
 	struct csiphy_device *csiphy_dev =
 		(struct csiphy_device *)phy_dev;
+	struct intf_params   *bridge_intf = NULL;
 	struct cam_control   *cmd = (struct cam_control *)arg;
 	int32_t              rc = 0;
 
@@ -851,28 +653,13 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 	case CAM_ACQUIRE_DEV: {
 		struct cam_sensor_acquire_dev csiphy_acq_dev;
 		struct cam_csiphy_acquire_dev_info csiphy_acq_params;
-		int index;
-		struct cam_create_dev_hdl bridge_params;
 
-		CAM_DBG(CAM_CSIPHY, "ACQUIRE_CNT: %d COMBO_MODE: %d",
-			csiphy_dev->acquire_count,
-			csiphy_dev->combo_mode);
-		if ((csiphy_dev->csiphy_state == CAM_CSIPHY_START) &&
-			(csiphy_dev->combo_mode == 0) &&
-			(csiphy_dev->acquire_count > 0)) {
-			CAM_ERR(CAM_CSIPHY,
-				"NonComboMode does not support multiple acquire: Acquire_count: %d",
-				csiphy_dev->acquire_count);
-			rc = -EINVAL;
-			goto release_mutex;
-		}
+		struct cam_create_dev_hdl bridge_params;
 
-		if ((csiphy_dev->acquire_count) &&
-			(csiphy_dev->acquire_count >=
-			csiphy_dev->session_max_device_support)) {
+		if (csiphy_dev->csiphy_state == CAM_CSIPHY_START) {
 			CAM_ERR(CAM_CSIPHY,
-				"Max acquires are allowed in combo mode: %d",
-				csiphy_dev->session_max_device_support);
+				"Not in right state to acquire : %d",
+				csiphy_dev->csiphy_state);
 			rc = -EINVAL;
 			goto release_mutex;
 		}
@@ -895,16 +682,32 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			goto release_mutex;
 		}
 
-		if (csiphy_acq_params.combo_mode == 1) {
-			CAM_DBG(CAM_CSIPHY, "combo mode stream detected");
-			csiphy_dev->combo_mode = 1;
-			csiphy_dev->session_max_device_support =
-					CSIPHY_MAX_INSTANCES_PER_PHY;
+		if (csiphy_dev->acquire_count == 2) {
+			CAM_ERR(CAM_CSIPHY,
+					"CSIPHY device do not allow more than 2 acquires");
+			rc = -EINVAL;
+			goto release_mutex;
 		}
 
-		if (!csiphy_acq_params.combo_mode) {
-			CAM_DBG(CAM_CSIPHY, "Non Combo Mode stream");
-			csiphy_dev->session_max_device_support = 1;
+		if ((csiphy_acq_params.combo_mode == 1) &&
+			(csiphy_dev->is_acquired_dev_combo_mode == 1)) {
+			CAM_ERR(CAM_CSIPHY,
+				"Multiple Combo Acq are not allowed: cm: %d, acm: %d",
+				csiphy_acq_params.combo_mode,
+				csiphy_dev->is_acquired_dev_combo_mode);
+			rc = -EINVAL;
+			goto release_mutex;
+		}
+
+		if ((csiphy_acq_params.combo_mode != 1) &&
+			(csiphy_dev->is_acquired_dev_combo_mode != 1) &&
+			(csiphy_dev->acquire_count == 1)) {
+			CAM_ERR(CAM_CSIPHY,
+				"Multiple Acquires are not allowed cm: %d acm: %d",
+				csiphy_acq_params.combo_mode,
+				csiphy_dev->is_acquired_dev_combo_mode);
+			rc = -EINVAL;
+			goto release_mutex;
 		}
 
 		bridge_params.ops = NULL;
@@ -912,23 +715,22 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 		bridge_params.v4l2_sub_dev_flag = 0;
 		bridge_params.media_entity_flag = 0;
 		bridge_params.priv = csiphy_dev;
-		index = csiphy_dev->acquire_count;
-		csiphy_acq_dev.device_handle =
-			cam_create_device_hdl(&bridge_params);
-		if (csiphy_acq_dev.device_handle <= 0) {
-			rc = -EFAULT;
-			CAM_ERR(CAM_CSIPHY, "Can not create device handle");
+
+		if (csiphy_acq_params.combo_mode >= 2) {
+			CAM_ERR(CAM_CSIPHY, "Invalid combo_mode %d",
+				csiphy_acq_params.combo_mode);
+			rc = -EINVAL;
 			goto release_mutex;
 		}
 
-		csiphy_dev->csiphy_info[index].hdl_data.device_hdl =
-			csiphy_acq_dev.device_handle;
-		csiphy_dev->csiphy_info[index].hdl_data.session_hdl =
+		csiphy_acq_dev.device_handle =
+			cam_create_device_hdl(&bridge_params);
+		bridge_intf = &csiphy_dev->bridge_intf;
+		bridge_intf->device_hdl[csiphy_acq_params.combo_mode]
+			= csiphy_acq_dev.device_handle;
+		bridge_intf->session_hdl[csiphy_acq_params.combo_mode] =
 			csiphy_acq_dev.session_handle;
 
-		CAM_DBG(CAM_CSIPHY, "Add dev_handle:0x%x at index: %d ",
-			csiphy_dev->csiphy_info[index].hdl_data.device_hdl,
-			index);
 		if (copy_to_user(u64_to_user_ptr(cmd->handle),
 				&csiphy_acq_dev,
 				sizeof(struct cam_sensor_acquire_dev))) {
@@ -936,12 +738,11 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			rc = -EINVAL;
 			goto release_mutex;
 		}
+		if (csiphy_acq_params.combo_mode == 1)
+			csiphy_dev->is_acquired_dev_combo_mode = 1;
 
 		csiphy_dev->acquire_count++;
-		CAM_DBG(CAM_CSIPHY, "ACQUIRE_CNT: %d",
-			csiphy_dev->acquire_count);
-		if (csiphy_dev->csiphy_state == CAM_CSIPHY_INIT)
-			csiphy_dev->csiphy_state = CAM_CSIPHY_ACQUIRE;
+		csiphy_dev->csiphy_state = CAM_CSIPHY_ACQUIRE;
 	}
 		break;
 	case CAM_QUERY_CAP: {
@@ -967,7 +768,8 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			goto release_mutex;
 		}
 
-		if (csiphy_dev->csiphy_state != CAM_CSIPHY_START) {
+		if ((csiphy_dev->csiphy_state != CAM_CSIPHY_START) ||
+			!csiphy_dev->start_dev_count) {
 			CAM_ERR(CAM_CSIPHY, "Not in right state to stop : %d",
 				csiphy_dev->csiphy_state);
 			goto release_mutex;
@@ -975,44 +777,35 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 
 		offset = cam_csiphy_get_instance_offset(csiphy_dev,
 			config.dev_handle);
-		if (offset < 0 ||
-			offset >= csiphy_dev->session_max_device_support) {
-			CAM_ERR(CAM_CSIPHY, "Index is invalid: %d", offset);
+		if (offset < 0 || offset >= CSIPHY_MAX_INSTANCES) {
+			CAM_ERR(CAM_CSIPHY, "Invalid offset");
 			goto release_mutex;
 		}
 
-		CAM_INFO(CAM_CSIPHY,
-			"STOP_DEV: CSIPHY_IDX: %d, Device_slot: %d, Datarate: %llu, Settletime: %llu",
-			csiphy_dev->soc_info.index, offset,
-			csiphy_dev->csiphy_info[offset].data_rate,
-			csiphy_dev->csiphy_info[offset].settle_time);
-
 		if (--csiphy_dev->start_dev_count) {
 			CAM_DBG(CAM_CSIPHY, "Stop Dev ref Cnt: %d",
 				csiphy_dev->start_dev_count);
-			if (csiphy_dev->csiphy_info[offset].secure_mode)
+			if (csiphy_dev->csiphy_info.secure_mode[offset])
 				cam_csiphy_notify_secure_mode(
 					csiphy_dev,
 					CAM_SECURE_MODE_NON_SECURE, offset);
 
-			csiphy_dev->csiphy_info[offset].secure_mode =
+			csiphy_dev->csiphy_info.secure_mode[offset] =
 				CAM_SECURE_MODE_NON_SECURE;
-			csiphy_dev->csiphy_info[offset].csiphy_cpas_cp_reg_mask
-				= 0;
+			csiphy_dev->csiphy_cpas_cp_reg_mask[offset] = 0;
 
-			cam_csiphy_update_lane(csiphy_dev, offset, false);
 			goto release_mutex;
 		}
 
-		if (csiphy_dev->csiphy_info[offset].secure_mode)
+		if (csiphy_dev->csiphy_info.secure_mode[offset])
 			cam_csiphy_notify_secure_mode(
 				csiphy_dev,
 				CAM_SECURE_MODE_NON_SECURE, offset);
 
-		csiphy_dev->csiphy_info[offset].secure_mode =
+		csiphy_dev->csiphy_info.secure_mode[offset] =
 			CAM_SECURE_MODE_NON_SECURE;
 
-		csiphy_dev->csiphy_info[offset].csiphy_cpas_cp_reg_mask = 0x0;
+		csiphy_dev->csiphy_cpas_cp_reg_mask[offset] = 0x0;
 
 		rc = cam_csiphy_disable_hw(csiphy_dev);
 		if (rc < 0)
@@ -1022,12 +815,10 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 		if (rc < 0)
 			CAM_ERR(CAM_CSIPHY, "de-voting CPAS: %d", rc);
 
-		CAM_DBG(CAM_CSIPHY, "All PHY devices stopped");
 		csiphy_dev->csiphy_state = CAM_CSIPHY_ACQUIRE;
 	}
 		break;
 	case CAM_RELEASE_DEV: {
-		int32_t offset;
 		struct cam_release_dev_cmd release;
 
 		if (!csiphy_dev->acquire_count) {
@@ -1043,50 +834,35 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			goto release_mutex;
 		}
 
-		offset = cam_csiphy_get_instance_offset(csiphy_dev,
-			release.dev_handle);
-		if (offset < 0 ||
-			offset >= csiphy_dev->session_max_device_support) {
-			CAM_ERR(CAM_CSIPHY, "index is invalid: %d", offset);
-			goto release_mutex;
-		}
-
-		if (csiphy_dev->csiphy_info[offset].secure_mode)
-			cam_csiphy_notify_secure_mode(
-				csiphy_dev,
-				CAM_SECURE_MODE_NON_SECURE, offset);
-
-		csiphy_dev->csiphy_info[offset].secure_mode =
-			CAM_SECURE_MODE_NON_SECURE;
-
-		csiphy_dev->csiphy_cpas_cp_reg_mask[offset] = 0x0;
-
 		rc = cam_destroy_device_hdl(release.dev_handle);
 		if (rc < 0)
 			CAM_ERR(CAM_CSIPHY, "destroying the device hdl");
-		csiphy_dev->csiphy_info[offset].hdl_data.device_hdl = -1;
-		csiphy_dev->csiphy_info[offset].hdl_data.session_hdl = -1;
+		if (release.dev_handle ==
+			csiphy_dev->bridge_intf.device_hdl[0]) {
+			csiphy_dev->bridge_intf.device_hdl[0] = -1;
+			csiphy_dev->bridge_intf.link_hdl[0] = -1;
+			csiphy_dev->bridge_intf.session_hdl[0] = -1;
+		} else {
+			csiphy_dev->bridge_intf.device_hdl[1] = -1;
+			csiphy_dev->bridge_intf.link_hdl[1] = -1;
+			csiphy_dev->bridge_intf.session_hdl[1] = -1;
+			csiphy_dev->is_acquired_dev_combo_mode = 0;
+		}
 
 		csiphy_dev->config_count--;
-		if (csiphy_dev->acquire_count) {
-			csiphy_dev->acquire_count--;
-			CAM_DBG(CAM_CSIPHY, "Acquire_cnt: %d",
-				csiphy_dev->acquire_count);
-		}
+		csiphy_dev->acquire_count--;
 
-		if (csiphy_dev->start_dev_count == 0) {
-			CAM_DBG(CAM_CSIPHY, "All PHY devices released");
+		if (csiphy_dev->acquire_count == 0)
 			csiphy_dev->csiphy_state = CAM_CSIPHY_INIT;
-		}
+
 		if (csiphy_dev->config_count == 0) {
 			CAM_DBG(CAM_CSIPHY, "reset csiphy_info");
-			csiphy_dev->csiphy_info[offset].lane_cnt = 0;
-			csiphy_dev->csiphy_info[offset].lane_assign = 0;
-			csiphy_dev->csiphy_info[offset].csiphy_3phase = -1;
-			csiphy_dev->combo_mode = 0;
+			csiphy_dev->csiphy_info.lane_mask = 0;
+			csiphy_dev->csiphy_info.lane_cnt = 0;
+			csiphy_dev->csiphy_info.combo_mode = 0;
 		}
-		break;
 	}
+		break;
 	case CAM_CONFIG_DEV: {
 		struct cam_config_dev_cmd config;
 
@@ -1108,7 +884,6 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 		struct cam_axi_vote axi_vote = {0};
 		struct cam_start_stop_dev_cmd config;
 		int32_t offset;
-		int clk_vote_level = -1;
 
 		rc = copy_from_user(&config, (void __user *)cmd->handle,
 			sizeof(config));
@@ -1117,86 +892,18 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			goto release_mutex;
 		}
 
-		if ((csiphy_dev->csiphy_state == CAM_CSIPHY_START) &&
-			(csiphy_dev->start_dev_count >
-			csiphy_dev->session_max_device_support)) {
-			CAM_ERR(CAM_CSIPHY,
-				"Invalid start count: %d, Max supported devices: %u",
-				csiphy_dev->start_dev_count,
-				csiphy_dev->session_max_device_support);
-			rc = -EINVAL;
+		if (csiphy_dev->csiphy_state == CAM_CSIPHY_START) {
+			csiphy_dev->start_dev_count++;
 			goto release_mutex;
 		}
 
 		offset = cam_csiphy_get_instance_offset(csiphy_dev,
 			config.dev_handle);
-		if (offset < 0 ||
-			offset >= csiphy_dev->session_max_device_support) {
-			CAM_ERR(CAM_CSIPHY, "index is invalid: %d", offset);
+		if (offset < 0 || offset >= CSIPHY_MAX_INSTANCES) {
+			CAM_ERR(CAM_CSIPHY, "Invalid offset");
 			goto release_mutex;
 		}
 
-		CAM_INFO(CAM_CSIPHY,
-			"START_DEV: CSIPHY_IDX: %d, Device_slot: %d, Datarate: %llu, Settletime: %llu",
-			csiphy_dev->soc_info.index, offset,
-			csiphy_dev->csiphy_info[offset].data_rate,
-			csiphy_dev->csiphy_info[offset].settle_time);
-
-		if (csiphy_dev->start_dev_count) {
-			clk_vote_level =
-				csiphy_dev->ctrl_reg->getclockvoting(
-					csiphy_dev, offset);
-			rc = cam_soc_util_set_clk_rate_level(
-				&csiphy_dev->soc_info, clk_vote_level);
-			if (rc) {
-				CAM_WARN(CAM_CSIPHY,
-					"Failed to set the clk_rate level: %d",
-					clk_vote_level);
-				rc = 0;
-			}
-
-			if (csiphy_dev->csiphy_info[offset].secure_mode == 1) {
-				if (cam_cpas_is_feature_supported(
-					CAM_CPAS_SECURE_CAMERA_ENABLE) != 1) {
-					CAM_WARN(CAM_CSIPHY,
-						"sec_cam: camera fuse bit not set");
-					rc = 0;
-					goto release_mutex;
-				}
-
-				rc = cam_csiphy_notify_secure_mode(csiphy_dev,
-					CAM_SECURE_MODE_SECURE, offset);
-				if (rc < 0) {
-					csiphy_dev->csiphy_info[offset]
-						.secure_mode =
-						CAM_SECURE_MODE_NON_SECURE;
-					CAM_WARN(CAM_CSIPHY,
-						"sec_cam: notify failed: rc: %d",
-						rc);
-					rc = 0;
-					goto release_mutex;
-				}
-			}
-			if (csiphy_dev->csiphy_info[offset].csiphy_3phase)
-				cam_csiphy_cphy_data_rate_config(
-					csiphy_dev, offset);
-
-			rc = cam_csiphy_update_lane(csiphy_dev, offset, true);
-			if (csiphy_dump == 1)
-				cam_csiphy_mem_dmp(&csiphy_dev->soc_info);
-			if (rc) {
-				CAM_WARN(CAM_CSIPHY,
-					"csiphy_config_dev failed");
-				goto release_mutex;
-			}
-
-			csiphy_dev->start_dev_count++;
-			goto release_mutex;
-		}
-
-		CAM_DBG(CAM_CSIPHY, "Start_dev_cnt: %d",
-			csiphy_dev->start_dev_count);
-
 		ahb_vote.type = CAM_VOTE_ABSOLUTE;
 		ahb_vote.vote.level = CAM_LOWSVS_VOTE;
 		axi_vote.num_paths = 1;
@@ -1210,10 +917,12 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			&ahb_vote, &axi_vote);
 		if (rc < 0) {
 			CAM_ERR(CAM_CSIPHY, "voting CPAS: %d", rc);
+			if (rc == -EALREADY)
+				cam_cpas_stop(csiphy_dev->cpas_handle);
 			goto release_mutex;
 		}
 
-		if (csiphy_dev->csiphy_info[offset].secure_mode == 1) {
+		if (csiphy_dev->csiphy_info.secure_mode[offset] == 1) {
 			if (cam_cpas_is_feature_supported(
 					CAM_CPAS_SECURE_CAMERA_ENABLE) != 1) {
 				CAM_ERR(CAM_CSIPHY,
@@ -1227,20 +936,20 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 				csiphy_dev,
 				CAM_SECURE_MODE_SECURE, offset);
 			if (rc < 0) {
-				csiphy_dev->csiphy_info[offset].secure_mode =
+				csiphy_dev->csiphy_info.secure_mode[offset] =
 					CAM_SECURE_MODE_NON_SECURE;
 				cam_cpas_stop(csiphy_dev->cpas_handle);
 				goto release_mutex;
 			}
 		}
 
-		rc = cam_csiphy_enable_hw(csiphy_dev, offset);
+		rc = cam_csiphy_enable_hw(csiphy_dev);
 		if (rc != 0) {
 			CAM_ERR(CAM_CSIPHY, "cam_csiphy_enable_hw failed");
 			cam_cpas_stop(csiphy_dev->cpas_handle);
 			goto release_mutex;
 		}
-		rc = cam_csiphy_config_dev(csiphy_dev, config.dev_handle);
+		rc = cam_csiphy_config_dev(csiphy_dev);
 		if (csiphy_dump == 1)
 			cam_csiphy_mem_dmp(&csiphy_dev->soc_info);
 
@@ -1251,8 +960,6 @@ int32_t cam_csiphy_core_cfg(void *phy_dev,
 			goto release_mutex;
 		}
 		csiphy_dev->start_dev_count++;
-		CAM_DBG(CAM_CSIPHY, "START DEV CNT: %d",
-			csiphy_dev->start_dev_count);
 		csiphy_dev->csiphy_state = CAM_CSIPHY_START;
 	}
 		break;
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.c
index 0d031e430db7..ba98d9adcc2d 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_csiphy_dev.h"
@@ -9,25 +9,6 @@
 #include "cam_csiphy_core.h"
 #include <media/cam_sensor.h>
 
-static void cam_csiphy_subdev_handle_message(
-	struct v4l2_subdev *sd,
-	enum cam_subdev_message_type_t message_type,
-	uint32_t data)
-{
-	struct csiphy_device *csiphy_dev = v4l2_get_subdevdata(sd);
-
-	switch (message_type) {
-	case CAM_SUBDEV_MESSAGE_IRQ_ERR:
-		CAM_INFO(CAM_CSIPHY, "subdev index : %d CSIPHY index: %d",
-			csiphy_dev->soc_info.index, data);
-		if (data == csiphy_dev->soc_info.index)
-			cam_csiphy_status_dmp(csiphy_dev);
-		break;
-	default:
-		break;
-	}
-}
-
 static long cam_csiphy_subdev_ioctl(struct v4l2_subdev *sd,
 	unsigned int cmd, void *arg)
 {
@@ -50,26 +31,6 @@ static long cam_csiphy_subdev_ioctl(struct v4l2_subdev *sd,
 	return rc;
 }
 
-
-static int cam_csiphy_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct csiphy_device *csiphy_dev =
-		v4l2_get_subdevdata(sd);
-
-	if (!csiphy_dev) {
-		CAM_ERR(CAM_CSIPHY, "csiphy_dev ptr is NULL");
-		return -EINVAL;
-	}
-
-	mutex_lock(&csiphy_dev->mutex);
-	csiphy_dev->open_cnt++;
-	CAM_DBG(CAM_CSIPHY, "csiphy_dev open count %d", csiphy_dev->open_cnt);
-	mutex_unlock(&csiphy_dev->mutex);
-
-	return 0;
-}
-
 static int cam_csiphy_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -82,14 +43,7 @@ static int cam_csiphy_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&csiphy_dev->mutex);
-	if (csiphy_dev->open_cnt <= 0) {
-		mutex_unlock(&csiphy_dev->mutex);
-		return -EINVAL;
-	}
-	csiphy_dev->open_cnt--;
-	CAM_DBG(CAM_CSIPHY, "csiphy_dev open count %d", csiphy_dev->open_cnt);
-	if (csiphy_dev->open_cnt == 0)
-		cam_csiphy_shutdown(csiphy_dev);
+	cam_csiphy_shutdown(csiphy_dev);
 	mutex_unlock(&csiphy_dev->mutex);
 
 	return 0;
@@ -147,7 +101,6 @@ static const struct v4l2_subdev_ops csiphy_subdev_ops = {
 };
 
 static const struct v4l2_subdev_internal_ops csiphy_subdev_intern_ops = {
-	.open  = cam_csiphy_subdev_open,
 	.close = cam_csiphy_subdev_close,
 };
 
@@ -156,7 +109,6 @@ static int32_t cam_csiphy_platform_probe(struct platform_device *pdev)
 	struct cam_cpas_register_params cpas_parms;
 	struct csiphy_device *new_csiphy_dev;
 	int32_t              rc = 0;
-	int i;
 
 	new_csiphy_dev = devm_kzalloc(&pdev->dev,
 		sizeof(struct csiphy_device), GFP_KERNEL);
@@ -196,8 +148,6 @@ static int32_t cam_csiphy_platform_probe(struct platform_device *pdev)
 		(V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS);
 	new_csiphy_dev->v4l2_dev_str.ent_function =
 		CAM_CSIPHY_DEVICE_TYPE;
-	new_csiphy_dev->v4l2_dev_str.msg_cb =
-		cam_csiphy_subdev_handle_message;
 	new_csiphy_dev->v4l2_dev_str.token =
 		new_csiphy_dev;
 
@@ -209,25 +159,18 @@ static int32_t cam_csiphy_platform_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, &(new_csiphy_dev->v4l2_dev_str.sd));
 
-	for (i = 0; i < CSIPHY_MAX_INSTANCES_PER_PHY; i++) {
-		new_csiphy_dev->csiphy_info[i].hdl_data.device_hdl = -1;
-		new_csiphy_dev->csiphy_info[i].hdl_data.session_hdl = -1;
-		new_csiphy_dev->csiphy_info[i].csiphy_3phase = -1;
-		new_csiphy_dev->csiphy_info[i].data_rate = 0;
-		new_csiphy_dev->csiphy_info[i].settle_time = 0;
-		new_csiphy_dev->csiphy_info[i].lane_cnt = 0;
-		new_csiphy_dev->csiphy_info[i].lane_assign = 0;
-		new_csiphy_dev->csiphy_info[i].lane_enable = 0;
-		new_csiphy_dev->csiphy_info[i].mipi_flags = 0;
-	}
-
-	new_csiphy_dev->ops.get_dev_info = NULL;
-	new_csiphy_dev->ops.link_setup = NULL;
-	new_csiphy_dev->ops.apply_req = NULL;
+	new_csiphy_dev->bridge_intf.device_hdl[0] = -1;
+	new_csiphy_dev->bridge_intf.device_hdl[1] = -1;
+	new_csiphy_dev->bridge_intf.ops.get_dev_info =
+		NULL;
+	new_csiphy_dev->bridge_intf.ops.link_setup =
+		NULL;
+	new_csiphy_dev->bridge_intf.ops.apply_req =
+		NULL;
 
 	new_csiphy_dev->acquire_count = 0;
 	new_csiphy_dev->start_dev_count = 0;
-	new_csiphy_dev->open_cnt = 0;
+	new_csiphy_dev->is_acquired_dev_combo_mode = 0;
 
 	cpas_parms.cam_cpas_client_cb = NULL;
 	cpas_parms.cell_index = new_csiphy_dev->soc_info.index;
@@ -238,16 +181,13 @@ static int32_t cam_csiphy_platform_probe(struct platform_device *pdev)
 	rc = cam_cpas_register_client(&cpas_parms);
 	if (rc) {
 		CAM_ERR(CAM_CSIPHY, "CPAS registration failed rc: %d", rc);
-		goto csiphy_unregister_subdev;
+		goto csiphy_no_resource;
 	}
 	CAM_DBG(CAM_CSIPHY, "CPAS registration successful handle=%d",
 		cpas_parms.client_handle);
 	new_csiphy_dev->cpas_handle = cpas_parms.client_handle;
 
 	return rc;
-
-csiphy_unregister_subdev:
-	cam_unregister_subdev(&(new_csiphy_dev->v4l2_dev_str));
 csiphy_no_resource:
 	mutex_destroy(&new_csiphy_dev->mutex);
 	kfree(new_csiphy_dev->ctrl_reg);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.h
index bd2037df863f..78c7a848cd81 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_DEV_H_
@@ -29,7 +29,7 @@
 #include "cam_context.h"
 
 #define MAX_CSIPHY                  6
-
+#define MAX_DPHY_DATA_LN            4
 #define MAX_LRME_V4l2_EVENTS        30
 #define CSIPHY_NUM_CLK_MAX          16
 #define MAX_CSIPHY_REG_ARRAY        70
@@ -53,9 +53,8 @@
 #define CSIPHY_DNP_PARAMS                4
 #define CSIPHY_2PH_REGS                  5
 #define CSIPHY_3PH_REGS                  6
-#define CSIPHY_SKEW_CAL                  7
 
-#define CSIPHY_MAX_INSTANCES_PER_PHY     2
+#define CSIPHY_MAX_INSTANCES     2
 
 #define CAM_CSIPHY_MAX_DPHY_LANES    4
 #define CAM_CSIPHY_MAX_CPHY_LANES    3
@@ -69,17 +68,6 @@
 #define CDBG(fmt, args...) pr_debug(fmt, ##args)
 #endif
 
-#define DPHY_LANE_0    BIT(0)
-#define CPHY_LANE_0    BIT(1)
-#define DPHY_LANE_1    BIT(2)
-#define CPHY_LANE_1    BIT(3)
-#define DPHY_LANE_2    BIT(4)
-#define CPHY_LANE_2    BIT(5)
-#define DPHY_LANE_3    BIT(6)
-#define DPHY_CLK_LN    BIT(7)
-
-
-
 enum cam_csiphy_state {
 	CAM_CSIPHY_INIT,
 	CAM_CSIPHY_ACQUIRE,
@@ -98,7 +86,6 @@ enum cam_csiphy_state {
  * @mipi_csiphy_interrupt_clear0_addr:
  *     CSIPhy interrupt clear addr
  * @csiphy_version: CSIPhy Version
- * @csiphy_interrupt_status_size: CSIPhy status register size
  * @csiphy_common_array_size: CSIPhy common array size
  * @csiphy_reset_array_size: CSIPhy reset array size
  * @csiphy_2ph_config_array_size: 2ph settings size
@@ -120,7 +107,6 @@ struct csiphy_reg_parms_t {
 	uint32_t mipi_csiphy_interrupt_mask_addr;
 	uint32_t mipi_csiphy_interrupt_clear0_addr;
 	uint32_t csiphy_version;
-	uint32_t csiphy_interrupt_status_size;
 	uint32_t csiphy_common_array_size;
 	uint32_t csiphy_reset_array_size;
 	uint32_t csiphy_2ph_config_array_size;
@@ -134,19 +120,24 @@ struct csiphy_reg_parms_t {
 };
 
 /**
- * struct csiphy_hdl_tbl
+ * struct intf_params
  * @device_hdl: Device Handle
  * @session_hdl: Session Handle
+ * @ops: KMD operations
+ * @crm_cb: Callback API pointers
  */
-struct csiphy_hdl_tbl {
-	int32_t device_hdl;
-	int32_t session_hdl;
+struct intf_params {
+	int32_t device_hdl[CSIPHY_MAX_INSTANCES];
+	int32_t session_hdl[CSIPHY_MAX_INSTANCES];
+	int32_t link_hdl[CSIPHY_MAX_INSTANCES];
+	struct cam_req_mgr_kmd_ops ops;
+	struct cam_req_mgr_crm_cb *crm_cb;
 };
 
 /**
  * struct csiphy_reg_t
- * @reg_addr:          Register address
- * @reg_data:          Register data
+ * @reg_addr: Register address
+ * @reg_data: Register data
  * @delay: Delay
  * @csiphy_param_type: CSIPhy parameter type
  */
@@ -210,34 +201,37 @@ struct csiphy_ctrl_t {
 	struct csiphy_reg_t (*csiphy_2ph_combo_mode_reg)[MAX_SETTINGS_PER_LANE];
 	struct csiphy_reg_t (*csiphy_3ph_reg)[MAX_SETTINGS_PER_LANE];
 	struct csiphy_reg_t (*csiphy_2ph_3ph_mode_reg)[MAX_SETTINGS_PER_LANE];
-	enum   cam_vote_level (*getclockvoting)(struct csiphy_device *phy_dev,
-		int32_t index);
+	enum   cam_vote_level (*getclockvoting)(struct csiphy_device *phy_dev);
 	struct data_rate_settings_t *data_rates_settings_table;
 };
 
-/*
- * cam_csiphy_param            :  Provides cmdbuffer structure
- * @lane_assign                :  Lane sensor will be using
+/**
+ * cam_csiphy_param: Provides cmdbuffer structre
+ * @lane_mask     :  Lane mask details
+ * @lane_assign   :  Lane sensor will be using
  * @csiphy_3phase :  Mentions DPHY or CPHY
- * @lane_cnt                   :  Total number of lanes
- * @lane_enable                :  Data Lane selection
- * @settle_time                :  Settling time in ms
- * @data_rate                  :  Data rate in mbps
- * @csiphy_cpas_cp_reg_mask    :  CP reg mask for phy instance
- * @hdl_data                   :  CSIPHY handle table
- * @mipi_flags                 :  Mipi flags
+ * @combo_mode    :  Info regarding combo_mode is enable / disable
+ * @lane_cnt      :  Total number of lanes
+ * @reserved
+ * @3phase        :  Details whether 3Phase / 2Phase operation
+ * @settle_time   :  Settling time in ms
+ * @settle_time_combo_sensor   :  Settling time in ms
+ * @data_rate     :  Data rate in mbps
+ * @data_rate_combo_sensor: data rate of combo sensor
+ *                          in the the same phy
+ *
  */
 struct cam_csiphy_param {
-	uint16_t                   lane_assign;
-	int                        csiphy_3phase;
-	uint8_t                    lane_cnt;
-	uint8_t                    secure_mode;
-	uint32_t                   lane_enable;
-	uint64_t                   settle_time;
-	uint64_t                   data_rate;
-	uint32_t                   mipi_flags;
-	uint64_t                   csiphy_cpas_cp_reg_mask;
-	struct csiphy_hdl_tbl      hdl_data;
+	uint16_t    lane_mask;
+	uint16_t    lane_assign;
+	uint8_t     csiphy_3phase;
+	uint8_t     combo_mode;
+	uint8_t     lane_cnt;
+	uint8_t     secure_mode[CSIPHY_MAX_INSTANCES];
+	uint64_t    settle_time;
+	uint64_t    settle_time_combo_sensor;
+	uint64_t    data_rate;
+	uint64_t    data_rate_combo_sensor;
 };
 
 /**
@@ -263,47 +257,39 @@ struct cam_csiphy_param {
  * @clk_lane:                   Clock lane
  * @acquire_count:              Acquire device count
  * @start_dev_count:            Start count
+ * @is_acquired_dev_combo_mode: Flag that mentions whether already acquired
+ *                              device is for combo mode
  * @soc_info:                   SOC information
  * @cpas_handle:                CPAS handle
  * @config_count:               Config reg count
- * @current_data_rate:          Data rate in mbps
- * @csiphy_3phase:              To identify DPHY or CPHY at top level
- * @combo_mode:                 Info regarding combo_mode is enable / disable
- * @ops:                        KMD operations
- * @crm_cb:                     Callback API pointers
+ * @csiphy_cpas_cp_reg_mask:    CP reg mask for phy instance
  */
 struct csiphy_device {
-	char                           device_name[CAM_CTX_DEV_NAME_MAX_LENGTH];
-	struct mutex                   mutex;
-	uint32_t                       hw_version;
-	enum cam_csiphy_state          csiphy_state;
-	struct csiphy_ctrl_t          *ctrl_reg;
-	uint32_t                       csiphy_max_clk;
-	struct msm_cam_clk_info        csiphy_3p_clk_info[2];
-	struct clk                    *csiphy_3p_clk[2];
-	unsigned char                  csi_3phase;
-	int32_t                        ref_count;
-	uint16_t                       lane_mask[MAX_CSIPHY];
-	uint8_t                        is_csiphy_3phase_hw;
-	uint8_t                        is_divisor_32_comp;
-	uint8_t                        num_irq_registers;
-	struct cam_subdev              v4l2_dev_str;
-	struct cam_csiphy_param        csiphy_info[
-					CSIPHY_MAX_INSTANCES_PER_PHY];
-	uint32_t                       clk_lane;
-	uint32_t                       acquire_count;
-	uint32_t                       start_dev_count;
-	struct cam_hw_soc_info         soc_info;
-	uint32_t                       cpas_handle;
-	uint32_t                       config_count;
-	uint32_t                       open_cnt;
-	uint64_t                       csiphy_cpas_cp_reg_mask[
-					CSIPHY_MAX_INSTANCES_PER_PHY];
-	uint64_t                       current_data_rate;
-	uint8_t                        session_max_device_support;
-	uint8_t                        combo_mode;
-	struct cam_req_mgr_kmd_ops     ops;
-	struct cam_req_mgr_crm_cb     *crm_cb;
+	char device_name[CAM_CTX_DEV_NAME_MAX_LENGTH];
+	struct mutex mutex;
+	uint32_t hw_version;
+	enum cam_csiphy_state csiphy_state;
+	struct csiphy_ctrl_t *ctrl_reg;
+	uint32_t csiphy_max_clk;
+	struct msm_cam_clk_info csiphy_3p_clk_info[2];
+	struct clk *csiphy_3p_clk[2];
+	unsigned char csi_3phase;
+	int32_t ref_count;
+	uint16_t lane_mask[MAX_CSIPHY];
+	uint8_t is_csiphy_3phase_hw;
+	uint8_t is_divisor_32_comp;
+	uint8_t num_irq_registers;
+	struct cam_subdev v4l2_dev_str;
+	struct cam_csiphy_param csiphy_info;
+	struct intf_params bridge_intf;
+	uint32_t clk_lane;
+	uint32_t acquire_count;
+	uint32_t start_dev_count;
+	uint32_t is_acquired_dev_combo_mode;
+	struct cam_hw_soc_info   soc_info;
+	uint32_t cpas_handle;
+	uint32_t config_count;
+	uint64_t csiphy_cpas_cp_reg_mask[CSIPHY_MAX_INSTANCES];
 };
 
 #endif /* _CAM_CSIPHY_DEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.c b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.c
index 293f1b064a07..c5a8033aaffb 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_csiphy_soc.h"
@@ -9,8 +9,6 @@
 #include "include/cam_csiphy_1_0_hwreg.h"
 #include "include/cam_csiphy_1_2_hwreg.h"
 #include "include/cam_csiphy_1_2_1_hwreg.h"
-#include "include/cam_csiphy_1_2_2_hwreg.h"
-#include "include/cam_csiphy_1_2_3_hwreg.h"
 #include "include/cam_csiphy_2_0_hwreg.h"
 
 #define CSIPHY_DIVISOR_16           16
@@ -78,72 +76,26 @@ int32_t cam_csiphy_mem_dmp(struct cam_hw_soc_info *soc_info)
 	return rc;
 }
 
-int32_t cam_csiphy_status_dmp(struct csiphy_device *csiphy_dev)
-{
-	struct csiphy_reg_parms_t *csiphy_reg = NULL;
-	int32_t                   rc = 0;
-	resource_size_t           size = 0;
-	void __iomem              *phy_base = NULL;
-	int                       reg_id = 0;
-	uint32_t                  irq, status_reg, clear_reg;
-
-	if (!csiphy_dev) {
-		rc = -EINVAL;
-		CAM_ERR(CAM_CSIPHY, "invalid input %d", rc);
-		return rc;
-	}
-
-	csiphy_reg = &csiphy_dev->ctrl_reg->csiphy_reg;
-	phy_base = csiphy_dev->soc_info.reg_map[0].mem_base;
-	status_reg = csiphy_reg->mipi_csiphy_interrupt_status0_addr;
-	clear_reg = csiphy_reg->mipi_csiphy_interrupt_clear0_addr;
-	size = csiphy_reg->csiphy_interrupt_status_size;
-
-	CAM_INFO(CAM_CSIPHY, "PHY base addr=%pK offset=0x%x size=%d",
-			phy_base, status_reg, size);
-
-	if (phy_base != NULL) {
-		for (reg_id = 0; reg_id < size; reg_id++) {
-			uint32_t offset;
-
-			offset = status_reg + (0x4 * reg_id);
-			irq = cam_io_r(phy_base +  offset);
-			offset = clear_reg + (0x4 * reg_id);
-			cam_io_w_mb(irq, phy_base + offset);
-			cam_io_w_mb(0, phy_base + offset);
-
-			CAM_INFO(CAM_CSIPHY,
-				"CSIPHY%d_IRQ_STATUS_ADDR%d = 0x%x",
-				csiphy_dev->soc_info.index, reg_id, irq);
-		}
-	} else {
-		rc = -EINVAL;
-		CAM_ERR(CAM_CSIPHY, "phy base is NULL  %d", rc);
-		return rc;
-	}
-
-	return rc;
-}
-
-enum cam_vote_level get_clk_vote_default(struct csiphy_device *csiphy_dev,
-	int32_t index)
+enum cam_vote_level get_clk_vote_default(struct csiphy_device *csiphy_dev)
 {
 	CAM_DBG(CAM_CSIPHY, "voting for SVS");
 	return CAM_SVS_VOTE;
 }
 
-enum cam_vote_level get_clk_voting_dynamic(
-	struct csiphy_device *csiphy_dev, int32_t index)
+enum cam_vote_level get_clk_voting_dynamic(struct csiphy_device *csiphy_dev)
 {
 	uint32_t cam_vote_level = 0;
 	uint32_t last_valid_vote = 0;
 	struct cam_hw_soc_info *soc_info;
-	uint64_t phy_data_rate = csiphy_dev->csiphy_info[index].data_rate;
+	uint64_t phy_data_rate = csiphy_dev->csiphy_info.data_rate;
 
 	soc_info = &csiphy_dev->soc_info;
-	phy_data_rate = max(phy_data_rate, csiphy_dev->current_data_rate);
 
-	if (csiphy_dev->csiphy_info[index].csiphy_3phase) {
+	if (csiphy_dev->is_acquired_dev_combo_mode)
+		phy_data_rate = max(phy_data_rate,
+			csiphy_dev->csiphy_info.data_rate_combo_sensor);
+
+	if (csiphy_dev->csiphy_info.csiphy_3phase) {
 		if (csiphy_dev->is_divisor_32_comp)
 			do_div(phy_data_rate, CSIPHY_DIVISOR_32);
 		else
@@ -154,7 +106,6 @@ enum cam_vote_level get_clk_voting_dynamic(
 
 	 /* round off to next integer */
 	phy_data_rate += 1;
-	csiphy_dev->current_data_rate = phy_data_rate;
 
 	for (cam_vote_level = 0;
 			cam_vote_level < CAM_MAX_VOTE; cam_vote_level++) {
@@ -176,7 +127,7 @@ enum cam_vote_level get_clk_voting_dynamic(
 	return last_valid_vote;
 }
 
-int32_t cam_csiphy_enable_hw(struct csiphy_device *csiphy_dev, int32_t index)
+int32_t cam_csiphy_enable_hw(struct csiphy_device *csiphy_dev)
 {
 	int32_t rc = 0;
 	struct cam_hw_soc_info   *soc_info;
@@ -190,7 +141,7 @@ int32_t cam_csiphy_enable_hw(struct csiphy_device *csiphy_dev, int32_t index)
 		return rc;
 	}
 
-	vote_level = csiphy_dev->ctrl_reg->getclockvoting(csiphy_dev, index);
+	vote_level = csiphy_dev->ctrl_reg->getclockvoting(csiphy_dev);
 	rc = cam_soc_util_enable_platform_resource(soc_info, true,
 		vote_level, ENABLE_IRQ);
 	if (rc < 0) {
@@ -359,46 +310,6 @@ int32_t cam_csiphy_parse_dt_info(struct platform_device *pdev,
 		csiphy_dev->clk_lane = 0;
 		csiphy_dev->ctrl_reg->data_rates_settings_table =
 			&data_rate_delta_table_1_2;
-	} else if (of_device_is_compatible(soc_info->dev->of_node,
-		"qcom,csiphy-v1.2.2.2")) {
-		/* settings for lito v2 */
-		csiphy_dev->ctrl_reg->csiphy_2ph_reg = csiphy_2ph_v1_2_reg;
-		csiphy_dev->ctrl_reg->csiphy_2ph_combo_mode_reg =
-			csiphy_2ph_v1_2_2_combo_mode_reg;
-		csiphy_dev->ctrl_reg->csiphy_3ph_reg = csiphy_3ph_v1_2_reg;
-		csiphy_dev->ctrl_reg->csiphy_2ph_3ph_mode_reg = NULL;
-		csiphy_dev->ctrl_reg->csiphy_irq_reg = csiphy_irq_reg_1_2;
-		csiphy_dev->ctrl_reg->csiphy_common_reg =
-			csiphy_common_reg_1_2_2;
-		csiphy_dev->ctrl_reg->csiphy_reset_reg =
-			csiphy_reset_reg_1_2;
-		csiphy_dev->ctrl_reg->getclockvoting = get_clk_vote_default;
-		csiphy_dev->ctrl_reg->csiphy_reg = csiphy_v1_2_2;
-		csiphy_dev->is_csiphy_3phase_hw = CSI_3PHASE_HW;
-		csiphy_dev->is_divisor_32_comp = false;
-		csiphy_dev->hw_version = CSIPHY_VERSION_V12;
-		csiphy_dev->clk_lane = 0;
-		csiphy_dev->ctrl_reg->data_rates_settings_table =
-			&data_rate_delta_table_1_2;
-	} else if (of_device_is_compatible(soc_info->dev->of_node,
-		"qcom,csiphy-v1.2.3")) {
-		csiphy_dev->ctrl_reg->csiphy_2ph_reg = csiphy_2ph_v1_2_3_reg;
-		csiphy_dev->ctrl_reg->csiphy_2ph_combo_mode_reg =
-			csiphy_2ph_v1_2_3_combo_mode_reg;
-		csiphy_dev->ctrl_reg->csiphy_3ph_reg = csiphy_3ph_v1_2_3_reg;
-		csiphy_dev->ctrl_reg->csiphy_2ph_3ph_mode_reg = NULL;
-		csiphy_dev->ctrl_reg->csiphy_irq_reg = csiphy_irq_reg_1_2_3;
-		csiphy_dev->ctrl_reg->csiphy_common_reg =
-			csiphy_common_reg_1_2_3;
-		csiphy_dev->ctrl_reg->csiphy_reset_reg =
-			csiphy_reset_reg_1_2_3;
-		csiphy_dev->ctrl_reg->getclockvoting = get_clk_voting_dynamic;
-		csiphy_dev->ctrl_reg->csiphy_reg = csiphy_v1_2_3;
-		csiphy_dev->is_csiphy_3phase_hw = CSI_3PHASE_HW;
-		csiphy_dev->is_divisor_32_comp = true;
-		csiphy_dev->hw_version = CSIPHY_VERSION_V123;
-		csiphy_dev->clk_lane = 0;
-		csiphy_dev->ctrl_reg->data_rates_settings_table = NULL;
 	} else if (of_device_is_compatible(soc_info->dev->of_node,
 		"qcom,csiphy-v2.0")) {
 		csiphy_dev->ctrl_reg->csiphy_2ph_reg = csiphy_2ph_v2_0_reg;
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.h
index 8e727704b4a8..c02b9556add4 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/cam_csiphy_soc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_SOC_H_
@@ -30,7 +30,6 @@
 #define CSIPHY_VERSION_V11                        0x11
 #define CSIPHY_VERSION_V12                        0x12
 #define CSIPHY_VERSION_V121                       0x121
-#define CSIPHY_VERSION_V123                       0x123
 #define CSIPHY_VERSION_V20                        0x20
 
 /**
@@ -54,7 +53,7 @@ int cam_csiphy_parse_dt_info(struct platform_device *pdev,
  *
  * This API enables SOC related parameters
  */
-int cam_csiphy_enable_hw(struct csiphy_device *csiphy_dev, int32_t index);
+int cam_csiphy_enable_hw(struct csiphy_device *csiphy_dev);
 
 /**
  * @csiphy_dev: CSIPhy device structure
@@ -71,11 +70,4 @@ int cam_csiphy_disable_hw(struct csiphy_device *csiphy_dev);
  */
 int cam_csiphy_mem_dmp(struct cam_hw_soc_info *soc_info);
 
-/**
- * @csiphy_dev: CSIPhy device structure
- *
- * This API dumps memory for the entire status region
- */
-int32_t cam_csiphy_status_dmp(struct csiphy_device *csiphy_dev);
-
 #endif /* _CAM_CSIPHY_SOC_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_0_hwreg.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_0_hwreg.h
index eaedc7b672a8..e910162858b3 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_0_hwreg.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_0_hwreg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_1_0_HWREG_H_
@@ -12,7 +12,6 @@ struct csiphy_reg_parms_t csiphy_v1_0 = {
 	.mipi_csiphy_interrupt_status0_addr = 0x8B0,
 	.mipi_csiphy_interrupt_clear0_addr = 0x858,
 	.mipi_csiphy_glbl_irq_cmd_addr = 0x828,
-	.csiphy_interrupt_status_size = 11,
 	.csiphy_common_array_size = 5,
 	.csiphy_reset_array_size = 5,
 	.csiphy_2ph_config_array_size = 14,
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_1_hwreg.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_1_hwreg.h
index e1db638da5f0..30b61067a792 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_1_hwreg.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_1_hwreg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_1_1_HWREG_H_
@@ -12,7 +12,6 @@ struct csiphy_reg_parms_t csiphy_v1_1 = {
 	.mipi_csiphy_interrupt_status0_addr = 0x8B0,
 	.mipi_csiphy_interrupt_clear0_addr = 0x858,
 	.mipi_csiphy_glbl_irq_cmd_addr = 0x828,
-	.csiphy_interrupt_status_size = 11,
 	.csiphy_common_array_size = 5,
 	.csiphy_reset_array_size = 5,
 	.csiphy_2ph_config_array_size = 14,
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_1_hwreg.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_1_hwreg.h
index 8bf373677a51..32fbf47eabd9 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_1_hwreg.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_1_hwreg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_1_2_1_HWREG_H_
@@ -12,11 +12,10 @@ struct csiphy_reg_parms_t csiphy_v1_2_1 = {
 	.mipi_csiphy_interrupt_status0_addr = 0x8B0,
 	.mipi_csiphy_interrupt_clear0_addr = 0x858,
 	.mipi_csiphy_glbl_irq_cmd_addr = 0x828,
-	.csiphy_interrupt_status_size = 11,
-	.csiphy_common_array_size = 7,
+	.csiphy_common_array_size = 6,
 	.csiphy_reset_array_size = 5,
 	.csiphy_2ph_config_array_size = 20,
-	.csiphy_3ph_config_array_size = 33,
+	.csiphy_3ph_config_array_size = 34,
 	.csiphy_2ph_clock_lane = 0x1,
 	.csiphy_2ph_combo_ck_ln = 0x10,
 };
@@ -26,7 +25,6 @@ struct csiphy_reg_t csiphy_common_reg_1_2_1[] = {
 	{0x0818, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x081C, 0x02, 0x00, CSIPHY_2PH_REGS},
 	{0x081C, 0x52, 0x00, CSIPHY_3PH_REGS},
-	{0x0800, 0x03, 0x01, CSIPHY_DEFAULT_PARAMS},
 	{0x0800, 0x02, 0x00, CSIPHY_2PH_REGS},
 	{0x0800, 0x0E, 0x00, CSIPHY_3PH_REGS},
 };
@@ -35,7 +33,7 @@ struct csiphy_reg_t csiphy_reset_reg_1_2_1[] = {
 	{0x0814, 0x00, 0x05, CSIPHY_LANE_ENABLE},
 	{0x0818, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x081C, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-	{0x0800, 0x01, 0x01, CSIPHY_DEFAULT_PARAMS},
+	{0x0800, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x0800, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 };
 
@@ -60,7 +58,7 @@ csiphy_reg_t csiphy_2ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0900, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0908, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0904, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0904, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0904, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0004, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x002C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0034, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -82,7 +80,7 @@ csiphy_reg_t csiphy_2ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0C80, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0C88, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0C84, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0C84, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0C84, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0704, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x072C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0734, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -104,7 +102,7 @@ csiphy_reg_t csiphy_2ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0A00, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A08, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0A04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0A04, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0204, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x022C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0234, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -126,7 +124,7 @@ csiphy_reg_t csiphy_2ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0B00, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B08, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0B04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0B04, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0404, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x042C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0434, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -148,7 +146,7 @@ csiphy_reg_t csiphy_2ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0C00, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0C08, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0C04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0C04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0C04, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0604, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x062C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0634, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -290,11 +288,10 @@ csiphy_reg_t csiphy_3ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0990, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0994, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0998, 0x1A, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x098C, 0xAF, 0x01, CSIPHY_DEFAULT_PARAMS},
-		{0x015C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0168, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x098C, 0xAF, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0168, 0xAC, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0104, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x010C, 0x12, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x010C, 0x07, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
 		{0x0108, 0x00, 0x00, CSIPHY_SETTLE_CNT_HIGHER_BYTE},
 		{0x0114, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0150, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -309,27 +306,28 @@ csiphy_reg_t csiphy_3ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x012C, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0160, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x01CC, 0x41, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0164, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x01DC, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x09C0, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x09C4, 0x7D, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x09C8, 0x7F, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0984, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0988, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0980, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x09AC, 0x35, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x09B0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0800, 0x0E, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0884, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	},
 	{
 		{0x0A90, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A94, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A98, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A90, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0A94, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0A98, 0x1A, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0A8C, 0xAF, 0x01, CSIPHY_DEFAULT_PARAMS},
-		{0x035C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0368, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0A94, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0A98, 0x1F, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0A8C, 0xBF, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0368, 0xAC, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0304, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x030C, 0x12, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x030C, 0x07, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
 		{0x0308, 0x00, 0x00, CSIPHY_SETTLE_CNT_HIGHER_BYTE},
 		{0x0314, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0350, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -344,14 +342,16 @@ csiphy_reg_t csiphy_3ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x032C, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0360, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x03CC, 0x41, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0364, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x03DC, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0AC0, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0AC4, 0x7D, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0AC8, 0x7F, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A84, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A88, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0A80, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0AAC, 0x35, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0AB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0800, 0x0E, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0884, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	},
 	{
 		{0x0B90, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -360,11 +360,10 @@ csiphy_reg_t csiphy_3ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0B90, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B94, 0x08, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B98, 0x1A, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0B8C, 0xAF, 0x01, CSIPHY_DEFAULT_PARAMS},
-		{0x055C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0568, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0B8C, 0xAF, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0568, 0xAC, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0504, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x050C, 0x12, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x050C, 0x07, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
 		{0x0508, 0x00, 0x00, CSIPHY_SETTLE_CNT_HIGHER_BYTE},
 		{0x0514, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0550, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -379,14 +378,16 @@ csiphy_reg_t csiphy_3ph_v1_2_1_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x052C, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0560, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x05CC, 0x41, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0564, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x05DC, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0BC0, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0BC4, 0x7D, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0BC8, 0x7F, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B84, 0x20, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B88, 0x05, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0B80, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0BAC, 0x35, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0BB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0800, 0x0E, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0884, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	},
 };
 
@@ -396,55 +397,82 @@ struct data_rate_settings_t data_rate_delta_table_1_2_1 = {
 		{
 			/* (2.5 * 10**3 * 2.28) rounded value*/
 			.bandwidth = 5700000000,
-			.data_rate_reg_array_size = 9,
+			.data_rate_reg_array_size = 12,
 			.csiphy_data_rate_regs = {
-				{0x144, 0x32, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x344, 0x32, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x544, 0x32, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x164, 0x0B, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x364, 0x0B, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x564, 0x0B, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x16C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x36C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x56C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x15C, 0x66, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x35C, 0x66, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x55C, 0x66, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x9B4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xAB4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xBB4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x144, 0x22, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x344, 0x22, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x544, 0x22, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x16C, 0xAD, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x36C, 0xAD, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x56C, 0xAD, 0x00, CSIPHY_DEFAULT_PARAMS},
 			}
 		},
 		{
 			/* (3.5 * 10**3 * 2.28) rounded value */
 			.bandwidth = 7980000000,
-			.data_rate_reg_array_size = 12,
+			.data_rate_reg_array_size = 24,
 			.csiphy_data_rate_regs = {
-				{0x144, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x344, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x544, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x164, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x364, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x564, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x16C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x36C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x56C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x15C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x35C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x55C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
 				{0x9B4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
 				{0xAB4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0xBB4, 0x03, 0x01, CSIPHY_DEFAULT_PARAMS},
+				{0xBB4, 0x03, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x9B0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xAB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xBB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x144, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x344, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x544, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x13C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x33C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x53C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x140, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x340, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x540, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x168, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x368, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x568, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x16C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x36C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x56C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
 			},
 		},
 		{
 			/* (4.5 * 10**3 * 2.28) rounded value */
 			.bandwidth = 10260000000,
-			.data_rate_reg_array_size = 12,
+			.data_rate_reg_array_size = 24,
 			.csiphy_data_rate_regs = {
-				{0x144, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x344, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x544, 0xB2, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x164, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x364, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x564, 0x33, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x16C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x36C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x56C, 0x25, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0x9B4, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0xAB4, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
-				{0xBB4, 0x02, 0x01, CSIPHY_DEFAULT_PARAMS},
+				{0x15C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x35C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x55C, 0x46, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x9B4, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xAB4, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xBB4, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x9B0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xAB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0xBB0, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x144, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x344, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x544, 0xA2, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x13C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x33C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x53C, 0x10, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x140, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x340, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x540, 0x81, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x168, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x368, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x568, 0xA0, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x16C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x36C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
+				{0x56C, 0x1D, 0x00, CSIPHY_DEFAULT_PARAMS},
 			},
 		}
 	}
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_hwreg.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_hwreg.h
index 8a87d4056a6b..3bed231e0246 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_hwreg.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_1_2_hwreg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_1_2_HWREG_H_
@@ -12,10 +12,9 @@ struct csiphy_reg_parms_t csiphy_v1_2 = {
 	.mipi_csiphy_interrupt_status0_addr = 0x8B0,
 	.mipi_csiphy_interrupt_clear0_addr = 0x858,
 	.mipi_csiphy_glbl_irq_cmd_addr = 0x828,
-	.csiphy_interrupt_status_size = 11,
-	.csiphy_common_array_size = 7,
+	.csiphy_common_array_size = 6,
 	.csiphy_reset_array_size = 5,
-	.csiphy_2ph_config_array_size = 19,
+	.csiphy_2ph_config_array_size = 18,
 	.csiphy_3ph_config_array_size = 33,
 	.csiphy_2ph_clock_lane = 0x1,
 	.csiphy_2ph_combo_ck_ln = 0x10,
@@ -25,7 +24,6 @@ struct csiphy_reg_t csiphy_common_reg_1_2[] = {
 	{0x0814, 0xd5, 0x00, CSIPHY_LANE_ENABLE},
 	{0x0818, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x081C, 0x5A, 0x00, CSIPHY_DEFAULT_PARAMS},
-	{0x0800, 0x03, 0x01, CSIPHY_DEFAULT_PARAMS},
 	{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x0884, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 	{0x0824, 0x72, 0x00, CSIPHY_2PH_REGS},
@@ -74,7 +72,6 @@ csiphy_reg_t csiphy_2ph_v1_2_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x005C, 0xC0, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0060, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0064, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0730, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -95,7 +92,6 @@ csiphy_reg_t csiphy_2ph_v1_2_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0230, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -116,7 +112,6 @@ csiphy_reg_t csiphy_2ph_v1_2_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x025C, 0xC0, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0260, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0264, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0430, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -137,7 +132,6 @@ csiphy_reg_t csiphy_2ph_v1_2_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x045C, 0xC0, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0460, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0464, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0630, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -158,7 +152,6 @@ csiphy_reg_t csiphy_2ph_v1_2_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x065C, 0xC0, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0660, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0664, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 };
 
@@ -183,7 +176,6 @@ csiphy_2ph_v1_2_combo_mode_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0060, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0064, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0800, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0730, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -204,7 +196,6 @@ csiphy_2ph_v1_2_combo_mode_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0800, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0230, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -225,15 +216,13 @@ csiphy_2ph_v1_2_combo_mode_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0260, 0x0D, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0264, 0x7F, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0800, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 	{
 		{0x0430, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x042C, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0434, 0x0F, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0410, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0418, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x041C, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x041C, 0x0A, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0414, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0428, 0x0A, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x043C, 0xB8, 0x00, CSIPHY_DEFAULT_PARAMS},
@@ -260,14 +249,13 @@ csiphy_2ph_v1_2_combo_mode_reg[MAX_LANES][MAX_SETTINGS_PER_LANE] = {
 		{0x0600, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0604, 0x0C, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0620, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
-		{0x0624, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0624, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0608, 0x10, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
 		{0x060C, 0xFF, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0638, 0x1F, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0800, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
-		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
 	},
 };
 
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_2_0_hwreg.h b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_2_0_hwreg.h
index 453da81ff35d..cbd0dc582b32 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_2_0_hwreg.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_csiphy/include/cam_csiphy_2_0_hwreg.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_CSIPHY_2_0_HWREG_H_
@@ -12,7 +12,6 @@ struct csiphy_reg_parms_t csiphy_v2_0 = {
 	.mipi_csiphy_interrupt_status0_addr = 0x8B0,
 	.mipi_csiphy_interrupt_clear0_addr = 0x858,
 	.mipi_csiphy_glbl_irq_cmd_addr = 0x828,
-	.csiphy_interrupt_status_size = 11,
 	.csiphy_common_array_size = 6,
 	.csiphy_reset_array_size = 3,
 	.csiphy_2ph_config_array_size = 15,
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_core.c b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
index 41f3a9538c08..c50230309c57 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_core.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -109,7 +108,7 @@ static int cam_eeprom_read_memory(struct cam_eeprom_ctrl_t *e_ctrl,
 				emap[j].mem.addr_type,
 				emap[j].mem.data_type,
 				emap[j].mem.valid_size);
-			if (rc < 0) {
+			if (rc) {
 				CAM_ERR(CAM_EEPROM, "read failed rc %d",
 					rc);
 				return rc;
@@ -355,10 +354,6 @@ static int32_t cam_eeprom_get_dev_handle(struct cam_eeprom_ctrl_t *e_ctrl,
 
 	eeprom_acq_dev.device_handle =
 		cam_create_device_hdl(&bridge_params);
-	if (eeprom_acq_dev.device_handle <= 0) {
-		CAM_ERR(CAM_EEPROM, "Can not create device handle");
-		return -EFAULT;
-	}
 	e_ctrl->bridge_intf.device_hdl = eeprom_acq_dev.device_handle;
 	e_ctrl->bridge_intf.session_hdl = eeprom_acq_dev.session_handle;
 
@@ -992,16 +987,7 @@ static int32_t cam_eeprom_init_pkt_parser(struct cam_eeprom_ctrl_t *e_ctrl,
 					rc = -EINVAL;
 					goto end;
 				}
-
-				if ((num_map + 1) >=
-					(MSM_EEPROM_MAX_MEM_MAP_CNT *
-					MSM_EEPROM_MEMORY_MAP_MAX_SIZE)) {
-					CAM_ERR(CAM_EEPROM, "OOB error");
-					rc = -EINVAL;
-					goto end;
-				}
 				/* Configure the following map slave address */
-
 				map[num_map + 1].saddr = i2c_info->slave_addr;
 				rc = cam_eeprom_update_slaveInfo(e_ctrl,
 					cmd_buf);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.c
index c3fc4397ce94..328541553b59 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_eeprom_dev.h"
@@ -27,26 +27,6 @@ static long cam_eeprom_subdev_ioctl(struct v4l2_subdev *sd,
 	return rc;
 }
 
-static int cam_eeprom_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct cam_eeprom_ctrl_t *e_ctrl =
-		v4l2_get_subdevdata(sd);
-
-	if (!e_ctrl) {
-		CAM_ERR(CAM_EEPROM, "e_ctrl ptr is NULL");
-			return -EINVAL;
-	}
-
-	mutex_lock(&(e_ctrl->eeprom_mutex));
-	e_ctrl->open_cnt++;
-	CAM_DBG(CAM_EEPROM, "eeprom Subdev open count %d", e_ctrl->open_cnt);
-	mutex_unlock(&(e_ctrl->eeprom_mutex));
-
-	return 0;
-}
-
-
 static int cam_eeprom_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -59,14 +39,7 @@ static int cam_eeprom_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&(e_ctrl->eeprom_mutex));
-	if (e_ctrl->open_cnt <= 0) {
-		mutex_unlock(&(e_ctrl->eeprom_mutex));
-		return -EINVAL;
-	}
-	e_ctrl->open_cnt--;
-	CAM_DBG(CAM_EEPROM, "eeprom Subdev open count %d", e_ctrl->open_cnt);
-	if (e_ctrl->open_cnt == 0)
-		cam_eeprom_shutdown(e_ctrl);
+	cam_eeprom_shutdown(e_ctrl);
 	mutex_unlock(&(e_ctrl->eeprom_mutex));
 
 	return 0;
@@ -143,7 +116,6 @@ static long cam_eeprom_init_subdev_do_ioctl(struct v4l2_subdev *sd,
 #endif
 
 static const struct v4l2_subdev_internal_ops cam_eeprom_internal_ops = {
-	.open  = cam_eeprom_subdev_open,
 	.close = cam_eeprom_subdev_close,
 };
 
@@ -245,7 +217,6 @@ static int cam_eeprom_i2c_driver_probe(struct i2c_client *client,
 	e_ctrl->bridge_intf.ops.link_setup = NULL;
 	e_ctrl->bridge_intf.ops.apply_req = NULL;
 	e_ctrl->cam_eeprom_state = CAM_EEPROM_INIT;
-	e_ctrl->open_cnt = 0;
 
 	return rc;
 free_soc:
@@ -367,7 +338,6 @@ static int cam_eeprom_spi_setup(struct spi_device *spi)
 	e_ctrl->bridge_intf.ops.get_dev_info = NULL;
 	e_ctrl->bridge_intf.ops.link_setup = NULL;
 	e_ctrl->bridge_intf.ops.apply_req = NULL;
-	e_ctrl->open_cnt = 0;
 
 	v4l2_set_subdevdata(&e_ctrl->v4l2_dev_str.sd, e_ctrl);
 	return rc;
@@ -499,7 +469,6 @@ static int32_t cam_eeprom_platform_driver_probe(
 	e_ctrl->bridge_intf.ops.apply_req = NULL;
 	platform_set_drvdata(pdev, e_ctrl);
 	e_ctrl->cam_eeprom_state = CAM_EEPROM_INIT;
-	e_ctrl->open_cnt = 0;
 
 	return rc;
 free_soc:
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.h
index 65afb96661b1..66f8aaddc958 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_eeprom/cam_eeprom_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 #ifndef _CAM_EEPROM_DEV_H_
 #define _CAM_EEPROM_DEV_H_
@@ -190,7 +190,6 @@ struct cam_eeprom_ctrl_t {
 	uint16_t is_multimodule_mode;
 	struct i2c_settings_array wr_settings;
 	struct eebin_info eebin_info;
-	uint32_t open_cnt;
 };
 
 int32_t cam_eeprom_update_i2c_info(struct cam_eeprom_ctrl_t *e_ctrl,
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_core.c b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_core.c
index e861fd328951..ce5440dff75b 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -11,41 +11,6 @@
 #include "cam_common_util.h"
 #include "cam_packet_util.h"
 
-static int cam_flash_set_gpio(struct cam_flash_ctrl *fctrl,
-	bool enable)
-{
-	int i;
-	struct cam_hw_soc_info *soc_info = NULL;
-	struct cam_soc_gpio_data *gpio_conf = NULL;
-	uint8_t size = 0;
-
-	if (!fctrl) {
-		CAM_ERR(CAM_FLASH, "Flash node is NULL");
-		return -EINVAL;
-	}
-
-	soc_info = &fctrl->soc_info;
-	gpio_conf = soc_info->gpio_data;
-
-	if (gpio_conf == NULL) {
-		CAM_ERR(CAM_FLASH, "GPIO DATA NULL");
-		return -EINVAL;
-	}
-
-	size = gpio_conf->gpio_delay_tbl_size;
-
-	for (i = 0; i < size; i++) {
-		CAM_DBG(CAM_FLASH, "flash %s gpio %d",
-			(enable ? "ENABLE" : "DISABLE"),
-			gpio_conf->cam_gpio_req_tbl[i].gpio);
-		cam_res_mgr_gpio_set_value(gpio_conf->cam_gpio_req_tbl[i].gpio,
-			(enable ? 1 : 0));
-		usleep_range(gpio_conf->gpio_delay_tbl[i] * 1000,
-			gpio_conf->gpio_delay_tbl[i] * 1000 + 10);
-	}
-	return 0;
-}
-
 static int cam_flash_prepare(struct cam_flash_ctrl *flash_ctrl,
 	bool regulator_enable)
 {
@@ -119,8 +84,7 @@ static int cam_flash_prepare(struct cam_flash_ctrl *flash_ctrl,
 	return rc;
 }
 
-static int cam_flash_pmic_gpio_flush_nrt(
-	struct cam_flash_ctrl *fctrl)
+static int cam_flash_pmic_flush_nrt(struct cam_flash_ctrl *fctrl)
 {
 	int j = 0;
 	struct cam_flash_frame_setting *nrt_settings;
@@ -216,18 +180,11 @@ static int cam_flash_construct_default_power_setting(
 	return rc;
 }
 
-int cam_flash_pmic_gpio_power_ops(
-	struct cam_flash_ctrl *fctrl,
+int cam_flash_pmic_power_ops(struct cam_flash_ctrl *fctrl,
 	bool regulator_enable)
 {
 	int rc = 0;
 
-	/* Gpio flash do not need to power on and off */
-	if (fctrl->soc_info.gpio_data) {
-		CAM_DBG(CAM_FLASH, "gpio based flash not need power");
-		return rc;
-	}
-
 	if (!(fctrl->switch_trigger)) {
 		CAM_ERR(CAM_FLASH, "Invalid argument");
 		return -EINVAL;
@@ -324,15 +281,13 @@ int cam_flash_i2c_power_ops(struct cam_flash_ctrl *fctrl,
 	return rc;
 }
 
-int cam_flash_pmic_gpio_flush_request(
-	struct cam_flash_ctrl *fctrl,
+int cam_flash_pmic_flush_request(struct cam_flash_ctrl *fctrl,
 	enum cam_flash_flush_type type, uint64_t req_id)
 {
 	int rc = 0;
 	int i = 0, j = 0;
 	int frame_offset = 0;
-	bool is_off_needed = false;
-	struct cam_flash_frame_setting *flash_data = NULL;
+        bool is_off_needed = false;
 
 	if (!fctrl) {
 		CAM_ERR(CAM_FLASH, "Device data is NULL");
@@ -342,56 +297,53 @@ int cam_flash_pmic_gpio_flush_request(
 	if (type == FLUSH_ALL) {
 	/* flush all requests*/
 		for (i = 0; i < MAX_PER_FRAME_ARRAY; i++) {
-			flash_data =
-				&fctrl->per_frame[i];
-			if ((flash_data->opcode ==
-				CAMERA_SENSOR_FLASH_OP_OFF) &&
-				(flash_data->cmn_attr.request_id > 0) &&
-				flash_data->cmn_attr.is_settings_valid) {
-				is_off_needed = true;
-				CAM_DBG(CAM_FLASH,
-					"FLASH_ALL: Turn off the flash for req %llu",
-					flash_data->cmn_attr.request_id);
-			}
-
-			flash_data->cmn_attr.request_id = 0;
-			flash_data->cmn_attr.is_settings_valid = false;
-			flash_data->cmn_attr.count = 0;
-			for (j = 0; j < CAM_FLASH_MAX_LED_TRIGGERS; j++)
-				flash_data->led_current_ma[j] = 0;
-		}
-
-		cam_flash_pmic_gpio_flush_nrt(fctrl);
+                       if ((fctrl->per_frame[i].opcode ==
+                               CAMERA_SENSOR_FLASH_OP_OFF) &&
+                               (fctrl->per_frame[i].cmn_attr.request_id > 0) &&
+                               (fctrl->per_frame[i].cmn_attr.request_id <= req_id) &&
+                               fctrl->per_frame[i].cmn_attr.is_settings_valid) {
+                               is_off_needed = true;
+                               CAM_DBG(CAM_FLASH,
+                                       "FLASH_ALL: Turn off the flash for req %llu",
+                                       fctrl->per_frame[i].cmn_attr.request_id);
+                       }
+
+                       fctrl->per_frame[i].cmn_attr.request_id = 0;
+                       fctrl->per_frame[i].cmn_attr.is_settings_valid = false;
+                       fctrl->per_frame[i].cmn_attr.count = 0;
+                       for (j = 0; j < CAM_FLASH_MAX_LED_TRIGGERS; j++)
+                              fctrl->per_frame[i].led_current_ma[j] = 0;
+                }
+
+		cam_flash_pmic_flush_nrt(fctrl);
 	} else if ((type == FLUSH_REQ) && (req_id != 0)) {
 	/* flush request with req_id*/
 		frame_offset = req_id % MAX_PER_FRAME_ARRAY;
-		flash_data =
-			&fctrl->per_frame[frame_offset];
 
-		if (flash_data->opcode ==
-			CAMERA_SENSOR_FLASH_OP_OFF) {
-			is_off_needed = true;
-			CAM_DBG(CAM_FLASH,
-				"FLASH_REQ: Turn off the flash for req %llu",
-				flash_data->cmn_attr.request_id);
-		}
+                if (fctrl->per_frame[frame_offset].opcode ==
+                        CAMERA_SENSOR_FLASH_OP_OFF) {
+                        is_off_needed = true;
+                        CAM_DBG(CAM_FLASH,
+                                "FLASH_REQ: Turn off the flash for req %llu",
+                                fctrl->per_frame[frame_offset].cmn_attr.request_id);
+                }
 
-		flash_data->cmn_attr.request_id = 0;
-		flash_data->cmn_attr.is_settings_valid =
+		fctrl->per_frame[frame_offset].cmn_attr.request_id = 0;
+		fctrl->per_frame[frame_offset].cmn_attr.is_settings_valid =
 			false;
-		flash_data->cmn_attr.count = 0;
+		fctrl->per_frame[frame_offset].cmn_attr.count = 0;
 		for (i = 0; i < CAM_FLASH_MAX_LED_TRIGGERS; i++)
-			flash_data->led_current_ma[i] = 0;
+			fctrl->per_frame[frame_offset].led_current_ma[i] = 0;
 	} else if ((type == FLUSH_REQ) && (req_id == 0)) {
 		/* Handels NonRealTime usecase */
-		cam_flash_pmic_gpio_flush_nrt(fctrl);
+		cam_flash_pmic_flush_nrt(fctrl);
 	} else {
 		CAM_ERR(CAM_FLASH, "Invalid arguments");
 		return -EINVAL;
 	}
 
-	if (is_off_needed)
-		cam_flash_off(fctrl);
+        if (is_off_needed)
+                cam_flash_off(fctrl);
 
 	return rc;
 }
@@ -403,7 +355,6 @@ int cam_flash_i2c_flush_request(struct cam_flash_ctrl *fctrl,
 	int i = 0;
 	uint32_t cancel_req_id_found = 0;
 	struct i2c_settings_array *i2c_set = NULL;
-	struct i2c_settings_list *i2c_list;
 
 	if (!fctrl) {
 		CAM_ERR(CAM_FLASH, "Device data is NULL");
@@ -424,20 +375,6 @@ int cam_flash_i2c_flush_request(struct cam_flash_ctrl *fctrl,
 				continue;
 
 			if (i2c_set->is_settings_valid == 1) {
-				/* If any flash_off request pending,
-				 * process it before deleting it
-				 */
-				list_for_each_entry(i2c_list,
-				&(i2c_set->list_head), list) {
-					rc = cam_sensor_util_i2c_apply_setting(
-						&(fctrl->io_master_info),
-						i2c_list);
-					if (rc) {
-						CAM_ERR(CAM_FLASH,
-						"Failed to apply settings: %d",
-						rc);
-					}
-				}
 				rc = delete_request(i2c_set);
 				if (rc < 0)
 					CAM_ERR(CAM_FLASH,
@@ -514,11 +451,6 @@ static int cam_flash_ops(struct cam_flash_ctrl *flash_ctrl,
 		flash_ctrl->soc_info.soc_private;
 
 	if (op == CAMERA_SENSOR_FLASH_OP_FIRELOW) {
-		/* Turn On Gpio Flash */
-		if (flash_ctrl->soc_info.gpio_data) {
-			cam_flash_set_gpio(flash_ctrl, true);
-			return 0;
-		}
 		for (i = 0; i < flash_ctrl->torch_num_sources; i++) {
 			if (flash_ctrl->torch_trigger[i]) {
 				max_current = soc_private->torch_max_current[i];
@@ -534,11 +466,6 @@ static int cam_flash_ops(struct cam_flash_ctrl *flash_ctrl,
 				flash_ctrl->torch_trigger[i], curr);
 		}
 	} else if (op == CAMERA_SENSOR_FLASH_OP_FIREHIGH) {
-		/* Turn On Gpio Flash */
-		if (flash_ctrl->soc_info.gpio_data) {
-			cam_flash_set_gpio(flash_ctrl, true);
-			return 0;
-		}
 		for (i = 0; i < flash_ctrl->flash_num_sources; i++) {
 			if (flash_ctrl->flash_trigger[i]) {
 				max_current = soc_private->flash_max_current[i];
@@ -572,15 +499,11 @@ int cam_flash_off(struct cam_flash_ctrl *flash_ctrl)
 		CAM_ERR(CAM_FLASH, "Flash control Null");
 		return -EINVAL;
 	}
-	CAM_DBG(CAM_FLASH, "Flash OFF Triggered");
+
 	if (flash_ctrl->switch_trigger)
 		cam_res_mgr_led_trigger_event(flash_ctrl->switch_trigger,
 			(enum led_brightness)LED_SWITCH_OFF);
 
-	/* Turn Off Gpio Flash */
-	if (flash_ctrl->soc_info.gpio_data)
-		cam_flash_set_gpio(flash_ctrl, false);
-
 	flash_ctrl->flash_state = CAM_FLASH_STATE_START;
 	return 0;
 }
@@ -640,7 +563,6 @@ static int cam_flash_i2c_delete_req(struct cam_flash_ctrl *fctrl,
 {
 	int i = 0, rc = 0;
 	uint64_t top = 0, del_req_id = 0;
-	int frame_offset = 0;
 
 	if (req_id != 0) {
 		for (i = 0; i < MAX_PER_FRAME_ARRAY; i++) {
@@ -669,23 +591,19 @@ static int cam_flash_i2c_delete_req(struct cam_flash_ctrl *fctrl,
 		CAM_DBG(CAM_FLASH, "top: %llu, del_req_id:%llu",
 			top, del_req_id);
 	}
-	/* delete/invalidate the request */
-	frame_offset = del_req_id % MAX_PER_FRAME_ARRAY;
-	fctrl->i2c_data.per_frame[frame_offset].is_settings_valid = false;
 
-	cam_flash_i2c_flush_nrt(fctrl);
+        cam_flash_i2c_flush_nrt(fctrl);
 
 	return 0;
 }
 
-static int cam_flash_pmic_gpio_delete_req(
-	struct cam_flash_ctrl *fctrl,
+static int cam_flash_pmic_delete_req(struct cam_flash_ctrl *fctrl,
 	uint64_t req_id)
 {
 	int i = 0;
 	struct cam_flash_frame_setting *flash_data = NULL;
 	uint64_t top = 0, del_req_id = 0;
-	int frame_offset = 0;
+        int frame_offset = 0;
 
 	if (req_id != 0) {
 		for (i = 0; i < MAX_PER_FRAME_ARRAY; i++) {
@@ -721,15 +639,15 @@ static int cam_flash_pmic_gpio_delete_req(
 			top, del_req_id);
 	}
 
-	/* delete the request */
-	frame_offset = del_req_id % MAX_PER_FRAME_ARRAY;
-	flash_data = &fctrl->per_frame[frame_offset];
-	flash_data->cmn_attr.request_id = 0;
-	flash_data->cmn_attr.is_settings_valid = false;
-	flash_data->cmn_attr.count = 0;
+        /* delete the request */
+        frame_offset = req_id % MAX_PER_FRAME_ARRAY;
+        flash_data = &fctrl->per_frame[frame_offset];
+        flash_data->cmn_attr.request_id = 0;
+        flash_data->cmn_attr.is_settings_valid = false;
+        flash_data->cmn_attr.count = 0;
 
-	for (i = 0; i < CAM_FLASH_MAX_LED_TRIGGERS; i++)
-		flash_data->led_current_ma[i] = 0;
+        for (i = 0; i < CAM_FLASH_MAX_LED_TRIGGERS; i++)
+                flash_data->led_current_ma[i] = 0;
 
 	return 0;
 }
@@ -835,8 +753,7 @@ int cam_flash_i2c_apply_setting(struct cam_flash_ctrl *fctrl,
 	return rc;
 }
 
-int cam_flash_pmic_gpio_apply_setting(
-	struct cam_flash_ctrl *fctrl,
+int cam_flash_pmic_apply_setting(struct cam_flash_ctrl *fctrl,
 	uint64_t req_id)
 {
 	int rc = 0, i = 0;
@@ -1013,7 +930,7 @@ int cam_flash_pmic_gpio_apply_setting(
 	}
 
 nrt_del_req:
-	cam_flash_pmic_gpio_delete_req(fctrl, req_id);
+	cam_flash_pmic_delete_req(fctrl, req_id);
 apply_setting_err:
 	return rc;
 }
@@ -1199,7 +1116,7 @@ int cam_flash_i2c_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg)
 				rc = cam_sensor_i2c_command_parser(
 					&fctrl->io_master_info,
 					i2c_reg_settings,
-					&cmd_desc[i], 1, NULL);
+					&cmd_desc[i], 1);
 				if (rc < 0) {
 					CAM_ERR(CAM_FLASH,
 					"pkt parsing failed: %d", rc);
@@ -1279,7 +1196,7 @@ int cam_flash_i2c_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg)
 		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 		rc = cam_sensor_i2c_command_parser(
 			&fctrl->io_master_info,
-			i2c_reg_settings, cmd_desc, 1, NULL);
+			i2c_reg_settings, cmd_desc, 1);
 		if (rc) {
 			CAM_ERR(CAM_FLASH,
 			"Failed in parsing i2c packets");
@@ -1310,7 +1227,7 @@ int cam_flash_i2c_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg)
 		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 		rc = cam_sensor_i2c_command_parser(
 			&fctrl->io_master_info,
-			i2c_reg_settings, cmd_desc, 1, NULL);
+			i2c_reg_settings, cmd_desc, 1);
 		if (rc) {
 			CAM_ERR(CAM_FLASH,
 			"Failed in parsing i2c NRT packets");
@@ -1366,8 +1283,7 @@ int cam_flash_i2c_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg)
 	return rc;
 }
 
-int cam_flash_pmic_gpio_pkt_parser(
-	struct cam_flash_ctrl *fctrl, void *arg)
+int cam_flash_pmic_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg)
 {
 	int rc = 0, i = 0;
 	uintptr_t generic_ptr, cmd_buf_ptr;
@@ -1631,8 +1547,6 @@ int cam_flash_pmic_gpio_pkt_parser(
 				flash_data->led_current_ma[i]
 				= flash_operation_info->led_current_ma[i];
 
-			CAM_DBG(CAM_FLASH,
-				"FLASH_CMD_TYPE op:%d", flash_data->opcode);
 			if (flash_data->opcode == CAMERA_SENSOR_FLASH_OP_OFF)
 				add_req.skip_before_applying |= SKIP_NEXT_FRAME;
 		}
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.c
index c8b5a4fb85cf..5eccfd8aa11b 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -66,11 +66,6 @@ static int32_t cam_flash_driver_cmd(struct cam_flash_ctrl *fctrl,
 
 		flash_acq_dev.device_handle =
 			cam_create_device_hdl(&bridge_params);
-		if (flash_acq_dev.device_handle <= 0) {
-			rc = -EFAULT;
-			CAM_ERR(CAM_FLASH, "Can not create device handle");
-			goto release_mutex;
-		}
 		fctrl->bridge_intf.device_hdl =
 			flash_acq_dev.device_handle;
 		fctrl->bridge_intf.session_hdl =
@@ -347,25 +342,6 @@ static int32_t cam_flash_i2c_driver_remove(struct i2c_client *client)
 	return rc;
 }
 
-static int cam_flash_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct cam_flash_ctrl *fctrl =
-		v4l2_get_subdevdata(sd);
-
-	if (!fctrl) {
-		CAM_ERR(CAM_FLASH, "Flash ctrl ptr is NULL");
-		return -EINVAL;
-	}
-
-	mutex_lock(&fctrl->flash_mutex);
-	fctrl->open_cnt++;
-	CAM_DBG(CAM_FLASH, "Flash open count %d", fctrl->open_cnt);
-	mutex_unlock(&fctrl->flash_mutex);
-
-	return 0;
-}
-
 static int cam_flash_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -378,14 +354,7 @@ static int cam_flash_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&fctrl->flash_mutex);
-	if (fctrl->open_cnt <= 0) {
-		mutex_unlock(&fctrl->flash_mutex);
-		return -EINVAL;
-	}
-	fctrl->open_cnt--;
-	CAM_DBG(CAM_FLASH, "Flash open count %d", fctrl->open_cnt);
-	if (fctrl->open_cnt == 0)
-		cam_flash_shutdown(fctrl);
+	cam_flash_shutdown(fctrl);
 	mutex_unlock(&fctrl->flash_mutex);
 
 	return 0;
@@ -403,7 +372,6 @@ static struct v4l2_subdev_ops cam_flash_subdev_ops = {
 };
 
 static const struct v4l2_subdev_internal_ops cam_flash_internal_ops = {
-	.open  = cam_flash_subdev_open,
 	.close = cam_flash_subdev_close,
 };
 
@@ -509,26 +477,11 @@ static int32_t cam_flash_platform_probe(struct platform_device *pdev)
 		fctrl->func_tbl.power_ops = cam_flash_i2c_power_ops;
 		fctrl->func_tbl.flush_req = cam_flash_i2c_flush_request;
 	} else {
-		if (fctrl->soc_info.gpio_data) {
-			rc = cam_sensor_util_request_gpio_table(
-				&fctrl->soc_info,
-				true);
-			if (rc) {
-				CAM_ERR(CAM_FLASH,
-					"GPIO table request failed: rc: %d",
-					rc);
-				goto free_gpio_resource;
-			}
-		}
-		/* PMIC GPIO Flash */
-		fctrl->func_tbl.parser =
-			cam_flash_pmic_gpio_pkt_parser;
-		fctrl->func_tbl.apply_setting =
-			cam_flash_pmic_gpio_apply_setting;
-		fctrl->func_tbl.power_ops =
-			cam_flash_pmic_gpio_power_ops;
-		fctrl->func_tbl.flush_req =
-			cam_flash_pmic_gpio_flush_request;
+		/* PMIC Flash */
+		fctrl->func_tbl.parser = cam_flash_pmic_pkt_parser;
+		fctrl->func_tbl.apply_setting = cam_flash_pmic_apply_setting;
+		fctrl->func_tbl.power_ops = cam_flash_pmic_power_ops;
+		fctrl->func_tbl.flush_req = cam_flash_pmic_flush_request;
 	}
 
 	rc = cam_flash_init_subdev(fctrl);
@@ -550,17 +503,12 @@ static int32_t cam_flash_platform_probe(struct platform_device *pdev)
 	mutex_init(&(fctrl->flash_mutex));
 
 	fctrl->flash_state = CAM_FLASH_STATE_INIT;
-	fctrl->open_cnt = 0;
 	CAM_DBG(CAM_FLASH, "Probe success");
 	return rc;
 
 free_cci_resource:
 	kfree(fctrl->io_master_info.cci_client);
 	fctrl->io_master_info.cci_client = NULL;
-free_gpio_resource:
-	cam_sensor_util_request_gpio_table(&fctrl->soc_info, false);
-	kfree(fctrl->soc_info.gpio_data);
-	fctrl->soc_info.gpio_data = NULL;
 free_resource:
 	kfree(fctrl->i2c_data.per_frame);
 	kfree(fctrl->soc_info.soc_private);
@@ -640,7 +588,6 @@ static int32_t cam_flash_i2c_driver_probe(struct i2c_client *client,
 
 	mutex_init(&(fctrl->flash_mutex));
 	fctrl->flash_state = CAM_FLASH_STATE_INIT;
-	fctrl->open_cnt = 0;
 
 	return rc;
 
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.h
index 407246cb0d59..29e352e47ce9 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_flash/cam_flash_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_FLASH_DEV_H_
@@ -115,7 +115,7 @@ struct cam_flash_frame_setting {
 	uint16_t                     num_iterations;
 	uint16_t                     led_on_delay_ms;
 	uint16_t                     led_off_delay_ms;
-	uint8_t                      opcode;
+	int8_t                       opcode;
 	uint32_t                     led_current_ma[CAM_FLASH_MAX_LED_TRIGGERS];
 };
 
@@ -207,23 +207,20 @@ struct cam_flash_ctrl {
 	struct camera_io_master             io_master_info;
 	struct i2c_data_settings            i2c_data;
 	uint32_t                            last_flush_req;
-	uint32_t                            open_cnt;
 };
 
-int cam_flash_pmic_gpio_pkt_parser(
-	struct cam_flash_ctrl *fctrl, void *arg);
+int cam_flash_pmic_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg);
 int cam_flash_i2c_pkt_parser(struct cam_flash_ctrl *fctrl, void *arg);
-int cam_flash_pmic_gpio_apply_setting(
-	struct cam_flash_ctrl *fctrl, uint64_t req_id);
+int cam_flash_pmic_apply_setting(struct cam_flash_ctrl *fctrl, uint64_t req_id);
 int cam_flash_i2c_apply_setting(struct cam_flash_ctrl *fctrl, uint64_t req_id);
 int cam_flash_off(struct cam_flash_ctrl *fctrl);
-int cam_flash_pmic_gpio_power_ops(struct cam_flash_ctrl *fctrl,
+int cam_flash_pmic_power_ops(struct cam_flash_ctrl *fctrl,
 	bool regulator_enable);
 int cam_flash_i2c_power_ops(struct cam_flash_ctrl *fctrl,
 	bool regulator_enable);
 int cam_flash_i2c_flush_request(struct cam_flash_ctrl *fctrl,
 	enum cam_flash_flush_type type, uint64_t req_id);
-int cam_flash_pmic_gpio_flush_request(struct cam_flash_ctrl *fctrl,
+int cam_flash_pmic_flush_request(struct cam_flash_ctrl *fctrl,
 	enum cam_flash_flush_type, uint64_t req_id);
 void cam_flash_shutdown(struct cam_flash_ctrl *fctrl);
 int cam_flash_release_dev(struct cam_flash_ctrl *fctrl);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_core.c b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_core.c
old mode 100644
new mode 100755
index 4520139fa001..b4f28f3da234
--- a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_core.c
@@ -54,6 +54,8 @@ int32_t cam_ois_construct_default_power_setting(
 	return rc;
 }
 
+#define OIS_TRANS_SIZE 64
+#define LC124EP3_OIS_TRANS_SIZE 5 * 12
 
 /**
  * cam_ois_get_dev_handle - get device handle
@@ -85,10 +87,6 @@ static int cam_ois_get_dev_handle(struct cam_ois_ctrl_t *o_ctrl,
 
 	ois_acq_dev.device_handle =
 		cam_create_device_hdl(&bridge_params);
-	if (ois_acq_dev.device_handle <= 0) {
-		CAM_ERR(CAM_OIS, "Can not create device handle");
-		return -EFAULT;
-	}
 	o_ctrl->bridge_intf.device_hdl = ois_acq_dev.device_handle;
 	o_ctrl->bridge_intf.session_hdl = ois_acq_dev.session_handle;
 
@@ -271,14 +269,18 @@ static int cam_ois_slaveInfo_pkt_parser(struct cam_ois_ctrl_t *o_ctrl,
 			ois_info->slave_addr >> 1;
 		o_ctrl->ois_fw_flag = ois_info->ois_fw_flag;
 		o_ctrl->is_ois_calib = ois_info->is_ois_calib;
+		o_ctrl->is_ois_pre_init = ois_info->is_ois_pre_init; //xiaomi add
 		memcpy(o_ctrl->ois_name, ois_info->ois_name, OIS_NAME_LEN);
 		o_ctrl->ois_name[OIS_NAME_LEN - 1] = '\0';
 		o_ctrl->io_master_info.cci_client->retries = 3;
 		o_ctrl->io_master_info.cci_client->id_map = 0;
+		/* xiaomi add disable cci optmz for OIS by default */
+		o_ctrl->io_master_info.cci_client->disable_optmz = 1;
 		memcpy(&(o_ctrl->opcode), &(ois_info->opcode),
 			sizeof(struct cam_ois_opcode));
-		CAM_DBG(CAM_OIS, "Slave addr: 0x%x Freq Mode: %d",
-			ois_info->slave_addr, ois_info->i2c_freq_mode);
+		CAM_DBG(CAM_OIS, "Slave addr: 0x%x Freq Mode: %d, disable optmz %d",
+			ois_info->slave_addr, ois_info->i2c_freq_mode,
+			o_ctrl->io_master_info.cci_client->disable_optmz);
 	} else if (o_ctrl->io_master_info.master_type == I2C_MASTER) {
 		o_ctrl->io_master_info.client->addr = ois_info->slave_addr;
 		CAM_DBG(CAM_OIS, "Slave addr: 0x%x", ois_info->slave_addr);
@@ -295,30 +297,51 @@ static int cam_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
 {
 	uint16_t                           total_bytes = 0;
 	uint8_t                           *ptr = NULL;
-	int32_t                            rc = 0, cnt;
+	int32_t                            rc = 0, cnt, i;
 	uint32_t                           fw_size;
+	uint32_t                           fw_size_xm;
+	uint32_t                           prog_addr;
+	uint32_t                           coeff_addr;
+	uint32_t                           mem_addr;
+	uint32_t                           pheripheral_addr;
 	const struct firmware             *fw = NULL;
+	const struct firmware             *fw_xm = NULL;
 	const char                        *fw_name_prog = NULL;
 	const char                        *fw_name_coeff = NULL;
+	const char                        *fw_name_mem = NULL;
+	const char                        *fw_name_ph = NULL;
 	char                               name_prog[32] = {0};
 	char                               name_coeff[32] = {0};
+	char                               name_mem[32] = {0};
+	char                               name_ph[32] = {0};
 	struct device                     *dev = &(o_ctrl->pdev->dev);
 	struct cam_sensor_i2c_reg_setting  i2c_reg_setting;
 	struct page                       *page = NULL;
+	struct page                       *page_xm = NULL;
 
 	if (!o_ctrl) {
 		CAM_ERR(CAM_OIS, "Invalid Args");
 		return -EINVAL;
 	}
 
+	prog_addr = o_ctrl->opcode.prog;
+	coeff_addr = o_ctrl->opcode.coeff;
+	mem_addr = o_ctrl->opcode.memory;
+	pheripheral_addr = o_ctrl->opcode.pheripheral;
+
 	snprintf(name_coeff, 32, "%s.coeff", o_ctrl->ois_name);
 
 	snprintf(name_prog, 32, "%s.prog", o_ctrl->ois_name);
 
+	snprintf(name_mem, 32, "%s.mem", o_ctrl->ois_name);
+
+	snprintf(name_ph, 32, "%s.ph", o_ctrl->ois_name);
+
 	/* cast pointer as const pointer*/
 	fw_name_prog = name_prog;
 	fw_name_coeff = name_coeff;
-
+	fw_name_mem = name_mem;
+	fw_name_ph = name_ph;
 	/* Load FW */
 	rc = request_firmware(&fw, fw_name_prog, dev);
 	if (rc) {
@@ -327,7 +350,7 @@ static int cam_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
 	}
 
 	total_bytes = fw->size;
-	i2c_reg_setting.addr_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+	i2c_reg_setting.addr_type = o_ctrl->opcode.fw_addr_type;
 	i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
 	i2c_reg_setting.size = total_bytes;
 	i2c_reg_setting.delay = 0;
@@ -344,27 +367,314 @@ static int cam_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
 	i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
 		page_address(page));
 
-	for (cnt = 0, ptr = (uint8_t *)fw->data; cnt < total_bytes;
-		cnt++, ptr++) {
-		i2c_reg_setting.reg_setting[cnt].reg_addr =
-			o_ctrl->opcode.prog;
-		i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
-		i2c_reg_setting.reg_setting[cnt].delay = 0;
-		i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+	for (i = 0, ptr = (uint8_t *)fw->data; i < total_bytes;) {
+		for (cnt = 0; cnt < OIS_TRANS_SIZE && i < total_bytes;
+			cnt++, ptr++, i++) {
+			i2c_reg_setting.reg_setting[cnt].reg_addr = prog_addr;
+			i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
+			i2c_reg_setting.reg_setting[cnt].delay = 0;
+			i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+		}
+		i2c_reg_setting.size = cnt;
+		if (o_ctrl->opcode.is_addr_increase)
+			prog_addr += cnt;
+		rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+			&i2c_reg_setting, 1);
+		if (rc < 0) {
+			CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
+			goto release_firmware;
+		}
+	}
+	cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
+		page, fw_size);
+	page = NULL;
+	fw_size = 0;
+	release_firmware(fw);
+
+	rc = request_firmware(&fw, fw_name_coeff, dev);
+	if (rc) {
+		CAM_ERR(CAM_OIS, "Failed to locate %s", fw_name_coeff);
+		return rc;
+	}
+
+	total_bytes = fw->size;
+	i2c_reg_setting.addr_type = o_ctrl->opcode.fw_addr_type;
+	i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+	i2c_reg_setting.size = total_bytes;
+	i2c_reg_setting.delay = 0;
+	fw_size = PAGE_ALIGN(sizeof(struct cam_sensor_i2c_reg_array) *
+		total_bytes) >> PAGE_SHIFT;
+	page = cma_alloc(dev_get_cma_area((o_ctrl->soc_info.dev)),
+		fw_size, 0, GFP_KERNEL);
+	if (!page) {
+		CAM_ERR(CAM_OIS, "Failed in allocating i2c_array");
+		release_firmware(fw);
+		return -ENOMEM;
+	}
+
+	i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
+		page_address(page));
+
+	for (i = 0, ptr = (uint8_t *)fw->data; i < total_bytes;) {
+		for (cnt = 0; cnt < OIS_TRANS_SIZE && i < total_bytes;
+			cnt++, ptr++, i++) {
+			i2c_reg_setting.reg_setting[cnt].reg_addr = coeff_addr;
+			i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
+			i2c_reg_setting.reg_setting[cnt].delay = 0;
+			i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+		}
+		i2c_reg_setting.size = cnt;
+		if (o_ctrl->opcode.is_addr_increase)
+			coeff_addr += cnt;
+		rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+			&i2c_reg_setting, 1);
+		if (rc < 0)
+			CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
+	}
+
+	/* Load xxx.mem added by xiaomi*/
+	rc = request_firmware(&fw_xm, fw_name_mem, dev);
+	if (rc) {
+		CAM_INFO(CAM_OIS, "no fw named %s, skip", fw_name_mem);
+		rc = 0;
+	} else {
+		total_bytes = fw_xm->size;
+		i2c_reg_setting.addr_type = o_ctrl->opcode.fw_addr_type;
+		i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+		i2c_reg_setting.size = total_bytes;
+		i2c_reg_setting.delay = 0;
+		fw_size_xm = PAGE_ALIGN(sizeof(struct cam_sensor_i2c_reg_array) *
+			total_bytes) >> PAGE_SHIFT;
+		page_xm = cma_alloc(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			fw_size_xm, 0, GFP_KERNEL);
+		if (!page_xm) {
+			CAM_ERR(CAM_OIS, "Failed in allocating i2c_array");
+			release_firmware(fw_xm);
+			return -ENOMEM;
+		}
+
+		i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
+			page_address(page_xm));
+
+		for (i = 0, ptr = (uint8_t *)fw_xm->data; i < total_bytes;) {
+			for (cnt = 0; cnt < OIS_TRANS_SIZE && i < total_bytes;
+				cnt++, ptr++, i++) {
+				i2c_reg_setting.reg_setting[cnt].reg_addr = mem_addr;
+				i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
+				i2c_reg_setting.reg_setting[cnt].delay = 0;
+				i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+			}
+			i2c_reg_setting.size = cnt;
+			if (o_ctrl->opcode.is_addr_increase)
+				mem_addr += cnt;
+			rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+				&i2c_reg_setting, 1);
+			if (rc < 0)
+				CAM_ERR(CAM_OIS, "OIS FW Memory download failed %d", rc);
+		}
+		cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			page_xm, fw_size_xm);
+		page_xm = NULL;
+		fw_size_xm = 0;
+		release_firmware(fw_xm);
+	}
+
+	/* Load xxx.ph added by xiaomi, not used by now*/
+	/*
+	rc = request_firmware(&fw_xm, fw_name_ph, dev);
+	if (rc) {
+		CAM_INFO(CAM_OIS, "Failed to locate %s, not error", fw_name_ph);
+		rc = 0;
+	} else {
+		total_bytes = fw_xm->size;
+		i2c_reg_setting.addr_type = o_ctrl->opcode.fw_addr_type;
+		i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+		i2c_reg_setting.size = total_bytes;
+		i2c_reg_setting.delay = 0;
+		fw_size_xm = PAGE_ALIGN(sizeof(struct cam_sensor_i2c_reg_array) *
+			total_bytes) >> PAGE_SHIFT;
+		page_xm = cma_alloc(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			fw_size_xm, 0, GFP_KERNEL);
+		if (!page_xm) {
+			CAM_ERR(CAM_OIS, "Failed in allocating i2c_array");
+			release_firmware(fw_xm);
+			return -ENOMEM;
+		}
+
+		i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
+			page_address(page_xm));
+
+		for (i = 0, ptr = (uint8_t *)fw_xm->data; i < total_bytes;) {
+				for (cnt = 0; cnt < OIS_TRANS_SIZE && i < total_bytes;
+					cnt++, ptr++, i++) {
+					i2c_reg_setting.reg_setting[cnt].reg_addr = pheripheral_addr;
+					i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
+					i2c_reg_setting.reg_setting[cnt].delay = 0;
+					i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+				}
+			i2c_reg_setting.size = cnt;
+			if (o_ctrl->opcode.is_addr_increase)
+				pheripheral_addr += cnt;
+			rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+				&i2c_reg_setting, 1);
+			if (rc < 0)
+				CAM_ERR(CAM_OIS, "OIS FW Memory download failed %d", rc);
+		}
+		cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			page_xm, fw_size_xm);
+		page_xm = NULL;
+		fw_size_xm = 0;
+		release_firmware(fw_xm);
+	}
+	*/
+
+release_firmware:
+	cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
+		page, fw_size);
+	release_firmware(fw);
+
+	return rc;
+}
+
+
+struct cam_sensor_i2c_reg_array ois_pm_add_array[]= {
+	{0x30, 0x00, 0x0, 0x0},
+	{0x30, 0x10, 0x0, 0x0},
+	{0x30, 0x00, 0x0, 0x0},
+	{0x30, 0x00, 0x0, 0x0},
+};
+
+struct cam_sensor_i2c_reg_array ois_pm_length_array[]= {
+	{0xF0, 0x0A, 0x0, 0x0},
+	{0xF0, 0x07, 0x0, 0x0},
+	{0xF0, 0x59, 0x0, 0x0},
+};
+
+static int cam_lc898124_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
+{
+	uint16_t                           total_bytes = 0;
+	uint8_t                           *ptr = NULL;
+	int32_t                            rc = 0, cnt, i;
+	uint32_t                           fw_size;
+	uint32_t                           fw_size_xm;
+	uint32_t                           prog_addr;
+	uint32_t                           coeff_addr;
+	uint32_t                           mem_addr;
+	const struct firmware             *fw = NULL;
+	const struct firmware             *fw_xm = NULL;
+	const char                        *fw_name_prog = NULL;
+	const char                        *fw_name_coeff = NULL;
+	const char                        *fw_name_mem = NULL;
+	char                               name_prog[32] = {0};
+	char                               name_coeff[32] = {0};
+	char                               name_mem[32] = {0};
+	struct device                     *dev = &(o_ctrl->pdev->dev);
+	struct cam_sensor_i2c_reg_setting  i2c_reg_setting;
+	struct page                       *page = NULL;
+	struct page                       *page_xm = NULL;
+	int32_t rtc = 0;
+	struct cam_sensor_i2c_reg_setting write_setting;
+	uint32_t  DMA_ByteSize = 0x0054;
+	uint32_t  DMB_ByteSize = 0x0498;
+
+	if (!o_ctrl) {
+		CAM_ERR(CAM_OIS, "Invalid Args");
+		return -EINVAL;
 	}
 
+	prog_addr = o_ctrl->opcode.prog;
+	coeff_addr = o_ctrl->opcode.coeff;
+	mem_addr = o_ctrl->opcode.memory;
+
+	snprintf(name_coeff, 32, "%s.coeff", o_ctrl->ois_name);
+
+	snprintf(name_prog, 32, "%s.prog", o_ctrl->ois_name);
+
+	snprintf(name_mem, 32, "%s.mem", o_ctrl->ois_name);
+
+	/* cast pointer as const pointer*/
+	fw_name_prog = name_prog;
+	fw_name_coeff = name_coeff;
+	fw_name_mem = name_mem;
+
+	/* PM data address write */
+	write_setting.size=  sizeof(ois_pm_add_array)/sizeof(struct cam_sensor_i2c_reg_array);
+	write_setting.addr_type =CAMERA_SENSOR_I2C_TYPE_BYTE;
+	write_setting.data_type= CAMERA_SENSOR_I2C_TYPE_BYTE;
+	write_setting.delay=0;
+	write_setting.reg_setting= ois_pm_add_array;
+
 	rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
-		&i2c_reg_setting, 1);
+		&write_setting, 1);
 	if (rc < 0) {
-		CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
-		goto release_firmware;
+		CAM_ERR(CAM_OIS, "OIS ois pm add failed %d", rc);
+	}
+
+	/* Load FW */
+	rc = request_firmware(&fw, fw_name_prog, dev);
+	if (rc) {
+		CAM_ERR(CAM_OIS, "Failed to locate %s", fw_name_prog);
+		return rc;
 	}
+
+	total_bytes = fw->size;
+	i2c_reg_setting.addr_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+	i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+	i2c_reg_setting.size = total_bytes;
+	i2c_reg_setting.delay = 0;
+	fw_size = PAGE_ALIGN(sizeof(struct cam_sensor_i2c_reg_array) *
+		total_bytes) >> PAGE_SHIFT;
+	page = cma_alloc(dev_get_cma_area((o_ctrl->soc_info.dev)),
+		fw_size, 0, GFP_KERNEL);
+	if (!page) {
+		CAM_ERR(CAM_OIS, "Failed in allocating i2c_array");
+		release_firmware(fw);
+		return -ENOMEM;
+	}
+
+	i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
+		page_address(page));
+
+	for (i = 0, ptr = (uint8_t *)fw->data; i < total_bytes;) {
+		CAM_DBG(CAM_OIS, "download  %s prog_addr =0x%02x total_bytes=%d", fw_name_prog, prog_addr,total_bytes);
+		for (cnt = 0; cnt < LC124EP3_OIS_TRANS_SIZE && i < total_bytes;
+			cnt++, ptr++, i++) {
+			i2c_reg_setting.reg_setting[cnt].reg_addr = prog_addr;
+			i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
+			i2c_reg_setting.reg_setting[cnt].delay = 0;
+			i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+		}
+		i2c_reg_setting.size = cnt;
+		rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+			&i2c_reg_setting, 1);
+		if (rc < 0) {
+			CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
+			goto release_firmware;
+		}
+	}
+
 	cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
 		page, fw_size);
 	page = NULL;
 	fw_size = 0;
 	release_firmware(fw);
 
+    /* write 0xF00A PM size*/
+
+	CAM_DBG(CAM_OIS, "PM size write");
+	write_setting.size=  sizeof(ois_pm_length_array)/sizeof(struct cam_sensor_i2c_reg_array);
+	write_setting.addr_type =CAMERA_SENSOR_I2C_TYPE_BYTE;
+	write_setting.data_type= CAMERA_SENSOR_I2C_TYPE_BYTE;
+	write_setting.delay=0;
+	write_setting.reg_setting= ois_pm_length_array;
+
+		rtc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+			&write_setting, 1);
+		if (rtc < 0) {
+			CAM_ERR(CAM_OIS, "OIS 0xF00A PM size failed %d", rc);
+		}
+
+ /* load coeff download*/
 	rc = request_firmware(&fw, fw_name_coeff, dev);
 	if (rc) {
 		CAM_ERR(CAM_OIS, "Failed to locate %s", fw_name_coeff);
@@ -389,19 +699,101 @@ static int cam_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
 	i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
 		page_address(page));
 
-	for (cnt = 0, ptr = (uint8_t *)fw->data; cnt < total_bytes;
-		cnt++, ptr++) {
-		i2c_reg_setting.reg_setting[cnt].reg_addr =
-			o_ctrl->opcode.coeff;
-		i2c_reg_setting.reg_setting[cnt].reg_data = *ptr;
-		i2c_reg_setting.reg_setting[cnt].delay = 0;
-		i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+	if( total_bytes == ((DMA_ByteSize + DMB_ByteSize) * 6 / 4))
+	{
+		ptr = (uint8_t *)fw->data;
+		coeff_addr = ptr[0];
+		for (i = 0 ; i < (DMA_ByteSize *6 /4);) {
+			CAM_DBG(CAM_OIS, "download DMA %s,coeff_addr=0x%04x", fw_name_coeff,coeff_addr);
+			for (cnt = 0; cnt < LC124EP3_OIS_TRANS_SIZE && i < (DMA_ByteSize *6 /4);
+				cnt++, i++) {
+				i2c_reg_setting.reg_setting[cnt].reg_addr = coeff_addr;
+				i2c_reg_setting.reg_setting[cnt].reg_data = ptr[i+1];
+				i2c_reg_setting.reg_setting[cnt].delay = 0;
+				i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+			}
+			i2c_reg_setting.size = cnt;
+			coeff_addr = ptr[0+i];
+			rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+				&i2c_reg_setting, 1);
+			if (rc < 0) {
+				CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
+				goto release_firmware;
+			}
+		}
+		for (i = (DMA_ByteSize *6 /4); i < total_bytes;) {
+			CAM_DBG(CAM_OIS, "download DMB %s,coeff_addr=0x%04x", fw_name_coeff,coeff_addr);
+			for (cnt = 0; cnt < LC124EP3_OIS_TRANS_SIZE && i < total_bytes;
+				cnt++, i++) {
+				i2c_reg_setting.reg_setting[cnt].reg_addr = coeff_addr;
+				i2c_reg_setting.reg_setting[cnt].reg_data = ptr[i+1];
+				i2c_reg_setting.reg_setting[cnt].delay = 0;
+				i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+			}
+			i2c_reg_setting.size = cnt;
+			coeff_addr = ptr[i];
+			rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+				&i2c_reg_setting, 1);
+			if (rc < 0) {
+				CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
+				goto release_firmware;
+			}
+		}
+	}else{
+		CAM_ERR(CAM_OIS, "OIS FW DM download failed %d", rc);
+		goto release_firmware;
+	}
+
+
+	/* Load xxx.mem added by xiaomi*/
+	rc = request_firmware(&fw_xm, fw_name_mem, dev);
+	if (rc) {
+		CAM_INFO(CAM_OIS, "no fw named %s, skip", fw_name_mem);
+		rc = 0;
+	} else {
+		total_bytes = fw_xm->size;
+		i2c_reg_setting.addr_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+		i2c_reg_setting.data_type = CAMERA_SENSOR_I2C_TYPE_BYTE;
+		i2c_reg_setting.size = total_bytes;
+		i2c_reg_setting.delay = 0;
+		fw_size_xm = PAGE_ALIGN(sizeof(struct cam_sensor_i2c_reg_array) *
+			total_bytes) >> PAGE_SHIFT;
+		page_xm = cma_alloc(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			fw_size_xm, 0, GFP_KERNEL);
+		if (!page_xm) {
+			CAM_ERR(CAM_OIS, "Failed in allocating i2c_array");
+			release_firmware(fw);
+			return -ENOMEM;
+		}
+
+		i2c_reg_setting.reg_setting = (struct cam_sensor_i2c_reg_array *) (
+			page_address(page_xm));
+
+		ptr = (uint8_t *)fw_xm->data;
+		mem_addr = ptr[0];
+		for (i = 0; i < total_bytes;) {
+			CAM_DBG(CAM_OIS, "download	%s,mem_addr=0x%04x", fw_name_mem,mem_addr);
+			for (cnt = 0; cnt < LC124EP3_OIS_TRANS_SIZE && i < total_bytes;
+				cnt++, i++) {
+				i2c_reg_setting.reg_setting[cnt].reg_addr = mem_addr;
+				i2c_reg_setting.reg_setting[cnt].reg_data = ptr[i+1];
+				i2c_reg_setting.reg_setting[cnt].delay = 0;
+				i2c_reg_setting.reg_setting[cnt].data_mask = 0;
+			}
+			i2c_reg_setting.size = cnt;
+				mem_addr = ptr[i];
+			rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
+				&i2c_reg_setting, 1);
+			if (rc < 0)
+				CAM_ERR(CAM_OIS, "OIS FW Memory download failed %d", rc);
+		}
+		cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
+			page_xm, fw_size_xm);
+		page_xm = NULL;
+		fw_size_xm = 0;
+		release_firmware(fw_xm);
 	}
 
-	rc = camera_io_dev_write_continuous(&(o_ctrl->io_master_info),
-		&i2c_reg_setting, 1);
-	if (rc < 0)
-		CAM_ERR(CAM_OIS, "OIS FW download failed %d", rc);
 
 release_firmware:
 	cma_release(dev_get_cma_area((o_ctrl->soc_info.dev)),
@@ -409,8 +801,93 @@ static int cam_ois_fw_download(struct cam_ois_ctrl_t *o_ctrl)
 	release_firmware(fw);
 
 	return rc;
+
 }
 
+#ifdef ENABLE_OIS_EIS
+static int cam_ois_get_data(struct cam_ois_ctrl_t *o_ctrl,
+		struct cam_packet *csl_packet)
+{
+	struct cam_buf_io_cfg *io_cfg;
+	uint32_t              i = 0;
+	int                   rc = 0;
+	uintptr_t             buf_addr;
+	size_t                buf_size;
+	uint8_t               *read_buffer;
+	uint32_t num_data = sizeof(o_ctrl->ois_data.data);
+	struct timespec64     ts64;
+	cycles_t              t_now;
+	uint64_t              boottime64;
+
+	memset(&o_ctrl->ois_data, 0, sizeof(struct ois_data_eis_t));
+	get_monotonic_boottime64(&ts64);
+	t_now = get_cycles();
+	boottime64 = (uint64_t)((ts64.tv_sec * 1000000000) + ts64.tv_nsec);
+
+	rc = camera_io_dev_read_seq(&(o_ctrl->io_master_info),
+			OIS_DATA_ADDR, o_ctrl->ois_data.data,
+			CAMERA_SENSOR_I2C_TYPE_BYTE, CAMERA_SENSOR_I2C_TYPE_BYTE,
+			num_data);
+	o_ctrl->ois_data.data_timestamp = (uint64_t)(t_now*10000/192);//< QTimer Freq = 19.2 MHz
+
+	if (rc < 0) {
+		CAM_ERR(CAM_OIS, "read failed");
+	} else {
+		CAM_DBG(CAM_OIS, "ois_data count=%d,data_timestamp=%llu,boottime64=%llu,t_now=%llu",
+				o_ctrl->ois_data.data[0], o_ctrl->ois_data.data_timestamp, boottime64, t_now);
+	}
+
+	io_cfg = (struct cam_buf_io_cfg *) ((uint8_t *)
+			&csl_packet->payload +
+			csl_packet->io_configs_offset);
+
+	CAM_DBG(CAM_OIS, "number of IO configs: %d:",
+			csl_packet->num_io_configs);
+
+	for (i = 0; i < csl_packet->num_io_configs; i++) {
+		CAM_DBG(CAM_OIS, "Direction: %d:", io_cfg->direction);
+		if (io_cfg->direction == CAM_BUF_OUTPUT) {
+			rc = cam_mem_get_cpu_buf(io_cfg->mem_handle[0],
+					&buf_addr, &buf_size);
+			if (rc) {
+				CAM_ERR(CAM_OIS, "Fail in get buffer: %d",
+						rc);
+				return rc;
+			}
+
+			CAM_DBG(CAM_OIS, "buf_addr : %pK, buf_size : %zu\n",
+					(void *)buf_addr, buf_size);
+
+			read_buffer = (uint8_t *)buf_addr;
+			if (!read_buffer) {
+				CAM_ERR(CAM_OIS,
+						"invalid buffer to copy data");
+				rc = -EINVAL;
+				return rc;
+			}
+			read_buffer += io_cfg->offsets[0];
+
+			if (buf_size != sizeof(struct ois_data_eis_t)) {
+				CAM_ERR(CAM_OIS,
+						"failed to copy, Invalid size");
+				rc = -EINVAL;
+				return rc;
+			}
+
+			CAM_DBG(CAM_OIS, "copy the data, len:%d",
+					num_data);
+			memcpy(read_buffer, &o_ctrl->ois_data, sizeof(struct ois_data_eis_t));
+
+		} else {
+			CAM_ERR(CAM_OIS, "Invalid direction");
+			rc = -EINVAL;
+		}
+	}
+
+	return rc;
+}
+#endif
+
 /**
  * cam_ois_pkt_parse - Parse csl packet
  * @o_ctrl:     ctrl structure
@@ -544,7 +1021,7 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 				rc = cam_sensor_i2c_command_parser(
 					&o_ctrl->io_master_info,
 					i2c_reg_settings,
-					&cmd_desc[i], 1, NULL);
+					&cmd_desc[i], 1);
 				if (rc < 0) {
 					CAM_ERR(CAM_OIS,
 					"init parsing failed: %d", rc);
@@ -561,13 +1038,30 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 				rc = cam_sensor_i2c_command_parser(
 					&o_ctrl->io_master_info,
 					i2c_reg_settings,
-					&cmd_desc[i], 1, NULL);
+					&cmd_desc[i], 1);
 				if (rc < 0) {
 					CAM_ERR(CAM_OIS,
 						"Calib parsing failed: %d", rc);
 					return rc;
 				}
-			}
+			} else if ((o_ctrl->is_ois_pre_init != 0) && //xiaomi add begin
+				(o_ctrl->i2c_pre_init_data.is_settings_valid ==
+				0)) {
+				CAM_DBG(CAM_OIS,
+					"Received pre init settings");
+				i2c_reg_settings = &(o_ctrl->i2c_pre_init_data);
+				i2c_reg_settings->is_settings_valid = 1;
+				i2c_reg_settings->request_id = 0;
+				rc = cam_sensor_i2c_command_parser(
+					&o_ctrl->io_master_info,
+					i2c_reg_settings,
+					&cmd_desc[i], 1);
+				if (rc < 0) {
+					CAM_ERR(CAM_OIS,
+						"pre init settings parsing failed: %d", rc);
+					return rc;
+				}
+			} //xiaomi add end
 			break;
 			}
 		}
@@ -581,14 +1075,34 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 			o_ctrl->cam_ois_state = CAM_OIS_CONFIG;
 		}
 
+		//xiaomi add begin
+		if (o_ctrl->is_ois_pre_init) {
+			CAM_DBG(CAM_OIS, "apply pre init settings");
+			rc = cam_ois_apply_settings(o_ctrl,
+				&o_ctrl->i2c_pre_init_data);
+			if (rc) {
+				CAM_ERR(CAM_OIS, "Cannot apply pre init data");
+				goto pwr_dwn;
+			}
+		} //xiaomi add end
+
 		if (o_ctrl->ois_fw_flag) {
-			rc = cam_ois_fw_download(o_ctrl);
+			/* xiaomi add begin */
+			if(o_ctrl->opcode.is_addr_indata) {
+				CAM_DBG(CAM_OIS, "apply lc898124 ois_fw settings");
+				rc = cam_lc898124_ois_fw_download(o_ctrl);
+			/* xiaomi add end */
+			} else {
+				CAM_DBG(CAM_OIS, "apply ois_fw settings");
+				rc = cam_ois_fw_download(o_ctrl);
+			}
 			if (rc) {
 				CAM_ERR(CAM_OIS, "Failed OIS FW Download");
 				goto pwr_dwn;
 			}
 		}
 
+		CAM_DBG(CAM_OIS, "apply init settings");
 		rc = cam_ois_apply_settings(o_ctrl, &o_ctrl->i2c_init_data);
 		if ((rc == -EAGAIN) &&
 			(o_ctrl->io_master_info.master_type == CCI_MASTER)) {
@@ -614,6 +1128,15 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 			}
 		}
 
+
+		// xiaomi add begin
+		rc = delete_request(&o_ctrl->i2c_pre_init_data);
+		if (rc < 0) {
+			CAM_WARN(CAM_OIS,
+				"Fail deleting Pre Init data: rc: %d", rc);
+			rc = 0;
+		} //xiaomi add end
+
 		rc = delete_request(&o_ctrl->i2c_init_data);
 		if (rc < 0) {
 			CAM_WARN(CAM_OIS,
@@ -643,7 +1166,7 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 		i2c_reg_settings->request_id = 0;
 		rc = cam_sensor_i2c_command_parser(&o_ctrl->io_master_info,
 			i2c_reg_settings,
-			cmd_desc, 1, NULL);
+			cmd_desc, 1);
 		if (rc < 0) {
 			CAM_ERR(CAM_OIS, "OIS pkt parsing failed: %d", rc);
 			return rc;
@@ -662,67 +1185,23 @@ static int cam_ois_pkt_parse(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 			return rc;
 		}
 		break;
-	case CAM_OIS_PACKET_OPCODE_READ: {
-		struct cam_buf_io_cfg *io_cfg;
-		struct i2c_settings_array i2c_read_settings;
-
+#ifdef ENABLE_OIS_EIS
+	case CAM_OIS_PACKET_OPCODE_OIS_GETDATA:
 		if (o_ctrl->cam_ois_state < CAM_OIS_CONFIG) {
 			rc = -EINVAL;
-			CAM_WARN(CAM_OIS,
-				"Not in right state to read OIS: %d",
-				o_ctrl->cam_ois_state);
-			return rc;
-		}
-		CAM_DBG(CAM_OIS, "number of I/O configs: %d:",
-			csl_packet->num_io_configs);
-		if (csl_packet->num_io_configs == 0) {
-			CAM_ERR(CAM_OIS, "No I/O configs to process");
-			rc = -EINVAL;
-			return rc;
-		}
-
-		INIT_LIST_HEAD(&(i2c_read_settings.list_head));
-
-		io_cfg = (struct cam_buf_io_cfg *) ((uint8_t *)
-			&csl_packet->payload +
-			csl_packet->io_configs_offset);
-
-		if (io_cfg == NULL) {
-			CAM_ERR(CAM_OIS, "I/O config is invalid(NULL)");
-			rc = -EINVAL;
-			return rc;
-		}
-
-		offset = (uint32_t *)&csl_packet->payload;
-		offset += (csl_packet->cmd_buf_offset / sizeof(uint32_t));
-		cmd_desc = (struct cam_cmd_buf_desc *)(offset);
-		i2c_read_settings.is_settings_valid = 1;
-		i2c_read_settings.request_id = 0;
-		rc = cam_sensor_i2c_command_parser(&o_ctrl->io_master_info,
-			&i2c_read_settings,
-			cmd_desc, 1, io_cfg);
-		if (rc < 0) {
-			CAM_ERR(CAM_OIS, "OIS read pkt parsing failed: %d", rc);
-			return rc;
-		}
-
-		rc = cam_sensor_i2c_read_data(
-			&i2c_read_settings,
-			&o_ctrl->io_master_info);
-		if (rc < 0) {
-			CAM_ERR(CAM_OIS, "cannot read data rc: %d", rc);
-			delete_request(&i2c_read_settings);
+			CAM_ERR(CAM_OIS,
+					"Not in right state to control OIS: %d",
+					o_ctrl->cam_ois_state);
 			return rc;
 		}
-
-		rc = delete_request(&i2c_read_settings);
+		rc = cam_ois_get_data(o_ctrl, csl_packet);
 		if (rc < 0) {
 			CAM_ERR(CAM_OIS,
-				"Failed in deleting the read settings");
+					"Fail ois_get_data: rc: %d", rc);
 			return rc;
 		}
 		break;
-	}
+#endif
 	default:
 		CAM_ERR(CAM_OIS, "Invalid Opcode: %d",
 			(csl_packet->header.op_code & 0xFFFFFF));
@@ -771,6 +1250,10 @@ void cam_ois_shutdown(struct cam_ois_ctrl_t *o_ctrl)
 	if (o_ctrl->i2c_init_data.is_settings_valid == 1)
 		delete_request(&o_ctrl->i2c_init_data);
 
+	// xiaomi add
+	if (o_ctrl->i2c_pre_init_data.is_settings_valid == 1)
+		delete_request(&o_ctrl->i2c_pre_init_data);
+
 	kfree(power_info->power_setting);
 	kfree(power_info->power_down_setting);
 	power_info->power_setting = NULL;
@@ -898,6 +1381,10 @@ int cam_ois_driver_cmd(struct cam_ois_ctrl_t *o_ctrl, void *arg)
 		if (o_ctrl->i2c_init_data.is_settings_valid == 1)
 			delete_request(&o_ctrl->i2c_init_data);
 
+		// xiaomi add
+		if (o_ctrl->i2c_pre_init_data.is_settings_valid == 1)
+			delete_request(&o_ctrl->i2c_pre_init_data);
+
 		break;
 	case CAM_STOP_DEV:
 		if (o_ctrl->cam_ois_state != CAM_OIS_START) {
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.c
index 6de45da89c44..640d91d42c21 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_ois_dev.h"
@@ -27,25 +27,6 @@ static long cam_ois_subdev_ioctl(struct v4l2_subdev *sd,
 	return rc;
 }
 
-static int cam_ois_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct cam_ois_ctrl_t *o_ctrl =
-		v4l2_get_subdevdata(sd);
-
-	if (!o_ctrl) {
-		CAM_ERR(CAM_OIS, "o_ctrl ptr is NULL");
-			return -EINVAL;
-	}
-
-	mutex_lock(&(o_ctrl->ois_mutex));
-	o_ctrl->open_cnt++;
-	CAM_DBG(CAM_OIS, "OIS open count %d", o_ctrl->open_cnt);
-	mutex_unlock(&(o_ctrl->ois_mutex));
-
-	return 0;
-}
-
 static int cam_ois_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -58,14 +39,7 @@ static int cam_ois_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&(o_ctrl->ois_mutex));
-	if (o_ctrl->open_cnt <= 0) {
-		mutex_unlock(&(o_ctrl->ois_mutex));
-		return -EINVAL;
-	}
-	o_ctrl->open_cnt--;
-	CAM_DBG(CAM_OIS, "OIS open count %d", o_ctrl->open_cnt);
-	if (o_ctrl->open_cnt == 0)
-		cam_ois_shutdown(o_ctrl);
+	cam_ois_shutdown(o_ctrl);
 	mutex_unlock(&(o_ctrl->ois_mutex));
 
 	return 0;
@@ -137,7 +111,6 @@ static long cam_ois_init_subdev_do_ioctl(struct v4l2_subdev *sd,
 #endif
 
 static const struct v4l2_subdev_internal_ops cam_ois_internal_ops = {
-	.open  = cam_ois_subdev_open,
 	.close = cam_ois_subdev_close,
 };
 
@@ -225,7 +198,6 @@ static int cam_ois_i2c_driver_probe(struct i2c_client *client,
 		goto soc_free;
 
 	o_ctrl->cam_ois_state = CAM_OIS_INIT;
-	o_ctrl->open_cnt = 0;
 
 	return rc;
 
@@ -308,6 +280,7 @@ static int32_t cam_ois_platform_driver_probe(
 	INIT_LIST_HEAD(&(o_ctrl->i2c_init_data.list_head));
 	INIT_LIST_HEAD(&(o_ctrl->i2c_calib_data.list_head));
 	INIT_LIST_HEAD(&(o_ctrl->i2c_mode_data.list_head));
+	INIT_LIST_HEAD(&(o_ctrl->i2c_pre_init_data.list_head)); //xiaomi add
 	mutex_init(&(o_ctrl->ois_mutex));
 	rc = cam_ois_driver_soc_init(o_ctrl);
 	if (rc) {
@@ -328,7 +301,6 @@ static int32_t cam_ois_platform_driver_probe(
 
 	platform_set_drvdata(pdev, o_ctrl);
 	o_ctrl->cam_ois_state = CAM_OIS_INIT;
-	o_ctrl->open_cnt = 0;
 
 	return rc;
 unreg_subdev:
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.h
index d3ba747d96e7..e4b0b59e7693 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_ois/cam_ois_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 #ifndef _CAM_OIS_DEV_H_
 #define _CAM_OIS_DEV_H_
@@ -25,6 +25,9 @@
 #define DEFINE_MSM_MUTEX(mutexname) \
 	static struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)
 
+#define ENABLE_OIS_EIS
+#define OIS_DATA_ADDR 0x8A
+
 enum cam_ois_state {
 	CAM_OIS_INIT,
 	CAM_OIS_ACQUIRE,
@@ -81,7 +84,12 @@ struct cam_ois_intf_params {
 	struct cam_req_mgr_kmd_ops ops;
 	struct cam_req_mgr_crm_cb *crm_cb;
 };
-
+#ifdef ENABLE_OIS_EIS
+struct ois_data_eis_t {
+    uint64_t data_timestamp;
+    uint8_t  data[52];
+};
+#endif
 /**
  * struct cam_ois_ctrl_t - OIS ctrl private data
  * @device_name     :   ois device_name
@@ -101,6 +109,8 @@ struct cam_ois_intf_params {
  * @is_ois_calib    :   flag for Calibration data
  * @opcode          :   ois opcode
  * @device_name     :   Device name
+ * @i2c_pre_init_data:  ois i2c pre init settings
+ * @is_ois_pre_init :   flag for pre init settings
  *
  */
 struct cam_ois_ctrl_t {
@@ -122,7 +132,11 @@ struct cam_ois_ctrl_t {
 	uint8_t ois_fw_flag;
 	uint8_t is_ois_calib;
 	struct cam_ois_opcode opcode;
-	uint32_t open_cnt;
+	struct i2c_settings_array i2c_pre_init_data; //xiaomi add
+	uint8_t is_ois_pre_init; //xiaomi add
+#ifdef ENABLE_OIS_EIS
+	struct ois_data_eis_t ois_data;
+#endif
 };
 
 #endif /*_CAM_OIS_DEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c b/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c
index c87540f7950f..34055db2863e 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_res_mgr/cam_res_mgr.c
@@ -377,14 +377,12 @@ static bool cam_res_mgr_gpio_is_shared(uint gpio)
 	bool found = false;
 	struct cam_res_mgr_dt *dt = &cam_res->dt;
 
-	mutex_lock(&cam_res->gpio_res_lock);
 	for (; index < dt->num_shared_gpio; index++) {
 		if (gpio == dt->shared_gpio[index]) {
 			found = true;
 			break;
 		}
 	}
-	mutex_unlock(&cam_res->gpio_res_lock);
 
 	return found;
 }
@@ -396,15 +394,15 @@ int cam_res_mgr_gpio_request(struct device *dev, uint gpio,
 	bool found = false;
 	struct cam_gpio_res *gpio_res = NULL;
 
+	mutex_lock(&cam_res->gpio_res_lock);
+
 	if (cam_res && cam_res->shared_gpio_enabled) {
-		mutex_lock(&cam_res->gpio_res_lock);
 		list_for_each_entry(gpio_res, &cam_res->gpio_res_list, list) {
 			if (gpio == gpio_res->gpio) {
 				found = true;
 				break;
 			}
 		}
-		mutex_unlock(&cam_res->gpio_res_lock);
 	}
 
 	/*
@@ -433,15 +431,17 @@ int cam_res_mgr_gpio_request(struct device *dev, uint gpio,
 		cam_res_mgr_gpio_is_shared(gpio)) {
 
 		gpio_res = kzalloc(sizeof(struct cam_gpio_res), GFP_KERNEL);
-		if (!gpio_res)
+		if (!gpio_res) {
+			CAM_ERR(CAM_RES, "NO MEM for cam_gpio_res");
+			mutex_unlock(&cam_res->gpio_res_lock);
 			return -ENOMEM;
+		}
 
 		gpio_res->gpio = gpio;
 		gpio_res->power_on_count = 0;
 		INIT_LIST_HEAD(&gpio_res->list);
 		INIT_LIST_HEAD(&gpio_res->dev_list);
 
-		mutex_lock(&cam_res->gpio_res_lock);
 		rc = cam_res_mgr_add_device(dev, gpio_res);
 		if (rc) {
 			kfree(gpio_res);
@@ -450,7 +450,6 @@ int cam_res_mgr_gpio_request(struct device *dev, uint gpio,
 		}
 
 		list_add_tail(&gpio_res->list, &cam_res->gpio_res_list);
-		mutex_unlock(&cam_res->gpio_res_lock);
 	}
 
 	if (found && cam_res
@@ -458,7 +457,6 @@ int cam_res_mgr_gpio_request(struct device *dev, uint gpio,
 		struct cam_dev_res *dev_res = NULL;
 
 		found = 0;
-		mutex_lock(&cam_res->gpio_res_lock);
 		list_for_each_entry(dev_res, &gpio_res->dev_list, list) {
 			if (dev_res->dev == dev) {
 				found = 1;
@@ -468,10 +466,9 @@ int cam_res_mgr_gpio_request(struct device *dev, uint gpio,
 
 		if (!found)
 			rc = cam_res_mgr_add_device(dev, gpio_res);
-
-		mutex_unlock(&cam_res->gpio_res_lock);
 	}
 
+	mutex_unlock(&cam_res->gpio_res_lock);
 	return rc;
 }
 EXPORT_SYMBOL(cam_res_mgr_gpio_request);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
index a6cbd20d62af..c16ad5b39a20 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_core.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -58,31 +58,6 @@ static void cam_sensor_release_stream_rsc(
 	}
 }
 
-static void cam_sensor_free_power_reg_rsc(
-	struct cam_sensor_ctrl_t *s_ctrl)
-{
-	struct i2c_settings_array *i2c_set = NULL;
-	int rc;
-
-	i2c_set = &(s_ctrl->i2c_data.poweron_reg_settings);
-	if (i2c_set->is_settings_valid == 1) {
-		i2c_set->is_settings_valid = -1;
-		rc = delete_request(i2c_set);
-		if (rc < 0)
-			CAM_ERR(CAM_SENSOR,
-				"failed while deleting PowerOnReg settings");
-	}
-
-	i2c_set = &(s_ctrl->i2c_data.poweroff_reg_settings);
-	if (i2c_set->is_settings_valid == 1) {
-		i2c_set->is_settings_valid = -1;
-		rc = delete_request(i2c_set);
-		if (rc < 0)
-			CAM_ERR(CAM_SENSOR,
-				"failed while deleting PowerOffReg settings");
-	}
-}
-
 static void cam_sensor_release_per_frame_resource(
 	struct cam_sensor_ctrl_t *s_ctrl)
 {
@@ -112,7 +87,6 @@ static int32_t cam_sensor_i2c_pkt_parse(struct cam_sensor_ctrl_t *s_ctrl,
 	struct cam_control *ioctl_ctrl = NULL;
 	struct cam_packet *csl_packet = NULL;
 	struct cam_cmd_buf_desc *cmd_desc = NULL;
-	struct cam_buf_io_cfg *io_cfg = NULL;
 	struct i2c_settings_array *i2c_reg_settings = NULL;
 	size_t len_of_buff = 0;
 	size_t remain_len = 0;
@@ -156,7 +130,7 @@ static int32_t cam_sensor_i2c_pkt_parse(struct cam_sensor_ctrl_t *s_ctrl,
 	csl_packet = (struct cam_packet *)(generic_ptr +
 		(uint32_t)config.offset);
 
-	if ((csl_packet == NULL) || cam_packet_util_validate_packet(csl_packet,
+	if (cam_packet_util_validate_packet(csl_packet,
 		remain_len)) {
 		CAM_ERR(CAM_SENSOR, "Invalid packet params");
 		rc = -EINVAL;
@@ -213,28 +187,7 @@ static int32_t cam_sensor_i2c_pkt_parse(struct cam_sensor_ctrl_t *s_ctrl,
 		i2c_reg_settings->is_settings_valid = 1;
 		break;
 	}
-	case CAM_SENSOR_PACKET_OPCODE_SENSOR_READ: {
-		i2c_reg_settings = &(i2c_data->read_settings);
-		i2c_reg_settings->request_id = 0;
-		i2c_reg_settings->is_settings_valid = 1;
-
-		CAM_DBG(CAM_SENSOR, "number of IO configs: %d:",
-			csl_packet->num_io_configs);
-		if (csl_packet->num_io_configs == 0) {
-			CAM_ERR(CAM_SENSOR, "No I/O configs to process");
-			goto end;
-		}
-
-		io_cfg = (struct cam_buf_io_cfg *) ((uint8_t *)
-			&csl_packet->payload +
-			csl_packet->io_configs_offset);
 
-		if (io_cfg == NULL) {
-			CAM_ERR(CAM_SENSOR, "I/O config is invalid(NULL)");
-			goto end;
-		}
-		break;
-	}
 	case CAM_SENSOR_PACKET_OPCODE_SENSOR_UPDATE: {
 		if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||
 			(s_ctrl->sensor_state == CAM_SENSOR_ACQUIRE)) {
@@ -286,7 +239,7 @@ static int32_t cam_sensor_i2c_pkt_parse(struct cam_sensor_ctrl_t *s_ctrl,
 	cmd_desc = (struct cam_cmd_buf_desc *)(offset);
 
 	rc = cam_sensor_i2c_command_parser(&s_ctrl->io_master_info,
-			i2c_reg_settings, cmd_desc, 1, io_cfg);
+			i2c_reg_settings, cmd_desc, 1);
 	if (rc < 0) {
 		CAM_ERR(CAM_SENSOR, "Fail parsing I2C Pkt: %d", rc);
 		goto end;
@@ -303,103 +256,24 @@ static int32_t cam_sensor_i2c_pkt_parse(struct cam_sensor_ctrl_t *s_ctrl,
 	return rc;
 }
 
-static int32_t cam_sensor_restore_slave_info(struct cam_sensor_ctrl_t *s_ctrl)
-{
-	int32_t rc = 0;
-
-	switch (s_ctrl->io_master_info.master_type) {
-	case CCI_MASTER:
-		s_ctrl->io_master_info.cci_client->sid =
-			(s_ctrl->sensordata->slave_info.sensor_slave_addr >> 1);
-		s_ctrl->io_master_info.cci_client->i2c_freq_mode =
-			s_ctrl->sensordata->slave_info.i2c_freq_mode;
-		break;
-
-	case I2C_MASTER:
-		s_ctrl->io_master_info.client->addr =
-			 s_ctrl->sensordata->slave_info.sensor_slave_addr;
-		break;
-
-	case SPI_MASTER:
-		break;
-
-	default:
-		CAM_ERR(CAM_SENSOR, "Invalid master type: %d",
-				s_ctrl->io_master_info.master_type);
-		rc = -EINVAL;
-		break;
-	}
-
-	return rc;
-}
-
-static int32_t cam_sensor_update_i2c_info(struct cam_cmd_i2c_info *i2c_info,
-	struct cam_sensor_ctrl_t *s_ctrl,
-	bool isInit)
-{
-	int32_t rc = 0;
-	struct cam_sensor_cci_client   *cci_client = NULL;
-
-	switch (s_ctrl->io_master_info.master_type) {
-	case CCI_MASTER:
-		cci_client = s_ctrl->io_master_info.cci_client;
-		if (!cci_client) {
-			CAM_ERR(CAM_SENSOR, "failed: cci_client %pK",
-				cci_client);
-			return -EINVAL;
-		}
-		cci_client->cci_i2c_master = s_ctrl->cci_i2c_master;
-		cci_client->sid = i2c_info->slave_addr >> 1;
-		cci_client->retries = 3;
-		cci_client->id_map = 0;
-		cci_client->i2c_freq_mode = i2c_info->i2c_freq_mode;
-		CAM_DBG(CAM_SENSOR, " Master: %d sid: 0x%x freq_mode: %d",
-			cci_client->cci_i2c_master, i2c_info->slave_addr,
-			i2c_info->i2c_freq_mode);
-		break;
-
-	case I2C_MASTER:
-		s_ctrl->io_master_info.client->addr = i2c_info->slave_addr;
-		break;
-
-	case SPI_MASTER:
-		break;
-
-	default:
-		CAM_ERR(CAM_SENSOR, "Invalid master type: %d",
-			s_ctrl->io_master_info.master_type);
-		rc = -EINVAL;
-		break;
-	}
-
-	if (isInit) {
-		s_ctrl->sensordata->slave_info.sensor_slave_addr =
-			i2c_info->slave_addr;
-		s_ctrl->sensordata->slave_info.i2c_freq_mode =
-			i2c_info->i2c_freq_mode;
-	}
-
-	return rc;
-}
-
 static int32_t cam_sensor_i2c_modes_util(
-	struct cam_sensor_ctrl_t *s_ctrl,
+	struct camera_io_master *io_master_info,
 	struct i2c_settings_list *i2c_list)
 {
 	int32_t rc = 0;
 	uint32_t i, size;
-	struct camera_io_master *io_master_info;
-
-	if (s_ctrl == NULL) {
-		CAM_ERR(CAM_SENSOR, "Invalid args");
-		return -EINVAL;
-	}
-
-	io_master_info = &s_ctrl->io_master_info;
 
 	if (i2c_list->op_code == CAM_SENSOR_I2C_WRITE_RANDOM) {
 		rc = camera_io_dev_write(io_master_info,
 			&(i2c_list->i2c_settings));
+		if ((rc == -ETIMEDOUT) &&
+			(io_master_info->master_type == CCI_MASTER)) {
+			CAM_WARN(CAM_SENSOR,
+				"CCI HW is restting: Reapplying request settings");
+			usleep_range(2000, 2010);
+			rc = camera_io_dev_write(io_master_info,
+				&(i2c_list->i2c_settings));
+		}
 		if (rc < 0) {
 			CAM_ERR(CAM_SENSOR,
 				"Failed to random write I2C settings: %d",
@@ -445,20 +319,39 @@ static int32_t cam_sensor_i2c_modes_util(
 				return rc;
 			}
 		}
-	} else if (i2c_list->op_code == CAM_SENSOR_I2C_SET_I2C_INFO) {
-		rc = cam_sensor_update_i2c_info(&i2c_list->slave_info,
-			s_ctrl,
-			false);
-	} else if ((i2c_list->op_code == CAM_SENSOR_I2C_READ_RANDOM) ||
-		(i2c_list->op_code == CAM_SENSOR_I2C_READ_SEQ)) {
-		rc = cam_sensor_i2c_read_data(
-			&s_ctrl->i2c_data.read_settings,
-			&s_ctrl->io_master_info);
 	}
 
 	return rc;
 }
 
+int32_t cam_sensor_update_i2c_info(struct cam_cmd_i2c_info *i2c_info,
+	struct cam_sensor_ctrl_t *s_ctrl)
+{
+	int32_t rc = 0;
+	struct cam_sensor_cci_client   *cci_client = NULL;
+
+	if (s_ctrl->io_master_info.master_type == CCI_MASTER) {
+		cci_client = s_ctrl->io_master_info.cci_client;
+		if (!cci_client) {
+			CAM_ERR(CAM_SENSOR, "failed: cci_client %pK",
+				cci_client);
+			return -EINVAL;
+		}
+		cci_client->cci_i2c_master = s_ctrl->cci_i2c_master;
+		cci_client->sid = i2c_info->slave_addr >> 1;
+		cci_client->retries = 3;
+		cci_client->id_map = 0;
+		cci_client->i2c_freq_mode = i2c_info->i2c_freq_mode;
+		CAM_DBG(CAM_SENSOR, " Master: %d sid: %d freq_mode: %d",
+			cci_client->cci_i2c_master, i2c_info->slave_addr,
+			i2c_info->i2c_freq_mode);
+	}
+
+	s_ctrl->sensordata->slave_info.sensor_slave_addr =
+		i2c_info->slave_addr;
+	return rc;
+}
+
 int32_t cam_sensor_update_slave_info(struct cam_cmd_probe *probe_info,
 	struct cam_sensor_ctrl_t *s_ctrl)
 {
@@ -487,8 +380,7 @@ int32_t cam_sensor_update_slave_info(struct cam_cmd_probe *probe_info,
 
 int32_t cam_handle_cmd_buffers_for_probe(void *cmd_buf,
 	struct cam_sensor_ctrl_t *s_ctrl,
-	int32_t cmd_buf_num, uint32_t cmd_buf_length, size_t remain_len,
-	struct cam_cmd_buf_desc   *cmd_desc)
+	int32_t cmd_buf_num, uint32_t cmd_buf_length, size_t remain_len)
 {
 	int32_t rc = 0;
 
@@ -505,7 +397,7 @@ int32_t cam_handle_cmd_buffers_for_probe(void *cmd_buf,
 			return -EINVAL;
 		}
 		i2c_info = (struct cam_cmd_i2c_info *)cmd_buf;
-		rc = cam_sensor_update_i2c_info(i2c_info, s_ctrl, true);
+		rc = cam_sensor_update_i2c_info(i2c_info, s_ctrl);
 		if (rc < 0) {
 			CAM_ERR(CAM_SENSOR, "Failed in Updating the i2c Info");
 			return rc;
@@ -531,42 +423,6 @@ int32_t cam_handle_cmd_buffers_for_probe(void *cmd_buf,
 		}
 	}
 		break;
-	case 2: {
-		struct i2c_settings_array *i2c_reg_settings = NULL;
-		struct i2c_data_settings *i2c_data = NULL;
-		struct cam_buf_io_cfg *io_cfg = NULL;
-
-		CAM_DBG(CAM_SENSOR, "poweron_reg_settings");
-		i2c_data = &(s_ctrl->i2c_data);
-		i2c_reg_settings = &i2c_data->poweron_reg_settings;
-		i2c_reg_settings->request_id = 0;
-		rc = cam_sensor_i2c_command_parser(&s_ctrl->io_master_info,
-				i2c_reg_settings, cmd_desc, 1, io_cfg);
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR,
-				"Failed in updating power register settings");
-			return rc;
-		}
-	}
-		break;
-	case 3: {
-		struct i2c_settings_array *i2c_reg_settings = NULL;
-		struct i2c_data_settings *i2c_data = NULL;
-		struct cam_buf_io_cfg *io_cfg = NULL;
-
-		CAM_DBG(CAM_SENSOR, "poweroff_reg_settings");
-		i2c_data = &(s_ctrl->i2c_data);
-		i2c_reg_settings = &i2c_data->poweroff_reg_settings;
-		i2c_reg_settings->request_id = 0;
-		rc = cam_sensor_i2c_command_parser(&s_ctrl->io_master_info,
-				i2c_reg_settings, cmd_desc, 1, io_cfg);
-		if (rc < 0) {
-			CAM_ERR(CAM_SENSOR,
-				"Failed in updating power register settings");
-			return rc;
-		}
-	}
-		break;
 	default:
 		CAM_ERR(CAM_SENSOR, "Invalid command buffer");
 		break;
@@ -614,7 +470,7 @@ int32_t cam_handle_mem_ptr(uint64_t handle, struct cam_sensor_ctrl_t *s_ctrl)
 		rc = -EINVAL;
 		goto end;
 	}
-	if (pkt->num_cmd_buf < 2) {
+	if (pkt->num_cmd_buf != 2) {
 		CAM_ERR(CAM_SENSOR, "Expected More Command Buffers : %d",
 			 pkt->num_cmd_buf);
 		rc = -EINVAL;
@@ -649,7 +505,7 @@ int32_t cam_handle_mem_ptr(uint64_t handle, struct cam_sensor_ctrl_t *s_ctrl)
 		ptr = (void *) cmd_buf;
 
 		rc = cam_handle_cmd_buffers_for_probe(ptr, s_ctrl,
-			i, cmd_desc[i].length, remain_len, &cmd_desc[i]);
+			i, cmd_desc[i].length, remain_len);
 		if (rc < 0) {
 			CAM_ERR(CAM_SENSOR,
 				"Failed to parse the command Buffer Header");
@@ -757,8 +613,7 @@ int cam_sensor_match_id(struct cam_sensor_ctrl_t *s_ctrl)
 	rc = camera_io_dev_read(
 		&(s_ctrl->io_master_info),
 		slave_info->sensor_id_reg_addr,
-		&chipid,
-		s_ctrl->sensor_probe_addr_type,
+		&chipid, s_ctrl->sensor_probe_addr_type,
 		s_ctrl->sensor_probe_data_type);
 
 	CAM_DBG(CAM_SENSOR, "read id: 0x%x expected id 0x%x:",
@@ -845,14 +700,6 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 			CAM_ERR(CAM_SENSOR, "power up failed");
 			goto free_power_settings;
 		}
-		if (s_ctrl->i2c_data.poweron_reg_settings.is_settings_valid) {
-			rc = cam_sensor_apply_settings(s_ctrl, 0,
-				CAM_SENSOR_PACKET_OPCODE_SENSOR_POWERON_REG);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "PowerOn REG_WR failed");
-				goto free_power_settings;
-			}
-		}
 
 		/* Match sensor ID */
 		rc = cam_sensor_match_id(s_ctrl);
@@ -862,22 +709,12 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 			goto free_power_settings;
 		}
 
-		if (s_ctrl->i2c_data.poweroff_reg_settings.is_settings_valid) {
-			rc = cam_sensor_apply_settings(s_ctrl, 0,
-				CAM_SENSOR_PACKET_OPCODE_SENSOR_POWEROFF_REG);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR, "PowerOff REG_WR failed");
-				goto free_power_settings;
-			}
-		}
-
 		CAM_INFO(CAM_SENSOR,
 			"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",
 			s_ctrl->soc_info.index,
 			s_ctrl->sensordata->slave_info.sensor_slave_addr,
 			s_ctrl->sensordata->slave_info.sensor_id);
 
-		cam_sensor_free_power_reg_rsc(s_ctrl);
 		rc = cam_sensor_power_down(s_ctrl);
 		if (rc < 0) {
 			CAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");
@@ -898,8 +735,8 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 		if ((s_ctrl->is_probe_succeed == 0) ||
 			(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {
 			CAM_WARN(CAM_SENSOR,
-				"Not in right state to aquire %d probe %d",
-				s_ctrl->sensor_state, s_ctrl->is_probe_succeed);
+				"Not in right state to aquire %d",
+				s_ctrl->sensor_state);
 			rc = -EINVAL;
 			goto release_mutex;
 		}
@@ -925,11 +762,6 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 
 		sensor_acq_dev.device_handle =
 			cam_create_device_hdl(&bridge_params);
-		if (sensor_acq_dev.device_handle <= 0) {
-			rc = -EFAULT;
-			CAM_ERR(CAM_SENSOR, "Can not create device handle");
-			goto release_mutex;
-		}
 		s_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;
 		s_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;
 
@@ -958,6 +790,26 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 	}
 		break;
 	case CAM_RELEASE_DEV: {
+
+		/*STOP DEV when sensor is START DEV and RELEASE called*/
+		if (s_ctrl->sensor_state == CAM_SENSOR_START)
+		{
+			CAM_WARN(CAM_SENSOR,
+			"Unbalance Release called with out STOP: %d",
+						s_ctrl->sensor_state);
+			if (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&
+				(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {
+				rc = cam_sensor_apply_settings(s_ctrl, 0,
+					CAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);
+				if (rc < 0) {
+					/*Even Stream off failure do force power down*/
+					CAM_ERR(CAM_SENSOR,
+					"cannot apply streamoff settings");
+				}
+			}
+			s_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;
+		}
+
 		if ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||
 			(s_ctrl->sensor_state == CAM_SENSOR_START)) {
 			rc = -EINVAL;
@@ -1141,32 +993,100 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 			}
 			s_ctrl->sensor_state = CAM_SENSOR_CONFIG;
 		}
+	}
+		break;
+	case CAM_UPDATE_REG: {
+		struct cam_sensor_i2c_reg_setting user_reg_setting;
+		struct cam_sensor_i2c_reg_array *i2c_reg_setting = NULL;
+		int i = 0;
 
-		if (s_ctrl->i2c_data.read_settings.is_settings_valid) {
-			rc = cam_sensor_apply_settings(s_ctrl, 0,
-				CAM_SENSOR_PACKET_OPCODE_SENSOR_READ);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR,
-					"cannot apply read settings");
-				delete_request(
-					&s_ctrl->i2c_data.read_settings);
-				goto release_mutex;
-			}
-			rc = delete_request(
-				&s_ctrl->i2c_data.read_settings);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR,
-					"Fail in deleting the read settings");
-				goto release_mutex;
-			}
+		rc = copy_from_user(&user_reg_setting, (void __user *)(cmd->handle), sizeof(user_reg_setting));
+		if (rc < 0) {
+			CAM_ERR(CAM_SENSOR, "Copy data from user space failed\n");
+			goto release_mutex;
 		}
 
-		CAM_DBG(CAM_SENSOR,
-			"CAM_CONFIG_DEV done sensor_id:0x%x,sensor_slave_addr:0x%x",
-			s_ctrl->sensordata->slave_info.sensor_id,
-			s_ctrl->sensordata->slave_info.sensor_slave_addr);
+		CAM_DBG(CAM_SENSOR, "CAM_UPDATE_REG reg setting size = %d", user_reg_setting.size);
+		i2c_reg_setting = kzalloc(sizeof(struct cam_sensor_i2c_reg_array) *
+			user_reg_setting.size, GFP_KERNEL);
+		if (!i2c_reg_setting) {
+			rc = -ENOMEM;
+			CAM_ERR(CAM_SENSOR, "kzalloc memory failed\n");
+			goto release_mutex;
+		}
+
+		rc = copy_from_user(i2c_reg_setting, (void __user *)(user_reg_setting.reg_setting),
+			sizeof(struct cam_sensor_i2c_reg_array) * user_reg_setting.size);
+		if (rc < 0) {
+			CAM_ERR(CAM_SENSOR, "Copy i2c setting from user space failed\n");
+			kfree(i2c_reg_setting);
+			goto release_mutex;
+		}
+		user_reg_setting.reg_setting = i2c_reg_setting;
+
+		for (i = 0; i < user_reg_setting.size; i++) {
+			CAM_DBG(CAM_SENSOR, "CAM_UPDATE_REG reg_addr=0x%x, reg_value=0x%x",
+				i2c_reg_setting[i].reg_addr, i2c_reg_setting[i].reg_data);
+		}
+
+		rc = camera_io_dev_write(&s_ctrl->io_master_info, &user_reg_setting);
+		if (rc < 0)
+			CAM_ERR(CAM_SENSOR, "Write setting failed, rc = %d\n", rc);
+
+		kfree(i2c_reg_setting);
 	}
 		break;
+	case CAM_READ_REG: {
+		struct cam_sensor_i2c_reg_setting user_reg_setting;
+		struct cam_sensor_i2c_reg_array *i2c_reg_setting;
+		int ret = 0;
+		int i = 0;
+
+		rc = copy_from_user(&user_reg_setting, (void __user *)(cmd->handle), sizeof(user_reg_setting));
+		if (rc < 0) {
+			CAM_ERR(CAM_SENSOR, "Copy data from user space failed");
+			goto release_mutex;
+		}
+
+		CAM_DBG(CAM_SENSOR, "CAM_READ_REG reg setting size = %d", user_reg_setting.size);
+		i2c_reg_setting = kzalloc(sizeof(struct cam_sensor_i2c_reg_array) *
+			user_reg_setting.size, GFP_KERNEL);
+		if (!i2c_reg_setting) {
+			rc = -ENOMEM;
+			CAM_ERR(CAM_SENSOR, "kzalloc memory failed\n");
+			goto release_mutex;
+		}
+
+		rc = copy_from_user(i2c_reg_setting, (void __user *)(user_reg_setting.reg_setting),
+			sizeof(struct cam_sensor_i2c_reg_array) * user_reg_setting.size);
+		if (rc < 0) {
+			CAM_ERR(CAM_SENSOR, "Copy i2c setting from user space failed");
+			kfree(i2c_reg_setting);
+			goto release_mutex;
+		}
+
+		for (i = 0; i < user_reg_setting.size; i++) {
+			ret += camera_io_dev_read(
+				&(s_ctrl->io_master_info),
+				i2c_reg_setting[i].reg_addr,
+				&i2c_reg_setting[i].reg_data, user_reg_setting.addr_type,
+				user_reg_setting.data_type);
+			CAM_DBG(CAM_SENSOR, "CAM_READ_REG reg_addr=0x%x, reg_value=0x%x, sid = 0x%x",
+				i2c_reg_setting[i].reg_addr, i2c_reg_setting[i].reg_data, s_ctrl->io_master_info.cci_client->sid);
+		}
+
+		if (copy_to_user((void __user *)(user_reg_setting.reg_setting), i2c_reg_setting,
+			sizeof(struct cam_sensor_i2c_reg_array) * user_reg_setting.size) || ret != 0) {
+			CAM_ERR(CAM_SENSOR, "Copy data to user space failed");
+			rc = -EFAULT;
+		}
+		if (copy_to_user((void __user *)(cmd->handle), &user_reg_setting, sizeof(user_reg_setting)) || ret != 0) {
+			CAM_ERR(CAM_SENSOR, "Copy data to user space failed");
+			rc = -EFAULT;
+		}
+		kfree(i2c_reg_setting);
+	}
+	break;
 	default:
 		CAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);
 		rc = -EINVAL;
@@ -1184,7 +1104,6 @@ int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,
 	power_info->power_down_setting = NULL;
 	power_info->power_down_setting_size = 0;
 	power_info->power_setting_size = 0;
-	cam_sensor_free_power_reg_rsc(s_ctrl);
 	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
 	return rc;
 }
@@ -1262,7 +1181,8 @@ int cam_sensor_power_up(struct cam_sensor_ctrl_t *s_ctrl)
 	int rc;
 	struct cam_sensor_power_ctrl_t *power_info;
 	struct cam_camera_slave_info *slave_info;
-	struct cam_hw_soc_info *soc_info;
+	struct cam_hw_soc_info *soc_info =
+		&s_ctrl->soc_info;
 
 	if (!s_ctrl) {
 		CAM_ERR(CAM_SENSOR, "failed: %pK", s_ctrl);
@@ -1277,8 +1197,6 @@ int cam_sensor_power_up(struct cam_sensor_ctrl_t *s_ctrl)
 		return -EINVAL;
 	}
 
-	soc_info = &s_ctrl->soc_info;
-
 	if (s_ctrl->bob_pwm_switch) {
 		rc = cam_sensor_bob_pwm_mode_switch(soc_info,
 			s_ctrl->bob_reg_index, true);
@@ -1367,18 +1285,6 @@ int cam_sensor_apply_settings(struct cam_sensor_ctrl_t *s_ctrl,
 			i2c_set = &s_ctrl->i2c_data.streamoff_settings;
 			break;
 		}
-		case CAM_SENSOR_PACKET_OPCODE_SENSOR_READ: {
-			i2c_set = &s_ctrl->i2c_data.read_settings;
-			break;
-		}
-		case CAM_SENSOR_PACKET_OPCODE_SENSOR_POWERON_REG: {
-			i2c_set = &s_ctrl->i2c_data.poweron_reg_settings;
-			break;
-		}
-		case CAM_SENSOR_PACKET_OPCODE_SENSOR_POWEROFF_REG: {
-			i2c_set = &s_ctrl->i2c_data.poweroff_reg_settings;
-			break;
-		}
 		case CAM_SENSOR_PACKET_OPCODE_SENSOR_UPDATE:
 		case CAM_SENSOR_PACKET_OPCODE_SENSOR_PROBE:
 		default:
@@ -1387,13 +1293,14 @@ int cam_sensor_apply_settings(struct cam_sensor_ctrl_t *s_ctrl,
 		if (i2c_set->is_settings_valid == 1) {
 			list_for_each_entry(i2c_list,
 				&(i2c_set->list_head), list) {
-				rc = cam_sensor_i2c_modes_util(s_ctrl,
+				rc = cam_sensor_i2c_modes_util(
+					&(s_ctrl->io_master_info),
 					i2c_list);
 				if (rc < 0) {
 					CAM_ERR(CAM_SENSOR,
 						"Failed to apply settings: %d",
 						rc);
-					goto EXIT_RESTORE;
+					return rc;
 				}
 			}
 		}
@@ -1404,13 +1311,14 @@ int cam_sensor_apply_settings(struct cam_sensor_ctrl_t *s_ctrl,
 			i2c_set->request_id == req_id) {
 			list_for_each_entry(i2c_list,
 				&(i2c_set->list_head), list) {
-				rc = cam_sensor_i2c_modes_util(s_ctrl,
+				rc = cam_sensor_i2c_modes_util(
+					&(s_ctrl->io_master_info),
 					i2c_list);
 				if (rc < 0) {
 					CAM_ERR(CAM_SENSOR,
 						"Failed to apply settings: %d",
 						rc);
-					goto EXIT_RESTORE;
+					return rc;
 				}
 			}
 		} else {
@@ -1440,7 +1348,7 @@ int cam_sensor_apply_settings(struct cam_sensor_ctrl_t *s_ctrl,
 		}
 
 		if (!del_req_id)
-			goto EXIT_RESTORE;
+			return rc;
 
 		CAM_DBG(CAM_SENSOR, "top: %llu, del_req_id:%llu",
 			top, del_req_id);
@@ -1461,9 +1369,6 @@ int cam_sensor_apply_settings(struct cam_sensor_ctrl_t *s_ctrl,
 		}
 	}
 
-EXIT_RESTORE:
-	(void)cam_sensor_restore_slave_info(s_ctrl);
-
 	return rc;
 }
 
@@ -1508,8 +1413,8 @@ int32_t cam_sensor_flush_request(struct cam_req_mgr_flush_request *flush_req)
 	}
 
 	mutex_lock(&(s_ctrl->cam_sensor_mutex));
-	if ((s_ctrl->sensor_state != CAM_SENSOR_START) &&
-		(s_ctrl->sensor_state != CAM_SENSOR_CONFIG)) {
+	if (s_ctrl->sensor_state != CAM_SENSOR_START ||
+		s_ctrl->sensor_state != CAM_SENSOR_CONFIG) {
 		mutex_unlock(&(s_ctrl->cam_sensor_mutex));
 		return rc;
 	}
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.c b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.c
index ed6b17b7bea3..f847079c730a 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_sensor_dev.h"
@@ -27,26 +27,6 @@ static long cam_sensor_subdev_ioctl(struct v4l2_subdev *sd,
 	return rc;
 }
 
-static int cam_sensor_subdev_open(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh)
-{
-	struct cam_sensor_ctrl_t *s_ctrl =
-		v4l2_get_subdevdata(sd);
-
-	if (!s_ctrl) {
-		CAM_ERR(CAM_SENSOR, "s_ctrl ptr is NULL");
-		return -EINVAL;
-	}
-
-	mutex_lock(&(s_ctrl->cam_sensor_mutex));
-	s_ctrl->open_cnt++;
-	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
-
-	CAM_DBG(CAM_SENSOR, "sensor Subdev open count %d", s_ctrl->open_cnt);
-
-	return 0;
-}
-
 static int cam_sensor_subdev_close(struct v4l2_subdev *sd,
 	struct v4l2_subdev_fh *fh)
 {
@@ -59,16 +39,7 @@ static int cam_sensor_subdev_close(struct v4l2_subdev *sd,
 	}
 
 	mutex_lock(&(s_ctrl->cam_sensor_mutex));
-	if (s_ctrl->open_cnt <= 0) {
-		mutex_unlock(&(s_ctrl->cam_sensor_mutex));
-		return -EINVAL;
-	}
-
-	s_ctrl->open_cnt--;
-	CAM_DBG(CAM_SENSOR, "sensor Subdev open count %d", s_ctrl->open_cnt);
-
-	if (s_ctrl->open_cnt == 0)
-		cam_sensor_shutdown(s_ctrl);
+	cam_sensor_shutdown(s_ctrl);
 	mutex_unlock(&(s_ctrl->cam_sensor_mutex));
 
 	return 0;
@@ -126,7 +97,6 @@ static struct v4l2_subdev_ops cam_sensor_subdev_ops = {
 };
 
 static const struct v4l2_subdev_internal_ops cam_sensor_internal_ops = {
-	.open  = cam_sensor_subdev_open,
 	.close = cam_sensor_subdev_close,
 };
 
@@ -185,7 +155,6 @@ static int32_t cam_sensor_driver_i2c_probe(struct i2c_client *client,
 	s_ctrl->of_node = client->dev.of_node;
 	s_ctrl->io_master_info.master_type = I2C_MASTER;
 	s_ctrl->is_probe_succeed = 0;
-	s_ctrl->open_cnt = 0;
 	s_ctrl->last_flush_req = 0;
 
 	rc = cam_sensor_parse_dt(s_ctrl);
@@ -210,9 +179,6 @@ static int32_t cam_sensor_driver_i2c_probe(struct i2c_client *client,
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.config_settings.list_head));
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.streamon_settings.list_head));
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.streamoff_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.poweron_reg_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.poweroff_reg_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.read_settings.list_head));
 
 	for (i = 0; i < MAX_PER_FRAME_ARRAY; i++)
 		INIT_LIST_HEAD(&(s_ctrl->i2c_data.per_frame[i].list_head));
@@ -316,7 +282,6 @@ static int32_t cam_sensor_driver_platform_probe(
 	/* Initialize sensor device type */
 	s_ctrl->of_node = pdev->dev.of_node;
 	s_ctrl->is_probe_succeed = 0;
-	s_ctrl->open_cnt = 0;
 	s_ctrl->last_flush_req = 0;
 
 	/*fill in platform device*/
@@ -349,9 +314,6 @@ static int32_t cam_sensor_driver_platform_probe(
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.config_settings.list_head));
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.streamon_settings.list_head));
 	INIT_LIST_HEAD(&(s_ctrl->i2c_data.streamoff_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.poweron_reg_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.poweroff_reg_settings.list_head));
-	INIT_LIST_HEAD(&(s_ctrl->i2c_data.read_settings.list_head));
 
 	for (i = 0; i < MAX_PER_FRAME_ARRAY; i++)
 		INIT_LIST_HEAD(&(s_ctrl->i2c_data.per_frame[i].list_head));
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.h b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.h
index d9e8eaaeb129..b1963e15eb59 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor/cam_sensor_dev.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_SENSOR_DEV_H_
@@ -111,7 +111,6 @@ struct cam_sensor_ctrl_t {
 	bool bob_pwm_switch;
 	uint32_t last_flush_req;
 	uint16_t pipeline_delay;
-	int32_t open_cnt;
 };
 
 #endif /* _CAM_SENSOR_DEV_H_ */
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
index a5e780a2e119..a79df6f943ce 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_cci_i2c.c
@@ -160,7 +160,7 @@ int32_t cam_cci_i2c_write_continuous_table(
 }
 
 static int32_t cam_cci_i2c_compare(struct cam_sensor_cci_client *client,
-	uint32_t addr, uint16_t data, uint16_t data_mask,
+	uint32_t addr, uint32_t data, uint32_t data_mask,
 	enum camera_sensor_i2c_type data_type,
 	enum camera_sensor_i2c_type addr_type)
 {
@@ -171,15 +171,18 @@ static int32_t cam_cci_i2c_compare(struct cam_sensor_cci_client *client,
 		addr_type, data_type);
 	if (rc < 0)
 		return rc;
+	//add by baichunyu@xiaomi.com
+	CAM_DBG(CAM_SENSOR, "addr %04x, %04x,compare data = %d", addr, reg_data, (int16_t)reg_data);
+	//add by baichunyu@xiaomi.com
 
-	reg_data = reg_data & 0xFFFF;
+	reg_data = reg_data & 0xFFFFFFFF;
 	if (data == (reg_data & ~data_mask))
 		return I2C_COMPARE_MATCH;
 	return I2C_COMPARE_MISMATCH;
 }
 
 int32_t cam_cci_i2c_poll(struct cam_sensor_cci_client *client,
-	uint32_t addr, uint16_t data, uint16_t data_mask,
+	uint32_t addr, uint32_t data, uint32_t data_mask,
 	enum camera_sensor_i2c_type data_type,
 	enum camera_sensor_i2c_type addr_type,
 	uint32_t delay_ms)
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_i2c.h b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_i2c.h
index def8be55bc8b..4f29aca59718 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_i2c.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_i2c.h
@@ -92,7 +92,7 @@ int32_t cam_sensor_cci_i2c_util(struct cam_sensor_cci_client *cci_client,
  * This API implements CCI based I2C poll
  */
 int32_t cam_cci_i2c_poll(struct cam_sensor_cci_client *client,
-	uint32_t addr, uint16_t data, uint16_t data_mask,
+	uint32_t addr, uint32_t data, uint32_t data_mask,
 	enum camera_sensor_i2c_type data_type,
 	enum camera_sensor_i2c_type addr_type,
 	uint32_t delay_ms);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c
index 108c47923eb7..6abf5c3a4f1b 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.c
@@ -7,7 +7,7 @@
 #include "cam_sensor_i2c.h"
 
 int32_t camera_io_dev_poll(struct camera_io_master *io_master_info,
-	uint32_t addr, uint16_t data, uint32_t data_mask,
+	uint32_t addr, uint32_t data, uint32_t data_mask,
 	enum camera_sensor_i2c_type addr_type,
 	enum camera_sensor_i2c_type data_type,
 	uint32_t delay_ms)
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.h b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.h
index f70709997e69..b1482f08aafa 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_io/cam_sensor_io.h
@@ -106,7 +106,7 @@ int32_t camera_io_dev_erase(struct camera_io_master *io_master_info,
  * This API abstracts poll functionality based on master type
  */
 int32_t camera_io_dev_poll(struct camera_io_master *io_master_info,
-	uint32_t addr, uint16_t data, uint32_t data_mask,
+	uint32_t addr, uint32_t data, uint32_t data_mask,
 	enum camera_sensor_i2c_type addr_type,
 	enum camera_sensor_i2c_type data_type,
 	uint32_t delay_ms);
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_cmn_header.h b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_cmn_header.h
index 9c4025a789af..211c62ba38eb 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_cmn_header.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_cmn_header.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_SENSOR_CMN_HEADER_
@@ -138,6 +138,7 @@ enum msm_camera_power_seq_type {
 	SENSOR_VAF_PWDM,
 	SENSOR_CUSTOM_REG1,
 	SENSOR_CUSTOM_REG2,
+	SENSOR_CUSTOM_REG3,//xiaomi add liuqinhong@xiaomi.com
 	SENSOR_RESET,
 	SENSOR_STANDBY,
 	SENSOR_CUSTOM_GPIO1,
@@ -152,17 +153,13 @@ enum cam_sensor_packet_opcodes {
 	CAM_SENSOR_PACKET_OPCODE_SENSOR_PROBE,
 	CAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG,
 	CAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF,
-	CAM_SENSOR_PACKET_OPCODE_SENSOR_READ,
-	CAM_SENSOR_PACKET_OPCODE_SENSOR_POWERON_REG,
-	CAM_SENSOR_PACKET_OPCODE_SENSOR_POWEROFF_REG,
 	CAM_SENSOR_PACKET_OPCODE_SENSOR_NOP = 127
 };
 
 enum cam_actuator_packet_opcodes {
 	CAM_ACTUATOR_PACKET_OPCODE_INIT,
 	CAM_ACTUATOR_PACKET_AUTO_MOVE_LENS,
-	CAM_ACTUATOR_PACKET_MANUAL_MOVE_LENS,
-	CAM_ACTUATOR_PACKET_OPCODE_READ
+	CAM_ACTUATOR_PACKET_MANUAL_MOVE_LENS
 };
 
 enum cam_eeprom_packet_opcodes {
@@ -173,7 +170,7 @@ enum cam_eeprom_packet_opcodes {
 enum cam_ois_packet_opcodes {
 	CAM_OIS_PACKET_OPCODE_INIT,
 	CAM_OIS_PACKET_OPCODE_OIS_CONTROL,
-	CAM_OIS_PACKET_OPCODE_READ
+	CAM_OIS_PACKET_OPCODE_OIS_GETDATA
 };
 
 enum msm_bus_perf_setting {
@@ -223,10 +220,8 @@ enum cam_sensor_i2c_cmd_type {
 	CAM_SENSOR_I2C_WRITE_RANDOM,
 	CAM_SENSOR_I2C_WRITE_BURST,
 	CAM_SENSOR_I2C_WRITE_SEQ,
-	CAM_SENSOR_I2C_READ_RANDOM,
-	CAM_SENSOR_I2C_READ_SEQ,
-	CAM_SENSOR_I2C_POLL,
-	CAM_SENSOR_I2C_SET_I2C_INFO
+	CAM_SENSOR_I2C_READ,
+	CAM_SENSOR_I2C_POLL
 };
 
 struct common_header {
@@ -277,8 +272,6 @@ struct cam_sensor_i2c_reg_setting {
 	enum camera_sensor_i2c_type addr_type;
 	enum camera_sensor_i2c_type data_type;
 	unsigned short delay;
-	uint8_t *read_buff;
-	uint32_t read_buff_len;
 };
 
 struct cam_sensor_i2c_seq_reg {
@@ -291,7 +284,6 @@ struct cam_sensor_i2c_seq_reg {
 struct i2c_settings_list {
 	struct cam_sensor_i2c_reg_setting i2c_settings;
 	struct cam_sensor_i2c_seq_reg seq_settings;
-	struct cam_cmd_i2c_info slave_info;
 	enum cam_sensor_i2c_cmd_type op_code;
 	struct list_head list;
 };
@@ -307,9 +299,6 @@ struct i2c_data_settings {
 	struct i2c_settings_array config_settings;
 	struct i2c_settings_array streamon_settings;
 	struct i2c_settings_array streamoff_settings;
-	struct i2c_settings_array read_settings;
-	struct i2c_settings_array poweron_reg_settings;
-	struct i2c_settings_array poweroff_reg_settings;
 	struct i2c_settings_array *per_frame;
 };
 
@@ -329,7 +318,6 @@ struct cam_camera_slave_info {
 	uint16_t sensor_id_reg_addr;
 	uint16_t sensor_id;
 	uint16_t sensor_id_mask;
-	uint8_t  i2c_freq_mode;
 };
 
 struct msm_sensor_init_params {
@@ -389,6 +377,7 @@ enum msm_camera_vreg_name_t {
 	CAM_VAF,
 	CAM_V_CUSTOM1,
 	CAM_V_CUSTOM2,
+	CAM_V_CUSTOM3,//xiaomi add liuqinhong@xiaomi.com
 	CAM_VREG_MAX,
 };
 
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
index b0c0b4384366..4d6a82a9cdd5 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/kernel.h>
@@ -233,170 +233,46 @@ static int32_t cam_sensor_handle_continuous_write(
 	return rc;
 }
 
-static int32_t cam_sensor_get_io_buffer(
-	struct cam_buf_io_cfg *io_cfg,
-	struct cam_sensor_i2c_reg_setting *i2c_settings)
+static int cam_sensor_handle_slave_info(
+	struct camera_io_master *io_master,
+	uint32_t *cmd_buf)
 {
-	uintptr_t buf_addr = 0x0;
-	size_t buf_size = 0;
-	int32_t rc = 0;
+	int rc = 0;
+	struct cam_cmd_i2c_info *i2c_info = (struct cam_cmd_i2c_info *)cmd_buf;
 
-	if (io_cfg == NULL || i2c_settings == NULL) {
-		CAM_ERR(CAM_SENSOR,
-			"Invalid args, io buf or i2c settings is NULL");
+	if (io_master == NULL || cmd_buf == NULL) {
+		CAM_ERR(CAM_SENSOR, "Invalid args");
 		return -EINVAL;
 	}
 
-	if (io_cfg->direction == CAM_BUF_OUTPUT) {
-		rc = cam_mem_get_cpu_buf(io_cfg->mem_handle[0],
-			&buf_addr, &buf_size);
-		if ((rc < 0) || (!buf_addr)) {
-			CAM_ERR(CAM_SENSOR,
-				"invalid buffer, rc: %d, buf_addr: %pK",
-				rc, buf_addr);
-			return -EINVAL;
-		}
-		CAM_DBG(CAM_SENSOR,
-			"buf_addr: %pK, buf_size: %zu, offsetsize: %d",
-			(void *)buf_addr, buf_size, io_cfg->offsets[0]);
-		if (io_cfg->offsets[0] >= buf_size) {
-			CAM_ERR(CAM_SENSOR,
-				"invalid size:io_cfg->offsets[0]: %d, buf_size: %d",
-				io_cfg->offsets[0], buf_size);
-			return -EINVAL;
-		}
-		i2c_settings->read_buff =
-			 (uint8_t *)buf_addr + io_cfg->offsets[0];
-		i2c_settings->read_buff_len =
-			buf_size - io_cfg->offsets[0];
-	} else {
-		CAM_ERR(CAM_SENSOR, "Invalid direction: %d",
-			io_cfg->direction);
-		rc = -EINVAL;
-	}
-	return rc;
-}
-
-static int32_t cam_sensor_handle_random_read(
-	struct cam_cmd_i2c_random_rd *cmd_i2c_random_rd,
-	struct i2c_settings_array *i2c_reg_settings,
-	uint16_t *cmd_length_in_bytes,
-	int32_t *offset,
-	struct list_head **list,
-	struct cam_buf_io_cfg *io_cfg)
-{
-	struct i2c_settings_list *i2c_list;
-	int32_t rc = 0, cnt = 0;
-
-	i2c_list = cam_sensor_get_i2c_ptr(i2c_reg_settings,
-		cmd_i2c_random_rd->header.count);
-	if ((i2c_list == NULL) ||
-		(i2c_list->i2c_settings.reg_setting == NULL)) {
-		CAM_ERR(CAM_SENSOR,
-			"Failed in allocating i2c_list: %pK",
-			i2c_list);
-		return -ENOMEM;
-	}
-
-	rc = cam_sensor_get_io_buffer(io_cfg, &(i2c_list->i2c_settings));
-	if (rc) {
-		CAM_ERR(CAM_SENSOR, "Failed to get read buffer: %d", rc);
-	} else {
-		*cmd_length_in_bytes = sizeof(struct i2c_rdwr_header) +
-			(sizeof(struct cam_cmd_read) *
-			(cmd_i2c_random_rd->header.count));
-		i2c_list->op_code = CAM_SENSOR_I2C_READ_RANDOM;
-		i2c_list->i2c_settings.addr_type =
-			cmd_i2c_random_rd->header.addr_type;
-		i2c_list->i2c_settings.data_type =
-			cmd_i2c_random_rd->header.data_type;
-		i2c_list->i2c_settings.size =
-			cmd_i2c_random_rd->header.count;
-
-		for (cnt = 0; cnt < (cmd_i2c_random_rd->header.count);
-			cnt++) {
-			i2c_list->i2c_settings.reg_setting[cnt].reg_addr =
-				cmd_i2c_random_rd->data_read[cnt].reg_data;
-		}
-		*offset = cnt;
-		*list = &(i2c_list->list);
-	}
-
-	return rc;
-}
-
-static int32_t cam_sensor_handle_continuous_read(
-	struct cam_cmd_i2c_continuous_rd *cmd_i2c_continuous_rd,
-	struct i2c_settings_array *i2c_reg_settings,
-	uint16_t *cmd_length_in_bytes, int32_t *offset,
-	struct list_head **list,
-	struct cam_buf_io_cfg *io_cfg)
-{
-	struct i2c_settings_list *i2c_list;
-	int32_t rc = 0, cnt = 0;
-
-	i2c_list = cam_sensor_get_i2c_ptr(i2c_reg_settings, 1);
-	if ((i2c_list == NULL) ||
-		(i2c_list->i2c_settings.reg_setting == NULL)) {
-		CAM_ERR(CAM_SENSOR,
-			"Failed in allocating i2c_list: %pK",
-			i2c_list);
-		return -ENOMEM;
-	}
-
-	rc = cam_sensor_get_io_buffer(io_cfg, &(i2c_list->i2c_settings));
-	if (rc) {
-		CAM_ERR(CAM_SENSOR, "Failed to get read buffer: %d", rc);
-	} else {
-		*cmd_length_in_bytes = sizeof(struct cam_cmd_i2c_continuous_rd);
-		i2c_list->op_code = CAM_SENSOR_I2C_READ_SEQ;
-
-		i2c_list->i2c_settings.addr_type =
-			cmd_i2c_continuous_rd->header.addr_type;
-		i2c_list->i2c_settings.data_type =
-			cmd_i2c_continuous_rd->header.data_type;
-		i2c_list->i2c_settings.size =
-			cmd_i2c_continuous_rd->header.count;
-		i2c_list->i2c_settings.reg_setting[0].reg_addr =
-			cmd_i2c_continuous_rd->reg_addr;
+	switch (io_master->master_type) {
+	case CCI_MASTER:
+		io_master->cci_client->sid = (i2c_info->slave_addr >> 1);
+		io_master->cci_client->i2c_freq_mode = i2c_info->i2c_freq_mode;
+		break;
 
-		*offset = cnt;
-		*list = &(i2c_list->list);
-	}
+	case I2C_MASTER:
+		io_master->client->addr = i2c_info->slave_addr;
+		break;
 
-	return rc;
-}
+	case SPI_MASTER:
+		break;
 
-static int cam_sensor_handle_slave_info(
-	uint32_t *cmd_buf,
-	struct i2c_settings_array *i2c_reg_settings,
-	struct list_head **list_ptr)
-{
-	int rc = 0;
-	struct cam_cmd_i2c_info *i2c_info = (struct cam_cmd_i2c_info *)cmd_buf;
-	struct i2c_settings_list  *i2c_list;
-
-	i2c_list =
-		cam_sensor_get_i2c_ptr(i2c_reg_settings, 1);
-	if (!i2c_list || !i2c_list->i2c_settings.reg_setting) {
-		CAM_ERR(CAM_SENSOR, "Failed in allocating mem for list");
-		return -ENOMEM;
+	default:
+		CAM_ERR(CAM_SENSOR, "Invalid master type: %d",
+			io_master->master_type);
+		rc = -EINVAL;
+		break;
 	}
 
-	i2c_list->op_code = CAM_SENSOR_I2C_SET_I2C_INFO;
-	i2c_list->slave_info = *i2c_info;
-
 	return rc;
 }
 
 /**
  * Name : cam_sensor_i2c_command_parser
  * Description : Parse CSL CCI packet and apply register settings
- * Parameters :  io_master        input  master information
- *               i2c_reg_settings output register settings to fill
- *               cmd_desc         input  command description
- *               num_cmd_buffers  input  number of command buffers to process
- *               io_cfg           input  buffer details for read operation only
+ * Parameters :  s_ctrl  input/output    sub_device
+ *              arg     input           cam_control
  * Description :
  * Handle multiple I2C RD/WR and WAIT cmd formats in one command
  * buffer, for example, a command buffer of m x RND_WR + 1 x HW_
@@ -407,12 +283,11 @@ int cam_sensor_i2c_command_parser(
 	struct camera_io_master *io_master,
 	struct i2c_settings_array *i2c_reg_settings,
 	struct cam_cmd_buf_desc   *cmd_desc,
-	int32_t num_cmd_buffers,
-	struct cam_buf_io_cfg *io_cfg)
+	int32_t num_cmd_buffers)
 {
 	int16_t                   rc = 0, i = 0;
 	size_t                    len_of_buff = 0;
-	uintptr_t                 generic_ptr;
+	uintptr_t                  generic_ptr;
 	uint16_t                  cmd_length_in_bytes = 0;
 	size_t                    remain_len = 0;
 	size_t                    tot_size = 0;
@@ -597,14 +472,14 @@ int cam_sensor_i2c_command_parser(
 			}
 			case CAMERA_SENSOR_CMD_TYPE_I2C_INFO: {
 				if (remain_len - byte_cnt <
-					sizeof(struct cam_cmd_i2c_info)) {
+				    sizeof(struct cam_cmd_i2c_info)) {
 					CAM_ERR(CAM_SENSOR,
 						"Not enough buffer space");
 					rc = -EINVAL;
 					goto end;
 				}
 				rc = cam_sensor_handle_slave_info(
-					cmd_buf, i2c_reg_settings, &list);
+					io_master, cmd_buf);
 				if (rc) {
 					CAM_ERR(CAM_SENSOR,
 					"Handle slave info failed with rc: %d",
@@ -618,88 +493,6 @@ int cam_sensor_i2c_command_parser(
 				byte_cnt += cmd_length_in_bytes;
 				break;
 			}
-			case CAMERA_SENSOR_CMD_TYPE_I2C_RNDM_RD: {
-				uint16_t cmd_length_in_bytes   = 0;
-				struct cam_cmd_i2c_random_rd *i2c_random_rd =
-				(struct cam_cmd_i2c_random_rd *)cmd_buf;
-
-				if (remain_len - byte_cnt <
-					sizeof(struct cam_cmd_i2c_random_rd)) {
-					CAM_ERR(CAM_SENSOR,
-						"Not enough buffer space");
-					rc = -EINVAL;
-					goto end;
-				}
-
-				tot_size = sizeof(struct i2c_rdwr_header) +
-					(sizeof(struct cam_cmd_read) *
-					i2c_random_rd->header.count);
-
-				if (tot_size > (remain_len - byte_cnt)) {
-					CAM_ERR(CAM_SENSOR,
-						"Not enough buffer provided %d, %d, %d",
-						tot_size, remain_len, byte_cnt);
-					rc = -EINVAL;
-					goto end;
-				}
-
-				rc = cam_sensor_handle_random_read(
-					i2c_random_rd,
-					i2c_reg_settings,
-					&cmd_length_in_bytes, &j, &list,
-					io_cfg);
-				if (rc < 0) {
-					CAM_ERR(CAM_SENSOR,
-					"Failed in random read %d", rc);
-					goto end;
-				}
-
-				cmd_buf += cmd_length_in_bytes /
-					sizeof(uint32_t);
-				byte_cnt += cmd_length_in_bytes;
-				break;
-			}
-			case CAMERA_SENSOR_CMD_TYPE_I2C_CONT_RD: {
-				uint16_t cmd_length_in_bytes   = 0;
-				struct cam_cmd_i2c_continuous_rd
-				*i2c_continuous_rd =
-				(struct cam_cmd_i2c_continuous_rd *)cmd_buf;
-
-				if (remain_len - byte_cnt <
-				    sizeof(struct cam_cmd_i2c_continuous_rd)) {
-					CAM_ERR(CAM_SENSOR,
-						"Not enough buffer space");
-					rc = -EINVAL;
-					goto end;
-				}
-
-				tot_size =
-				sizeof(struct cam_cmd_i2c_continuous_rd);
-
-				if (tot_size > (remain_len - byte_cnt)) {
-					CAM_ERR(CAM_SENSOR,
-						"Not enough buffer provided %d, %d, %d",
-						tot_size, remain_len, byte_cnt);
-					rc = -EINVAL;
-					goto end;
-				}
-
-				rc = cam_sensor_handle_continuous_read(
-					i2c_continuous_rd,
-					i2c_reg_settings,
-					&cmd_length_in_bytes, &j, &list,
-					io_cfg);
-				if (rc < 0) {
-					CAM_ERR(CAM_SENSOR,
-					"Failed in continuous read %d", rc);
-					goto end;
-				}
-
-				cmd_buf += cmd_length_in_bytes /
-					sizeof(uint32_t);
-				byte_cnt += cmd_length_in_bytes;
-				break;
-			}
 			default:
 				CAM_ERR(CAM_SENSOR, "Invalid Command Type:%d",
 					 cmm_hdr->cmd_type);
@@ -783,96 +576,6 @@ int cam_sensor_util_i2c_apply_setting(
 	return rc;
 }
 
-int32_t cam_sensor_i2c_read_data(
-	struct i2c_settings_array *i2c_settings,
-	struct camera_io_master *io_master_info)
-{
-	int32_t                   rc = 0;
-	struct i2c_settings_list  *i2c_list;
-	uint32_t                  cnt = 0;
-	uint8_t                   *read_buff = NULL;
-	uint32_t                  buff_length = 0;
-	uint32_t                  read_length = 0;
-
-	list_for_each_entry(i2c_list,
-		&(i2c_settings->list_head), list) {
-		if (i2c_list->op_code == CAM_SENSOR_I2C_SET_I2C_INFO) {
-			CAM_DBG(CAM_SENSOR,
-				"CAM_SENSOR_I2C_SET_I2C_INFO continue");
-			continue;
-		}
-
-		read_buff = i2c_list->i2c_settings.read_buff;
-		buff_length = i2c_list->i2c_settings.read_buff_len;
-		if ((read_buff == NULL) || (buff_length == 0)) {
-			CAM_ERR(CAM_SENSOR,
-				"Invalid input buffer, buffer: %pK, length: %d",
-				read_buff, buff_length);
-			return -EINVAL;
-		}
-
-		if (i2c_list->op_code == CAM_SENSOR_I2C_READ_RANDOM) {
-			read_length = i2c_list->i2c_settings.data_type *
-				i2c_list->i2c_settings.size;
-			if ((read_length > buff_length) ||
-				(read_length < i2c_list->i2c_settings.size)) {
-				CAM_ERR(CAM_SENSOR,
-				"Invalid size, readLen:%d, bufLen:%d, size: %d",
-				read_length, buff_length,
-				i2c_list->i2c_settings.size);
-				return -EINVAL;
-			}
-			for (cnt = 0; cnt < (i2c_list->i2c_settings.size);
-				cnt++) {
-				struct cam_sensor_i2c_reg_array *reg_setting =
-				&(i2c_list->i2c_settings.reg_setting[cnt]);
-				rc = camera_io_dev_read(io_master_info,
-					reg_setting->reg_addr,
-					&reg_setting->reg_data,
-					i2c_list->i2c_settings.addr_type,
-					i2c_list->i2c_settings.data_type);
-				if (rc < 0) {
-					CAM_ERR(CAM_SENSOR,
-					"Failed: random read I2C settings: %d",
-					rc);
-					return rc;
-				}
-				if (i2c_list->i2c_settings.data_type <
-					CAMERA_SENSOR_I2C_TYPE_MAX) {
-					memcpy(read_buff,
-					&reg_setting->reg_data,
-					i2c_list->i2c_settings.data_type);
-					read_buff +=
-					i2c_list->i2c_settings.data_type;
-				}
-			}
-		} else if (i2c_list->op_code == CAM_SENSOR_I2C_READ_SEQ) {
-			read_length = i2c_list->i2c_settings.size;
-			if (read_length > buff_length) {
-				CAM_ERR(CAM_SENSOR,
-				"Invalid buffer size, readLen: %d, bufLen: %d",
-				read_length, buff_length);
-				return -EINVAL;
-			}
-			rc = camera_io_dev_read_seq(
-				io_master_info,
-				i2c_list->i2c_settings.reg_setting[0].reg_addr,
-				read_buff,
-				i2c_list->i2c_settings.addr_type,
-				i2c_list->i2c_settings.data_type,
-				i2c_list->i2c_settings.size);
-			if (rc < 0) {
-				CAM_ERR(CAM_SENSOR,
-					"failed: seq read I2C settings: %d",
-					rc);
-				return rc;
-			}
-		}
-	}
-
-	return rc;
-}
-
 int32_t msm_camera_fill_vreg_params(
 	struct cam_hw_soc_info *soc_info,
 	struct cam_sensor_power_setting *power_setting,
@@ -1052,6 +755,29 @@ int32_t msm_camera_fill_vreg_params(
 			if (j == num_vreg)
 				power_setting[i].seq_val = INVALID_VREG;
 			break;
+		case SENSOR_CUSTOM_REG3://xiaomi add liuqinhong@xiaomi.com start
+			for (j = 0; j < num_vreg; j++) {
+
+				if (!strcmp(soc_info->rgltr_name[j],
+					"cam_v_custom3")) {
+					CAM_DBG(CAM_SENSOR,
+						"i:%d j:%d cam_vcustom3", i, j);
+					power_setting[i].seq_val = j;
+
+					if (VALIDATE_VOLTAGE(
+						soc_info->rgltr_min_volt[j],
+						soc_info->rgltr_max_volt[j],
+						power_setting[i].config_val)) {
+						soc_info->rgltr_min_volt[j] =
+						soc_info->rgltr_max_volt[j] =
+						power_setting[i].config_val;
+					}
+					break;
+				}
+			}
+			if (j == num_vreg)
+				power_setting[i].seq_val = INVALID_VREG;
+			break;//xiaomi add liuqinhong@xiaomi.com end
 		default:
 			break;
 		}
@@ -1982,6 +1708,7 @@ int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,
 		case SENSOR_VAF_PWDM:
 		case SENSOR_CUSTOM_REG1:
 		case SENSOR_CUSTOM_REG2:
+		case SENSOR_CUSTOM_REG3://xiaomi add liuqinhong@xiaomi.com
 			if (power_setting->seq_val == INVALID_VREG)
 				break;
 
@@ -2098,6 +1825,7 @@ int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,
 		case SENSOR_VAF_PWDM:
 		case SENSOR_CUSTOM_REG1:
 		case SENSOR_CUSTOM_REG2:
+		case SENSOR_CUSTOM_REG3://xiaomi add liuqinhong@xiaomi.com
 			if (power_setting->seq_val < num_vreg) {
 				CAM_DBG(CAM_SENSOR, "Disable Regulator");
 				vreg_idx = power_setting->seq_val;
@@ -2266,6 +1994,7 @@ int cam_sensor_util_power_down(struct cam_sensor_power_ctrl_t *ctrl,
 		case SENSOR_VAF_PWDM:
 		case SENSOR_CUSTOM_REG1:
 		case SENSOR_CUSTOM_REG2:
+		case SENSOR_CUSTOM_REG3://xiaomi add liuqinhong@xiaomi.com
 			if (pd->seq_val == INVALID_VREG)
 				break;
 
diff --git a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.h b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.h
index 3600b5636cab..c923efe61dc5 100644
--- a/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.h
+++ b/techpack/camera/drivers/cam_sensor_module/cam_sensor_utils/cam_sensor_util.h
@@ -30,16 +30,11 @@ int msm_camera_pinctrl_init
 
 int cam_sensor_i2c_command_parser(struct camera_io_master *io_master,
 	struct i2c_settings_array *i2c_reg_settings,
-	struct cam_cmd_buf_desc *cmd_desc, int32_t num_cmd_buffers,
-	struct cam_buf_io_cfg *io_cfg);
+	struct cam_cmd_buf_desc *cmd_desc, int32_t num_cmd_buffers);
 
 int cam_sensor_util_i2c_apply_setting(struct camera_io_master *io_master_info,
 	struct i2c_settings_list *i2c_list);
 
-int32_t cam_sensor_i2c_read_data(
-	struct i2c_settings_array *i2c_settings,
-	struct camera_io_master *io_master_info);
-
 int32_t delete_request(struct i2c_settings_array *i2c_array);
 int cam_sensor_util_request_gpio_table(
 	struct cam_hw_soc_info *soc_info, int gpio_en);
diff --git a/techpack/camera/drivers/cam_smmu/Makefile b/techpack/camera/drivers/cam_smmu/Makefile
index 2968a7a1e2af..b674b48ceb2d 100644
--- a/techpack/camera/drivers/cam_smmu/Makefile
+++ b/techpack/camera/drivers/cam_smmu/Makefile
@@ -1,7 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 
 ccflags-y += -I$(srctree)/techpack/camera/include/uapi
-ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_core
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_utils
 ccflags-y += -I$(srctree)/techpack/camera/drivers/cam_req_mgr
 
diff --git a/techpack/camera/drivers/cam_smmu/cam_smmu_api.c b/techpack/camera/drivers/cam_smmu/cam_smmu_api.c
index b249182af954..4ab25ea73681 100644
--- a/techpack/camera/drivers/cam_smmu/cam_smmu_api.c
+++ b/techpack/camera/drivers/cam_smmu/cam_smmu_api.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/module.h>
@@ -21,8 +21,6 @@
 #include <media/cam_req_mgr.h>
 #include "cam_smmu_api.h"
 #include "cam_debug_util.h"
-#include "cam_trace.h"
-#include "cam_common_util.h"
 
 #define SHARED_MEM_POOL_GRANULARITY 16
 
@@ -37,11 +35,6 @@
 #define GET_SMMU_HDL(x, y) (((x) << COOKIE_SIZE) | ((y) & COOKIE_MASK))
 #define GET_SMMU_TABLE_IDX(x) (((x) >> COOKIE_SIZE) & COOKIE_MASK)
 
-#define CAM_SMMU_MONITOR_MAX_ENTRIES   100
-#define CAM_SMMU_INC_MONITOR_HEAD(head, ret) \
-	div_u64_rem(atomic64_add_return(1, head),\
-	CAM_SMMU_MONITOR_MAX_ENTRIES, (ret))
-
 static int g_num_pf_handled = 4;
 module_param(g_num_pf_handled, int, 0644);
 
@@ -100,17 +93,6 @@ struct secheap_buf_info {
 	struct sg_table *table;
 };
 
-struct cam_smmu_monitor {
-	struct timespec64       timestamp;
-	bool                    is_map;
-
-	/* map-unmap info */
-	int                     ion_fd;
-	dma_addr_t              paddr;
-	size_t                  len;
-	enum cam_smmu_region_id region_id;
-};
-
 struct cam_context_bank_info {
 	struct device *dev;
 	struct iommu_domain *domain;
@@ -158,9 +140,6 @@ struct cam_context_bank_info {
 	/* discard iova - non-zero values are valid */
 	dma_addr_t discard_iova_start;
 	size_t discard_iova_len;
-
-	atomic64_t  monitor_head;
-	struct cam_smmu_monitor monitor_entries[CAM_SMMU_MONITOR_MAX_ENTRIES];
 };
 
 struct cam_iommu_cb_set {
@@ -173,7 +152,6 @@ struct cam_iommu_cb_set {
 	u32 non_fatal_fault;
 	struct dentry *dentry;
 	bool cb_dump_enable;
-	bool map_profile_enable;
 };
 
 static const struct of_device_id msm_cam_smmu_dt_match[] = {
@@ -284,76 +262,6 @@ static int cam_smmu_probe(struct platform_device *pdev);
 
 static uint32_t cam_smmu_find_closest_mapping(int idx, void *vaddr);
 
-static void cam_smmu_update_monitor_array(
-	struct cam_context_bank_info *cb_info,
-	bool is_map,
-	struct cam_dma_buff_info *mapping_info)
-{
-	int iterator;
-
-	CAM_SMMU_INC_MONITOR_HEAD(&cb_info->monitor_head, &iterator);
-
-	ktime_get_real_ts64(&cb_info->monitor_entries[iterator].timestamp);
-
-	cb_info->monitor_entries[iterator].is_map = is_map;
-	cb_info->monitor_entries[iterator].ion_fd = mapping_info->ion_fd;
-	cb_info->monitor_entries[iterator].paddr = mapping_info->paddr;
-	cb_info->monitor_entries[iterator].len = mapping_info->len;
-	cb_info->monitor_entries[iterator].region_id = mapping_info->region_id;
-}
-
-static void cam_smmu_dump_monitor_array(
-	struct cam_context_bank_info *cb_info)
-{
-	int i = 0;
-	int64_t state_head = 0;
-	uint32_t index, num_entries, oldest_entry;
-	uint64_t ms, tmp, hrs, min, sec;
-	struct timespec64 *ts = NULL;
-
-	state_head = atomic64_read(&cb_info->monitor_head);
-
-	if (state_head == -1) {
-		return;
-	} else if (state_head < CAM_SMMU_MONITOR_MAX_ENTRIES) {
-		num_entries = state_head;
-		oldest_entry = 0;
-	} else {
-		num_entries = CAM_SMMU_MONITOR_MAX_ENTRIES;
-		div_u64_rem(state_head + 1,
-			CAM_SMMU_MONITOR_MAX_ENTRIES, &oldest_entry);
-	}
-
-	CAM_INFO(CAM_SMMU,
-		"========Dumping monitor information for cb %s===========",
-		cb_info->name);
-
-	index = oldest_entry;
-
-	for (i = 0; i < num_entries; i++) {
-		ts = &cb_info->monitor_entries[index].timestamp;
-		tmp = ts->tv_sec;
-		ms = (ts->tv_nsec) / 1000000;
-		sec = do_div(tmp, 60);
-		min = do_div(tmp, 60);
-		hrs = do_div(tmp, 24);
-
-		CAM_INFO(CAM_SMMU,
-		"**** %llu:%llu:%llu.%llu : Index[%d] [%s] : ion_fd=%d start=0x%x end=0x%x len=%u region=%d",
-		hrs, min, sec, ms,
-		index,
-		cb_info->monitor_entries[index].is_map ? "MAP" : "UNMAP",
-		cb_info->monitor_entries[index].ion_fd,
-		(void *)cb_info->monitor_entries[index].paddr,
-		((uint64_t)cb_info->monitor_entries[index].paddr +
-		(uint64_t)cb_info->monitor_entries[index].len),
-		(unsigned int)cb_info->monitor_entries[index].len,
-		cb_info->monitor_entries[index].region_id);
-
-		index = (index + 1) % CAM_SMMU_MONITOR_MAX_ENTRIES;
-	}
-}
-
 static void cam_smmu_page_fault_work(struct work_struct *work)
 {
 	int j;
@@ -436,8 +344,6 @@ static void cam_smmu_dump_cb_info(int idx)
 				(unsigned int)mapping->len,
 				mapping->region_id);
 		}
-
-		cam_smmu_dump_monitor_array(&iommu_cb_set.cb_info[idx]);
 	}
 }
 
@@ -495,7 +401,7 @@ static uint32_t cam_smmu_find_closest_mapping(int idx, void *vaddr)
 	list_for_each_entry(mapping,
 			&iommu_cb_set.cb_info[idx].smmu_buf_list, list) {
 		start_addr = (unsigned long)mapping->paddr;
-		end_addr = (unsigned long)mapping->paddr + mapping->len;
+		end_addr = (unsigned long)mapping->paddr + mapping->len - 1;
 
 		if (start_addr <= current_addr && current_addr <= end_addr) {
 			closest_mapping = mapping;
@@ -526,11 +432,11 @@ static uint32_t cam_smmu_find_closest_mapping(int idx, void *vaddr)
 	if (closest_mapping) {
 		buf_handle = GET_MEM_HANDLE(idx, closest_mapping->ion_fd);
 		CAM_INFO(CAM_SMMU,
-			"Closest map fd %d 0x%lx %llu-%llu 0x%lx-0x%lx buf=%pK mem %0x",
+			"Closest map fd %d 0x%lx %llu 0x%lx-0x%lx buf=%pK mem %0x",
 			closest_mapping->ion_fd, current_addr,
-			mapping->len, closest_mapping->len,
+			closest_mapping->len,
 			(unsigned long)closest_mapping->paddr,
-			(unsigned long)closest_mapping->paddr + mapping->len,
+			(unsigned long)closest_mapping->paddr + mapping->len - 1,
 			closest_mapping->buf,
 			buf_handle);
 	} else
@@ -1809,8 +1715,6 @@ static int cam_smmu_map_buffer_validate(struct dma_buf *buf,
 	size_t size = 0;
 	uint32_t iova = 0;
 	int rc = 0;
-	struct timespec64 ts1, ts2;
-	long microsec = 0;
 
 	if (IS_ERR_OR_NULL(buf)) {
 		rc = PTR_ERR(buf);
@@ -1825,9 +1729,6 @@ static int cam_smmu_map_buffer_validate(struct dma_buf *buf,
 		goto err_out;
 	}
 
-	if (iommu_cb_set.map_profile_enable)
-		CAM_GET_TIMESTAMP(ts1);
-
 	attach = dma_buf_attach(buf, iommu_cb_set.cb_info[idx].dev);
 	if (IS_ERR_OR_NULL(attach)) {
 		rc = PTR_ERR(attach);
@@ -1887,9 +1788,7 @@ static int cam_smmu_map_buffer_validate(struct dma_buf *buf,
 		table = dma_buf_map_attachment(attach, dma_dir);
 		if (IS_ERR_OR_NULL(table)) {
 			rc = PTR_ERR(table);
-			CAM_ERR(CAM_SMMU,
-				"Error: dma map attachment failed, size=%zu",
-				buf->size);
+			CAM_ERR(CAM_SMMU, "Error: dma map attachment failed");
 			goto err_detach;
 		}
 
@@ -1902,16 +1801,8 @@ static int cam_smmu_map_buffer_validate(struct dma_buf *buf,
 		goto err_unmap_sg;
 	}
 
-	CAM_DBG(CAM_SMMU,
-		"iova=%pK, region_id=%d, paddr=%pK, len=%d, dma_map_attrs=%d",
-		iova, region_id, *paddr_ptr, *len_ptr, attach->dma_map_attrs);
-
-	if (iommu_cb_set.map_profile_enable) {
-		CAM_GET_TIMESTAMP(ts2);
-		CAM_GET_TIMESTAMP_DIFF_IN_MICRO(ts1, ts2, microsec);
-		trace_cam_log_event("SMMUMapProfile", "size and time in micro",
-			*len_ptr, microsec);
-	}
+	CAM_DBG(CAM_SMMU, "iova=%pK, region_id=%d, paddr=%pK, len=%d",
+		iova, region_id, *paddr_ptr, *len_ptr);
 
 	if (table->sgl) {
 		CAM_DBG(CAM_SMMU,
@@ -2003,9 +1894,6 @@ static int cam_smmu_map_buffer_and_add_to_list(int idx, int ion_fd,
 	list_add(&mapping_info->list,
 		&iommu_cb_set.cb_info[idx].smmu_buf_list);
 
-	cam_smmu_update_monitor_array(&iommu_cb_set.cb_info[idx], true,
-		mapping_info);
-
 	return 0;
 }
 
@@ -2031,9 +1919,6 @@ static int cam_smmu_map_kernel_buffer_and_add_to_list(int idx,
 	list_add(&mapping_info->list,
 		&iommu_cb_set.cb_info[idx].smmu_buf_kernel_list);
 
-	cam_smmu_update_monitor_array(&iommu_cb_set.cb_info[idx], true,
-		mapping_info);
-
 	return 0;
 }
 
@@ -2045,8 +1930,6 @@ static int cam_smmu_unmap_buf_and_remove_from_list(
 	int rc;
 	size_t size;
 	struct iommu_domain *domain;
-	struct timespec64 ts1, ts2;
-	long microsec = 0;
 
 	if ((!mapping_info->buf) || (!mapping_info->table) ||
 		(!mapping_info->attach)) {
@@ -2060,17 +1943,6 @@ static int cam_smmu_unmap_buf_and_remove_from_list(
 		return -EINVAL;
 	}
 
-	cam_smmu_update_monitor_array(&iommu_cb_set.cb_info[idx], false,
-		mapping_info);
-
-	CAM_DBG(CAM_SMMU,
-		"region_id=%d, paddr=%pK, len=%d, dma_map_attrs=%d",
-		mapping_info->region_id, mapping_info->paddr, mapping_info->len,
-		mapping_info->attach->dma_map_attrs);
-
-	if (iommu_cb_set.map_profile_enable)
-		CAM_GET_TIMESTAMP(ts1);
-
 	if (mapping_info->region_id == CAM_SMMU_REGION_SHARED) {
 		CAM_DBG(CAM_SMMU,
 			"Removing SHARED buffer paddr = %pK, len = %zu",
@@ -2107,13 +1979,6 @@ static int cam_smmu_unmap_buf_and_remove_from_list(
 	dma_buf_detach(mapping_info->buf, mapping_info->attach);
 	dma_buf_put(mapping_info->buf);
 
-	if (iommu_cb_set.map_profile_enable) {
-		CAM_GET_TIMESTAMP(ts2);
-		CAM_GET_TIMESTAMP_DIFF_IN_MICRO(ts1, ts2, microsec);
-		trace_cam_log_event("SMMUUnmapProfile",
-			"size and time in micro", mapping_info->len, microsec);
-	}
-
 	mapping_info->buf = NULL;
 
 	list_del_init(&mapping_info->list);
@@ -3031,7 +2896,6 @@ int cam_smmu_get_iova(int handle, int ion_fd,
 	if (buf_state == CAM_SMMU_BUFF_NOT_EXIST) {
 		CAM_ERR(CAM_SMMU, "ion_fd:%d not in the mapped list", ion_fd);
 		rc = -EINVAL;
-		cam_smmu_dump_cb_info(idx);
 		goto get_addr_end;
 	}
 
@@ -3377,8 +3241,6 @@ static int cam_smmu_setup_cb(struct cam_context_bank_info *cb,
 	cb->is_fw_allocated = false;
 	cb->is_secheap_allocated = false;
 
-	atomic64_set(&cb->monitor_head, -1);
-
 	/* Create a pool with 64K granularity for supporting shared memory */
 	if (cb->shared_support) {
 		cb->shared_mem_pool = gen_pool_create(
@@ -3432,7 +3294,6 @@ static int cam_smmu_setup_cb(struct cam_context_bank_info *cb,
 		if (cb->discard_iova_start)
 			iommu_dma_reserve_iova(dev, cb->discard_iova_start,
 				cb->discard_iova_len);
-
 		cb->state = CAM_SMMU_ATTACH;
 	} else {
 		CAM_ERR(CAM_SMMU, "Context bank does not have IO region");
@@ -3848,15 +3709,6 @@ static int cam_smmu_create_debug_fs(void)
 		goto err;
 	}
 
-	if (!debugfs_create_bool("map_profile_enable",
-		0644,
-		iommu_cb_set.dentry,
-		&iommu_cb_set.map_profile_enable)) {
-		CAM_ERR(CAM_SMMU,
-			"failed to create map_profile_enable");
-		goto err;
-	}
-
 	return 0;
 err:
 	debugfs_remove_recursive(iommu_cb_set.dentry);
diff --git a/techpack/camera/drivers/cam_sync/cam_sync.c b/techpack/camera/drivers/cam_sync/cam_sync.c
index 691f4113012b..9099e2a91088 100644
--- a/techpack/camera/drivers/cam_sync/cam_sync.c
+++ b/techpack/camera/drivers/cam_sync/cam_sync.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/init.h>
@@ -38,7 +38,7 @@ static void cam_sync_print_fence_table(void)
 			sync_dev->sync_table[idx].name,
 			sync_dev->sync_table[idx].type,
 			sync_dev->sync_table[idx].state,
-			atomic_read(&sync_dev->sync_table[idx].ref_cnt));
+			sync_dev->sync_table[idx].ref_cnt);
 		spin_unlock_bh(&sync_dev->row_spinlocks[idx]);
 	}
 }
@@ -286,7 +286,6 @@ int cam_sync_merge(int32_t *sync_obj, uint32_t num_objs, int32_t *merged_obj)
 	int rc;
 	long idx = 0;
 	bool bit;
-	int i = 0;
 
 	if (!sync_obj || !merged_obj) {
 		CAM_ERR(CAM_SYNC, "Invalid pointer(s)");
@@ -298,20 +297,18 @@ int cam_sync_merge(int32_t *sync_obj, uint32_t num_objs, int32_t *merged_obj)
 		return -EINVAL;
 	}
 
+	if (cam_sync_validate_sync_objects(sync_obj, num_objs)) {
+		CAM_ERR(CAM_SYNC,
+			"The objects passed for merge are not valid");
+		return -EINVAL;
+	}
+
 	if (cam_common_util_remove_duplicate_arr(sync_obj, num_objs)
 		!= num_objs) {
 		CAM_ERR(CAM_SYNC, "The obj list has duplicate fence");
 		return -EINVAL;
 	}
 
-	for (i = 0; i < num_objs; i++) {
-		rc = cam_sync_check_valid(sync_obj[i]);
-		if (rc) {
-			CAM_ERR(CAM_SYNC, "Sync_obj[%d] %d valid check fail",
-				i, sync_obj[i]);
-			return rc;
-		}
-	}
 	do {
 		idx = find_first_zero_bit(sync_dev->bitmap, CAM_SYNC_MAX_OBJS);
 		if (idx >= CAM_SYNC_MAX_OBJS)
@@ -383,30 +380,6 @@ int cam_sync_destroy(int32_t sync_obj)
 	return cam_sync_deinit_object(sync_dev->sync_table, sync_obj);
 }
 
-int cam_sync_check_valid(int32_t sync_obj)
-{
-	struct sync_table_row *row = NULL;
-
-	if (sync_obj >= CAM_SYNC_MAX_OBJS || sync_obj <= 0)
-		return -EINVAL;
-
-	row = sync_dev->sync_table + sync_obj;
-
-	if (!test_bit(sync_obj, sync_dev->bitmap)) {
-		CAM_ERR(CAM_SYNC, "Error: Released sync obj received %d",
-			sync_obj);
-		return -EINVAL;
-	}
-
-	if (row->state == CAM_SYNC_STATE_INVALID) {
-		CAM_ERR(CAM_SYNC,
-			"Error: accessing an uninitialized sync obj = %d",
-			sync_obj);
-		return -EINVAL;
-	}
-	return 0;
-}
-
 int cam_sync_wait(int32_t sync_obj, uint64_t timeout_ms)
 {
 	unsigned long timeleft;
@@ -469,7 +442,6 @@ static int cam_sync_handle_create(struct cam_private_ioctl_arg *k_ioctl)
 		u64_to_user_ptr(k_ioctl->ioctl_ptr),
 		k_ioctl->size))
 		return -EFAULT;
-	sync_create.name[SYNC_DEBUG_NAME_LEN] = '\0';
 
 	result = cam_sync_create(&sync_create.sync_obj,
 		sync_create.name);
diff --git a/techpack/camera/drivers/cam_sync/cam_sync_api.h b/techpack/camera/drivers/cam_sync/cam_sync_api.h
index 3304acb50bba..3d99bc15eb18 100644
--- a/techpack/camera/drivers/cam_sync/cam_sync_api.h
+++ b/techpack/camera/drivers/cam_sync/cam_sync_api.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #ifndef __CAM_SYNC_API_H__
@@ -140,14 +140,5 @@ int cam_sync_destroy(int32_t sync_obj);
  */
 int cam_sync_wait(int32_t sync_obj, uint64_t timeout_ms);
 
-/**
- * @brief: Check if sync object is valid
- *
- * @param sync_obj: int referencing the sync object to be checked
- *
- * @return 0 upon success, -EINVAL if sync object is in bad state or arguments
- * are invalid
- */
-int cam_sync_check_valid(int32_t sync_obj);
 
 #endif /* __CAM_SYNC_API_H__ */
diff --git a/techpack/camera/drivers/cam_sync/cam_sync_private.h b/techpack/camera/drivers/cam_sync/cam_sync_private.h
index a8612fdcd7c5..29fdc799e506 100644
--- a/techpack/camera/drivers/cam_sync/cam_sync_private.h
+++ b/techpack/camera/drivers/cam_sync/cam_sync_private.h
@@ -24,8 +24,9 @@
 #endif
 
 #define CAM_SYNC_OBJ_NAME_LEN           64
-#define CAM_SYNC_MAX_OBJS               1024
-#define CAM_SYNC_MAX_V4L2_EVENTS        100
+//changed by xiaomi: CMI-6335(vedio/slow motion) needs upto 1024 fences
+#define CAM_SYNC_MAX_OBJS               1792 // 1536=1024+768
+#define CAM_SYNC_MAX_V4L2_EVENTS        200
 #define CAM_SYNC_DEBUG_FILENAME         "cam_debug"
 #define CAM_SYNC_DEBUG_BASEDIR          "cam"
 #define CAM_SYNC_DEBUG_BUF_SIZE         32
diff --git a/techpack/camera/drivers/cam_sync/cam_sync_util.c b/techpack/camera/drivers/cam_sync/cam_sync_util.c
index 05e59dde9c26..86f6e1732050 100644
--- a/techpack/camera/drivers/cam_sync/cam_sync_util.c
+++ b/techpack/camera/drivers/cam_sync/cam_sync_util.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  */
 
 #include "cam_sync_util.h"
@@ -53,6 +53,22 @@ int cam_sync_init_row(struct sync_table_row *table,
 	return 0;
 }
 
+int cam_sync_validate_sync_objects(uint32_t *sync_objs,
+	uint32_t num_objs)
+{
+	int i = 0;
+
+	for (i = 0; i < num_objs; i++) {
+		if (sync_objs[i] >= CAM_SYNC_MAX_OBJS) {
+			CAM_ERR(CAM_SYNC, "Invalid sync object %u",
+				sync_objs[i]);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 int cam_sync_init_group_object(struct sync_table_row *table,
 	uint32_t idx,
 	uint32_t *sync_objs,
@@ -72,13 +88,17 @@ int cam_sync_init_group_object(struct sync_table_row *table,
 	 * If any child state is ERROR or SUCCESS, it will not be added to list.
 	 */
 	for (i = 0; i < num_objs; i++) {
-		if (idx == sync_objs[i]) {
-			CAM_ERR(CAM_SYNC,
-				"Invalid, same as parent fence : %i", idx);
-			rc = -EINVAL;
-			goto clean_children_info;
-		}
 		child_row = table + sync_objs[i];
+
+		if (sync_objs[i] == idx) {
+		        CAM_ERR(CAM_SYNC,
+		                 "Invalid child fence:%i state:%u type:%u",
+		                 child_row->sync_id, child_row->state,
+		                 child_row->type);
+		        rc = -EINVAL;
+		         goto clean_children_info;
+		}
+
 		spin_lock_bh(&sync_dev->row_spinlocks[sync_objs[i]]);
 
 		/* validate child */
diff --git a/techpack/camera/drivers/cam_sync/cam_sync_util.h b/techpack/camera/drivers/cam_sync/cam_sync_util.h
index e114c33c655a..ab6b40696c6d 100644
--- a/techpack/camera/drivers/cam_sync/cam_sync_util.h
+++ b/techpack/camera/drivers/cam_sync/cam_sync_util.h
@@ -50,6 +50,18 @@ int cam_sync_init_row(struct sync_table_row *table,
  */
 int cam_sync_deinit_object(struct sync_table_row *table, uint32_t idx);
 
+/**
+ * @brief: Function to validate sync objects passed to merge
+ *
+ * @param table : Array of sync objects which will merged
+ *                    or grouped together
+ * @param idx   : Number of sync objects in the array
+ *
+ * @return Status of operation. Negative in case of error. Zero otherwise.
+ */
+int cam_sync_validate_sync_objects(uint32_t *sync_objs,
+	uint32_t num_objs);
+
 /**
  * @brief: Function to initialize a row in the sync table when the object is a
  *         group object, also known as a merged sync object
diff --git a/techpack/camera/drivers/cam_utils/cam_common_util.h b/techpack/camera/drivers/cam_utils/cam_common_util.h
index ebe75f6eb5e9..e202bae5b761 100644
--- a/techpack/camera/drivers/cam_utils/cam_common_util.h
+++ b/techpack/camera/drivers/cam_utils/cam_common_util.h
@@ -14,25 +14,6 @@
 #define PTR_TO_U64(ptr) ((uint64_t)(uintptr_t)ptr)
 #define U64_TO_PTR(ptr) ((void *)(uintptr_t)ptr)
 
-#define CAM_GET_TIMESTAMP(timestamp) ktime_get_real_ts64(&(timestamp))
-#define CAM_GET_TIMESTAMP_DIFF_IN_MICRO(ts_start, ts_end, diff_microsec)       \
-({                                                                             \
-	diff_microsec = 0;                                                     \
-	if (ts_end.tv_nsec >= ts_start.tv_nsec) {                              \
-		diff_microsec =                                                \
-			(ts_end.tv_nsec - ts_start.tv_nsec) / 1000;            \
-		diff_microsec +=                                               \
-			(ts_end.tv_sec - ts_start.tv_sec) * 1000 * 1000;       \
-	} else {                                                               \
-		diff_microsec =                                                \
-			(ts_end.tv_nsec +                                      \
-			(1000*1000*1000 - ts_start.tv_nsec)) / 1000;           \
-		diff_microsec +=                                               \
-			(ts_end.tv_sec - ts_start.tv_sec - 1) * 1000 * 1000;   \
-	}                                                                      \
-})
-
-
 /**
  * cam_common_util_get_string_index()
  *
diff --git a/techpack/camera/drivers/cam_utils/cam_cx_ipeak.c b/techpack/camera/drivers/cam_utils/cam_cx_ipeak.c
index 58246e86b8da..b0f93ba045e0 100644
--- a/techpack/camera/drivers/cam_utils/cam_cx_ipeak.c
+++ b/techpack/camera/drivers/cam_utils/cam_cx_ipeak.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/of.h>
@@ -35,7 +35,7 @@ int cam_cx_ipeak_register_cx_ipeak(struct cam_hw_soc_info *soc_info)
 	if (cam_cx_ipeak) {
 		goto exit;
 	} else {
-		CAM_WARN(CAM_UTIL, "cx_ipeak_register failed");
+		rc = -EINVAL;
 		goto exit;
 	}
 
diff --git a/techpack/camera/drivers/cam_utils/cam_debug_util.h b/techpack/camera/drivers/cam_utils/cam_debug_util.h
index b21312f61bea..181a1558a904 100644
--- a/techpack/camera/drivers/cam_utils/cam_debug_util.h
+++ b/techpack/camera/drivers/cam_utils/cam_debug_util.h
@@ -1,15 +1,11 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #ifndef _CAM_DEBUG_UTIL_H_
 #define _CAM_DEBUG_UTIL_H_
 
-#define CAM_IS_NULL_TO_STR(ptr) ((ptr) ? "Non-NULL" : "NULL")
-
-/* Module IDs used for debug logging */
 #define CAM_CDM        (1 << 0)
 #define CAM_CORE       (1 << 1)
 #define CAM_CPAS       (1 << 2)
diff --git a/techpack/camera/drivers/cam_utils/cam_io_util.c b/techpack/camera/drivers/cam_utils/cam_io_util.c
index fcbc4b5e00f5..d35320e7e487 100644
--- a/techpack/camera/drivers/cam_utils/cam_io_util.c
+++ b/techpack/camera/drivers/cam_utils/cam_io_util.c
@@ -265,8 +265,8 @@ int cam_io_dump(void __iomem *base_addr, uint32_t start_offset, int size)
 			p_str += 11;
 		}
 		data = readl_relaxed(base_addr + REG_OFFSET(start_offset, i));
-		snprintf(p_str, 10, "%08x  ", data);
-		p_str += 9;
+		snprintf(p_str, 9, "%08x ", data);
+		p_str += 8;
 		if ((i + 1) % NUM_REGISTER_PER_LINE == 0) {
 			CAM_ERR(CAM_UTIL, "%s", line_str);
 			line_str[0] = '\0';
diff --git a/techpack/camera/drivers/cam_utils/cam_packet_util.c b/techpack/camera/drivers/cam_utils/cam_packet_util.c
index 1569d5dbafa6..4eadee666219 100644
--- a/techpack/camera/drivers/cam_utils/cam_packet_util.c
+++ b/techpack/camera/drivers/cam_utils/cam_packet_util.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #include <linux/types.h>
@@ -154,59 +154,6 @@ int cam_packet_util_get_kmd_buffer(struct cam_packet *packet,
 	return rc;
 }
 
-void cam_packet_dump_patch_info(struct cam_packet *packet,
-	int32_t iommu_hdl, int32_t sec_mmu_hdl)
-{
-	struct cam_patch_desc *patch_desc = NULL;
-	dma_addr_t iova_addr;
-	size_t     dst_buf_len;
-	size_t     src_buf_size;
-	int        i, rc = 0;
-	int32_t    hdl;
-	uintptr_t  cpu_addr = 0;
-	uint32_t  *dst_cpu_addr;
-	uint64_t   value = 0;
-
-	patch_desc = (struct cam_patch_desc *)
-			((uint32_t *) &packet->payload +
-			packet->patch_offset/4);
-
-	for (i = 0; i < packet->num_patches; i++) {
-		hdl = cam_mem_is_secure_buf(patch_desc[i].src_buf_hdl) ?
-			sec_mmu_hdl : iommu_hdl;
-		rc = cam_mem_get_io_buf(patch_desc[i].src_buf_hdl,
-			hdl, &iova_addr, &src_buf_size);
-		if (rc < 0) {
-			CAM_ERR(CAM_UTIL,
-				"unable to get src buf address for hdl 0x%x",
-				hdl);
-			return;
-		}
-
-		rc = cam_mem_get_cpu_buf(patch_desc[i].dst_buf_hdl,
-			&cpu_addr, &dst_buf_len);
-		if (rc < 0 || !cpu_addr || (dst_buf_len == 0)) {
-			CAM_ERR(CAM_UTIL, "unable to get dst buf address");
-			return;
-		}
-
-		dst_cpu_addr = (uint32_t *)cpu_addr;
-		dst_cpu_addr = (uint32_t *)((uint8_t *)dst_cpu_addr +
-			patch_desc[i].dst_offset);
-		value = *((uint64_t *)dst_cpu_addr);
-		CAM_INFO(CAM_UTIL,
-			"i = %d src_buf 0x%llx src_hdl 0x%x src_buf_with_offset 0x%llx size 0x%llx dst %p dst_offset %u dst_hdl 0x%x value 0x%llx",
-			i, iova_addr, patch_desc[i].src_buf_hdl,
-			(iova_addr + patch_desc[i].src_offset),
-			src_buf_size, dst_cpu_addr,
-			patch_desc[i].dst_offset,
-			patch_desc[i].dst_buf_hdl, value);
-
-		if (!(*dst_cpu_addr))
-			CAM_ERR(CAM_ICP, "Null at dst addr %p", dst_cpu_addr);
-	}
-}
-
 int cam_packet_util_process_patches(struct cam_packet *packet,
 	int32_t iommu_hdl, int32_t sec_mmu_hdl)
 {
diff --git a/techpack/camera/drivers/cam_utils/cam_packet_util.h b/techpack/camera/drivers/cam_utils/cam_packet_util.h
index 62866a962cc6..d5fc8f70ec07 100644
--- a/techpack/camera/drivers/cam_utils/cam_packet_util.h
+++ b/techpack/camera/drivers/cam_utils/cam_packet_util.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
 /*
- * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef _CAM_PACKET_UTIL_H_
@@ -86,20 +86,6 @@ int cam_packet_util_validate_cmd_desc(struct cam_cmd_buf_desc *cmd_desc);
 int cam_packet_util_get_kmd_buffer(struct cam_packet *packet,
 	struct cam_kmd_buf_info *kmd_buf_info);
 
-/**
- * cam_packet_dump_patch_info()
- *
- * @brief:              Dump patch info in case of page fault
- *
- * @packet:             Input packet containing Command Buffers and Patches
- * @iommu_hdl:          IOMMU handle of the HW Device that received the packet
- * @sec_iommu_hdl:      Secure IOMMU handle of the HW Device that
- *                      received the packet
- *
- */
-void cam_packet_dump_patch_info(struct cam_packet *packet,
-	int32_t iommu_hdl, int32_t sec_mmu_hdl);
-
 /**
  * cam_packet_util_process_patches()
  *
diff --git a/techpack/camera/drivers/cam_utils/cam_soc_util.c b/techpack/camera/drivers/cam_utils/cam_soc_util.c
index 01eba5544c6f..f20b42b97ad2 100644
--- a/techpack/camera/drivers/cam_utils/cam_soc_util.c
+++ b/techpack/camera/drivers/cam_utils/cam_soc_util.c
@@ -368,6 +368,18 @@ long cam_soc_util_get_clk_round_rate(struct cam_hw_soc_info *soc_info,
 	return clk_round_rate(soc_info->clk[clk_index], clk_rate);
 }
 
+int cam_soc_util_set_clk_flags(struct cam_hw_soc_info *soc_info,
+	uint32_t clk_index, unsigned long flags)
+{
+	if (!soc_info || (clk_index >= soc_info->num_clk)) {
+		CAM_ERR(CAM_UTIL, "Invalid input params %pK, %d",
+			soc_info, clk_index);
+		return -EINVAL;
+	}
+
+	return clk_set_flags(soc_info->clk[clk_index], flags);
+}
+
 /**
  * cam_soc_util_set_clk_rate()
  *
@@ -1029,53 +1041,6 @@ static int cam_soc_util_get_dt_gpio_req_tbl(struct device_node *of_node,
 			gconf->cam_gpio_req_tbl[i].label);
 	}
 
-	if (!of_get_property(of_node, "gpio-req-tbl-delay", &count)) {
-		CAM_DBG(CAM_UTIL, "no gpio-req-tbl-delay");
-		kfree(val_array);
-		return rc;
-	}
-
-	count /= sizeof(uint32_t);
-	if (!count) {
-		CAM_ERR(CAM_UTIL, "Invalid gpio count for gpio-req-tbl-delay");
-		kfree(val_array);
-		return rc;
-	}
-
-	if (count != gconf->cam_gpio_req_tbl_size) {
-		CAM_ERR(CAM_UTIL,
-			"Invalid number of gpio-req-tbl-delay entries: %d",
-			count);
-		goto free_val_array;
-	}
-
-	gconf->gpio_delay_tbl = kcalloc(count, sizeof(uint32_t),
-		GFP_KERNEL);
-	if (!gconf->gpio_delay_tbl) {
-		CAM_ERR(CAM_UTIL,
-			"Failed to allocate memory for gpio_delay_tbl");
-		rc = -ENOMEM;
-		goto free_val_array;
-	}
-
-	gconf->gpio_delay_tbl_size = count;
-
-	rc = of_property_read_u32_array(of_node, "gpio-req-tbl-delay",
-		val_array, count);
-	if (rc) {
-		CAM_ERR(CAM_UTIL, "Failed to read gpio-req-tbl-delay entry");
-		kfree(gconf->gpio_delay_tbl);
-		gconf->gpio_delay_tbl_size = 0;
-		kfree(val_array);
-		return rc;
-	}
-
-	for (i = 0; i < count; i++) {
-		gconf->gpio_delay_tbl[i] = val_array[i];
-		CAM_DBG(CAM_UTIL, "gpio_delay_tbl[%d] = %ld", i,
-			gconf->gpio_delay_tbl[i]);
-	}
-
 	kfree(val_array);
 
 	return rc;
@@ -2045,268 +2010,9 @@ static int cam_soc_util_dump_dmi_reg_range(
 	return rc;
 }
 
-static int cam_soc_util_dump_dmi_reg_range_user_buf(
-	struct cam_hw_soc_info *soc_info,
-	struct cam_dmi_read_desc *dmi_read, uint32_t base_idx,
-	struct cam_hw_soc_dump_args *dump_args)
-{
-	int                            i;
-	int                            rc;
-	size_t                         buf_len = 0;
-	uint8_t                       *dst;
-	size_t                         remain_len;
-	uint32_t                       min_len;
-	uint32_t                      *waddr, *start;
-	uintptr_t                      cpu_addr;
-	struct cam_hw_soc_dump_header *hdr;
-
-	if (!soc_info || !dump_args || !dmi_read) {
-		CAM_ERR(CAM_UTIL,
-			"Invalid input args soc_info: %pK, dump_args: %pK",
-			soc_info, dump_args);
-		rc = -EINVAL;
-		goto end;
-	}
-
-	if (dmi_read->num_pre_writes > CAM_REG_DUMP_DMI_CONFIG_MAX ||
-		dmi_read->num_post_writes > CAM_REG_DUMP_DMI_CONFIG_MAX) {
-		CAM_ERR(CAM_UTIL,
-			"Invalid number of requested writes, pre: %d post: %d",
-			dmi_read->num_pre_writes, dmi_read->num_post_writes);
-		rc = -EINVAL;
-		goto end;
-	}
-
-	rc = cam_mem_get_cpu_buf(dump_args->buf_handle, &cpu_addr, &buf_len);
-	if (rc) {
-		CAM_ERR(CAM_UTIL, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		goto end;
-	}
-
-	if (buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_UTIL, "Dump offset overshoot offset %zu len %zu",
-			dump_args->offset, buf_len);
-		rc = -ENOSPC;
-		goto end;
-	}
-	remain_len = buf_len - dump_args->offset;
-	min_len = (dmi_read->num_pre_writes * 2 * sizeof(uint32_t)) +
-		(dmi_read->dmi_data_read.num_values * 2 * sizeof(uint32_t)) +
-		sizeof(uint32_t);
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_UTIL,
-			"Dump Buffer exhaust read %d write %d remain %zu min %u",
-			dmi_read->dmi_data_read.num_values,
-			dmi_read->num_pre_writes, remain_len,
-			min_len);
-		rc = -ENOSPC;
-		goto end;
-	}
-
-	dst = (uint8_t *)cpu_addr + dump_args->offset;
-	hdr = (struct cam_hw_soc_dump_header *)dst;
-	memset(hdr, 0, sizeof(struct cam_hw_soc_dump_header));
-	scnprintf(hdr->tag, CAM_SOC_HW_DUMP_TAG_MAX_LEN,
-		"DMI_DUMP:");
-	waddr = (uint32_t *)(dst + sizeof(struct cam_hw_soc_dump_header));
-	start = waddr;
-	hdr->word_size = sizeof(uint32_t);
-	*waddr = soc_info->index;
-	waddr++;
-	for (i = 0; i < dmi_read->num_pre_writes; i++) {
-		if (dmi_read->pre_read_config[i].offset >
-			(uint32_t)soc_info->reg_map[base_idx].size) {
-			CAM_ERR(CAM_UTIL,
-				"Reg offset out of range, offset: 0x%X reg_map size: 0x%X",
-				dmi_read->pre_read_config[i].offset,
-				(uint32_t)soc_info->reg_map[base_idx].size);
-			rc = -EINVAL;
-			goto end;
-		}
-
-		cam_soc_util_w_mb(soc_info, base_idx,
-			dmi_read->pre_read_config[i].offset,
-			dmi_read->pre_read_config[i].value);
-		*waddr++ = dmi_read->pre_read_config[i].offset;
-		*waddr++ = dmi_read->pre_read_config[i].value;
-	}
-
-	if (dmi_read->dmi_data_read.offset >
-		(uint32_t)soc_info->reg_map[base_idx].size) {
-		CAM_ERR(CAM_UTIL,
-			"Reg offset out of range, offset: 0x%X reg_map size: 0x%X",
-			dmi_read->dmi_data_read.offset,
-			(uint32_t)soc_info->reg_map[base_idx].size);
-		rc = -EINVAL;
-		goto end;
-	}
-
-	for (i = 0; i < dmi_read->dmi_data_read.num_values; i++) {
-		*waddr++ = dmi_read->dmi_data_read.offset;
-		*waddr++ = cam_soc_util_r_mb(soc_info, base_idx,
-			dmi_read->dmi_data_read.offset);
-	}
-
-	for (i = 0; i < dmi_read->num_post_writes; i++) {
-		if (dmi_read->post_read_config[i].offset >
-			(uint32_t)soc_info->reg_map[base_idx].size) {
-			CAM_ERR(CAM_UTIL,
-				"Reg offset out of range, offset: 0x%X reg_map size: 0x%X",
-				dmi_read->post_read_config[i].offset,
-				(uint32_t)soc_info->reg_map[base_idx].size);
-			rc = -EINVAL;
-			goto end;
-		}
-		cam_soc_util_w_mb(soc_info, base_idx,
-			dmi_read->post_read_config[i].offset,
-			dmi_read->post_read_config[i].value);
-	}
-	hdr->size = (waddr - start) * hdr->word_size;
-	dump_args->offset +=  hdr->size +
-		sizeof(struct cam_hw_soc_dump_header);
-
-end:
-	return rc;
-}
-
-static int cam_soc_util_dump_cont_reg_range_user_buf(
-	struct cam_hw_soc_info *soc_info,
-	struct cam_reg_range_read_desc *reg_read,
-	uint32_t base_idx,
-	struct cam_hw_soc_dump_args *dump_args)
-{
-	int                            i;
-	int                            rc = 0;
-	size_t                         buf_len;
-	uint8_t                       *dst;
-	size_t                         remain_len;
-	uint32_t                       min_len;
-	uint32_t                      *waddr, *start;
-	uintptr_t                      cpu_addr;
-	struct cam_hw_soc_dump_header  *hdr;
-
-	if (!soc_info || !dump_args || !reg_read) {
-		CAM_ERR(CAM_UTIL,
-			"Invalid input args soc_info: %pK, dump_out_buffer: %pK reg_read: %pK",
-			soc_info, dump_args, reg_read);
-		rc = -EINVAL;
-		goto end;
-	}
-	rc = cam_mem_get_cpu_buf(dump_args->buf_handle, &cpu_addr, &buf_len);
-	if (rc) {
-		CAM_ERR(CAM_UTIL, "Invalid handle %u rc %d",
-			dump_args->buf_handle, rc);
-		goto end;
-	}
-	if (buf_len <= dump_args->offset) {
-		CAM_WARN(CAM_UTIL, "Dump offset overshoot %zu %zu",
-			dump_args->offset, buf_len);
-		rc = -ENOSPC;
-		goto end;
-	}
-	remain_len = buf_len - dump_args->offset;
-	min_len = (reg_read->num_values * 2 * sizeof(uint32_t)) +
-		sizeof(struct cam_hw_soc_dump_header) + sizeof(uint32_t);
-	if (remain_len < min_len) {
-		CAM_WARN(CAM_UTIL,
-			"Dump Buffer exhaust read_values %d remain %zu min %u",
-			reg_read->num_values,
-			remain_len,
-			min_len);
-		rc = -ENOSPC;
-		goto end;
-	}
-	dst = (uint8_t *)cpu_addr + dump_args->offset;
-	hdr = (struct cam_hw_soc_dump_header *)dst;
-	memset(hdr, 0, sizeof(struct cam_hw_soc_dump_header));
-	scnprintf(hdr->tag, CAM_SOC_HW_DUMP_TAG_MAX_LEN, "%s_REG:",
-		soc_info->dev_name);
-	waddr = (uint32_t *)(dst + sizeof(struct cam_hw_soc_dump_header));
-	start = waddr;
-	hdr->word_size = sizeof(uint32_t);
-	*waddr = soc_info->index;
-	waddr++;
-	for (i = 0; i < reg_read->num_values; i++) {
-		if ((reg_read->offset + (i * sizeof(uint32_t))) >
-			(uint32_t)soc_info->reg_map[base_idx].size) {
-			CAM_ERR(CAM_UTIL,
-				"Reg offset out of range, offset: 0x%X reg_map size: 0x%X",
-				(reg_read->offset + (i * sizeof(uint32_t))),
-				(uint32_t)soc_info->reg_map[base_idx].size);
-			rc = -EINVAL;
-			goto end;
-		}
-
-		waddr[0] = reg_read->offset + (i * sizeof(uint32_t));
-		waddr[1] = cam_soc_util_r(soc_info, base_idx,
-			(reg_read->offset + (i * sizeof(uint32_t))));
-		waddr += 2;
-	}
-	hdr->size = (waddr - start) * hdr->word_size;
-	dump_args->offset +=  hdr->size +
-		sizeof(struct cam_hw_soc_dump_header);
-end:
-	return rc;
-}
-
-static int cam_soc_util_user_reg_dump(
-	struct cam_reg_dump_desc *reg_dump_desc,
-	struct cam_hw_soc_dump_args *dump_args,
-	struct cam_hw_soc_info *soc_info,
-	uint32_t reg_base_idx)
-{
-	int rc = 0;
-	int i;
-	struct cam_reg_read_info  *reg_read_info = NULL;
-
-	if (!dump_args || !reg_dump_desc || !soc_info) {
-		CAM_ERR(CAM_UTIL,
-			"Invalid input parameters %pK %pK %pK",
-			dump_args, reg_dump_desc, soc_info);
-		return -EINVAL;
-	}
-	for (i = 0; i < reg_dump_desc->num_read_range; i++) {
-
-		reg_read_info = &reg_dump_desc->read_range[i];
-		if (reg_read_info->type ==
-				CAM_REG_DUMP_READ_TYPE_CONT_RANGE) {
-			rc = cam_soc_util_dump_cont_reg_range_user_buf(
-				soc_info,
-				&reg_read_info->reg_read,
-				reg_base_idx,
-				dump_args);
-		} else if (reg_read_info->type ==
-				CAM_REG_DUMP_READ_TYPE_DMI) {
-			rc = cam_soc_util_dump_dmi_reg_range_user_buf(
-				soc_info,
-				&reg_read_info->dmi_read,
-				reg_base_idx,
-				dump_args);
-		} else {
-			CAM_ERR(CAM_UTIL,
-					"Invalid Reg dump read type: %d",
-					reg_read_info->type);
-			rc = -EINVAL;
-			goto end;
-		}
-
-		if (rc) {
-			CAM_ERR(CAM_UTIL,
-				"Reg range read failed rc: %d reg_base_idx: %d",
-				rc, reg_base_idx);
-			goto end;
-		}
-	}
-end:
-	return rc;
-}
-
 int cam_soc_util_reg_dump_to_cmd_buf(void *ctx,
 	struct cam_cmd_buf_desc *cmd_desc, uint64_t req_id,
-	cam_soc_util_regspace_data_cb reg_data_cb,
-	struct cam_hw_soc_dump_args *soc_dump_args,
-	bool user_triggered_dump)
+	cam_soc_util_regspace_data_cb reg_data_cb)
 {
 	int                               rc = 0, i, j;
 	uintptr_t                         cpu_addr = 0;
@@ -2450,6 +2156,12 @@ int cam_soc_util_reg_dump_to_cmd_buf(void *ctx,
 			goto end;
 		}
 
+		dump_out_buf = (struct cam_reg_dump_out_buffer *)
+			(cmd_buf_start +
+			(uintptr_t)reg_dump_desc->dump_buffer_offset);
+		dump_out_buf->req_id = req_id;
+		dump_out_buf->bytes_written = 0;
+
 		reg_base_type = reg_dump_desc->reg_base_type;
 		if (reg_base_type == 0 || reg_base_type >
 			CAM_REG_DUMP_BASE_TYPE_CAMNOC) {
@@ -2481,31 +2193,6 @@ int cam_soc_util_reg_dump_to_cmd_buf(void *ctx,
 			"Reg data callback success req_id: %llu base_type: %d base_idx: %d num_read_range: %d",
 			req_id, reg_base_type, reg_base_idx,
 			reg_dump_desc->num_read_range);
-
-		/* If the dump request is triggered by user space
-		 * buffer will be different from the buffer which is received
-		 * in init packet. In this case, dump the data to the
-		 * user provided buffer and exit.
-		 */
-		if (user_triggered_dump) {
-			rc = cam_soc_util_user_reg_dump(reg_dump_desc,
-				soc_dump_args, soc_info, reg_base_idx);
-			CAM_INFO(CAM_UTIL,
-				"%s reg_base_idx %d dumped offset %u",
-				soc_info->dev_name, reg_base_idx,
-				soc_dump_args->offset);
-			goto end;
-		}
-
-		/* Below code is executed when data is dumped to the
-		 * out buffer received in init packet
-		 */
-		dump_out_buf = (struct cam_reg_dump_out_buffer *)
-			(cmd_buf_start +
-			(uintptr_t)reg_dump_desc->dump_buffer_offset);
-		dump_out_buf->req_id = req_id;
-		dump_out_buf->bytes_written = 0;
-
 		for (j = 0; j < reg_dump_desc->num_read_range; j++) {
 			CAM_DBG(CAM_UTIL,
 				"Number of bytes written to cmd buffer: %u req_id: %llu",
diff --git a/techpack/camera/drivers/cam_utils/cam_soc_util.h b/techpack/camera/drivers/cam_utils/cam_soc_util.h
index 69f748b80661..2914d4160720 100644
--- a/techpack/camera/drivers/cam_utils/cam_soc_util.h
+++ b/techpack/camera/drivers/cam_utils/cam_soc_util.h
@@ -30,7 +30,7 @@
 #define CAM_SOC_MAX_BASE            CAM_SOC_MAX_BLOCK
 
 /* maximum number of device regulator */
-#define CAM_SOC_MAX_REGULATOR       5
+#define CAM_SOC_MAX_REGULATOR       10//xiaomi add liuqinhong@xiaomi.com
 
 /* maximum number of device clock */
 #define CAM_SOC_MAX_CLK             32
@@ -41,9 +41,6 @@
 #define DDR_TYPE_LPDDR5        8
 #define DDR_TYPE_LPDDR5X       9
 
-/* Maximum length of tag while dumping */
-#define CAM_SOC_HW_DUMP_TAG_MAX_LEN 32
-
 /**
  * enum cam_vote_level - Enum for voting level
  *
@@ -108,16 +105,12 @@ struct cam_soc_pinctrl_info {
  *                             gpios node in DTSI
  * @cam_gpio_req_tbl            It is list of al the requesetd gpios
  * @cam_gpio_req_tbl_size:      It is size of requested gpios
- * @gpio_delay_tbl:            It is list of al requested gpios delay
- * @gpio_delay_tbl_size:       It is size of requested gpios delay
  **/
 struct cam_soc_gpio_data {
 	struct gpio *cam_gpio_common_tbl;
 	uint8_t cam_gpio_common_tbl_size;
 	struct gpio *cam_gpio_req_tbl;
 	uint8_t cam_gpio_req_tbl_size;
-	uint32_t *gpio_delay_tbl;
-	uint8_t gpio_delay_tbl_size;
 };
 
 /**
@@ -223,34 +216,6 @@ struct cam_hw_soc_info {
 	void                           *soc_private;
 };
 
-/**
- * struct cam_hw_soc_dump_header - SOC dump header
- *
- * @Brief:        soc hw dump header
- *
- * @tag:          Tag name for the header
- * @word_size:    Size of each word
- * @size:         Total size of dumped data
- */
-struct cam_hw_soc_dump_header {
-	uint8_t   tag[CAM_SOC_HW_DUMP_TAG_MAX_LEN];
-	uint64_t  size;
-	uint32_t  word_size;
-};
-
-/**
- * struct cam_hw_soc_dump_args:   SOC Dump args
- *
- * @request_id:          Issue request id
- * @offset:              Buffer offset, updated as the informaton is dumped
- * @buf_handle:          Buffer handle of the out buffer
- */
-struct cam_hw_soc_dump_args {
-	uint64_t             request_id;
-	size_t               offset;
-	uint32_t             buf_handle;
-};
-
 /*
  * CAM_SOC_GET_REG_MAP_START
  *
@@ -406,6 +371,20 @@ int cam_soc_util_disable_platform_resource(struct cam_hw_soc_info *soc_info,
 long cam_soc_util_get_clk_round_rate(struct cam_hw_soc_info *soc_info,
 	uint32_t clk_index, unsigned long clk_rate);
 
+/**
+ * cam_soc_util_set_clk_flags()
+ *
+ * @brief:              Camera SOC util to set the flags for a specified clock
+ *
+ * @soc_info:           Device soc information
+ * @clk_index:          Clock index in soc_info for which flags are to be set
+ * @flags:              Flags to set
+ *
+ * @return:             Success or Failure
+ */
+int cam_soc_util_set_clk_flags(struct cam_hw_soc_info *soc_info,
+	 uint32_t clk_index, unsigned long flags);
+
 /**
  * cam_soc_util_set_src_clk_rate()
  *
@@ -669,23 +648,19 @@ typedef int (*cam_soc_util_regspace_data_cb)(uint32_t reg_base_type,
 /**
  * cam_soc_util_reg_dump_to_cmd_buf()
  *
- * @brief:                 Camera SOC util for dumping sets of register ranges
- *                         command buffer
- *
- * @ctx:                   Context info from specific hardware manager
- * @cmd_desc:              Command buffer descriptor
- * @req_id:                Last applied req id for which reg dump is required
- * @reg_data_cb:           Callback function to get reg space info based on type
- *                         in command buffer
- * @soc_dump_args:         Dump buffer args to dump the soc information.
- * @user_triggered_dump:   Flag to indicate if the dump request is issued by
- *                         user.
- * @return:                Success or Failure
+ * @brief:              Camera SOC util for dumping sets of register ranges to
+ *                      to command buffer
+ *
+ * @ctx:                Context info from specific hardware manager
+ * @cmd_desc:           Command buffer descriptor
+ * @req_id:             Last applied req id for which reg dump is required
+ * @reg_data_cb:        Callback function to get reg space info based on type
+ *                      in command buffer
+ *
+ * @return:             Success or Failure
  */
 int cam_soc_util_reg_dump_to_cmd_buf(void *ctx,
 	struct cam_cmd_buf_desc *cmd_desc, uint64_t req_id,
-	cam_soc_util_regspace_data_cb reg_data_cb,
-	struct cam_hw_soc_dump_args *soc_dump_args,
-	bool user_triggered_dump);
+	cam_soc_util_regspace_data_cb reg_data_cb);
 
 #endif /* _CAM_SOC_UTIL_H_ */
diff --git a/techpack/camera/drivers/cam_utils/cam_trace.h b/techpack/camera/drivers/cam_utils/cam_trace.h
index c564b1582a3a..838997590771 100644
--- a/techpack/camera/drivers/cam_utils/cam_trace.h
+++ b/techpack/camera/drivers/cam_utils/cam_trace.h
@@ -63,29 +63,6 @@ TRACE_EVENT(cam_isp_activated_irq,
 	)
 );
 
-TRACE_EVENT(cam_log_event,
-	TP_PROTO(const char *string1, const char *string2,
-		uint64_t val1, uint64_t val2),
-	TP_ARGS(string1, string2, val1, val2),
-	TP_STRUCT__entry(
-		__string(string1, string1)
-		__string(string2, string2)
-		__field(uint64_t, val1)
-		__field(uint64_t, val2)
-	),
-	TP_fast_assign(
-		__assign_str(string1, string1);
-		__assign_str(string2, string2);
-		__entry->val1 = val1;
-		__entry->val2 = val2;
-	),
-	TP_printk(
-		"%s: %s val1=%llu val2=%llu",
-			__get_str(string1), __get_str(string2),
-			__entry->val1, __entry->val2
-	)
-);
-
 TRACE_EVENT(cam_icp_fw_dbg,
 	TP_PROTO(char *dbg_message, uint64_t timestamp),
 	TP_ARGS(dbg_message, timestamp),
diff --git a/techpack/camera/include/uapi/media/cam_custom.h b/techpack/camera/include/uapi/media/cam_custom.h
index 37edce171e4b..b36891f4a0dc 100644
--- a/techpack/camera/include/uapi/media/cam_custom.h
+++ b/techpack/camera/include/uapi/media/cam_custom.h
@@ -170,23 +170,6 @@ struct cam_custom_resource {
 	uint64_t                       res_hdl;
 };
 
-/**
- * struct cam_custom_acquire_hw_info - Custom acquire HW params
- *
- * @num_inputs           : Number of inputs
- * @input_info_size      : Size of input info struct used
- * @input_info_offset    : Offset of input info from start of data
- * @reserved             : reserved
- * @data                 : Start of data region
- */
-struct cam_custom_acquire_hw_info {
-	uint32_t                num_inputs;
-	uint32_t                input_info_size;
-	uint32_t                input_info_offset;
-	uint32_t                reserved;
-	uint64_t                data;
-};
-
 /**
  * struct cam_custom_cmd_buf_type_1 - cmd buf type 1
  *
diff --git a/techpack/camera/include/uapi/media/cam_defs.h b/techpack/camera/include/uapi/media/cam_defs.h
index 9883517d74e0..efc841b8b7c6 100644
--- a/techpack/camera/include/uapi/media/cam_defs.h
+++ b/techpack/camera/include/uapi/media/cam_defs.h
@@ -26,10 +26,11 @@
 #define CAM_COMMON_OPCODE_BASE_v2           0x150
 #define CAM_ACQUIRE_HW                      (CAM_COMMON_OPCODE_BASE_v2 + 0x1)
 #define CAM_RELEASE_HW                      (CAM_COMMON_OPCODE_BASE_v2 + 0x2)
-#define CAM_DUMP_REQ                        (CAM_COMMON_OPCODE_BASE_v2 + 0x3)
 
 #define CAM_EXT_OPCODE_BASE                     0x200
 #define CAM_CONFIG_DEV_EXTERNAL                 (CAM_EXT_OPCODE_BASE + 0x1)
+#define CAM_UPDATE_REG                          (CAM_EXT_OPCODE_BASE + 0x2)
+#define CAM_READ_REG                            (CAM_EXT_OPCODE_BASE + 0x3)
 
 /* camera handle type */
 #define CAM_HANDLE_USER_POINTER                 1
@@ -857,26 +858,5 @@ struct cam_reg_dump_input_info {
 	uint32_t                   dump_set_offsets[1];
 };
 
-/**
- * struct cam_dump_req_cmd -
- *        Dump the information of issue req id
- *
- * @issue_req_id   : Issue Request Id
- * @offset         : Offset for the buffer
- * @buf_handle     : Buffer Handle
- * @error_type     : Error type, using it, dumping information can be extended
- * @session_handle : Session Handle
- * @link_hdl       : link handle
- * @dev_handle     : Device Handle
- */
-struct cam_dump_req_cmd {
-	uint64_t       issue_req_id;
-	size_t         offset;
-	uint32_t       buf_handle;
-	uint32_t       error_type;
-	int32_t        session_handle;
-	int32_t        link_hdl;
-	int32_t        dev_handle;
-};
 
 #endif /* __UAPI_CAM_DEFS_H__ */
diff --git a/techpack/camera/include/uapi/media/cam_isp.h b/techpack/camera/include/uapi/media/cam_isp.h
index 408d153e944a..e4778cfc9cc2 100644
--- a/techpack/camera/include/uapi/media/cam_isp.h
+++ b/techpack/camera/include/uapi/media/cam_isp.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef __UAPI_CAM_ISP_H__
@@ -92,19 +92,17 @@
 #define CAM_ISP_DSP_MODE_ROUND                  2
 
 /* ISP Generic Cmd Buffer Blob types */
-#define CAM_ISP_GENERIC_BLOB_TYPE_HFR_CONFIG                0
-#define CAM_ISP_GENERIC_BLOB_TYPE_CLOCK_CONFIG              1
-#define CAM_ISP_GENERIC_BLOB_TYPE_BW_CONFIG                 2
-#define CAM_ISP_GENERIC_BLOB_TYPE_UBWC_CONFIG               3
-#define CAM_ISP_GENERIC_BLOB_TYPE_CSID_CLOCK_CONFIG         4
-#define CAM_ISP_GENERIC_BLOB_TYPE_FE_CONFIG                 5
-#define CAM_ISP_GENERIC_BLOB_TYPE_UBWC_CONFIG_V2            6
-#define CAM_ISP_GENERIC_BLOB_TYPE_IFE_CORE_CONFIG           7
-#define CAM_ISP_GENERIC_BLOB_TYPE_VFE_OUT_CONFIG            8
-#define CAM_ISP_GENERIC_BLOB_TYPE_BW_CONFIG_V2              9
-#define CAM_ISP_GENERIC_BLOB_TYPE_CSID_CONFIG               10
-#define CAM_ISP_GENERIC_BLOB_TYPE_SENSOR_DIMENSION_CONFIG   11
-#define CAM_ISP_GENERIC_BLOB_TYPE_CSID_QCFA_CONFIG          12
+#define CAM_ISP_GENERIC_BLOB_TYPE_HFR_CONFIG          0
+#define CAM_ISP_GENERIC_BLOB_TYPE_CLOCK_CONFIG        1
+#define CAM_ISP_GENERIC_BLOB_TYPE_BW_CONFIG           2
+#define CAM_ISP_GENERIC_BLOB_TYPE_UBWC_CONFIG         3
+#define CAM_ISP_GENERIC_BLOB_TYPE_CSID_CLOCK_CONFIG   4
+#define CAM_ISP_GENERIC_BLOB_TYPE_FE_CONFIG           5
+#define CAM_ISP_GENERIC_BLOB_TYPE_UBWC_CONFIG_V2      6
+#define CAM_ISP_GENERIC_BLOB_TYPE_IFE_CORE_CONFIG     7
+#define CAM_ISP_GENERIC_BLOB_TYPE_VFE_OUT_CONFIG      8
+#define CAM_ISP_GENERIC_BLOB_TYPE_BW_CONFIG_V2        9
+#define CAM_ISP_GENERIC_BLOB_TYPE_CSID_QCFA_CONFIG    12
 
 #define CAM_ISP_VC_DT_CFG    4
 
@@ -113,9 +111,6 @@
 #define CAM_ISP_IFE0_LITE_HW     0x4
 #define CAM_ISP_IFE1_LITE_HW     0x8
 #define CAM_ISP_IFE2_LITE_HW     0x10
-#define CAM_ISP_IFE3_LITE_HW     0x20
-#define CAM_ISP_IFE4_LITE_HW     0x40
-#define CAM_ISP_IFE2_HW          0x100
 
 #define CAM_ISP_PXL_PATH          0x1
 #define CAM_ISP_PPP_PATH          0x2
@@ -136,8 +131,6 @@
 #define CAM_ISP_ACQ_CUSTOM_PRIMARY    1
 #define CAM_ISP_ACQ_CUSTOM_SECONDARY  2
 
-#define CAM_IFE_CSID_RDI_MAX          4
-
 /* Query devices */
 /**
  * struct cam_isp_dev_cap_info - A cap info for particular hw type
@@ -600,37 +593,6 @@ struct cam_fe_config {
 	uint32_t    latency_buf_size;
 } __attribute__((packed));
 
-
-/**
- * struct cam_isp_sensor_path_dimension
- *
- * @width             expected width
- * @height            expected height
- * @measure_enabled   flag to indicate if pixel measurement is to be enabled
- */
-struct cam_isp_sensor_dimension {
-	uint32_t width;
-	uint32_t height;
-	uint32_t measure_enabled;
-} __attribute__((packed));
-
-/**
- * struct cam_isp_sensor_config - Sensor Dimension configuration
- *
- * @ppp_path:                   expected ppp path configuration
- * @ipp_path:                   expected ipp path configuration
- * @rdi_path:                   expected rdi path configuration
- * @hbi:                        HBI value
- * @vbi:                        VBI value
- */
-struct cam_isp_sensor_config {
-	struct cam_isp_sensor_dimension  ppp_path;
-	struct cam_isp_sensor_dimension  ipp_path;
-	struct cam_isp_sensor_dimension  rdi_path[CAM_IFE_CSID_RDI_MAX];
-	uint32_t                   hbi;
-	uint32_t                   vbi;
-} __attribute__((packed));
-
 /**
  * struct cam_isp_core_config - ISP core registers configuration
  *
@@ -734,15 +696,6 @@ struct cam_isp_vfe_out_config {
 	struct cam_isp_vfe_wm_config  wm_config[1];
 };
 
-/**
- * struct cam_isp_csid_epd_config  -  Support for EPD Packet config
- *
- * @is_epd_sensor      : flag to check if epd supported
- */
-struct cam_isp_csid_epd_config {
-	uint32_t                      is_epd_supported;
-};
-
 #define CAM_ISP_ACQUIRE_COMMON_VER0         0x1000
 
 #define CAM_ISP_ACQUIRE_COMMON_SIZE_VER0    0x0
diff --git a/techpack/camera/include/uapi/media/cam_req_mgr.h b/techpack/camera/include/uapi/media/cam_req_mgr.h
index 126d49d4b3f5..2a7f54d5a428 100644
--- a/techpack/camera/include/uapi/media/cam_req_mgr.h
+++ b/techpack/camera/include/uapi/media/cam_req_mgr.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef __UAPI_LINUX_CAM_REQ_MGR_H
@@ -41,7 +41,7 @@
  * It includes both session and device handles
  */
 #define CAM_REQ_MGR_MAX_HANDLES           64
-#define CAM_REQ_MGR_MAX_HANDLES_V2        128
+#define CAM_REQ_MGR_MAX_HANDLES_V2        182
 #define MAX_LINKS_PER_SESSION             2
 
 /* V4L event type which user space will subscribe to */
@@ -51,7 +51,6 @@
 #define V4L_EVENT_CAM_REQ_MGR_SOF            0
 #define V4L_EVENT_CAM_REQ_MGR_ERROR          1
 #define V4L_EVENT_CAM_REQ_MGR_SOF_BOOT_TS    2
-#define V4L_EVENT_CAM_REQ_MGR_CUSTOM_EVT     3
 
 /* SOF Event status */
 #define CAM_REQ_MGR_SOF_EVENT_SUCCESS           0
@@ -231,9 +230,6 @@ struct cam_req_mgr_sync_mode {
  * @session_hdl:         Input param - Identifier for CSL session
  * @num_links:           Input Param - Num of links
  * @reserved:            reserved field
- * @init_timeout:        To account for INIT exposure settings
- *                       If there is no change in exp settings
- *                       field needs to assigned to 0
  * @link_hdls:           Input Param - Links to be activated/deactivated
  *
  * @opcode: CAM_REQ_MGR_LINK_CONTROL
@@ -243,7 +239,6 @@ struct cam_req_mgr_link_control {
 	int32_t session_hdl;
 	int32_t num_links;
 	int32_t reserved;
-	int32_t init_timeout[MAX_LINKS_PER_SESSION];
 	int32_t link_hdls[MAX_LINKS_PER_SESSION];
 };
 
@@ -264,8 +259,6 @@ struct cam_req_mgr_link_control {
 #define CAM_REQ_MGR_CACHE_OPS                   (CAM_COMMON_OPCODE_MAX + 12)
 #define CAM_REQ_MGR_LINK_CONTROL                (CAM_COMMON_OPCODE_MAX + 13)
 #define CAM_REQ_MGR_LINK_V2                     (CAM_COMMON_OPCODE_MAX + 14)
-#define CAM_REQ_MGR_REQUEST_DUMP                (CAM_COMMON_OPCODE_MAX + 15)
-
 /* end of cam_req_mgr opcodes */
 
 #define CAM_MEM_FLAG_HW_READ_WRITE              (1<<0)
@@ -286,7 +279,7 @@ struct cam_req_mgr_link_control {
 #define CAM_MEM_MMU_MAX_HANDLE                  16
 
 /* Maximum allowed buffers in existence */
-#define CAM_MEM_BUFQ_MAX                        1024
+#define CAM_MEM_BUFQ_MAX                        1536
 
 #define CAM_MEM_MGR_SECURE_BIT_POS              15
 #define CAM_MEM_MGR_HDL_IDX_SIZE                15
@@ -422,14 +415,12 @@ struct cam_mem_cache_ops_cmd {
  * @CAM_REQ_MGR_ERROR_TYPE_BUFFER: Buffer was not filled, not fatal
  * @CAM_REQ_MGR_ERROR_TYPE_RECOVERY: Fatal error, can be recovered
  * @CAM_REQ_MGR_ERROR_TYPE_SOF_FREEZE: SOF freeze, can be recovered
- * @CAM_REQ_MGR_ERROR_TYPE_FULL_RECOVERY: Full recovery, can be recovered
  */
 #define CAM_REQ_MGR_ERROR_TYPE_DEVICE           0
 #define CAM_REQ_MGR_ERROR_TYPE_REQUEST          1
 #define CAM_REQ_MGR_ERROR_TYPE_BUFFER           2
 #define CAM_REQ_MGR_ERROR_TYPE_RECOVERY         3
 #define CAM_REQ_MGR_ERROR_TYPE_SOF_FREEZE       4
-#define CAM_REQ_MGR_ERROR_TYPE_FULL_RECOVERY    5
 
 /**
  * struct cam_req_mgr_error_msg
@@ -468,29 +459,11 @@ struct cam_req_mgr_frame_msg {
 	uint32_t reserved;
 };
 
-/**
- * struct cam_req_mgr_custom_msg
- * @custom_type: custom type
- * @request_id: request id of the frame
- * @frame_id: frame id of the frame
- * @timestamp: timestamp of the frame
- * @link_hdl: link handle associated with this message
- * @custom_data: custom data
- */
-struct cam_req_mgr_custom_msg {
-	uint32_t custom_type;
-	uint64_t request_id;
-	uint64_t frame_id;
-	uint64_t timestamp;
-	int32_t  link_hdl;
-	uint64_t custom_data;
-};
-
 /**
  * struct cam_req_mgr_message
  * @session_hdl: session to which the frame belongs to
  * @reserved: reserved field
- * @u: union which can either be error/frame/custom message
+ * @u: union which can either be error or frame message
  */
 struct cam_req_mgr_message {
 	int32_t session_hdl;
@@ -498,7 +471,6 @@ struct cam_req_mgr_message {
 	union {
 		struct cam_req_mgr_error_msg err_msg;
 		struct cam_req_mgr_frame_msg frame_msg;
-		struct cam_req_mgr_custom_msg custom_msg;
 	} u;
 };
 #endif /* __UAPI_LINUX_CAM_REQ_MGR_H */
diff --git a/techpack/camera/include/uapi/media/cam_sensor.h b/techpack/camera/include/uapi/media/cam_sensor.h
index 33601fc1f0b4..28a855f4e84a 100644
--- a/techpack/camera/include/uapi/media/cam_sensor.h
+++ b/techpack/camera/include/uapi/media/cam_sensor.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
 /*
- * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2019, The Linux Foundation. All rights reserved.
  */
 
 #ifndef __UAPI_CAM_SENSOR_H__
@@ -118,6 +118,12 @@ struct cam_ois_opcode {
 	uint32_t coeff;
 	uint32_t pheripheral;
 	uint32_t memory;
+	uint8_t  fw_addr_type; //Xiaomi add
+	uint8_t  is_addr_increase; //Xiaomi add
+	uint8_t  is_addr_indata; //Xiaomi add
+        uint8_t  fwversion;
+        uint32_t fwchecksumsize;
+	uint32_t fwchecksum;
 } __attribute__((packed));
 
 /**
@@ -128,6 +134,7 @@ struct cam_ois_opcode {
  * @cmd_type              :    Explains type of command
  * @ois_fw_flag           :    indicates if fw is present or not
  * @is_ois_calib          :    indicates the calibration data is available
+ * @is_ois_pre_init       :    indicates the pre initialize data is available
  * @ois_name              :    OIS name
  * @opcode                :    opcode
  */
@@ -137,6 +144,7 @@ struct cam_cmd_ois_info {
 	uint8_t               cmd_type;
 	uint8_t               ois_fw_flag;
 	uint8_t               is_ois_calib;
+	uint8_t               is_ois_pre_init; //xiaomi add
 	char                  ois_name[MAX_OIS_NAME_SIZE];
 	struct cam_ois_opcode opcode;
 } __attribute__((packed));
@@ -334,8 +342,7 @@ struct cam_cmd_unconditional_wait {
  * @3phase        : Details whether 3Phase / 2Phase operation
  * @settle_time   : Settling time in ms
  * @data_rate     : Data rate
- * @mipi_flags    : Mipi flags mask
- * @reserved
+ *
  */
 struct cam_csiphy_info {
 	uint16_t    lane_mask;
@@ -346,8 +353,6 @@ struct cam_csiphy_info {
 	uint8_t     secure_mode;
 	uint64_t    settle_time;
 	uint64_t    data_rate;
-	uint32_t    mipi_flags;
-	uint32_t    reserved;
 } __attribute__((packed));
 
 /**
-- 
2.48.1

