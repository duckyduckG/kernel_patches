From 75d9b856d45603cb781bde488b51695c9d912d74 Mon Sep 17 00:00:00 2001
From: Sebastiano Barezzi <barezzisebastiano@gmail.com>
Date: Tue, 15 Nov 2022 15:13:06 +0100
Subject: [PATCH 030/157] drivers: input: misc: Import AW8697 drivers

* From dagu-s-oss, except aw8697_haptic/aw8697.c, which comes from
  psyche-r-oss
* Run clang-format on source files

Change-Id: I1b2a6d6d8ed823c15d90636a023b015f30b833bd
---
 drivers/input/misc/Kconfig                    |    3 +
 drivers/input/misc/Makefile                   |    2 +
 drivers/input/misc/aw86927_haptic/Kconfig     |   14 +
 drivers/input/misc/aw86927_haptic/Makefile    |    2 +
 drivers/input/misc/aw86927_haptic/aw86907.c   | 4678 +++++++++++
 drivers/input/misc/aw86927_haptic/aw86907.h   | 1106 +++
 drivers/input/misc/aw86927_haptic/aw86927.c   | 4535 +++++++++++
 drivers/input/misc/aw86927_haptic/aw86927.h   |  825 ++
 drivers/input/misc/aw86927_haptic/aw869x.c    | 4588 +++++++++++
 drivers/input/misc/aw86927_haptic/aw869x.h    |  760 ++
 drivers/input/misc/aw86927_haptic/aw_config.h |  122 +
 drivers/input/misc/aw86927_haptic/aw_haptic.c | 1130 +++
 drivers/input/misc/aw86927_haptic/aw_haptic.h |  225 +
 .../input/misc/aw86927_haptic/ringbuffer.c    |  221 +
 .../input/misc/aw86927_haptic/ringbuffer.h    |   36 +
 drivers/input/misc/aw8697_haptic/Kconfig      |   23 +
 drivers/input/misc/aw8697_haptic/Makefile     |   21 +
 drivers/input/misc/aw8697_haptic/aw8697.c     | 6999 ++++++++++++++++
 drivers/input/misc/aw8697_haptic/aw8697.h     |  528 ++
 .../input/misc/aw8697_haptic/aw8697_config.h  |  117 +
 .../input/misc/aw8697_haptic/aw8697_dagu.c    | 7048 +++++++++++++++++
 drivers/input/misc/aw8697_haptic/aw8697_reg.h |  539 ++
 .../input/misc/aw8697_haptic/aw869xx_reg.h    |  907 +++
 drivers/input/misc/aw8697_haptic/ringbuffer.c |  223 +
 drivers/input/misc/aw8697_haptic/ringbuffer.h |   34 +
 25 files changed, 34686 insertions(+)
 create mode 100644 drivers/input/misc/aw86927_haptic/Kconfig
 create mode 100644 drivers/input/misc/aw86927_haptic/Makefile
 create mode 100644 drivers/input/misc/aw86927_haptic/aw86907.c
 create mode 100644 drivers/input/misc/aw86927_haptic/aw86907.h
 create mode 100644 drivers/input/misc/aw86927_haptic/aw86927.c
 create mode 100644 drivers/input/misc/aw86927_haptic/aw86927.h
 create mode 100644 drivers/input/misc/aw86927_haptic/aw869x.c
 create mode 100644 drivers/input/misc/aw86927_haptic/aw869x.h
 create mode 100644 drivers/input/misc/aw86927_haptic/aw_config.h
 create mode 100644 drivers/input/misc/aw86927_haptic/aw_haptic.c
 create mode 100644 drivers/input/misc/aw86927_haptic/aw_haptic.h
 create mode 100644 drivers/input/misc/aw86927_haptic/ringbuffer.c
 create mode 100644 drivers/input/misc/aw86927_haptic/ringbuffer.h
 create mode 100644 drivers/input/misc/aw8697_haptic/Kconfig
 create mode 100755 drivers/input/misc/aw8697_haptic/Makefile
 create mode 100644 drivers/input/misc/aw8697_haptic/aw8697.c
 create mode 100644 drivers/input/misc/aw8697_haptic/aw8697.h
 create mode 100644 drivers/input/misc/aw8697_haptic/aw8697_config.h
 create mode 100644 drivers/input/misc/aw8697_haptic/aw8697_dagu.c
 create mode 100644 drivers/input/misc/aw8697_haptic/aw8697_reg.h
 create mode 100644 drivers/input/misc/aw8697_haptic/aw869xx_reg.h
 create mode 100644 drivers/input/misc/aw8697_haptic/ringbuffer.c
 create mode 100644 drivers/input/misc/aw8697_haptic/ringbuffer.h

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 3d7ca037962d..6f3d14a71f16 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -885,4 +885,7 @@ config INPUT_SC27XX_VIBRA
 	  To compile this driver as a module, choose M here. The module will
 	  be called sc27xx_vibra.
 
+source "drivers/input/misc/aw8697_haptic/Kconfig"
+source "drivers/input/misc/aw86927_haptic/Kconfig"
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index a99ea9586234..f55f4be03343 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -85,3 +85,5 @@ obj-$(CONFIG_INPUT_WM831X_ON)		+= wm831x-on.o
 obj-$(CONFIG_INPUT_XEN_KBDDEV_FRONTEND)	+= xen-kbdfront.o
 obj-$(CONFIG_INPUT_YEALINK)		+= yealink.o
 obj-$(CONFIG_INPUT_IDEAPAD_SLIDEBAR)	+= ideapad_slidebar.o
+obj-$(CONFIG_INPUT_AW8697_HAPTIC)	+= aw8697_haptic/
+obj-$(CONFIG_INPUT_AW86927_HAPTIC)	+= aw86927_haptic/
diff --git a/drivers/input/misc/aw86927_haptic/Kconfig b/drivers/input/misc/aw86927_haptic/Kconfig
new file mode 100644
index 000000000000..aec045f988f8
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/Kconfig
@@ -0,0 +1,14 @@
+#
+# Awinic aw86927 driver
+#
+
+config INPUT_AW86927_HAPTIC
+	tristate "Awinic AW86927 HAPTIC"
+	depends on I2C
+	help
+	  Say Y here if you have Awinic AW86927 haptic controller
+	  chip in your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here.
diff --git a/drivers/input/misc/aw86927_haptic/Makefile b/drivers/input/misc/aw86927_haptic/Makefile
new file mode 100644
index 000000000000..6dbbd2b15b33
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_INPUT_AW86927_HAPTIC)	+= aw86927-haptic.o
+aw86927-haptic-objs = aw_haptic.o ringbuffer.o aw869x.o aw86927.o aw86907.o
diff --git a/drivers/input/misc/aw86927_haptic/aw86907.c b/drivers/input/misc/aw86927_haptic/aw86907.c
new file mode 100644
index 000000000000..73c762a9fe9d
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw86907.c
@@ -0,0 +1,4678 @@
+/*
+ * aw86907.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: <chelvming@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/vmalloc.h>
+#include <linux/pm_qos.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw_haptic.h"
+#include "ringbuffer.h"
+#include "aw_config.h"
+#include "aw86907.h"
+
+static struct aw86907_container *aw86907_rtp;
+static struct pm_qos_request pm_qos_req_vb;
+/******************************************************
+ *
+ * functions
+ *
+ ******************************************************/
+static void aw86907_interrupt_clear(struct aw86907 *aw86907);
+static void aw86907_haptic_bst_mode_config(struct aw86907 *aw86907,
+					   unsigned char boost_mode);
+static int aw86907_haptic_get_vbat(struct aw86907 *aw86907);
+
+const unsigned char aw86907_reg_access[AW86907_REG_MAX] = {
+	[AW86907_REG_ID] = REG_RD_ACCESS,
+	[AW86907_REG_SYSST] = REG_RD_ACCESS,
+	[AW86907_REG_SYSINT] = REG_RD_ACCESS,
+	[AW86907_REG_SYSINTM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSST2] = REG_RD_ACCESS,
+	[AW86907_REG_SYSER] = REG_RD_ACCESS,
+	[AW86907_REG_PLAYCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PLAYCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PLAYCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PLAYCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG9] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG10] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG11] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG12] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG13] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_WAVCFG14] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG9] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG10] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG11] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG12] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTCFG13] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CONTRD14] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD15] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD16] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD17] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD18] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD19] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD20] = REG_RD_ACCESS,
+	[AW86907_REG_CONTRD21] = REG_RD_ACCESS,
+	[AW86907_REG_RTPCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RTPCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RTPCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RTPCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RTPCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RTPDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRGCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_GLBCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_GLBCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_GLBCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_GLBCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_GLBRD5] = REG_RD_ACCESS,
+	[AW86907_REG_RAMADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RAMADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_RAMDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_SYSCTRL7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_I2SCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_I2SCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PWMCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PWMCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PWMCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PWMCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_DETCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_DETCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_DET_RL] = REG_RD_ACCESS,
+	[AW86907_REG_DET_OS] = REG_RD_ACCESS,
+	[AW86907_REG_DET_VBAT] = REG_RD_ACCESS,
+	[AW86907_REG_DET_TEST] = REG_RD_ACCESS,
+	[AW86907_REG_DET_LO] = REG_RD_ACCESS,
+	[AW86907_REG_TRIMCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRIMCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRIMCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_TRIMCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PLLCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_PLLCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_HDRVCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_IOCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BEMFCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BSTCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BSTCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BSTCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BSTCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_BSTCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_CPCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_LDOCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_OCCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_ADCCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW86907_REG_D2SCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+
+};
+
+/******************************************************
+ *
+ * aw86907 i2c write/read
+ *
+ ******************************************************/
+static int aw86907_i2c_write(struct aw86907 *aw86907, unsigned char reg_addr,
+			     unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw86907->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			aw_err("%s: addr=0x%02X, data=0x%02X, cnt=%d, error=%d\n",
+			       __func__, reg_addr, reg_data, cnt, ret);
+		} else {
+			break;
+		}
+		cnt++;
+		usleep_range(AW_I2C_RETRY_DELAY * 1000,
+			     AW_I2C_RETRY_DELAY * 1000 + 500);
+	}
+	return ret;
+}
+
+static int aw86907_i2c_read(struct aw86907 *aw86907, unsigned char reg_addr,
+			    unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw86907->i2c, reg_addr);
+		if (ret < 0) {
+			aw_err("%s: addr=0x%02X, cnt=%d, error=%d\n", __func__,
+			       reg_addr, cnt, ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		usleep_range(AW_I2C_RETRY_DELAY * 1000,
+			     AW_I2C_RETRY_DELAY * 1000 + 500);
+	}
+	return ret;
+}
+
+static int aw86907_i2c_write_bits(struct aw86907 *aw86907,
+				  unsigned char reg_addr, unsigned int mask,
+				  unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char reg_val = 0;
+
+	ret = aw86907_i2c_read(aw86907, reg_addr, &reg_val);
+	if (ret < 0) {
+		aw_err("%s: i2c read error, ret=%d\n", __func__, ret);
+		return ret;
+	}
+	reg_val &= mask;
+	reg_val |= (reg_data & (~mask));
+	ret = aw86907_i2c_write(aw86907, reg_addr, reg_val);
+	if (ret < 0) {
+		aw_err("%s: i2c write error, ret=%d\n", __func__, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int aw86907_i2c_writes(struct aw86907 *aw86907, unsigned char reg_addr,
+			      unsigned char *buf, unsigned int len)
+{
+	int ret = -1;
+	unsigned char *data = NULL;
+
+	data = kmalloc(len + 1, GFP_KERNEL);
+	if (data == NULL) {
+		aw_err("%s: can not allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+	data[0] = reg_addr;
+	memcpy(&data[1], buf, len);
+	ret = i2c_master_send(aw86907->i2c, data, len + 1);
+	if (ret < 0)
+		aw_err("%s: i2c master send error\n", __func__);
+	kfree(data);
+	return ret;
+}
+
+int aw86907_i2c_reads(struct aw86907 *aw86907, unsigned char reg_addr,
+		      unsigned char *buf, unsigned int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		[0] = {
+			.addr = aw86907->i2c->addr,
+			.flags = 0,
+			.len = sizeof(uint8_t),
+			.buf = &reg_addr,
+			},
+		[1] = {
+			.addr = aw86907->i2c->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buf,
+			},
+	};
+
+	ret = i2c_transfer(aw86907->i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		aw_err("%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != 2) {
+		aw_err("%s: transfer failed(size error).", __func__);
+		return -ENXIO;
+	}
+
+	return ret;
+}
+
+static void aw86907_haptic_raminit(struct aw86907 *aw86907, bool flag)
+{
+	if (flag) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL1,
+				       AW86907_BIT_SYSCTRL1_RAMINIT_MASK,
+				       AW86907_BIT_SYSCTRL1_RAMINIT_ON);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL1,
+				       AW86907_BIT_SYSCTRL1_RAMINIT_MASK,
+				       AW86907_BIT_SYSCTRL1_RAMINIT_OFF);
+	}
+}
+
+static void aw86907_haptic_play_go(struct aw86907 *aw86907)
+{
+	if (aw86907->info.is_enabled_one_wire) {
+		aw86907_i2c_write(aw86907, AW86907_REG_GLBCFG2,
+				  AW86907_BIT_START_DLY_20US);
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG4,
+				  AW86907_BIT_PLAYCFG4_GO_ON);
+		mdelay(1);
+		aw86907_i2c_write(aw86907, AW86907_REG_GLBCFG2,
+				  AW86907_BIT_START_DLY_2P5MS);
+	} else {
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG4,
+				  AW86907_BIT_PLAYCFG4_GO_ON);
+	}
+}
+
+static int aw86907_haptic_stop(struct aw86907 *aw86907)
+{
+	unsigned char cnt = 40;
+	unsigned char reg_val = 0;
+	bool force_flag = true;
+
+	aw_info("%s enter\n", __func__);
+	aw86907->play_mode = AW86907_HAPTIC_STANDBY_MODE;
+
+	aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG4,
+			  AW86907_BIT_PLAYCFG4_STOP_ON);
+	while (cnt) {
+		aw86907_i2c_read(aw86907, AW86907_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == AW86907_BIT_GLBRD5_STATE_STANDBY ||
+		    (reg_val & 0x0f) == AW86907_BIT_GLBRD5_STATE_I2S_GO) {
+			cnt = 0;
+			force_flag = false;
+			aw_info("%s entered standby! glb_state=0x%02X\n",
+				__func__, reg_val);
+		} else {
+			cnt--;
+			aw_dbg("%s wait for standby, glb_state=0x%02X\n",
+			       __func__, reg_val);
+		}
+		usleep_range(2000, 2500);
+	}
+
+	if (force_flag) {
+		aw_err("%s force to enter standby mode!\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_STANDBY_MASK,
+				       AW86907_BIT_SYSCTRL2_STANDBY_ON);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_STANDBY_MASK,
+				       AW86907_BIT_SYSCTRL2_STANDBY_OFF);
+	}
+	return 0;
+}
+
+static int aw86907_haptic_get_ram_number(struct aw86907 *aw86907)
+{
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char ram_data[3];
+	unsigned int first_wave_addr = 0;
+
+	aw_info("%s enter!\n", __func__);
+	if (!aw86907->ram_init) {
+		aw_err("%s: ram init faild, ram_num = 0!\n", __func__);
+		return -EPERM;
+	}
+
+	mutex_lock(&aw86907->lock);
+	/* RAMINIT Enable */
+	aw86907_haptic_raminit(aw86907, true);
+	aw86907_haptic_stop(aw86907);
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRH,
+			  (unsigned char)(aw86907->ram.base_addr >> 8));
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRL,
+			  (unsigned char)(aw86907->ram.base_addr & 0x00ff));
+	for (i = 0; i < 3; i++) {
+		aw86907_i2c_read(aw86907, AW86907_REG_RAMDATA, &reg_val);
+		ram_data[i] = reg_val;
+	}
+	first_wave_addr = (ram_data[1] << 8 | ram_data[2]);
+	aw86907->ram.ram_num =
+		(first_wave_addr - aw86907->ram.base_addr - 1) / 4;
+	aw_info("%s: ram_version = 0x%02x\n", __func__, ram_data[0]);
+	aw_info("%s: first waveform addr = 0x%04x\n", __func__,
+		first_wave_addr);
+	aw_info("%s: ram_num = %d\n", __func__, aw86907->ram.ram_num);
+	/* RAMINIT Disable */
+	aw86907_haptic_raminit(aw86907, false);
+	mutex_unlock(&aw86907->lock);
+
+	return 0;
+}
+
+#ifdef AW_CHECK_RAM_DATA
+static int aw86907_check_ram_data(struct aw86907 *aw86907,
+				  unsigned char *cont_data,
+				  unsigned char *ram_data, unsigned int len)
+{
+	int i = 0;
+
+	for (i = 0; i < len; i++) {
+		if (ram_data[i] != cont_data[i]) {
+			aw_err("%s: check ramdata error, addr=0x%04x, ram_data=0x%02x, file_data=0x%02x\n",
+			       __func__, i, ram_data[i], cont_data[i]);
+			return -ERANGE;
+		}
+	}
+	return 0;
+}
+#endif
+
+static int aw86907_container_update(struct aw86907 *aw86907,
+				    struct aw86907_container *aw86907_cont)
+{
+	int i = 0;
+	unsigned int shift = 0;
+	unsigned char reg_val = 0;
+	unsigned int temp = 0;
+	int ret = 0;
+#ifdef AW_CHECK_RAM_DATA
+	int len = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+#endif
+	aw_info("%s enter\n", __func__);
+	mutex_lock(&aw86907->lock);
+	aw86907->ram.baseaddr_shift = 2;
+	aw86907->ram.ram_shift = 4;
+	/* RAMINIT Enable */
+	aw86907_haptic_raminit(aw86907, true);
+	/* Enter standby mode */
+	aw86907_haptic_stop(aw86907);
+	/* base addr */
+	shift = aw86907->ram.baseaddr_shift;
+	aw86907->ram.base_addr =
+		(unsigned int)((aw86907_cont->data[0 + shift] << 8) |
+			       (aw86907_cont->data[1 + shift]));
+	aw_info("%s: base_addr = %d\n", __func__, aw86907->ram.base_addr);
+
+	aw86907_i2c_write(aw86907, AW86907_REG_RTPCFG1, /*ADDRH*/
+			  aw86907_cont->data[0 + shift]);
+	aw86907_i2c_write(aw86907, AW86907_REG_RTPCFG2, /*ADDRL*/
+			  aw86907_cont->data[1 + shift]);
+	/* FIFO_AEH */
+	aw86907_i2c_write_bits(
+		aw86907, AW86907_REG_RTPCFG3, AW86907_BIT_RTPCFG3_FIFO_AEH_MASK,
+		(unsigned char)(((aw86907->ram.base_addr >> 1) >> 4) & 0xF0));
+	/* FIFO AEL */
+	aw86907_i2c_write(
+		aw86907, AW86907_REG_RTPCFG4,
+		(unsigned char)(((aw86907->ram.base_addr >> 1) & 0x00FF)));
+	/* FIFO_AFH */
+	aw86907_i2c_write_bits(
+		aw86907, AW86907_REG_RTPCFG3, AW86907_BIT_RTPCFG3_FIFO_AFH_MASK,
+		(unsigned char)(((aw86907->ram.base_addr -
+				  (aw86907->ram.base_addr >> 2)) >>
+				 8) &
+				0x0F));
+	/* FIFO_AFL */
+	aw86907_i2c_write(aw86907, AW86907_REG_RTPCFG5,
+			  (unsigned char)(((aw86907->ram.base_addr -
+					    (aw86907->ram.base_addr >> 2)) &
+					   0x00FF)));
+	/*
+*	unsigned int temp
+*	HIGH<byte4 byte3 byte2 byte1>LOW
+*	|_ _ _ _AF-12BIT_ _ _ _AE-12BIT|
+*/
+	aw86907_i2c_read(aw86907, AW86907_REG_RTPCFG3, &reg_val);
+	temp = ((reg_val & 0x0f) << 24) | ((reg_val & 0xf0) << 4);
+	aw86907_i2c_read(aw86907, AW86907_REG_RTPCFG4, &reg_val);
+	temp = temp | reg_val;
+	aw_info("%s: almost_empty_threshold = %d\n", __func__,
+		(unsigned short)temp);
+	aw86907_i2c_read(aw86907, AW86907_REG_RTPCFG5, &reg_val);
+	temp = temp | (reg_val << 16);
+	aw_info("%s: almost_full_threshold = %d\n", __func__, temp >> 16);
+	/* ram */
+	shift = aw86907->ram.baseaddr_shift;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_RAMADDRH,
+			       AW86907_BIT_RAMADDRH_MASK,
+			       aw86907_cont->data[0 + shift]);
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRL,
+			  aw86907_cont->data[1 + shift]);
+	i = aw86907->ram.ram_shift;
+	while (i < aw86907_cont->len) {
+		if ((aw86907_cont->len - i) < AW_RAMDATA_WR_BUFFER_SIZE)
+			len = aw86907_cont->len - i;
+		else
+			len = AW_RAMDATA_WR_BUFFER_SIZE;
+		aw86907_i2c_writes(aw86907, AW86907_REG_RAMDATA,
+				   &aw86907_cont->data[i], len);
+		i += len;
+	}
+
+#ifdef AW_CHECK_RAM_DATA
+	shift = aw86907->ram.baseaddr_shift;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_RAMADDRH,
+			       AW86907_BIT_RAMADDRH_MASK,
+			       aw86907_cont->data[0 + shift]);
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRL,
+			  aw86907_cont->data[1 + shift]);
+
+	i = aw86907->ram.ram_shift;
+	while (i < aw86907_cont->len) {
+		if ((aw86907_cont->len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			len = aw86907_cont->len - i;
+		else
+			len = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw86907_i2c_reads(aw86907, AW86907_REG_RAMDATA, ram_data, len);
+		ret = aw86907_check_ram_data(aw86907, &aw86907_cont->data[i],
+					     ram_data, len);
+
+		if (ret < 0)
+			break;
+		i += len;
+	}
+	if (ret)
+		aw_err("%s: ram data check sum error\n", __func__);
+	else
+		aw_info("%s: ram data check sum pass\n", __func__);
+#endif
+	/* RAMINIT Disable */
+	aw86907_haptic_raminit(aw86907, false);
+	mutex_unlock(&aw86907->lock);
+	aw_info("%s exit\n", __func__);
+
+	return ret;
+}
+
+static void aw86907_ram_loaded(const struct firmware *cont, void *context)
+{
+	struct aw86907 *aw86907 = context;
+	struct aw86907_container *aw86907_fw;
+	int i = 0;
+	int ret = 0;
+	unsigned short check_sum = 0;
+
+	aw_info("%s enter\n", __func__);
+	if (!cont) {
+		aw_err("%s: failed to read %s\n", __func__, awinic_ram_name);
+		release_firmware(cont);
+		return;
+	}
+	aw_info("%s: loaded %s - size: %zu bytes\n", __func__, awinic_ram_name,
+		cont ? cont->size : 0);
+
+	/* check sum */
+	for (i = 2; i < cont->size; i++)
+		check_sum += cont->data[i];
+	if (check_sum !=
+	    (unsigned short)((cont->data[0] << 8) | (cont->data[1]))) {
+		aw_err("%s: check sum err: check_sum=0x%04x\n", __func__,
+		       check_sum);
+		release_firmware(cont);
+		return;
+	}
+	aw_info("%s: check sum pass: 0x%04x\n", __func__, check_sum);
+	aw86907->ram.check_sum = check_sum;
+
+	/* aw86907 ram update less then 128kB */
+	aw86907_fw = kzalloc(cont->size + sizeof(int), GFP_KERNEL);
+	if (!aw86907_fw) {
+		release_firmware(cont);
+		aw_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw86907_fw->len = cont->size;
+	memcpy(aw86907_fw->data, cont->data, cont->size);
+	release_firmware(cont);
+	ret = aw86907_container_update(aw86907, aw86907_fw);
+	if (ret) {
+		aw_err("%s: ram firmware update failed!\n", __func__);
+	} else {
+		aw86907->ram_init = 1;
+		aw_info("%s: ram firmware update complete!\n", __func__);
+	}
+	aw86907_haptic_get_ram_number(aw86907);
+	aw86907->ram.len = aw86907_fw->len - aw86907->ram.ram_shift;
+	kfree(aw86907_fw);
+}
+
+static int aw86907_ram_update(struct aw86907 *aw86907)
+{
+	aw86907->ram_init = 0;
+	aw86907->rtp_init = 0;
+
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       awinic_ram_name, aw86907->dev,
+				       GFP_KERNEL, aw86907, aw86907_ram_loaded);
+}
+
+static void aw86907_ram_work_routine(struct work_struct *work)
+{
+	struct aw86907 *aw86907 =
+		container_of(work, struct aw86907, ram_work.work);
+
+	aw_info("%s enter\n", __func__);
+	aw86907_ram_update(aw86907);
+}
+
+int aw86907_ram_init(struct aw86907 *aw86907)
+{
+#ifdef AW_RAM_UPDATE_DELAY
+	int ram_timer_val = 5000;
+
+	aw_info("%s enter\n", __func__);
+	INIT_DELAYED_WORK(&aw86907->ram_work, aw86907_ram_work_routine);
+	queue_delayed_work(aw86907->work_queue, &aw86907->ram_work,
+			   msecs_to_jiffies(ram_timer_val));
+#else
+	aw86907_ram_update(aw86907);
+#endif
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic control
+ *
+ *****************************************************/
+
+static int aw86907_haptic_play_mode(struct aw86907 *aw86907,
+				    unsigned char play_mode)
+{
+	aw_info("%s enter\n", __func__);
+
+	switch (play_mode) {
+	case AW86907_HAPTIC_STANDBY_MODE:
+		aw_info("%s: enter standby mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_STANDBY_MODE;
+		aw86907_haptic_stop(aw86907);
+		break;
+	case AW86907_HAPTIC_RAM_MODE:
+		aw_info("%s: enter ram mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_RAM_MODE;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		/* bst mode */
+		aw86907_haptic_bst_mode_config(aw86907,
+					       AW86907_HAPTIC_BST_MODE_BOOST);
+		break;
+	case AW86907_HAPTIC_RAM_LOOP_MODE:
+		aw_info("%s: enter ram loop mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_RAM_LOOP_MODE;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		/* bst mode */
+		aw86907_haptic_bst_mode_config(aw86907,
+					       AW86907_HAPTIC_BST_MODE_BYPASS);
+		break;
+	case AW86907_HAPTIC_RTP_MODE:
+		aw_info("%s: enter rtp mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_RTP_MODE;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_RTP);
+		/* bst mode */
+		aw86907_haptic_bst_mode_config(aw86907,
+					       AW86907_HAPTIC_BST_MODE_BOOST);
+		break;
+	case AW86907_HAPTIC_TRIG_MODE:
+		aw_info("%s: enter trig mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_TRIG_MODE;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		break;
+	case AW86907_HAPTIC_CONT_MODE:
+		aw_info("%s: enter cont mode\n", __func__);
+		aw86907->play_mode = AW86907_HAPTIC_CONT_MODE;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86907_BIT_PLAYCFG3_PLAY_MODE_CONT);
+		/* bst mode */
+		aw86907_haptic_bst_mode_config(aw86907,
+					       AW86907_HAPTIC_BST_MODE_BYPASS);
+		break;
+	default:
+		aw_err("%s: play mode %d error", __func__, play_mode);
+		break;
+	}
+	return 0;
+}
+
+static int aw86907_haptic_set_wav_seq(struct aw86907 *aw86907,
+				      unsigned char wav, unsigned char seq)
+{
+	aw86907_i2c_write(aw86907, AW86907_REG_WAVCFG1 + wav, seq);
+	return 0;
+}
+
+static int aw86907_haptic_set_wav_loop(struct aw86907 *aw86907,
+				       unsigned char wav, unsigned char loop)
+{
+	unsigned char tmp = 0;
+
+	if (wav % 2) {
+		tmp = loop << 0;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_WAVCFG9 + (wav / 2),
+				       AW86907_BIT_WAVLOOP_SEQ_EVEN_MASK, tmp);
+	} else {
+		tmp = loop << 4;
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_WAVCFG9 + (wav / 2),
+				       AW86907_BIT_WAVLOOP_SEQ_ODD_MASK, tmp);
+	}
+	return 0;
+}
+
+static void aw86907_haptic_set_repeat_wav_seq(struct aw86907 *aw86907,
+					      unsigned char seq)
+{
+	aw86907_haptic_set_wav_seq(aw86907, 0x00, seq);
+	aw86907_haptic_set_wav_loop(aw86907, 0x00,
+				    AW86907_BIT_WAVLOOP_INIFINITELY);
+}
+
+static int aw86907_haptic_set_bst_vol(struct aw86907 *aw86907,
+				      unsigned char bst_vol)
+{
+	if (bst_vol & 0xc0)
+		bst_vol = 0x3f;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG1,
+			       AW86907_BIT_PLAYCFG1_BST_VOUT_RDA_MASK, bst_vol);
+	return 0;
+}
+
+static int aw86907_haptic_set_bst_peak_cur(struct aw86907 *aw86907,
+					   unsigned char peak_cur)
+{
+	aw_info("%s enter!\n", __func__);
+	if (peak_cur > AW86907_BSTCFG_PEAKCUR_LIMIT)
+		peak_cur = AW86907_BSTCFG_PEAKCUR_LIMIT;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_BSTCFG1,
+			       AW86907_BIT_BSTCFG1_BST_PC_MASK, peak_cur);
+
+	return 0;
+}
+
+static int aw86907_haptic_set_gain(struct aw86907 *aw86907, unsigned char gain)
+{
+	unsigned char temp_gain = 0;
+
+	if (aw86907->ram_vbat_comp == AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE) {
+		aw86907_haptic_get_vbat(aw86907);
+		temp_gain = aw86907->gain * AW_VBAT_REFER / aw86907->vbat;
+		if (temp_gain > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			temp_gain = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_info("%s gain limit=%d\n", __func__, temp_gain);
+		}
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG2, temp_gain);
+	} else {
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG2, gain);
+	}
+	return 0;
+}
+
+static int aw86907_haptic_set_pwm(struct aw86907 *aw86907, unsigned char mode)
+{
+	switch (mode) {
+	case AW86907_PWM_48K:
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				       AW86907_BIT_SYSCTRL2_RATE_48K);
+		break;
+	case AW86907_PWM_24K:
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				       AW86907_BIT_SYSCTRL2_RATE_24K);
+		break;
+	case AW86907_PWM_12K:
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				       AW86907_BIT_SYSCTRL2_RATE_12K);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * motor protect
+ *
+ *****************************************************/
+static int aw86907_haptic_swicth_motor_protect_config(struct aw86907 *aw86907,
+						      unsigned char addr,
+						      unsigned char val)
+{
+	aw_info("%s enter\n", __func__);
+	if (addr == 1) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG1,
+				       AW86907_BIT_DETCFG1_PRCT_MODE_MASK,
+				       AW86907_BIT_DETCFG1_PRCT_MODE_VALID);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG1,
+				       AW86907_BIT_PWMCFG1_PRC_EN_MASK,
+				       AW86907_BIT_PWMCFG1_PRC_ENABLE);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG3,
+				       AW86907_BIT_PWMCFG3_PR_EN_MASK,
+				       AW86907_BIT_PWMCFG3_PR_ENABLE);
+	} else if (addr == 0) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG1,
+				       AW86907_BIT_DETCFG1_PRCT_MODE_MASK,
+				       AW86907_BIT_DETCFG1_PRCT_MODE_INVALID);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG1,
+				       AW86907_BIT_PWMCFG1_PRC_EN_MASK,
+				       AW86907_BIT_PWMCFG1_PRC_DISABLE);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG3,
+				       AW86907_BIT_PWMCFG3_PR_EN_MASK,
+				       AW86907_BIT_PWMCFG3_PR_DISABLE);
+	} else if (addr == 0x2d) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG1,
+				       AW86907_BIT_PWMCFG1_PRCTIME_MASK, val);
+	} else if (addr == 0x3e) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PWMCFG3,
+				       AW86907_BIT_PWMCFG3_PRLVL_MASK, val);
+	} else if (addr == 0x3f) {
+		aw86907_i2c_write(aw86907, AW86907_REG_PWMCFG4, val);
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * offset calibration
+ *
+ *****************************************************/
+static int aw86907_haptic_offset_calibration(struct aw86907 *aw86907)
+{
+	unsigned int cont = 2000;
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	aw86907_haptic_raminit(aw86907, true);
+
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG2,
+			       AW86907_BIT_DETCFG2_DIAG_GO_MASK,
+			       AW86907_BIT_DETCFG2_DIAG_GO_ON);
+	while (1) {
+		aw86907_i2c_read(aw86907, AW86907_REG_DETCFG2, &reg_val);
+		if ((reg_val & 0x01) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+	if (cont == 0)
+		aw_err("%s calibration offset failed!\n", __func__);
+	aw86907_haptic_raminit(aw86907, false);
+	return 0;
+}
+
+/*****************************************************
+ *
+ * trig config
+ *
+ *****************************************************/
+static void aw86907_haptic_trig1_param_init(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86907->trig[0].trig_level = aw86907->info.trig_config[0];
+	aw86907->trig[0].trig_polar = aw86907->info.trig_config[1];
+	aw86907->trig[0].pos_enable = aw86907->info.trig_config[2];
+	aw86907->trig[0].pos_sequence = aw86907->info.trig_config[3];
+	aw86907->trig[0].neg_enable = aw86907->info.trig_config[4];
+	aw86907->trig[0].neg_sequence = aw86907->info.trig_config[5];
+	aw86907->trig[0].trig_brk = aw86907->info.trig_config[6];
+	aw86907->trig[0].trig_bst = aw86907->info.trig_config[7];
+}
+
+static void aw86907_haptic_trig2_param_init(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86907->trig[1].trig_level = aw86907->info.trig_config[8 + 0];
+	aw86907->trig[1].trig_polar = aw86907->info.trig_config[8 + 1];
+	aw86907->trig[1].pos_enable = aw86907->info.trig_config[8 + 2];
+	aw86907->trig[1].pos_sequence = aw86907->info.trig_config[8 + 3];
+	aw86907->trig[1].neg_enable = aw86907->info.trig_config[8 + 4];
+	aw86907->trig[1].neg_sequence = aw86907->info.trig_config[8 + 5];
+	aw86907->trig[1].trig_brk = aw86907->info.trig_config[8 + 6];
+	aw86907->trig[1].trig_bst = aw86907->info.trig_config[8 + 7];
+}
+
+static void aw86907_haptic_trig3_param_init(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+	aw86907->trig[2].trig_level = aw86907->info.trig_config[16 + 0];
+	aw86907->trig[2].trig_polar = aw86907->info.trig_config[16 + 1];
+	aw86907->trig[2].pos_enable = aw86907->info.trig_config[16 + 2];
+	aw86907->trig[2].pos_sequence = aw86907->info.trig_config[16 + 3];
+	aw86907->trig[2].neg_enable = aw86907->info.trig_config[16 + 4];
+	aw86907->trig[2].neg_sequence = aw86907->info.trig_config[16 + 5];
+	aw86907->trig[2].trig_brk = aw86907->info.trig_config[16 + 6];
+	aw86907->trig[2].trig_bst = aw86907->info.trig_config[16 + 7];
+}
+
+static void aw86907_haptic_trig1_param_config(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86907->trig[0].trig_level) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_MODE_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_MODE_LEVEL);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_MODE_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_MODE_EDGE);
+	}
+	if (aw86907->trig[0].trig_polar) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_POLAR_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_POLAR_NEG);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_POLAR_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_POLAR_POS);
+	}
+	if (aw86907->trig[0].pos_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG1,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG1,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[0].neg_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG4,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG4,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[0].pos_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG1,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[0].pos_sequence);
+	}
+	if (aw86907->trig[0].neg_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG4,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[0].neg_sequence);
+	}
+	if (aw86907->trig[0].trig_brk) {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG7,
+			AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG7,
+			AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_DISABLE);
+	}
+	if (aw86907->trig[0].trig_bst) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_BST_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_BST_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG1_BST_MASK,
+				       AW86907_BIT_TRGCFG7_TRG1_BST_DISABLE);
+	}
+}
+
+static void aw86907_haptic_trig2_param_config(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86907->trig[1].trig_level) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_MODE_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_MODE_LEVEL);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_MODE_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_MODE_EDGE);
+	}
+	if (aw86907->trig[1].trig_polar) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_POLAR_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_POLAR_NEG);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_POLAR_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_POLAR_POS);
+	}
+	if (aw86907->trig[1].pos_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG2,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG2,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[1].neg_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG5,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG5,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[1].pos_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG2,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[1].pos_sequence);
+	}
+	if (aw86907->trig[1].neg_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG5,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[1].neg_sequence);
+	}
+	if (aw86907->trig[1].trig_brk) {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG7,
+			AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG7,
+			AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_DISABLE);
+	}
+	if (aw86907->trig[1].trig_bst) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_BST_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_BST_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG7,
+				       AW86907_BIT_TRGCFG7_TRG2_BST_MASK,
+				       AW86907_BIT_TRGCFG7_TRG2_BST_DISABLE);
+	}
+}
+
+static void aw86907_haptic_trig3_param_config(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86907->trig[2].trig_level) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_MODE_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_MODE_LEVEL);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_MODE_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_MODE_EDGE);
+	}
+	if (aw86907->trig[2].trig_polar) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_POLAR_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_POLAR_NEG);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_POLAR_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_POLAR_POS);
+	}
+	if (aw86907->trig[2].pos_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG3,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG3,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[2].neg_enable) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG6,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG6,
+				       AW86907_BIT_TRG_ENABLE_MASK,
+				       AW86907_BIT_TRG_DISABLE);
+	}
+	if (aw86907->trig[2].pos_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG3,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[2].pos_sequence);
+	}
+	if (aw86907->trig[2].neg_sequence) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG6,
+				       AW86907_BIT_TRG_SEQ_MASK,
+				       aw86907->trig[2].neg_sequence);
+	}
+	if (aw86907->trig[2].trig_brk) {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG8,
+			AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(
+			aw86907, AW86907_REG_TRGCFG8,
+			AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK,
+			AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_DISABLE);
+	}
+	if (aw86907->trig[2].trig_bst) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_BST_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_BST_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+				       AW86907_BIT_TRGCFG8_TRG3_BST_MASK,
+				       AW86907_BIT_TRGCFG8_TRG3_BST_DISABLE);
+	}
+}
+
+static void aw86907_haptic_bst_mode_config(struct aw86907 *aw86907,
+					   unsigned char boost_mode)
+{
+	aw86907->boost_mode = boost_mode;
+
+	switch (boost_mode) {
+	case AW86907_HAPTIC_BST_MODE_BOOST:
+		aw_info("%s haptic boost mode = boost\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG1,
+				       AW86907_BIT_PLAYCFG1_BST_MODE_MASK,
+				       AW86907_BIT_PLAYCFG1_BST_MODE_BOOST);
+		break;
+	case AW86907_HAPTIC_BST_MODE_BYPASS:
+		aw_info("%s haptic boost mode = bypass\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG1,
+				       AW86907_BIT_PLAYCFG1_BST_MODE_MASK,
+				       AW86907_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		break;
+	default:
+		aw_err("%s: boost_mode = %d error", __func__, boost_mode);
+		break;
+	}
+}
+
+static int aw86907_haptic_auto_bst_enable(struct aw86907 *aw86907,
+					  unsigned char flag)
+{
+	aw86907->auto_boost = flag;
+	if (flag) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_AUTO_BST_MASK,
+				       AW86907_BIT_PLAYCFG3_AUTO_BST_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_AUTO_BST_MASK,
+				       AW86907_BIT_PLAYCFG3_AUTO_BST_DISABLE);
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * vbat mode
+ *
+ *****************************************************/
+static int aw86907_haptic_vbat_mode_config(struct aw86907 *aw86907,
+					   unsigned char flag)
+{
+	if (flag == AW86907_HAPTIC_CONT_VBAT_HW_ADJUST_MODE) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL1,
+				       AW86907_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				       AW86907_BIT_SYSCTRL1_VBAT_MODE_HW);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL1,
+				       AW86907_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				       AW86907_BIT_SYSCTRL1_VBAT_MODE_SW);
+	}
+	return 0;
+}
+
+static int aw86907_haptic_get_vbat(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+	unsigned int vbat_code = 0;
+	unsigned int cont = 2000;
+
+	aw86907_haptic_stop(aw86907);
+	aw86907_haptic_raminit(aw86907, true);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG2,
+			       AW86907_BIT_DETCFG2_VBAT_GO_MASK,
+			       AW86907_BIT_DETCFG2_VABT_GO_ON);
+
+	while (1) {
+		aw86907_i2c_read(aw86907, AW86907_REG_DETCFG2, &reg_val);
+		if ((reg_val & 0x02) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+
+	aw86907_i2c_read(aw86907, AW86907_REG_DET_VBAT, &reg_val);
+	vbat_code = (vbat_code | reg_val) << 2;
+	aw86907_i2c_read(aw86907, AW86907_REG_DET_LO, &reg_val);
+	vbat_code = vbat_code | ((reg_val & 0x30) >> 4);
+	aw86907->vbat = 6100 * vbat_code / 1024;
+	if (aw86907->vbat > AW_VBAT_MAX) {
+		aw86907->vbat = AW_VBAT_MAX;
+		aw_info("%s vbat max limit = %dmV\n", __func__, aw86907->vbat);
+	}
+	if (aw86907->vbat < AW_VBAT_MIN) {
+		aw86907->vbat = AW_VBAT_MIN;
+		aw_info("%s vbat min limit = %dmV\n", __func__, aw86907->vbat);
+	}
+	aw_info("%s aw86907->vbat=%dmV, vbat_code=0x%02X\n", __func__,
+		aw86907->vbat, vbat_code);
+	aw86907_haptic_raminit(aw86907, false);
+	return 0;
+}
+
+static int aw86907_haptic_ram_vbat_comp(struct aw86907 *aw86907, bool flag)
+{
+	aw_dbg("%s: enter\n", __func__);
+	if (flag)
+		aw86907->ram_vbat_comp = AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	else
+		aw86907->ram_vbat_comp = AW86907_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	return 0;
+}
+
+static int aw86907_haptic_get_lra_resistance(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+	unsigned char d2s_gain_temp = 0;
+	unsigned int lra_code = 0;
+
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_stop(aw86907);
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSCTRL7, &reg_val);
+	d2s_gain_temp = 0x07 & reg_val;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			       aw86907->info.d2s_gain);
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSCTRL7, &reg_val);
+	aw_info("%s: d2s_gain=%d\n", __func__, 0x07 & reg_val);
+
+	aw86907_haptic_raminit(aw86907, true);
+	/* enter standby mode */
+	aw86907_haptic_stop(aw86907);
+	usleep_range(2000, 2500);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+			       AW86907_BIT_SYSCTRL2_STANDBY_MASK,
+			       AW86907_BIT_SYSCTRL2_STANDBY_OFF);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG1,
+			       AW86907_BIT_DETCFG1_RL_OS_MASK,
+			       AW86907_BIT_DETCFG1_RL);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_DETCFG2,
+			       AW86907_BIT_DETCFG2_DIAG_GO_MASK,
+			       AW86907_BIT_DETCFG2_DIAG_GO_ON);
+	usleep_range(30000, 35000);
+	aw86907_i2c_read(aw86907, AW86907_REG_DET_RL, &reg_val);
+	lra_code = (lra_code | reg_val) << 2;
+	aw86907_i2c_read(aw86907, AW86907_REG_DET_LO, &reg_val);
+	lra_code = lra_code | (reg_val & 0x03);
+	/* 2num */
+	aw86907->lra = (lra_code * 678 * 1000) / (1024 * 10);
+	aw86907_haptic_raminit(aw86907, false);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			       d2s_gain_temp);
+	mutex_unlock(&aw86907->lock);
+	return 0;
+}
+
+static enum hrtimer_restart qti_hap_stop_timer(struct hrtimer *timer)
+{
+	struct aw86907 *aw86907 =
+		container_of(timer, struct aw86907, stop_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	aw86907->play.length_us = 0;
+	rc = aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG4,
+			       AW86907_BIT_PLAYCFG4_STOP_ON);
+	if (rc < 0)
+		aw_err("Stop playing failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart qti_hap_disable_timer(struct hrtimer *timer)
+{
+	struct aw86907 *aw86907 =
+		container_of(timer, struct aw86907, hap_disable_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	rc = aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG4,
+			       AW86907_BIT_PLAYCFG4_STOP_ON);
+	if (rc < 0)
+		aw_err("Disable haptics module failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw86907_haptic_misc_para_init(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86907->f0_cali_status = true;
+	aw86907->rtp_routine_on = 0;
+	aw86907->rtp_num_max = awinic_rtp_name_len;
+	hrtimer_init(&aw86907->stop_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw86907->stop_timer.function = qti_hap_stop_timer;
+	hrtimer_init(&aw86907->hap_disable_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw86907->hap_disable_timer.function = qti_hap_disable_timer;
+
+	/* GAIN_BYPASS config */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_GAIN_BYPASS_MASK,
+			       AW86907_BIT_SYSCTRL7_GAIN_CHANGEABLE);
+
+	aw86907_i2c_write(aw86907, AW86907_REG_BSTCFG1,
+			  aw86907->info.bstcfg[0]);
+	aw86907_i2c_write(aw86907, AW86907_REG_BSTCFG2,
+			  aw86907->info.bstcfg[1]);
+	aw86907_i2c_write(aw86907, AW86907_REG_BSTCFG3,
+			  aw86907->info.bstcfg[2]);
+	aw86907_i2c_write(aw86907, AW86907_REG_BSTCFG4,
+			  aw86907->info.bstcfg[3]);
+	aw86907_i2c_write(aw86907, AW86907_REG_BSTCFG5,
+			  aw86907->info.bstcfg[4]);
+	aw86907_i2c_write(aw86907, AW86907_REG_SYSCTRL3,
+			  aw86907->info.sine_array[0]);
+	aw86907_i2c_write(aw86907, AW86907_REG_SYSCTRL4,
+			  aw86907->info.sine_array[1]);
+	aw86907_i2c_write(aw86907, AW86907_REG_SYSCTRL5,
+			  aw86907->info.sine_array[2]);
+	aw86907_i2c_write(aw86907, AW86907_REG_SYSCTRL6,
+			  aw86907->info.sine_array[3]);
+
+	/* brk_bst_md */
+	if (!aw86907->info.brk_bst_md)
+		aw_err("%s aw86907->info.brk_bst_md = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG1,
+			       AW86907_BIT_CONTCFG1_BRK_BST_MD_MASK,
+			       aw86907->info.brk_bst_md << 1);
+
+	/* d2s_gain */
+	if (!aw86907->info.d2s_gain)
+		aw_err("%s aw86907->info.d2s_gain = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			       aw86907->info.d2s_gain);
+
+	/* cont_tset */
+	if (!aw86907->info.cont_tset)
+		aw_err("%s aw86907->info.cont_tset = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG13,
+			       AW86907_BIT_CONTCFG13_TSET_MASK,
+			       aw86907->info.cont_tset << 4);
+
+	/* cont_bemf_set */
+	if (!aw86907->info.cont_bemf_set)
+		aw_err("%s aw86907->info.cont_bemf_set = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG13,
+			       AW86907_BIT_CONTCFG13_BEME_SET_MASK,
+			       aw86907->info.cont_bemf_set);
+
+	/* cont_brk_time */
+	if (!aw86907->info.cont_brk_time)
+		aw_err("%s aw86907->info.cont_brk_time = 0!\n", __func__);
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG10,
+			  aw86907->info.cont_brk_time);
+
+	/* cont_bst_brk_gain */
+	if (!aw86907->info.cont_bst_brk_gain)
+		aw_err("%s aw86907->info.cont_bst_brk_gain = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG5,
+			       AW86907_BIT_CONTCFG5_BST_BRK_GAIN_MASK,
+			       aw86907->info.cont_bst_brk_gain << 4);
+
+	/* cont_brk_gain */
+	if (!aw86907->info.cont_brk_gain)
+		aw_err("%s aw86907->info.cont_brk_gain = 0!\n", __func__);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG5,
+			       AW86907_BIT_CONTCFG5_BRK_GAIN_MASK,
+			       aw86907->info.cont_brk_gain);
+
+	/* i2s enbale */
+	if (aw86907->info.is_enabled_i2s) {
+		aw_info("%s i2s enabled!\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_I2S_PIN_MASK,
+				       AW86907_BIT_SYSCTRL2_I2S_PIN_I2S);
+	} else {
+		aw_info("%s i2s disabled!\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+				       AW86907_BIT_SYSCTRL2_I2S_PIN_MASK,
+				       AW86907_BIT_SYSCTRL2_I2S_PIN_TRIG);
+	}
+}
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static void aw86907_haptic_set_rtp_aei(struct aw86907 *aw86907, bool flag)
+{
+	if (flag) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+				       AW86907_BIT_SYSINTM_FF_AEM_MASK,
+				       AW86907_BIT_SYSINTM_FF_AEM_ON);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+				       AW86907_BIT_SYSINTM_FF_AEM_MASK,
+				       AW86907_BIT_SYSINTM_FF_AEM_OFF);
+	}
+}
+
+static unsigned char aw86907_haptic_rtp_get_fifo_afs(struct aw86907 *aw86907)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSST, &reg_val);
+	reg_val &= AW86907_BIT_SYSST_FF_AFS;
+	ret = reg_val >> 3;
+	return ret;
+}
+
+static int aw86907_haptic_rtp_play(struct aw86907 *aw86907)
+{
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw86907->ram.base_addr >> 2;
+
+	aw_info("%s enter\n", __func__);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+
+	mutex_lock(&aw86907->rtp_lock);
+	aw86907->rtp_cnt = 0;
+	disable_irq(gpio_to_irq(aw86907->irq_gpio));
+	while ((!aw86907_haptic_rtp_get_fifo_afs(aw86907)) &&
+	       (aw86907->play_mode == AW86907_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw86907->exit_in_rtp_loop)) {
+#ifdef AW_ENABLE_RTP_PRINT_LOG
+		aw_info("%s rtp cnt = %d\n", __func__, aw86907->rtp_cnt);
+#endif
+		if (!aw86907_rtp) {
+			aw_info("%s:aw86907_rtp is null, break!\n", __func__);
+			break;
+		}
+
+		if (aw86907->is_custom_wave == 0) {
+			if ((aw86907_rtp->len - aw86907->rtp_cnt) <
+			    (aw86907->ram.base_addr >> 2)) {
+				buf_len = aw86907_rtp->len - aw86907->rtp_cnt;
+			} else {
+				buf_len = (aw86907->ram.base_addr >> 2);
+			}
+			aw86907_i2c_writes(aw86907, AW86907_REG_RTPDATA,
+					   &aw86907_rtp->data[aw86907->rtp_cnt],
+					   buf_len);
+			aw86907->rtp_cnt += buf_len;
+			if (aw86907->rtp_cnt == aw86907_rtp->len) {
+				aw86907->rtp_cnt = 0;
+				aw86907_haptic_set_rtp_aei(aw86907, false);
+				break;
+			}
+		} else {
+			buf_len = read_rb(aw86907_rtp->data, period_size);
+			aw86907_i2c_writes(aw86907, AW86907_REG_RTPDATA,
+					   aw86907_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				aw_info("%s: custom rtp update complete\n",
+					__func__);
+				aw86907->rtp_cnt = 0;
+				aw86907_haptic_set_rtp_aei(aw86907, false);
+				break;
+			}
+		}
+	}
+
+	enable_irq(gpio_to_irq(aw86907->irq_gpio));
+	if (aw86907->play_mode == AW86907_HAPTIC_RTP_MODE &&
+	    !atomic_read(&aw86907->exit_in_rtp_loop) && aw86907->rtp_cnt != 0)
+		aw86907_haptic_set_rtp_aei(aw86907, true);
+
+	aw_info("%s exit\n", __func__);
+	mutex_unlock(&aw86907->rtp_lock);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+
+static void aw86907_haptic_upload_lra(struct aw86907 *aw86907,
+				      unsigned int flag)
+{
+	switch (flag) {
+	case WRITE_ZERO:
+		aw_info("%s write zero to trim_lra!\n", __func__);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRIMCFG3,
+				       AW86907_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				       0x00);
+		break;
+	case F0_CALI:
+		aw_info("%s write f0_cali_data to trim_lra = 0x%02X\n",
+			__func__, aw86907->f0_cali_data);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRIMCFG3,
+				       AW86907_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				       (char)aw86907->f0_cali_data);
+		break;
+	case OSC_CALI:
+		aw_info("%s write osc_cali_data to trim_lra = 0x%02X\n",
+			__func__, aw86907->osc_cali_data);
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_TRIMCFG3,
+				       AW86907_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				       (char)aw86907->osc_cali_data);
+		break;
+	default:
+		break;
+	}
+}
+
+static int aw86907_osc_trim_calculation(struct aw86907 *aw86907,
+					unsigned long int theory_time,
+					unsigned long int real_time)
+{
+	unsigned int real_code = 0;
+	unsigned int lra_code = 0;
+	unsigned int DFT_LRA_TRIM_CODE = 0;
+	/*0.1 percent below no need to calibrate */
+	unsigned int osc_cali_threshold = 10;
+
+	aw_info("%s enter\n", __func__);
+	if (theory_time == real_time) {
+		aw_info("%s theory_time == real_time: %ld, no need to calibrate!\n",
+			__func__, real_time);
+		return 0;
+	} else if (theory_time < real_time) {
+		if ((real_time - theory_time) > (theory_time / 50)) {
+			aw_info("%s (real_time - theory_time) > (theory_time/50), can't calibrate!\n",
+				__func__);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		if ((real_time - theory_time) <
+		    (osc_cali_threshold * theory_time / 10000)) {
+			aw_info("%s real_time: %ld, theory_time: %ld, no need to calibrate!\n",
+				__func__, real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		real_code = ((real_time - theory_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 + real_code;
+	} else if (theory_time > real_time) {
+		if ((theory_time - real_time) > (theory_time / 50)) {
+			aw_info("%s (theory_time - real_time) > (theory_time / 50), can't calibrate!\n",
+				__func__);
+			return DFT_LRA_TRIM_CODE;
+		}
+		if ((theory_time - real_time) <
+		    (osc_cali_threshold * theory_time / 10000)) {
+			aw_info("%s real_time: %ld, theory_time: %ld, no need to calibrate!\n",
+				__func__, real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+		real_code = ((theory_time - real_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 - real_code;
+	}
+	if (real_code > 31)
+		lra_code = real_code - 32;
+	else
+		lra_code = real_code + 32;
+	aw_info("%s real_time: %ld, theory_time: %ld\n", __func__, real_time,
+		theory_time);
+	aw_info("%s real_code: %02X, trim_lra: 0x%02X\n", __func__, real_code,
+		lra_code);
+	return lra_code;
+}
+
+static int aw86907_rtp_trim_lra_calibration(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_trim_code = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSCTRL2, &reg_val);
+	fre_val = (reg_val & 0x03) >> 0;
+
+	if (fre_val == 2 || fre_val == 3)
+		theory_time = (aw86907->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 0)
+		theory_time = (aw86907->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1)
+		theory_time = (aw86907->rtp_len / 48000) * 1000000; /*48K */
+
+	aw_info("%s microsecond:%ld  theory_time = %d\n", __func__,
+		aw86907->microsecond, theory_time);
+
+	lra_trim_code = aw86907_osc_trim_calculation(aw86907, theory_time,
+						     aw86907->microsecond);
+	if (lra_trim_code >= 0) {
+		aw86907->osc_cali_data = lra_trim_code;
+		aw86907_haptic_upload_lra(aw86907, OSC_CALI);
+	}
+	return 0;
+}
+
+static unsigned char aw86907_haptic_osc_read_status(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSST2, &reg_val);
+	return reg_val;
+}
+
+static int aw86907_rtp_osc_calibration(struct aw86907 *aw86907)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+
+	aw86907->rtp_cnt = 0;
+	aw86907->timeval_flags = 1;
+
+	aw_info("%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file, awinic_rtp_name[0], aw86907->dev);
+	if (ret < 0) {
+		aw_err("%s: failed to read %s\n", __func__, awinic_rtp_name[0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate */
+	aw86907_haptic_stop(aw86907);
+	aw86907->rtp_init = 0;
+	mutex_lock(&aw86907->rtp_lock);
+	vfree(aw86907_rtp);
+	aw86907_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw86907_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw86907->rtp_lock);
+		aw_err("%s: error allocating memory\n", __func__);
+		return -ENOMEM;
+	}
+	aw86907_rtp->len = rtp_file->size;
+	aw86907->rtp_len = rtp_file->size;
+	aw_info("%s: rtp file:[%s] size = %dbytes\n", __func__,
+		awinic_rtp_name[0], aw86907_rtp->len);
+
+	memcpy(aw86907_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw86907->rtp_lock);
+	/* gain */
+	aw86907_haptic_ram_vbat_comp(aw86907, false);
+	/* rtp mode config */
+	aw86907_haptic_play_mode(aw86907, AW86907_HAPTIC_RTP_MODE);
+	/* bst mode */
+	aw86907_haptic_bst_mode_config(aw86907, AW86907_HAPTIC_BST_MODE_BYPASS);
+	disable_irq(gpio_to_irq(aw86907->irq_gpio));
+
+	/* haptic go */
+	aw86907_haptic_play_go(aw86907);
+	/* require latency of CPU & DMA not more then PM_QOS_VALUE_VB us */
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw86907_haptic_rtp_get_fifo_afs(aw86907)) {
+#ifdef AW_ENABLE_RTP_PRINT_LOG
+			aw_info("%s not almost_full, aw86907->rtp_cnt=%d\n",
+				__func__, aw86907->rtp_cnt);
+#endif
+			mutex_lock(&aw86907->rtp_lock);
+			if ((aw86907_rtp->len - aw86907->rtp_cnt) <
+			    (aw86907->ram.base_addr >> 2))
+				buf_len = aw86907_rtp->len - aw86907->rtp_cnt;
+			else
+				buf_len = (aw86907->ram.base_addr >> 2);
+
+			if (aw86907->rtp_cnt != aw86907_rtp->len) {
+				if (aw86907->timeval_flags == 1) {
+					do_gettimeofday(&aw86907->start);
+					aw86907->timeval_flags = 0;
+				}
+				aw86907->rtp_update_flag = aw86907_i2c_writes(
+					aw86907, AW86907_REG_RTPDATA,
+					&aw86907_rtp->data[aw86907->rtp_cnt],
+					buf_len);
+				aw86907->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw86907->rtp_lock);
+		}
+		osc_int_state = aw86907_haptic_osc_read_status(aw86907);
+		if (osc_int_state & AW86907_BIT_SYSST2_FF_EMPTY) {
+			do_gettimeofday(&aw86907->end);
+			aw_info("%s osc trim playback done aw86907->rtp_cnt= %d\n",
+				__func__, aw86907->rtp_cnt);
+			break;
+		}
+		do_gettimeofday(&aw86907->end);
+		aw86907->microsecond =
+			(aw86907->end.tv_sec - aw86907->start.tv_sec) *
+				1000000 +
+			(aw86907->end.tv_usec - aw86907->start.tv_usec);
+		if (aw86907->microsecond > OSC_CALI_MAX_LENGTH) {
+			aw_info("%s osc trim time out! aw86907->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw86907->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw86907->irq_gpio));
+
+	aw86907->microsecond =
+		(aw86907->end.tv_sec - aw86907->start.tv_sec) * 1000000 +
+		(aw86907->end.tv_usec - aw86907->start.tv_usec);
+	/*calibration osc */
+	aw_info("%s awinic_microsecond: %ld\n", __func__, aw86907->microsecond);
+	aw_info("%s exit\n", __func__);
+	return 0;
+}
+
+static int aw86907_haptic_effect_strength(struct aw86907 *aw86907)
+{
+	aw_dbg("%s enter\n", __func__);
+	aw_dbg("%s: aw86907->play.vmax_mv =0x%x\n", __func__,
+	       aw86907->play.vmax_mv);
+#if 0
+	switch (aw86907->play.vmax_mv) {
+	case AW86907_LIGHT_MAGNITUDE:
+		aw86907->level = 0x80;
+		break;
+	case AW86907_MEDIUM_MAGNITUDE:
+		aw86907->level = 0x50;
+		break;
+	case AW86907_STRONG_MAGNITUDE:
+		aw86907->level = 0x30;
+		break;
+	default:
+		break;
+	}
+#else
+	if (aw86907->play.vmax_mv >= 0x7FFF)
+		aw86907->level = 0x80; /*128*/
+	else if (aw86907->play.vmax_mv <= 0x3FFF)
+		aw86907->level = 0x1E; /*30*/
+	else
+		aw86907->level = (aw86907->play.vmax_mv - 16383) / 128;
+	if (aw86907->level < 0x1E)
+		aw86907->level = 0x1E; /*30*/
+#endif
+
+	aw_info("%s: aw86907->level =0x%x\n", __func__, aw86907->level);
+	return 0;
+}
+
+static void aw86907_rtp_work_routine(struct work_struct *work)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int cnt = 200;
+	unsigned char reg_val = 0;
+	bool rtp_work_flag = false;
+	struct aw86907 *aw86907 = container_of(work, struct aw86907, rtp_work);
+
+	aw_info("%s enter\n", __func__);
+
+	aw_info("%s: effect_id = %d state=%d activate_mode = %d\n", __func__,
+		aw86907->effect_id, aw86907->state, aw86907->activate_mode);
+
+	if ((aw86907->effect_id < aw86907->info.effect_id_boundary) &&
+	    (aw86907->effect_id > aw86907->info.effect_max))
+		return;
+
+	mutex_lock(&aw86907->lock);
+
+	aw86907->rtp_routine_on = 1;
+	aw86907_haptic_upload_lra(aw86907, OSC_CALI);
+	aw86907_haptic_set_rtp_aei(aw86907, false);
+	aw86907_interrupt_clear(aw86907);
+
+	/* wait for irq to exit */
+	atomic_set(&aw86907->exit_in_rtp_loop, 1);
+	while (atomic_read(&aw86907->is_in_rtp_loop)) {
+		aw_info("%s  goint to waiting irq exit\n", __func__);
+		mutex_unlock(&aw86907->lock);
+		ret = wait_event_interruptible(
+			aw86907->wait_q,
+			atomic_read(&aw86907->is_in_rtp_loop) == 0);
+		aw_info("%s  wakeup\n", __func__);
+		mutex_lock(&aw86907->lock);
+		if (ret == -ERESTARTSYS) {
+			atomic_set(&aw86907->exit_in_rtp_loop, 0);
+			wake_up_interruptible(&aw86907->stop_wait_q);
+			mutex_unlock(&aw86907->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return;
+		}
+	}
+
+	atomic_set(&aw86907->exit_in_rtp_loop, 0);
+	wake_up_interruptible(&aw86907->stop_wait_q);
+
+	/* how to force exit this call */
+	if (aw86907->is_custom_wave == 1 && aw86907->state) {
+		aw_err("%s buffer size %d, availbe size %d\n", __func__,
+		       aw86907->ram.base_addr >> 2, get_rb_avalible_size());
+		while (get_rb_avalible_size() < aw86907->ram.base_addr &&
+		       !rb_shoule_exit()) {
+			mutex_unlock(&aw86907->lock);
+			ret = wait_event_interruptible(
+				aw86907->stop_wait_q,
+				(get_rb_avalible_size() >=
+				 aw86907->ram.base_addr) ||
+					rb_shoule_exit());
+			aw_info("%s  wakeup\n", __func__);
+			aw_err("%s after wakeup sbuffer size %d, availbe size %d\n",
+			       __func__, aw86907->ram.base_addr >> 2,
+			       get_rb_avalible_size());
+			if (ret == -ERESTARTSYS) {
+				aw_err("%s wake up by signal return erro\n",
+				       __func__);
+				return;
+			}
+			mutex_lock(&aw86907->lock);
+		}
+	}
+
+	aw86907_haptic_stop(aw86907);
+
+	if (aw86907->state) {
+		pm_stay_awake(aw86907->dev);
+		/* boost voltage */
+		if (aw86907->info.bst_vol_rtp <= AW86907_MAX_BST_VOL)
+			aw86907_haptic_set_bst_vol(aw86907,
+						   aw86907->info.bst_vol_rtp);
+		else
+			aw86907_haptic_set_bst_vol(aw86907, aw86907->vmax);
+		/* gain */
+		aw86907_haptic_ram_vbat_comp(aw86907, false);
+		aw86907_haptic_effect_strength(aw86907);
+		aw86907_haptic_set_gain(aw86907, aw86907->level);
+		aw86907->rtp_init = 0;
+		if (aw86907->is_custom_wave == 0) {
+			aw86907->rtp_file_num =
+				aw86907->effect_id -
+				aw86907->info.effect_id_boundary;
+			aw_info("%s: aw86907->rtp_file_num =%d\n", __func__,
+				aw86907->rtp_file_num);
+			if (aw86907->rtp_file_num < 0)
+				aw86907->rtp_file_num = 0;
+			if (aw86907->rtp_file_num > (awinic_rtp_name_len - 1))
+				aw86907->rtp_file_num = awinic_rtp_name_len - 1;
+			aw86907->rtp_routine_on = 1;
+			/* fw loaded */
+			ret = request_firmware(
+				&rtp_file,
+				awinic_rtp_name[aw86907->rtp_file_num],
+				aw86907->dev);
+			if (ret < 0) {
+				aw_err("%s: failed to read %s\n", __func__,
+				       awinic_rtp_name[aw86907->rtp_file_num]);
+				aw86907->rtp_routine_on = 0;
+				pm_relax(aw86907->dev);
+				mutex_unlock(&aw86907->lock);
+				return;
+			}
+			vfree(aw86907_rtp);
+			aw86907_rtp = vmalloc(rtp_file->size + sizeof(int));
+			if (!aw86907_rtp) {
+				release_firmware(rtp_file);
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				aw86907->rtp_routine_on = 0;
+				pm_relax(aw86907->dev);
+				mutex_unlock(&aw86907->lock);
+				return;
+			}
+			aw86907_rtp->len = rtp_file->size;
+			aw_info("%s: rtp file:[%s] size = %dbytes\n", __func__,
+				awinic_rtp_name[aw86907->rtp_file_num],
+				aw86907_rtp->len);
+			memcpy(aw86907_rtp->data, rtp_file->data,
+			       rtp_file->size);
+			release_firmware(rtp_file);
+		} else {
+			vfree(aw86907_rtp);
+			aw86907_rtp = vmalloc(aw86907->ram.base_addr >> 2);
+			if (!aw86907_rtp) {
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw86907->dev);
+				mutex_unlock(&aw86907->lock);
+				return;
+			}
+		}
+		aw86907->rtp_init = 1;
+		aw86907_haptic_play_mode(aw86907, AW86907_HAPTIC_RTP_MODE);
+		/* haptic go */
+		aw86907_haptic_play_go(aw86907);
+		usleep_range(2000, 2500);
+		while (cnt) {
+			aw86907_i2c_read(aw86907, AW86907_REG_GLBRD5, &reg_val);
+			if ((reg_val & 0x0f) == 0x08) {
+				cnt = 0;
+				rtp_work_flag = true;
+				aw_info("%s RTP_GO! glb_state=0x08\n",
+					__func__);
+			} else {
+				cnt--;
+				aw_dbg("%s wait for RTP_GO, glb_state=0x%02X\n",
+				       __func__, reg_val);
+			}
+			usleep_range(2000, 2500);
+		}
+		if (rtp_work_flag) {
+			aw86907_haptic_rtp_play(aw86907);
+		} else {
+			/* enter standby mode */
+			aw86907_haptic_stop(aw86907);
+			aw_err("%s failed to enter RTP_GO status!\n", __func__);
+		}
+		aw86907->rtp_routine_on = 0;
+
+	} else {
+		aw86907->rtp_cnt = 0;
+		aw86907->rtp_init = 0;
+		pm_relax(aw86907->dev);
+	}
+	mutex_unlock(&aw86907->lock);
+}
+
+/*****************************************************
+ *
+ * haptic - audio
+ *
+ *****************************************************/
+static int aw86907_haptic_start(struct aw86907 *aw86907)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	aw86907_haptic_play_go(aw86907);
+
+	return 0;
+}
+
+static void aw86907_clean_status(struct aw86907 *aw86907)
+{
+	aw86907->audio_ready = false;
+	aw86907->haptic_ready = false;
+	aw86907->rtp_routine_on = 0;
+	aw_info("%s enter\n", __func__);
+}
+
+static int aw86907_haptic_juge_RTP_is_going_on(struct aw86907 *aw86907)
+{
+	unsigned char glb_state = 0;
+	unsigned char rtp_state = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_GLBRD5, &glb_state);
+	if (aw86907->rtp_routine_on ||
+	    (glb_state == AW86907_BIT_GLBRD5_STATE_RTP_GO)) {
+		rtp_state = 1; /*is going on */
+		aw_info("%s: rtp_routine_on\n", __func__);
+	}
+	return rtp_state;
+}
+
+static enum hrtimer_restart
+aw86907_haptic_audio_timer_func(struct hrtimer *timer)
+{
+	struct aw86907 *aw86907 =
+		container_of(timer, struct aw86907, haptic_audio.timer);
+
+	aw_dbg("%s enter\n", __func__);
+	schedule_work(&aw86907->haptic_audio.work);
+
+	hrtimer_start(
+		&aw86907->haptic_audio.timer,
+		ktime_set(aw86907->haptic_audio.timer_val / 1000000,
+			  (aw86907->haptic_audio.timer_val % 1000000) * 1000),
+		HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static void aw86907_haptic_audio_work_routine(struct work_struct *work)
+{
+	struct aw86907 *aw86907 =
+		container_of(work, struct aw86907, haptic_audio.work);
+	int rtp_is_going_on = 0;
+
+	aw_info("%s enter\n", __func__);
+	mutex_lock(&aw86907->haptic_audio.lock);
+	/* rtp mode jump */
+	rtp_is_going_on = aw86907_haptic_juge_RTP_is_going_on(aw86907);
+	if (rtp_is_going_on) {
+		mutex_unlock(&aw86907->haptic_audio.lock);
+		return;
+	}
+	memcpy(&aw86907->haptic_audio.ctr,
+	       &aw86907->haptic_audio.data[aw86907->haptic_audio.cnt],
+	       sizeof(struct haptic_ctr));
+	aw_dbg("%s: cnt=%d, cmd=%d, play=%d, wavseq=%d, loop=%d, gain=%d\n",
+	       __func__, aw86907->haptic_audio.cnt,
+	       aw86907->haptic_audio.ctr.cmd, aw86907->haptic_audio.ctr.play,
+	       aw86907->haptic_audio.ctr.wavseq, aw86907->haptic_audio.ctr.loop,
+	       aw86907->haptic_audio.ctr.gain);
+	mutex_unlock(&aw86907->haptic_audio.lock);
+	if (aw86907->haptic_audio.ctr.cmd == AW86907_HAPTIC_CMD_ENABLE) {
+		if (aw86907->haptic_audio.ctr.play ==
+		    AW86907_HAPTIC_PLAY_ENABLE) {
+			aw_info("%s: haptic_audio_play_start\n", __func__);
+			mutex_lock(&aw86907->lock);
+			aw86907_haptic_stop(aw86907);
+			aw86907_haptic_play_mode(aw86907,
+						 AW86907_HAPTIC_RAM_MODE);
+
+			aw86907_haptic_set_wav_seq(
+				aw86907, 0x00,
+				aw86907->haptic_audio.ctr.wavseq);
+			aw86907_haptic_set_wav_seq(aw86907, 0x01, 0x00);
+
+			aw86907_haptic_set_wav_loop(
+				aw86907, 0x00, aw86907->haptic_audio.ctr.loop);
+
+			aw86907_haptic_set_gain(aw86907,
+						aw86907->haptic_audio.ctr.gain);
+
+			aw86907_haptic_start(aw86907);
+			mutex_unlock(&aw86907->lock);
+		} else if (AW86907_HAPTIC_PLAY_STOP ==
+			   aw86907->haptic_audio.ctr.play) {
+			mutex_lock(&aw86907->lock);
+			aw86907_haptic_stop(aw86907);
+			mutex_unlock(&aw86907->lock);
+		} else if (AW86907_HAPTIC_PLAY_GAIN ==
+			   aw86907->haptic_audio.ctr.play) {
+			mutex_lock(&aw86907->lock);
+			aw86907_haptic_set_gain(aw86907,
+						aw86907->haptic_audio.ctr.gain);
+			mutex_unlock(&aw86907->lock);
+		}
+		mutex_lock(&aw86907->haptic_audio.lock);
+		memset(&aw86907->haptic_audio.data[aw86907->haptic_audio.cnt],
+		       0, sizeof(struct haptic_ctr));
+		mutex_unlock(&aw86907->haptic_audio.lock);
+	}
+	mutex_lock(&aw86907->haptic_audio.lock);
+	aw86907->haptic_audio.cnt++;
+	if (aw86907->haptic_audio.data[aw86907->haptic_audio.cnt].cmd == 0) {
+		aw86907->haptic_audio.cnt = 0;
+		aw_dbg("%s: haptic play buffer restart\n", __func__);
+	}
+	mutex_unlock(&aw86907->haptic_audio.lock);
+}
+
+/*****************************************************
+ *
+ * haptic cont
+ *
+ *****************************************************/
+static int aw86907_haptic_cont_config(struct aw86907 *aw86907)
+{
+	aw_info("%s enter\n", __func__);
+
+	/* work mode */
+	aw86907_haptic_play_mode(aw86907, AW86907_HAPTIC_CONT_MODE);
+	/* cont config */
+	/* aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG1,
+	 **                     AW86907_BIT_CONTCFG1_EN_F0_DET_MASK,
+	 **                     AW86907_BIT_CONTCFG1_F0_DET_ENABLE);
+	 */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG6,
+			       AW86907_BIT_CONTCFG6_TRACK_EN_MASK,
+			       AW86907_BIT_CONTCFG6_TRACK_ENABLE);
+	/* f0 driver level */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG6,
+			       AW86907_BIT_CONTCFG6_DRV1_LVL_MASK,
+			       aw86907->info.cont_drv1_lvl);
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG7,
+			  aw86907->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	/* aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG8, 0xFF); */
+	/* DRV2_TIME */
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG9, 0xFF);
+	/* cont play go */
+	aw86907_haptic_play_go(aw86907);
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw86907_haptic_read_lra_f0(struct aw86907 *aw86907)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_info("%s enter\n", __func__);
+	/* F_LRA_F0_H */
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_CONTRD14, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	/* F_LRA_F0_L */
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_CONTRD15, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_err("%s didn't get lra f0 because f0_reg value is 0!\n",
+		       __func__);
+		aw86907->f0_cali_status = false;
+		return ret;
+	}
+	aw86907->f0_cali_status = true;
+	f0_tmp = 384000 * 10 / f0_reg;
+	aw86907->f0 = (unsigned int)f0_tmp;
+	aw_info("%s lra_f0=%d\n", __func__, aw86907->f0);
+
+	return ret;
+}
+
+static int aw86907_haptic_read_cont_f0(struct aw86907 *aw86907)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_info("%s enter\n", __func__);
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_CONTRD16, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_CONTRD17, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_err("%s didn't get cont f0 because f0_reg value is 0!\n",
+		       __func__);
+		aw86907->cont_f0 = aw86907->info.f0_ref;
+		return ret;
+	}
+	f0_tmp = 384000 * 10 / f0_reg;
+	aw86907->cont_f0 = (unsigned int)f0_tmp;
+	aw_info("%s cont_f0=%d\n", __func__, aw86907->cont_f0);
+	return ret;
+}
+
+static void aw86907_haptic_auto_break_mode(struct aw86907 *aw86907, bool flag)
+{
+	if (flag) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_BRK_EN_MASK,
+				       AW86907_BIT_PLAYCFG3_BRK_ENABLE);
+	} else {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_PLAYCFG3,
+				       AW86907_BIT_PLAYCFG3_BRK_EN_MASK,
+				       AW86907_BIT_PLAYCFG3_BRK_DISABLE);
+	}
+}
+
+static int aw86907_haptic_cont_get_f0(struct aw86907 *aw86907)
+{
+	int ret = 0;
+	unsigned int cnt = 200;
+	unsigned char reg_val = 0;
+	unsigned char brk_en_default = 0;
+	unsigned char d2s_gain_default = 0;
+	bool get_f0_flag = false;
+
+	aw_info("%s enter\n", __func__);
+	aw86907->f0 = aw86907->info.f0_ref;
+	/* enter standby mode */
+	aw86907_haptic_stop(aw86907);
+	/* config max d2s_gain */
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSCTRL7, &reg_val);
+	d2s_gain_default = reg_val & AW86907_BIT_SYSCTRL7_D2S_GAIN;
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_26);
+	/* f0 calibrate work mode */
+	aw86907_haptic_play_mode(aw86907, AW86907_HAPTIC_CONT_MODE);
+	/* enable f0 detect */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG1,
+			       AW86907_BIT_CONTCFG1_EN_F0_DET_MASK,
+			       AW86907_BIT_CONTCFG1_F0_DET_ENABLE);
+	/* cont config */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG6,
+			       AW86907_BIT_CONTCFG6_TRACK_EN_MASK,
+			       AW86907_BIT_CONTCFG6_TRACK_ENABLE);
+	/* enable auto break */
+	aw86907_i2c_read(aw86907, AW86907_REG_PLAYCFG3, &reg_val);
+	brk_en_default = 0x04 & reg_val;
+	aw86907_haptic_auto_break_mode(aw86907, true);
+
+	/* f0 driver level */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG6,
+			       AW86907_BIT_CONTCFG6_DRV1_LVL_MASK,
+			       aw86907->info.cont_drv1_lvl);
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG7,
+			  aw86907->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG8,
+			  aw86907->info.cont_drv1_time);
+	/* DRV2_TIME */
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG9,
+			  aw86907->info.cont_drv2_time);
+	/* TRACK_MARGIN */
+	if (!aw86907->info.cont_track_margin) {
+		aw_err("%s aw86907->info.cont_track_margin = 0!\n", __func__);
+	} else {
+		aw86907_i2c_write(
+			aw86907, AW86907_REG_CONTCFG11,
+			(unsigned char)aw86907->info.cont_track_margin);
+	}
+	/* DRV_WIDTH */
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG3,
+			  aw86907->info.cont_drv_width);
+
+	/* cont play go */
+	aw86907_haptic_play_go(aw86907);
+	usleep_range(20000, 20500);
+	/* 300ms */
+	while (cnt) {
+		aw86907_i2c_read(aw86907, AW86907_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == 0x00) {
+			cnt = 0;
+			get_f0_flag = true;
+			aw_info("%s: entered standby mode! glb_state=0x%02X\n",
+				__func__, reg_val);
+		} else {
+			cnt--;
+			aw_dbg("%s: waitting for standby, glb_state=0x%02X\n",
+			       __func__, reg_val);
+		}
+		usleep_range(10000, 10500);
+	}
+	if (get_f0_flag) {
+		aw86907_haptic_read_lra_f0(aw86907);
+		aw86907_haptic_read_cont_f0(aw86907);
+	} else {
+		aw_err("%s enter standby mode failed, stop reading f0!\n",
+		       __func__);
+	}
+	/* restore d2s_gain config */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			       d2s_gain_default);
+	/* restore default config */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG1,
+			       AW86907_BIT_CONTCFG1_EN_F0_DET_MASK,
+			       AW86907_BIT_CONTCFG1_F0_DET_DISABLE);
+	/* recover auto break config */
+	if (brk_en_default)
+		aw86907_haptic_auto_break_mode(aw86907, true);
+	else
+		aw86907_haptic_auto_break_mode(aw86907, false);
+
+	return ret;
+}
+
+static int aw86907_haptic_f0_calibration(struct aw86907 *aw86907)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+	unsigned int f0_cali_min = aw86907->info.f0_ref *
+				   (100 - aw86907->info.f0_cali_percent) / 100;
+	unsigned int f0_cali_max = aw86907->info.f0_ref *
+				   (100 + aw86907->info.f0_cali_percent) / 100;
+
+	aw_info("%s enter\n", __func__);
+
+#ifndef AW_ENABLE_MULTI_CALI
+	aw86907_haptic_upload_lra(aw86907, WRITE_ZERO);
+#endif
+
+	if (aw86907_haptic_cont_get_f0(aw86907)) {
+		aw_err("%s get f0 error, user defafult f0\n", __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw86907->f0;
+		aw_info("%s f0_ref = %d, f0_cali_min = %d, f0_cali_max = %d, f0 = %d\n",
+			__func__, aw86907->info.f0_ref, f0_cali_min,
+			f0_cali_max, aw86907->f0);
+
+		if ((aw86907->f0 < f0_cali_min) || aw86907->f0 > f0_cali_max) {
+			aw_err("%s f0 calibration out of range = %d!\n",
+			       __func__, aw86907->f0);
+			f0_limit = aw86907->info.f0_ref;
+			return -ERANGE;
+		}
+		aw_info("%s f0_limit = %d\n", __func__, (int)f0_limit);
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw86907->info.f0_ref) /
+			       ((int)f0_limit * 24);
+		aw_info("%s f0_cali_step = %d\n", __func__, f0_cali_step);
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5)
+				f0_cali_step = 32 + (f0_cali_step / 10 + 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		} else { /* f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5)
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		}
+		if (f0_cali_step > 31)
+			f0_cali_lra = (char)f0_cali_step - 32;
+		else
+			f0_cali_lra = (char)f0_cali_step + 32;
+		/* update cali step */
+		aw86907_i2c_read(aw86907, AW86907_REG_TRIMCFG3, &reg_val);
+		aw86907->f0_cali_data =
+			((int)f0_cali_lra + (int)(reg_val & 0x3f)) & 0x3f;
+
+		aw_info("%s origin trim_lra = 0x%02X, f0_cali_lra = 0x%02X, final f0_cali_data = 0x%02X\n",
+			__func__, (reg_val & 0x3f), f0_cali_lra,
+			aw86907->f0_cali_data);
+	}
+	aw86907_haptic_upload_lra(aw86907, F0_CALI);
+	/* restore standby work mode */
+	aw86907_haptic_stop(aw86907);
+	return ret;
+}
+
+static int aw86907_haptic_i2s_init(struct aw86907 *aw86907)
+{
+	aw_info("%s: enter\n", __func__);
+
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL2,
+			       AW86907_BIT_SYSCTRL2_I2S_PIN_MASK,
+			       AW86907_BIT_SYSCTRL2_I2S_PIN_I2S);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_IOCFG1,
+			       AW86907_BIT_IOCFG1_IO_FAST_MASK,
+			       AW86907_BIT_IOCFG1_IIS_IO_FAST_ENABLE);
+	return 0;
+}
+
+static int aw86907_haptic_one_wire_init(struct aw86907 *aw86907)
+{
+	aw_info("%s: enter\n", __func__);
+
+	/*if enable one-wire, trig1 priority must be less than trig2 and trig3*/
+	aw86907_i2c_write(aw86907, AW86907_REG_GLBCFG4, 0x6c);
+	aw86907_i2c_write(aw86907, AW86907_REG_GLBCFG2,
+			  AW86907_BIT_START_DLY_2P5MS);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_TRGCFG8,
+			       AW86907_BIT_TRGCFG8_TRG_ONEWIRE_MASK,
+			       AW86907_BIT_TRGCFG8_TRG_ONEWIRE_ENABLE);
+	return 0;
+}
+
+int aw86907_haptic_init(struct aw86907 *aw86907)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+	/* haptic audio */
+	aw86907->haptic_audio.delay_val = 1;
+	aw86907->haptic_audio.timer_val = 21318;
+	hrtimer_init(&aw86907->haptic_audio.timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw86907->haptic_audio.timer.function = aw86907_haptic_audio_timer_func;
+	INIT_WORK(&aw86907->haptic_audio.work,
+		  aw86907_haptic_audio_work_routine);
+	mutex_init(&aw86907->haptic_audio.lock);
+	aw86907_clean_status(aw86907);
+	/* haptic init */
+	mutex_lock(&aw86907->lock);
+	aw86907->activate_mode = aw86907->info.mode;
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_WAVCFG1, &reg_val);
+	aw86907->index = reg_val & 0x7F;
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_PLAYCFG2, &reg_val);
+	aw86907->gain = reg_val & 0xFF;
+	aw_info("%s aw86907->gain =0x%02X\n", __func__, aw86907->gain);
+	ret = aw86907_i2c_read(aw86907, AW86907_REG_PLAYCFG1, &reg_val);
+	aw86907->vmax = reg_val & 0x3F;
+	for (i = 0; i < AW86907_SEQUENCER_SIZE; i++) {
+		ret = aw86907_i2c_read(aw86907, AW86907_REG_WAVCFG1 + i,
+				       &reg_val);
+		aw86907->seq[i] = reg_val;
+	}
+	aw86907_haptic_play_mode(aw86907, AW86907_HAPTIC_STANDBY_MODE);
+	aw86907_haptic_set_pwm(aw86907, AW86907_PWM_24K);
+	/* misc value init */
+	aw86907_haptic_misc_para_init(aw86907);
+	/* set BST_ADJ */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_BSTCFG5,
+			       AW86907_BIT_BSTCFG5_BST_ADJ_MASK,
+			       AW86907_BIT_BSTCFG5_BST_ADJ_LOW);
+	aw86907_haptic_set_bst_peak_cur(aw86907, AW86907_DEFAULT_PEAKCUR);
+	aw86907_haptic_swicth_motor_protect_config(aw86907, AW_PROTECT_EN,
+						   AW_PROTECT_VAL);
+	aw86907_haptic_auto_bst_enable(aw86907, false);
+	aw86907_haptic_offset_calibration(aw86907);
+	/* vbat compensation */
+	aw86907_haptic_vbat_mode_config(
+		aw86907, AW86907_HAPTIC_CONT_VBAT_HW_ADJUST_MODE);
+	aw86907->ram_vbat_comp = AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	/* i2s config */
+	if (aw86907->info.is_enabled_i2s) {
+		aw_info("%s i2s is enabled!\n", __func__);
+		aw86907_haptic_i2s_init(aw86907);
+	} else {
+		aw86907_haptic_trig2_param_init(aw86907);
+		aw86907_haptic_trig3_param_init(aw86907);
+		aw86907_haptic_trig2_param_config(aw86907);
+		aw86907_haptic_trig3_param_config(aw86907);
+	}
+	/* one wire config */
+	if (aw86907->info.is_enabled_one_wire) {
+		aw_info("%s one wire is enabled!\n", __func__);
+		aw86907_haptic_one_wire_init(aw86907);
+	} else {
+		aw86907_haptic_trig1_param_init(aw86907);
+		aw86907_haptic_trig1_param_config(aw86907);
+	}
+	mutex_unlock(&aw86907->lock);
+
+	/* f0 calibration */
+#ifndef USE_CONT_F0_CALI
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_upload_lra(aw86907, WRITE_ZERO);
+	aw86907_haptic_f0_calibration(aw86907);
+	mutex_unlock(&aw86907->lock);
+#endif
+	return ret;
+}
+
+/*****************************************************
+ *
+ * vibrator
+ *
+ *****************************************************/
+static ssize_t aw86907_bst_vol_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"bst_vol_ram=%d, bst_vol_rtp=%d\n",
+			aw86907->info.bst_vol_ram, aw86907->info.bst_vol_rtp);
+	return len;
+}
+
+static ssize_t aw86907_bst_vol_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%d %d", &databuf[0], &databuf[1]) == 2) {
+		aw86907->info.bst_vol_ram = databuf[0];
+		aw86907->info.bst_vol_rtp = databuf[1];
+	}
+	return count;
+}
+
+static ssize_t aw86907_state_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "state = %d\n", aw86907->state);
+}
+
+static ssize_t aw86907_state_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86907_duration_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ktime_t time_rem;
+	s64 time_ms = 0;
+
+	if (hrtimer_active(&aw86907->timer)) {
+		time_rem = hrtimer_get_remaining(&aw86907->timer);
+		time_ms = ktime_to_ms(time_rem);
+	}
+	return snprintf(buf, PAGE_SIZE, "duration = %lldms\n", time_ms);
+}
+
+static ssize_t aw86907_duration_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	/* setting 0 on duration is NOP for now */
+	if (val <= 0)
+		return count;
+	aw86907->duration = val;
+	return count;
+}
+
+static ssize_t aw86907_activate_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "activate = %d\n", aw86907->state);
+}
+
+static ssize_t aw86907_activate_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw_info("%s: value=%d\n", __func__, val);
+	if (!aw86907->ram_init) {
+		aw_err("%s: ram init failed, not allow to play!\n", __func__);
+		return count;
+	}
+	mutex_lock(&aw86907->lock);
+	hrtimer_cancel(&aw86907->timer);
+	aw86907->state = val;
+	mutex_unlock(&aw86907->lock);
+	queue_work(aw86907->work_queue, &aw86907->vibrator_work);
+	return count;
+}
+
+static ssize_t aw86907_activate_mode_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "activate_mode = %d\n",
+			aw86907->activate_mode);
+}
+
+static ssize_t aw86907_activate_mode_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	mutex_lock(&aw86907->lock);
+	aw86907->activate_mode = val;
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_index_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned char reg_val = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_WAVCFG1, &reg_val);
+	aw86907->index = reg_val;
+	return snprintf(buf, PAGE_SIZE, "index = %d\n", aw86907->index);
+}
+
+static ssize_t aw86907_index_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val > aw86907->ram.ram_num) {
+		aw_err("%s: input value out of range!\n", __func__);
+		return count;
+	}
+	aw_info("%s: value=%d\n", __func__, val);
+	mutex_lock(&aw86907->lock);
+	aw86907->index = val;
+	aw86907_haptic_set_repeat_wav_seq(aw86907, aw86907->index);
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_vmax_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "vmax = 0x%02X\n", aw86907->vmax);
+}
+
+static ssize_t aw86907_vmax_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw_info("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86907->lock);
+	aw86907->vmax = val;
+	aw86907_haptic_set_bst_vol(aw86907, aw86907->vmax);
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_gain_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "gain = 0x%02X\n", aw86907->gain);
+}
+
+static ssize_t aw86907_gain_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw_info("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86907->lock);
+	aw86907->gain = val;
+	aw86907_haptic_set_gain(aw86907, aw86907->gain);
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_seq_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW86907_SEQUENCER_SIZE; i++) {
+		aw86907_i2c_read(aw86907, AW86907_REG_WAVCFG1 + i, &reg_val);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d = %d\n", i + 1, reg_val);
+		aw86907->seq[i] |= reg_val;
+	}
+	return count;
+}
+
+static ssize_t aw86907_seq_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] >= AW86907_SEQUENCER_SIZE ||
+		    databuf[1] > aw86907->ram.ram_num) {
+			aw_err("%s: input value out of range!\n", __func__);
+			return count;
+		}
+		aw_info("%s: seq%d=0x%02X\n", __func__, databuf[0], databuf[1]);
+		mutex_lock(&aw86907->lock);
+		aw86907->seq[databuf[0]] = (unsigned char)databuf[1];
+		aw86907_haptic_set_wav_seq(aw86907, (unsigned char)databuf[0],
+					   aw86907->seq[databuf[0]]);
+		mutex_unlock(&aw86907->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86907_loop_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW86907_SEQUENCER_LOOP_SIZE; i++) {
+		aw86907_i2c_read(aw86907, AW86907_REG_WAVCFG9 + i, &reg_val);
+		aw86907->loop[i * 2 + 0] = (reg_val >> 4) & 0x0F;
+		aw86907->loop[i * 2 + 1] = (reg_val >> 0) & 0x0F;
+
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d_loop = %d\n", i * 2 + 1,
+				  aw86907->loop[i * 2 + 0]);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d_loop = %d\n", i * 2 + 2,
+				  aw86907->loop[i * 2 + 1]);
+	}
+	return count;
+}
+
+static ssize_t aw86907_loop_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw_info("%s: seq%d loop=0x%02X\n", __func__, databuf[0],
+			databuf[1]);
+		mutex_lock(&aw86907->lock);
+		aw86907->loop[databuf[0]] = (unsigned char)databuf[1];
+		aw86907_haptic_set_wav_loop(aw86907, (unsigned char)databuf[0],
+					    aw86907->loop[databuf[0]]);
+		mutex_unlock(&aw86907->lock);
+	}
+
+	return count;
+}
+
+static ssize_t aw86907_reg_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW86907_REG_MAX; i++) {
+		if (!(aw86907_reg_access[i] & REG_RD_ACCESS))
+			continue;
+		aw86907_i2c_read(aw86907, i, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"reg:0x%02X=0x%02X\n", i, reg_val);
+	}
+	return len;
+}
+
+static ssize_t aw86907_reg_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw86907_i2c_write(aw86907, (unsigned char)databuf[0],
+				  (unsigned char)databuf[1]);
+	}
+
+	return count;
+}
+
+static ssize_t aw86907_rtp_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "rtp_cnt = %d\n",
+			aw86907->rtp_cnt);
+	return len;
+}
+
+static ssize_t aw86907_rtp_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0) {
+		aw_err("%s kstrtouint fail\n", __func__);
+		return rc;
+	}
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_stop(aw86907);
+	aw86907_haptic_set_rtp_aei(aw86907, false);
+	aw86907_interrupt_clear(aw86907);
+	if (val > 0) {
+		queue_work(aw86907->work_queue, &aw86907->rtp_work);
+	} else {
+		aw_err("%s input number error:%d\n", __func__, val);
+	}
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_ram_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+
+	/* RAMINIT Enable */
+	aw86907_haptic_raminit(aw86907, true);
+	aw86907_haptic_stop(aw86907);
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRH,
+			  (unsigned char)(aw86907->ram.base_addr >> 8));
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRL,
+			  (unsigned char)(aw86907->ram.base_addr & 0x00ff));
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86907_haptic_ram:\n");
+	for (i = 0; i < aw86907->ram.len; i++) {
+		aw86907_i2c_read(aw86907, AW86907_REG_RAMDATA, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "%02X,", reg_val);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw86907_haptic_raminit(aw86907, false);
+	return len;
+}
+
+static ssize_t aw86907_ram_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val)
+		aw86907_ram_update(aw86907);
+	return count;
+}
+
+static ssize_t aw86907_ram_update_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+	int size = 0;
+	int i = 0;
+	int j = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+
+	/* RAMINIT Enable */
+	aw86907_haptic_raminit(aw86907, true);
+	aw86907_haptic_stop(aw86907);
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRH,
+			  (unsigned char)(aw86907->ram.base_addr >> 8));
+	aw86907_i2c_write(aw86907, AW86907_REG_RAMADDRL,
+			  (unsigned char)(aw86907->ram.base_addr & 0x00ff));
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86907_haptic_ram:\n");
+	while (i < aw86907->ram.len) {
+		if ((aw86907->ram.len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			size = aw86907->ram.len - i;
+		else
+			size = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw86907_i2c_reads(aw86907, AW86907_REG_RAMDATA, ram_data, size);
+		for (j = 0; j < size; j++) {
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02X,",
+					ram_data[j]);
+		}
+		i += size;
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw86907_haptic_raminit(aw86907, false);
+	return len;
+}
+
+static ssize_t aw86907_ram_update_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val)
+		aw86907_ram_update(aw86907);
+	return count;
+}
+
+static ssize_t aw86907_ram_num_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	aw86907_haptic_get_ram_number(aw86907);
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_num = %d\n",
+			aw86907->ram.ram_num);
+	return len;
+}
+
+static ssize_t aw86907_f0_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_upload_lra(aw86907, WRITE_ZERO);
+	aw86907_haptic_cont_get_f0(aw86907);
+	aw86907_haptic_upload_lra(aw86907, F0_CALI);
+	mutex_unlock(&aw86907->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw86907->f0);
+	return len;
+}
+
+static ssize_t aw86907_f0_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	return count;
+}
+
+static ssize_t aw86907_f0_value_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw86907->f0);
+}
+
+static ssize_t aw86907_osc_save_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "osc_cali_data = 0x%02X\n",
+			aw86907->osc_cali_data);
+
+	return len;
+}
+
+static ssize_t aw86907_osc_save_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86907->osc_cali_data = val;
+	return count;
+}
+
+static ssize_t aw86907_f0_save_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "f0_cali_data = 0x%02X\n",
+			aw86907->f0_cali_data);
+
+	return len;
+}
+
+static ssize_t aw86907_f0_save_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86907->f0_cali_data = val;
+	return count;
+}
+
+static ssize_t aw86907_cali_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_upload_lra(aw86907, F0_CALI);
+	aw86907_haptic_cont_get_f0(aw86907);
+	mutex_unlock(&aw86907->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw86907->f0);
+	return len;
+}
+
+static ssize_t aw86907_cali_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val) {
+		mutex_lock(&aw86907->lock);
+		aw86907_haptic_f0_calibration(aw86907);
+		mutex_unlock(&aw86907->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86907_cont_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	aw86907_haptic_read_cont_f0(aw86907);
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_f0 = %d\n",
+			aw86907->cont_f0);
+	return len;
+}
+
+static ssize_t aw86907_cont_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw86907_haptic_stop(aw86907);
+	if (val) {
+		aw86907_haptic_upload_lra(aw86907, F0_CALI);
+		aw86907_haptic_cont_config(aw86907);
+	}
+	return count;
+}
+
+static ssize_t aw86907_cont_wait_num_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_wait_num = 0x%02X\n",
+			aw86907->info.cont_wait_num);
+	return len;
+}
+
+static ssize_t aw86907_cont_wait_num_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	int rc = 0;
+	unsigned int val = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86907->info.cont_wait_num = val;
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG4, val);
+
+	return count;
+}
+
+static ssize_t aw86907_cont_drv_lvl_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_lvl = 0x%02X, cont_drv2_lvl = 0x%02X\n",
+			aw86907->info.cont_drv1_lvl,
+			aw86907->info.cont_drv2_lvl);
+	return len;
+}
+
+static ssize_t aw86907_cont_drv_lvl_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw86907->info.cont_drv1_lvl = databuf[0];
+		aw86907->info.cont_drv2_lvl = databuf[1];
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_CONTCFG6,
+				       AW86907_BIT_CONTCFG6_DRV1_LVL_MASK,
+				       aw86907->info.cont_drv1_lvl);
+		aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG7,
+				  aw86907->info.cont_drv2_lvl);
+	}
+	return count;
+}
+
+static ssize_t aw86907_cont_drv_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_time = 0x%02X, cont_drv2_time = 0x%02X\n",
+			aw86907->info.cont_drv1_time,
+			aw86907->info.cont_drv2_time);
+	return len;
+}
+
+static ssize_t aw86907_cont_drv_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw86907->info.cont_drv1_time = databuf[0];
+		aw86907->info.cont_drv2_time = databuf[1];
+		aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG8,
+				  aw86907->info.cont_drv1_time);
+		aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG9,
+				  aw86907->info.cont_drv2_time);
+	}
+	return count;
+}
+
+static ssize_t aw86907_cont_brk_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_brk_time = 0x%02X\n",
+			aw86907->info.cont_brk_time);
+	return len;
+}
+
+static ssize_t aw86907_cont_brk_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	int rc = 0;
+	unsigned int val = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86907->info.cont_brk_time = val;
+	aw86907_i2c_write(aw86907, AW86907_REG_CONTCFG10,
+			  aw86907->info.cont_brk_time);
+	return count;
+}
+
+static ssize_t aw86907_vbat_monitor_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_get_vbat(aw86907);
+	len += snprintf(buf + len, PAGE_SIZE - len, "vbat_monitor = %d\n",
+			aw86907->vbat);
+	mutex_unlock(&aw86907->lock);
+
+	return len;
+}
+
+static ssize_t aw86907_vbat_monitor_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86907_lra_resistance_show(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	aw86907_haptic_get_lra_resistance(aw86907);
+	len += snprintf(buf + len, PAGE_SIZE - len, "lra_resistance = %d\n",
+			aw86907->lra);
+	return len;
+}
+
+static ssize_t aw86907_lra_resistance_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86907_auto_boost_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "auto_boost = %d\n",
+			aw86907->auto_boost);
+
+	return len;
+}
+
+static ssize_t aw86907_auto_boost_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86907->lock);
+	aw86907_haptic_stop(aw86907);
+	aw86907_haptic_auto_bst_enable(aw86907, val);
+	mutex_unlock(&aw86907->lock);
+
+	return count;
+}
+
+static ssize_t aw86907_prctmode_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	aw86907_i2c_read(aw86907, AW86907_REG_DETCFG1, &reg_val);
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "prctmode = %d\n",
+			reg_val & 0x08);
+	return len;
+}
+
+static ssize_t aw86907_prctmode_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[2] = { 0, 0 };
+	unsigned int addr = 0;
+	unsigned int val = 0;
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		addr = databuf[0];
+		val = databuf[1];
+		mutex_lock(&aw86907->lock);
+		aw86907_haptic_swicth_motor_protect_config(aw86907, addr, val);
+		mutex_unlock(&aw86907->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86907_trig_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+	unsigned char i = 0;
+
+	for (i = 0; i < AW86907_TRIG_NUM; i++) {
+		len += snprintf(
+			buf + len, PAGE_SIZE - len,
+			"trig%d: trig_level=%d, trig_polar=%d, pos_enable=%d, pos_sequence=%d, neg_enable=%d, neg_sequence=%d trig_brk=%d, trig_bst=%d\n",
+			i + 1, aw86907->trig[i].trig_level,
+			aw86907->trig[i].trig_polar,
+			aw86907->trig[i].pos_enable,
+			aw86907->trig[i].pos_sequence,
+			aw86907->trig[i].neg_enable,
+			aw86907->trig[i].neg_sequence,
+			aw86907->trig[i].trig_brk, aw86907->trig[i].trig_bst);
+	}
+
+	return len;
+}
+
+static ssize_t aw86907_trig_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int databuf[9] = { 0 };
+
+	if (sscanf(buf, "%d %d %d %d %d %d %d %d %d", &databuf[0], &databuf[1],
+		   &databuf[2], &databuf[3], &databuf[4], &databuf[5],
+		   &databuf[6], &databuf[7], &databuf[8]) == 9) {
+		aw_info("%s: %d, %d, %d, %d, %d, %d, %d, %d, %d\n", __func__,
+			databuf[0], databuf[1], databuf[2], databuf[3],
+			databuf[4], databuf[5], databuf[6], databuf[7],
+			databuf[8]);
+		if (databuf[0] < 1 || databuf[0] > 3) {
+			aw_info("%s: input trig_num out of range!\n", __func__);
+			return count;
+		}
+		if (databuf[0] == 1 && aw86907->info.is_enabled_one_wire) {
+			aw_info("%s: trig1 pin used for one wire!\n", __func__);
+			return count;
+		}
+		if ((databuf[0] == 2 || databuf[0] == 3) &&
+		    aw86907->info.is_enabled_i2s) {
+			aw_info("%s: trig2 and trig3 pin used for i2s!\n",
+				__func__);
+			return count;
+		}
+		if (!aw86907->ram_init) {
+			aw_err("%s: ram init failed, not allow to play!\n",
+			       __func__);
+			return count;
+		}
+		if (databuf[4] > aw86907->ram.ram_num ||
+		    databuf[6] > aw86907->ram.ram_num) {
+			aw_err("%s: input seq value out of range!\n", __func__);
+			return count;
+		}
+		databuf[0] -= 1;
+
+		aw86907->trig[databuf[0]].trig_level = databuf[1];
+		aw86907->trig[databuf[0]].trig_polar = databuf[2];
+		aw86907->trig[databuf[0]].pos_enable = databuf[3];
+		aw86907->trig[databuf[0]].pos_sequence = databuf[4];
+		aw86907->trig[databuf[0]].neg_enable = databuf[5];
+		aw86907->trig[databuf[0]].neg_sequence = databuf[6];
+		aw86907->trig[databuf[0]].trig_brk = databuf[7];
+		aw86907->trig[databuf[0]].trig_bst = databuf[8];
+		mutex_lock(&aw86907->lock);
+		switch (databuf[0]) {
+		case 0:
+			aw86907_haptic_trig1_param_config(aw86907);
+			break;
+		case 1:
+			aw86907_haptic_trig2_param_config(aw86907);
+			break;
+		case 2:
+			aw86907_haptic_trig3_param_config(aw86907);
+			break;
+		}
+		mutex_unlock(&aw86907->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86907_ram_vbat_compensate_show(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"ram_vbat_compensate = %d\n", aw86907->ram_vbat_comp);
+
+	return len;
+}
+
+static ssize_t aw86907_ram_vbat_compensate_store(struct device *dev,
+						 struct device_attribute *attr,
+						 const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86907->lock);
+	if (val)
+		aw86907->ram_vbat_comp = AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	else
+		aw86907->ram_vbat_comp = AW86907_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	mutex_unlock(&aw86907->lock);
+
+	return count;
+}
+
+static ssize_t aw86907_osc_cali_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "osc_cali_data = 0x%02X\n",
+			aw86907->osc_cali_data);
+
+	return len;
+}
+
+static ssize_t aw86907_osc_cali_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	mutex_lock(&aw86907->lock);
+	if (val == 3) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_D2SCFG1,
+				       AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				       AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+		aw86907_haptic_upload_lra(aw86907, WRITE_ZERO);
+		aw86907_rtp_osc_calibration(aw86907);
+		aw86907_rtp_trim_lra_calibration(aw86907);
+	} else if (val == 1) {
+		aw86907_i2c_write_bits(aw86907, AW86907_REG_D2SCFG1,
+				       AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				       AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+		aw86907_haptic_upload_lra(aw86907, OSC_CALI);
+		aw86907_rtp_osc_calibration(aw86907);
+	} else {
+		aw_err("%s input value out of range\n", __func__);
+	}
+	/* osc calibration flag end,Other behaviors are permitted */
+	mutex_unlock(&aw86907->lock);
+
+	return count;
+}
+
+static ssize_t aw86907_haptic_audio_time_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"haptic_audio.delay_val=%dus\n",
+			aw86907->haptic_audio.delay_val);
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"haptic_audio.timer_val=%dus\n",
+			aw86907->haptic_audio.timer_val);
+	return len;
+}
+
+static ssize_t aw86907_haptic_audio_time_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	unsigned int databuf[2] = { 0 };
+
+	if (sscanf(buf, "%d %d", &databuf[0], &databuf[1]) == 2) {
+		aw86907->haptic_audio.delay_val = databuf[0];
+		aw86907->haptic_audio.timer_val = databuf[1];
+	}
+
+	return count;
+}
+
+static ssize_t aw86907_gun_type_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw86907->gun_type);
+}
+
+static ssize_t aw86907_gun_type_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86907->lock);
+	aw86907->gun_type = val;
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_bullet_nr_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw86907->bullet_nr);
+}
+
+static ssize_t aw86907_bullet_nr_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86907->lock);
+	aw86907->bullet_nr = val;
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+static ssize_t aw86907_f0_check_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	if (aw86907->f0_cali_status == true)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 1);
+	if (aw86907->f0_cali_status == false)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 0);
+
+	return len;
+}
+
+static ssize_t aw86907_effect_id_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+
+	return snprintf(buf, PAGE_SIZE, "effect_id =%d\n", aw86907->effect_id);
+}
+
+static ssize_t aw86907_effect_id_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86907->lock);
+	aw86907->effect_id = val;
+	aw86907->play.vmax_mv = AW86907_MEDIUM_MAGNITUDE;
+	mutex_unlock(&aw86907->lock);
+	return count;
+}
+
+/* return buffer size and availbe size */
+static ssize_t aw86907_custom_wave_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "period_size=%d;",
+			aw86907->ram.base_addr >> 2);
+	len += snprintf(buf + len, PAGE_SIZE - len, "max_size=%d;free_size=%d;",
+			get_rb_max_size(), get_rb_free_size());
+	len += snprintf(buf + len, PAGE_SIZE - len, "custom_wave_id=%d;",
+			CUSTOME_WAVE_ID);
+	return len;
+}
+
+static ssize_t aw86907_custom_wave_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86907 *aw86907 = awinic->aw86907;
+	unsigned long buf_len, period_size, offset;
+	int ret;
+
+	period_size = (aw86907->ram.base_addr >> 2);
+	offset = 0;
+
+	aw_dbg("%swrite szie %zd, period size %lu", __func__, count,
+	       period_size);
+	if (count % period_size || count < period_size)
+		rb_end();
+	atomic_set(&aw86907->is_in_write_loop, 1);
+
+	while (count > 0) {
+		buf_len = MIN(count, period_size);
+		ret = write_rb(buf + offset, buf_len);
+		if (ret < 0)
+			goto exit;
+		count -= buf_len;
+		offset += buf_len;
+	}
+	ret = offset;
+exit:
+	atomic_set(&aw86907->is_in_write_loop, 0);
+	wake_up_interruptible(&aw86907->stop_wait_q);
+	aw_dbg(" return size %d", ret);
+	return ret;
+}
+
+static DEVICE_ATTR(custom_wave, S_IWUSR | S_IRUGO, aw86907_custom_wave_show,
+		   aw86907_custom_wave_store);
+static DEVICE_ATTR(effect_id, S_IWUSR | S_IRUGO, aw86907_effect_id_show,
+		   aw86907_effect_id_store);
+static DEVICE_ATTR(f0_check, S_IRUGO, aw86907_f0_check_show, NULL);
+static DEVICE_ATTR(bst_vol, S_IWUSR | S_IRUGO, aw86907_bst_vol_show,
+		   aw86907_bst_vol_store);
+static DEVICE_ATTR(state, S_IWUSR | S_IRUGO, aw86907_state_show,
+		   aw86907_state_store);
+static DEVICE_ATTR(duration, S_IWUSR | S_IRUGO, aw86907_duration_show,
+		   aw86907_duration_store);
+static DEVICE_ATTR(activate, S_IWUSR | S_IRUGO, aw86907_activate_show,
+		   aw86907_activate_store);
+static DEVICE_ATTR(activate_mode, S_IWUSR | S_IRUGO, aw86907_activate_mode_show,
+		   aw86907_activate_mode_store);
+static DEVICE_ATTR(index, S_IWUSR | S_IRUGO, aw86907_index_show,
+		   aw86907_index_store);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO, aw86907_vmax_show,
+		   aw86907_vmax_store);
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO, aw86907_gain_show,
+		   aw86907_gain_store);
+static DEVICE_ATTR(seq, S_IWUSR | S_IRUGO, aw86907_seq_show, aw86907_seq_store);
+static DEVICE_ATTR(loop, S_IWUSR | S_IRUGO, aw86907_loop_show,
+		   aw86907_loop_store);
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO, aw86907_reg_show, aw86907_reg_store);
+static DEVICE_ATTR(rtp, S_IWUSR | S_IRUGO, aw86907_rtp_show, aw86907_rtp_store);
+static DEVICE_ATTR(ram, S_IWUSR | S_IRUGO, aw86907_ram_show, aw86907_ram_store);
+static DEVICE_ATTR(ram_update, S_IWUSR | S_IRUGO, aw86907_ram_update_show,
+		   aw86907_ram_update_store);
+static DEVICE_ATTR(ram_num, S_IWUSR | S_IRUGO, aw86907_ram_num_show, NULL);
+static DEVICE_ATTR(f0, S_IWUSR | S_IRUGO, aw86907_f0_show, aw86907_f0_store);
+static DEVICE_ATTR(f0_value, S_IWUSR | S_IRUGO, aw86907_f0_value_show, NULL);
+static DEVICE_ATTR(f0_save, S_IWUSR | S_IRUGO, aw86907_f0_save_show,
+		   aw86907_f0_save_store);
+static DEVICE_ATTR(osc_save, S_IWUSR | S_IRUGO, aw86907_osc_save_show,
+		   aw86907_osc_save_store);
+static DEVICE_ATTR(cali, S_IWUSR | S_IRUGO, aw86907_cali_show,
+		   aw86907_cali_store);
+static DEVICE_ATTR(cont, S_IWUSR | S_IRUGO, aw86907_cont_show,
+		   aw86907_cont_store);
+static DEVICE_ATTR(cont_wait_num, S_IWUSR | S_IRUGO, aw86907_cont_wait_num_show,
+		   aw86907_cont_wait_num_store);
+static DEVICE_ATTR(cont_drv_lvl, S_IWUSR | S_IRUGO, aw86907_cont_drv_lvl_show,
+		   aw86907_cont_drv_lvl_store);
+static DEVICE_ATTR(cont_drv_time, S_IWUSR | S_IRUGO, aw86907_cont_drv_time_show,
+		   aw86907_cont_drv_time_store);
+static DEVICE_ATTR(cont_brk_time, S_IWUSR | S_IRUGO, aw86907_cont_brk_time_show,
+		   aw86907_cont_brk_time_store);
+static DEVICE_ATTR(vbat_monitor, S_IWUSR | S_IRUGO, aw86907_vbat_monitor_show,
+		   aw86907_vbat_monitor_store);
+static DEVICE_ATTR(lra_resistance, S_IWUSR | S_IRUGO,
+		   aw86907_lra_resistance_show, aw86907_lra_resistance_store);
+static DEVICE_ATTR(auto_boost, S_IWUSR | S_IRUGO, aw86907_auto_boost_show,
+		   aw86907_auto_boost_store);
+static DEVICE_ATTR(prctmode, S_IWUSR | S_IRUGO, aw86907_prctmode_show,
+		   aw86907_prctmode_store);
+static DEVICE_ATTR(trig, S_IWUSR | S_IRUGO, aw86907_trig_show,
+		   aw86907_trig_store);
+static DEVICE_ATTR(ram_vbat_comp, S_IWUSR | S_IRUGO,
+		   aw86907_ram_vbat_compensate_show,
+		   aw86907_ram_vbat_compensate_store);
+static DEVICE_ATTR(osc_cali, S_IWUSR | S_IRUGO, aw86907_osc_cali_show,
+		   aw86907_osc_cali_store);
+static DEVICE_ATTR(haptic_audio_time, S_IWUSR | S_IRUGO,
+		   aw86907_haptic_audio_time_show,
+		   aw86907_haptic_audio_time_store);
+static DEVICE_ATTR(gun_type, S_IWUSR | S_IRUGO, aw86907_gun_type_show,
+		   aw86907_gun_type_store);
+static DEVICE_ATTR(bullet_nr, S_IWUSR | S_IRUGO, aw86907_bullet_nr_show,
+		   aw86907_bullet_nr_store);
+static struct attribute *aw86907_vibrator_attributes[] = {
+	&dev_attr_bst_vol.attr,
+	&dev_attr_state.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_ram_num.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_wait_num.attr,
+	&dev_attr_cont_drv_lvl.attr,
+	&dev_attr_cont_drv_time.attr,
+	&dev_attr_cont_brk_time.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_trig.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_haptic_audio_time.attr,
+	&dev_attr_gun_type.attr,
+	&dev_attr_bullet_nr.attr,
+	&dev_attr_f0_check.attr,
+	&dev_attr_effect_id.attr,
+	&dev_attr_custom_wave.attr,
+	NULL
+};
+
+struct attribute_group aw86907_vibrator_attribute_group = {
+	.attrs = aw86907_vibrator_attributes
+};
+
+static enum hrtimer_restart aw86907_vibrator_timer_func(struct hrtimer *timer)
+{
+	struct aw86907 *aw86907 = container_of(timer, struct aw86907, timer);
+
+	aw_info("%s enter\n", __func__);
+	aw86907->state = 0;
+	queue_work(aw86907->work_queue, &aw86907->vibrator_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static int aw86907_haptic_play_effect_seq(struct aw86907 *aw86907,
+					  unsigned char flag)
+{
+	if (aw86907->effect_id > aw86907->info.effect_id_boundary)
+		return 0;
+
+	if (flag) {
+		if (aw86907->activate_mode ==
+		    AW86907_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw86907_haptic_set_wav_seq(
+				aw86907, 0x00, (char)aw86907->effect_id + 1);
+			aw86907_haptic_set_wav_seq(aw86907, 0x01, 0x00);
+			aw86907_haptic_set_wav_loop(aw86907, 0x00, 0x00);
+			aw86907_haptic_play_mode(aw86907,
+						 AW86907_HAPTIC_RAM_MODE);
+			if (aw86907->info.bst_vol_ram <= AW86907_MAX_BST_VOL)
+				aw86907_haptic_set_bst_vol(
+					aw86907, aw86907->info.bst_vol_ram);
+			else
+				aw86907_haptic_set_bst_vol(aw86907,
+							   aw86907->vmax);
+			aw86907_haptic_effect_strength(aw86907);
+			aw86907_haptic_set_gain(aw86907, aw86907->level);
+			aw86907_haptic_play_go(aw86907);
+		}
+		if (aw86907->activate_mode ==
+		    AW86907_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw86907_haptic_play_mode(aw86907,
+						 AW86907_HAPTIC_RAM_LOOP_MODE);
+			aw86907_haptic_set_repeat_wav_seq(
+				aw86907,
+				(aw86907->info.effect_id_boundary + 1));
+			aw86907_haptic_set_gain(aw86907, aw86907->level);
+			aw86907_haptic_play_go(aw86907);
+		}
+	}
+
+	return 0;
+}
+
+static void aw86907_vibrator_work_routine(struct work_struct *work)
+{
+	struct aw86907 *aw86907 =
+		container_of(work, struct aw86907, vibrator_work);
+
+	aw_info("%s enter\n", __func__);
+	aw_info("%s: effect_id = %d state=%d activate_mode = %d duration = %d\n",
+		__func__, aw86907->effect_id, aw86907->state,
+		aw86907->activate_mode, aw86907->duration);
+
+	mutex_lock(&aw86907->lock);
+	/* Enter standby mode */
+	aw86907_haptic_upload_lra(aw86907, F0_CALI);
+	aw86907_haptic_stop(aw86907);
+	if (aw86907->state) {
+		if (aw86907->activate_mode ==
+		    AW86907_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw86907_haptic_ram_vbat_comp(aw86907, false);
+			aw86907_haptic_play_effect_seq(aw86907, true);
+		} else if (aw86907->activate_mode ==
+			   AW86907_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw86907->level = 0x80;
+			aw86907_haptic_ram_vbat_comp(aw86907, true);
+			aw86907_haptic_play_effect_seq(aw86907, true);
+			hrtimer_start(
+				&aw86907->timer,
+				ktime_set(aw86907->duration / 1000,
+					  (aw86907->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else if (aw86907->activate_mode ==
+			   AW86907_HAPTIC_ACTIVATE_CONT_MODE) {
+			aw86907_haptic_cont_config(aw86907);
+			/* run ms timer */
+			hrtimer_start(
+				&aw86907->timer,
+				ktime_set(aw86907->duration / 1000,
+					  (aw86907->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else {
+			aw_err("%s: activate_mode error\n", __func__);
+		}
+	}
+	mutex_unlock(&aw86907->lock);
+}
+
+int aw86907_vibrator_init(struct aw86907 *aw86907)
+{
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+	ret = sysfs_create_group(&aw86907->i2c->dev.kobj,
+				 &aw86907_vibrator_attribute_group);
+	if (ret < 0) {
+		aw_err("%s error creating sysfs attr files\n", __func__);
+		return ret;
+	}
+
+	hrtimer_init(&aw86907->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw86907->timer.function = aw86907_vibrator_timer_func;
+	INIT_WORK(&aw86907->vibrator_work, aw86907_vibrator_work_routine);
+	INIT_WORK(&aw86907->rtp_work, aw86907_rtp_work_routine);
+	mutex_init(&aw86907->lock);
+	mutex_init(&aw86907->rtp_lock);
+	atomic_set(&aw86907->is_in_rtp_loop, 0);
+	atomic_set(&aw86907->exit_in_rtp_loop, 0);
+	atomic_set(&aw86907->is_in_write_loop, 0);
+	init_waitqueue_head(&aw86907->wait_q);
+	init_waitqueue_head(&aw86907->stop_wait_q);
+	return 0;
+}
+
+/******************************************************
+ *
+ * irq
+ *
+ ******************************************************/
+static void aw86907_interrupt_clear(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+}
+
+void aw86907_interrupt_setup(struct aw86907 *aw86907)
+{
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSINT, &reg_val);
+
+	aw_info("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+
+	/* edge int mode */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_INT_MODE_MASK,
+			       AW86907_BIT_SYSCTRL7_INT_MODE_EDGE);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSCTRL7,
+			       AW86907_BIT_SYSCTRL7_INT_EDGE_MODE_MASK,
+			       AW86907_BIT_SYSCTRL7_INT_EDGE_MODE_POS);
+	/* int enable */
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+			       AW86907_BIT_SYSINTM_BST_SCPM_MASK,
+			       AW86907_BIT_SYSINTM_BST_SCPM_ON);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+			       AW86907_BIT_SYSINTM_BST_OVPM_MASK,
+			       AW86907_BIT_SYSINTM_BST_OVPM_OFF);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+			       AW86907_BIT_SYSINTM_UVLM_MASK,
+			       AW86907_BIT_SYSINTM_UVLM_ON);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+			       AW86907_BIT_SYSINTM_OCDM_MASK,
+			       AW86907_BIT_SYSINTM_OCDM_ON);
+	aw86907_i2c_write_bits(aw86907, AW86907_REG_SYSINTM,
+			       AW86907_BIT_SYSINTM_OTM_MASK,
+			       AW86907_BIT_SYSINTM_OTM_ON);
+}
+
+irqreturn_t aw86907_irq(int irq, void *data)
+{
+	struct aw86907 *aw86907 = data;
+	unsigned char reg_val = 0;
+	unsigned char glb_state_val = 0;
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw86907->ram.base_addr >> 2;
+
+	atomic_set(&aw86907->is_in_rtp_loop, 1);
+	aw_info("%s enter\n", __func__);
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSINT, &reg_val);
+	aw_info("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	if (reg_val & AW86907_BIT_SYSINT_BST_OVPI) {
+		aw86907_clean_status(aw86907);
+		aw_err("%s chip ov int error\n", __func__);
+	}
+	if (reg_val & AW86907_BIT_SYSINT_UVLI) {
+		aw86907_clean_status(aw86907);
+		aw_err("%s chip uvlo int error\n", __func__);
+	}
+	if (reg_val & AW86907_BIT_SYSINT_OCDI) {
+		aw86907_clean_status(aw86907);
+		aw_err("%s chip over current int error\n", __func__);
+	}
+	if (reg_val & AW86907_BIT_SYSINT_OTI) {
+		aw86907_clean_status(aw86907);
+		aw_err("%s chip over temperature int error\n", __func__);
+	}
+	if (reg_val & AW86907_BIT_SYSINT_DONEI) {
+		aw86907_clean_status(aw86907);
+		aw_info("%s chip playback done\n", __func__);
+	}
+
+	if ((reg_val & AW86907_BIT_SYSINT_FF_AEI) && (aw86907->rtp_init)) {
+		aw_info("%s: aw86907 rtp fifo almost empty\n", __func__);
+		while ((!aw86907_haptic_rtp_get_fifo_afs(aw86907)) &&
+		       (aw86907->play_mode == AW86907_HAPTIC_RTP_MODE) &&
+		       !atomic_read(&aw86907->exit_in_rtp_loop)) {
+			mutex_lock(&aw86907->rtp_lock);
+			if (!aw86907->rtp_cnt) {
+				aw_info("%s:aw86907->rtp_cnt is 0!\n",
+					__func__);
+				mutex_unlock(&aw86907->rtp_lock);
+				break;
+			}
+#ifdef AW_ENABLE_RTP_PRINT_LOG
+			aw_info("%s:rtp mode fifo update, cnt=%d\n", __func__,
+				aw86907->rtp_cnt);
+#endif
+			if (!aw86907_rtp) {
+				aw_info("%s:aw86907_rtp is null, break!\n",
+					__func__);
+				mutex_unlock(&aw86907->rtp_lock);
+				break;
+			}
+
+			if (aw86907->is_custom_wave == 1) {
+				buf_len =
+					read_rb(aw86907_rtp->data, period_size);
+				aw86907_i2c_writes(aw86907, AW86907_REG_RTPDATA,
+						   aw86907_rtp->data, buf_len);
+				if (buf_len < period_size) {
+					aw_info("%s: rtp update complete\n",
+						__func__);
+					aw86907_haptic_set_rtp_aei(aw86907,
+								   false);
+					aw86907->rtp_cnt = 0;
+					aw86907->rtp_init = 0;
+					mutex_unlock(&aw86907->rtp_lock);
+					break;
+				}
+			} else {
+				if ((aw86907_rtp->len - aw86907->rtp_cnt) <
+				    period_size) {
+					buf_len = aw86907_rtp->len -
+						  aw86907->rtp_cnt;
+				} else {
+					buf_len = period_size;
+				}
+				aw86907_i2c_writes(
+					aw86907, AW86907_REG_RTPDATA,
+					&aw86907_rtp->data[aw86907->rtp_cnt],
+					buf_len);
+				aw86907->rtp_cnt += buf_len;
+				aw86907_i2c_read(aw86907, AW86907_REG_GLBRD5,
+						 &glb_state_val);
+				if ((glb_state_val & 0x0f) == 0) {
+					if (aw86907->rtp_cnt !=
+					    aw86907_rtp->len)
+						aw_err("%s: rtp play suspend!\n",
+						       __func__);
+					else
+						aw_info("%s: rtp update complete!\n",
+							__func__);
+					aw86907_clean_status(aw86907);
+					aw86907_haptic_set_rtp_aei(aw86907,
+								   false);
+					aw86907->rtp_cnt = 0;
+					aw86907->rtp_init = 0;
+					mutex_unlock(&aw86907->rtp_lock);
+					break;
+				}
+			}
+			mutex_unlock(&aw86907->rtp_lock);
+		}
+	}
+
+	if (reg_val & AW86907_BIT_SYSINT_FF_AFI)
+		aw_info("%s: aw86907 rtp mode fifo almost full!\n", __func__);
+
+	if (aw86907->play_mode != AW86907_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw86907->exit_in_rtp_loop))
+		aw86907_haptic_set_rtp_aei(aw86907, false);
+
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%x\n", __func__, reg_val);
+	aw86907_i2c_read(aw86907, AW86907_REG_SYSST, &reg_val);
+	aw_dbg("%s: reg SYSST=0x%x\n", __func__, reg_val);
+	atomic_set(&aw86907->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw86907->wait_q);
+	aw_info("%s exit\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+/*****************************************************
+ *
+ * device tree
+ *
+ *****************************************************/
+int aw86907_parse_dt(struct aw86907 *aw86907, struct device *dev,
+		     struct device_node *np)
+{
+	unsigned int val = 0;
+	struct qti_hap_config *config = &aw86907->config;
+	struct device_node *child_node;
+	struct qti_hap_effect *effect;
+	int rc = 0, tmp, i = 0, j;
+	unsigned int rtp_time[175];
+	unsigned int bstcfg_temp[5] = { 0x2a, 0x24, 0x9a, 0x40, 0x91 };
+	unsigned int prctmode_temp[3];
+	unsigned int sine_array_temp[4] = { 0x05, 0xB2, 0xFF, 0xEF };
+	unsigned int trig_config_temp[24] = { 1, 0, 1, 1, 1, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0 };
+
+	val = of_property_read_u32(np, "aw86907_vib_mode", &aw86907->info.mode);
+	if (val != 0)
+		aw_info("%s vib_mode not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_brk_bst_md",
+				   &aw86907->info.brk_bst_md);
+	if (val != 0)
+		aw_info("%s vib_brk_bst_md not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_f0_ref",
+				   &aw86907->info.f0_ref);
+	if (val != 0)
+		aw_info("%s vib_f0_ref not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_f0_cali_percent",
+				   &aw86907->info.f0_cali_percent);
+	if (val != 0)
+		aw_info("%s vib_f0_cali_percent not found\n", __func__);
+
+	val = of_property_read_u32(np, "aw86907_vib_cont_drv1_lvl",
+				   &aw86907->info.cont_drv1_lvl);
+	if (val != 0)
+		aw_info("%s vib_cont_drv1_lvl not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_drv2_lvl",
+				   &aw86907->info.cont_drv2_lvl);
+	if (val != 0)
+		aw_info("%s vib_cont_drv2_lvl not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_drv1_time",
+				   &aw86907->info.cont_drv1_time);
+	if (val != 0)
+		aw_info("%s vib_cont_drv1_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_drv2_time",
+				   &aw86907->info.cont_drv2_time);
+	if (val != 0)
+		aw_info("%s vib_cont_drv2_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_drv_width",
+				   &aw86907->info.cont_drv_width);
+	if (val != 0)
+		aw_info("%s vib_cont_drv_width not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_wait_num",
+				   &aw86907->info.cont_wait_num);
+	if (val != 0)
+		aw_info("%s vib_cont_wait_num not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_bst_brk_gain",
+				   &aw86907->info.cont_bst_brk_gain);
+	if (val != 0)
+		aw_info("%s vib_cont_bst_brk_gain not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_brk_gain",
+				   &aw86907->info.cont_brk_gain);
+	if (val != 0)
+		aw_info("%s vib_cont_brk_gain not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_tset",
+				   &aw86907->info.cont_tset);
+	if (val != 0)
+		aw_info("%s vib_cont_tset not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_bemf_set",
+				   &aw86907->info.cont_bemf_set);
+	if (val != 0)
+		aw_info("%s vib_cont_bemf_set not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_d2s_gain",
+				   &aw86907->info.d2s_gain);
+	if (val != 0)
+		aw_info("%s vib_d2s_gain not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_brk_time",
+				   &aw86907->info.cont_brk_time);
+	if (val != 0)
+		aw_info("%s vib_cont_brk_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_cont_track_margin",
+				   &aw86907->info.cont_track_margin);
+	if (val != 0)
+		aw_info("%s vib_cont_track_margin not found\n", __func__);
+	aw86907->info.is_enabled_auto_bst =
+		of_property_read_bool(np, "aw86907_vib_is_enabled_auto_bst");
+	aw_info("%s aw86907->info.is_enabled_auto_bst = %d\n", __func__,
+		aw86907->info.is_enabled_auto_bst);
+	aw86907->info.is_enabled_i2s =
+		of_property_read_bool(np, "aw86907_vib_is_enabled_i2s");
+	aw_info("%s aw86907->info.is_enabled_i2s = %d\n", __func__,
+		aw86907->info.is_enabled_i2s);
+	aw86907->info.is_enabled_one_wire =
+		of_property_read_bool(np, "aw86907_vib_is_enabled_one_wire");
+	aw_info("%s aw86907->info.is_enabled_one_wire = %d\n", __func__,
+		aw86907->info.is_enabled_one_wire);
+	aw86907->info.powerup_f0_cali =
+		of_property_read_bool(np, "aw86907_vib_powerup_f0_cali");
+	aw_info("%s aw86907->info.vib_powerup_f0_cali = %d\n", __func__,
+		aw86907->info.powerup_f0_cali);
+	val = of_property_read_u32_array(np, "aw86907_vib_bstcfg", bstcfg_temp,
+					 ARRAY_SIZE(bstcfg_temp));
+	if (val != 0)
+		aw_info("%s vib_bstcfg not found\n", __func__);
+	memcpy(aw86907->info.bstcfg, bstcfg_temp, sizeof(bstcfg_temp));
+
+	val = of_property_read_u32(np, "aw86907_vib_bst_vol_default",
+				   &aw86907->info.bst_vol_default);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_default not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_bst_vol_ram",
+				   &aw86907->info.bst_vol_ram);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_ram not found\n", __func__);
+	val = of_property_read_u32(np, "aw86907_vib_bst_vol_rtp",
+				   &aw86907->info.bst_vol_rtp);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_rtp not found\n", __func__);
+
+	val = of_property_read_u32_array(np, "aw86907_vib_prctmode",
+					 prctmode_temp,
+					 ARRAY_SIZE(prctmode_temp));
+	if (val != 0)
+		aw_info("%s vib_prctmode not found\n", __func__);
+	memcpy(aw86907->info.prctmode, prctmode_temp, sizeof(prctmode_temp));
+	val = of_property_read_u32_array(np, "aw86907_vib_sine_array",
+					 sine_array_temp,
+					 ARRAY_SIZE(sine_array_temp));
+	if (val != 0)
+		aw_info("%s vib_sine_array not found\n", __func__);
+	memcpy(aw86907->info.sine_array, sine_array_temp,
+	       sizeof(sine_array_temp));
+	val = of_property_read_u32_array(np, "aw86907_vib_trig_config",
+					 trig_config_temp,
+					 ARRAY_SIZE(trig_config_temp));
+	if (val != 0)
+		aw_info("%s vib_trig_config not found\n", __func__);
+	memcpy(aw86907->info.trig_config, trig_config_temp,
+	       sizeof(trig_config_temp));
+
+	val = of_property_read_u32(np, "vib_effect_id_boundary",
+				   &aw86907->info.effect_id_boundary);
+	if (val != 0)
+		aw_info("%s vib_effect_id_boundary not found\n", __func__);
+	val = of_property_read_u32(np, "vib_effect_max",
+				   &aw86907->info.effect_max);
+	if (val != 0)
+		aw_info("%s vib_effect_max not found\n", __func__);
+	val = of_property_read_u32_array(np, "vib_rtp_time", rtp_time,
+					 ARRAY_SIZE(rtp_time));
+	if (val != 0)
+		aw_info("%s vib_rtp_time not found\n", __func__);
+	memcpy(aw86907->info.rtp_time, rtp_time, sizeof(rtp_time));
+	config->play_rate_us = HAP_PLAY_RATE_US_DEFAULT;
+	rc = of_property_read_u32(np, "play-rate-us", &tmp);
+	if (!rc)
+		config->play_rate_us = (tmp >= HAP_PLAY_RATE_US_MAX) ?
+					       HAP_PLAY_RATE_US_MAX :
+					       tmp;
+
+	aw86907->constant.pattern = devm_kcalloc(
+		aw86907->dev, HAP_WAVEFORM_BUFFER_MAX, sizeof(u8), GFP_KERNEL);
+	if (!aw86907->constant.pattern)
+		return -ENOMEM;
+
+	tmp = of_get_available_child_count(np);
+	aw86907->predefined = devm_kcalloc(
+		aw86907->dev, tmp, sizeof(*aw86907->predefined), GFP_KERNEL);
+	if (!aw86907->predefined)
+		return -ENOMEM;
+
+	aw86907->effects_count = tmp;
+	for_each_available_child_of_node (np, child_node) {
+		effect = &aw86907->predefined[i++];
+		rc = of_property_read_u32(child_node, "mtk,effect-id",
+					  &effect->id);
+		if (rc != 0)
+			aw_info("%s Read mtk,effect-id failed\n", __func__);
+
+		effect->vmax_mv = config->vmax_mv;
+		rc = of_property_read_u32(child_node, "mtk,wf-vmax-mv", &tmp);
+		if (rc != 0)
+			aw_info("%s  Read mtk,wf-vmax-mv failed !\n", __func__);
+		else
+			effect->vmax_mv = tmp;
+
+		aw_info("%s ---%d effect->vmax_mv =%d\n", __func__, __LINE__,
+			effect->vmax_mv);
+		rc = of_property_count_elems_of_size(
+			child_node, "mtk,wf-pattern", sizeof(u8));
+		if (rc < 0) {
+			aw_info("%s Count mtk,wf-pattern property failed !\n",
+				__func__);
+		} else if (rc == 0) {
+			aw_info("%s mtk,wf-pattern has no data\n", __func__);
+		}
+		aw_info("%s ---%d\n", __func__, __LINE__);
+
+		effect->pattern_length = rc;
+		effect->pattern =
+			devm_kcalloc(aw86907->dev, effect->pattern_length,
+				     sizeof(u8), GFP_KERNEL);
+
+		rc = of_property_read_u8_array(child_node, "mtk,wf-pattern",
+					       effect->pattern,
+					       effect->pattern_length);
+		if (rc < 0) {
+			aw_info("%s Read mtk,wf-pattern property failed !\n",
+				__func__);
+		}
+
+		effect->play_rate_us = config->play_rate_us;
+		rc = of_property_read_u32(child_node, "mtk,wf-play-rate-us",
+					  &tmp);
+		if (rc < 0)
+			aw_info("%s Read mtk,wf-play-rate-us failed !\n",
+				__func__);
+		else
+			effect->play_rate_us = tmp;
+
+		rc = of_property_read_u32(child_node, "mtk,wf-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_repeat); j++)
+				if (tmp <= wf_repeat[j])
+					break;
+
+			effect->wf_repeat_n = j;
+		}
+
+		rc = of_property_read_u32(child_node, "mtk,wf-s-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-s-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_s_repeat); j++)
+				if (tmp <= wf_s_repeat[j])
+					break;
+
+			effect->wf_s_repeat_n = j;
+		}
+
+		effect->lra_auto_res_disable = of_property_read_bool(
+			child_node, "mtk,lra-auto-resonance-disable");
+
+		tmp = of_property_count_elems_of_size(
+			child_node, "mtk,wf-brake-pattern", sizeof(u8));
+		if (tmp <= 0)
+			continue;
+
+		if (tmp > HAP_BRAKE_PATTERN_MAX) {
+			aw_info("%s wf-brake-pattern shouldn't be more than %d bytes\n",
+				__func__, HAP_BRAKE_PATTERN_MAX);
+		}
+
+		rc = of_property_read_u8_array(
+			child_node, "mtk,wf-brake-pattern", effect->brake, tmp);
+		if (rc < 0) {
+			aw_info("%s Failed to get wf-brake-pattern !\n",
+				__func__);
+		}
+
+		effect->brake_pattern_length = tmp;
+	}
+
+	aw_info("%s aw86907->info.brk_bst_md: %d\n", __func__,
+		aw86907->info.brk_bst_md);
+	aw_info("%s aw86907->info.bst_vol_default: %d\n", __func__,
+		aw86907->info.bst_vol_default);
+	aw_info("%s aw86907->info.bst_vol_ram: %d\n", __func__,
+		aw86907->info.bst_vol_ram);
+	aw_info("%s aw86907->info.bst_vol_rtp: %d\n", __func__,
+		aw86907->info.bst_vol_rtp);
+
+	return 0;
+}
+
+int aw86907_check_qualify(struct aw86907 *aw86907)
+{
+	int ret = -1;
+	unsigned char reg = 0;
+
+	ret = aw86907_i2c_read(aw86907, 0x64, &reg);
+	if (ret < 0) {
+		aw_err("%s: failed to read register 0x64: %d\n", __func__, ret);
+		return ret;
+	}
+	if (!(reg & 0x80)) {
+		aw_err("%s:unqualified chip!\n", __func__);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
+int aw86907_haptics_upload_effect(struct input_dev *dev,
+				  struct ff_effect *effect,
+				  struct ff_effect *old)
+{
+	struct aw86907 *aw86907 = input_get_drvdata(dev);
+	struct qti_hap_play_info *play = &aw86907->play;
+	s16 data[CUSTOM_DATA_LEN];
+	ktime_t rem;
+	s64 time_us;
+	int ret;
+
+	/*for osc calibration*/
+	if (aw86907->osc_cali_run != 0)
+		return 0;
+
+	if (hrtimer_active(&aw86907->timer)) {
+		rem = hrtimer_get_remaining(&aw86907->timer);
+		time_us = ktime_to_us(rem);
+		aw_info("waiting for playing clear sequence: %lld us\n",
+			time_us);
+		usleep_range(time_us, time_us + 100);
+	}
+	aw_dbg("%s: effect->type=0x%x,FF_CONSTANT=0x%x,FF_PERIODIC=0x%x\n",
+	       __func__, effect->type, FF_CONSTANT, FF_PERIODIC);
+	aw86907->effect_type = effect->type;
+	mutex_lock(&aw86907->lock);
+	while (atomic_read(&aw86907->exit_in_rtp_loop)) {
+		aw_info("%s  goint to waiting rtp  exit\n", __func__);
+		mutex_unlock(&aw86907->lock);
+		ret = wait_event_interruptible(
+			aw86907->stop_wait_q,
+			atomic_read(&aw86907->exit_in_rtp_loop) == 0);
+		aw_info("%s wakeup\n", __func__);
+		if (ret == -ERESTARTSYS) {
+			mutex_unlock(&aw86907->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+		mutex_lock(&aw86907->lock);
+	}
+
+	if (aw86907->effect_type == FF_CONSTANT) {
+		aw_dbg("%s: effect_type is  FF_CONSTANT!\n", __func__);
+		/*cont mode set duration */
+		aw86907->duration = effect->replay.length;
+		aw86907->activate_mode = AW86907_HAPTIC_ACTIVATE_RAM_LOOP_MODE;
+		aw86907->effect_id = aw86907->info.effect_id_boundary;
+
+	} else if (aw86907->effect_type == FF_PERIODIC) {
+		if (aw86907->effects_count == 0) {
+			mutex_unlock(&aw86907->lock);
+			return -EINVAL;
+		}
+
+		aw_dbg("%s: effect_type is  FF_PERIODIC!\n", __func__);
+		if (copy_from_user(data, effect->u.periodic.custom_data,
+				   sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw86907->lock);
+			return -EFAULT;
+		}
+
+		aw86907->effect_id = data[0];
+		aw_dbg("%s: aw86907->effect_id =%d\n", __func__,
+		       aw86907->effect_id);
+		play->vmax_mv = effect->u.periodic.magnitude; /*vmax level*/
+
+		if (aw86907->effect_id < 0 ||
+		    aw86907->effect_id > aw86907->info.effect_max) {
+			mutex_unlock(&aw86907->lock);
+			return 0;
+		}
+		aw86907->is_custom_wave = 0;
+
+		if (aw86907->effect_id < aw86907->info.effect_id_boundary) {
+			aw86907->activate_mode =
+				AW86907_HAPTIC_ACTIVATE_RAM_MODE;
+			aw_dbg("%s: aw86907->effect_id=%d , aw86907->activate_mode = %d\n",
+			       __func__, aw86907->effect_id,
+			       aw86907->activate_mode);
+			/*second data*/
+			data[1] = aw86907->predefined[aw86907->effect_id]
+					  .play_rate_us /
+				  1000000;
+			/*millisecond data*/
+			data[2] = aw86907->predefined[aw86907->effect_id]
+					  .play_rate_us /
+				  1000;
+		}
+		if (aw86907->effect_id >= aw86907->info.effect_id_boundary) {
+			aw86907->activate_mode =
+				AW86907_HAPTIC_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw86907->effect_id=%d , aw86907->activate_mode = %d\n",
+			       __func__, aw86907->effect_id,
+			       aw86907->activate_mode);
+			/*second data*/
+			data[1] = aw86907->info.rtp_time[aw86907->effect_id] /
+				  1000;
+			/*millisecond data*/
+			data[2] = aw86907->info.rtp_time[aw86907->effect_id];
+		}
+		if (aw86907->effect_id == CUSTOME_WAVE_ID) {
+			aw86907->activate_mode =
+				AW86907_HAPTIC_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw86907->effect_id=%d , aw86907->activate_mode = %d\n",
+			       __func__, aw86907->effect_id,
+			       aw86907->activate_mode);
+			/*second data*/
+			data[1] = aw86907->info.rtp_time[aw86907->effect_id] /
+				  1000;
+			/*millisecond data*/
+			data[2] = aw86907->info.rtp_time[aw86907->effect_id];
+			aw86907->is_custom_wave = 1;
+			rb_init();
+		}
+
+		if (copy_to_user(effect->u.periodic.custom_data, data,
+				 sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw86907->lock);
+			return -EFAULT;
+		}
+
+	} else {
+		aw_err("%s Unsupported effect type: %d\n", __func__,
+		       effect->type);
+	}
+	mutex_unlock(&aw86907->lock);
+	return 0;
+}
+
+int aw86907_haptics_playback(struct input_dev *dev, int effect_id, int val)
+{
+	struct aw86907 *aw86907 = input_get_drvdata(dev);
+	int rc = 0;
+
+	aw_dbg("%s: effect_id=%d , activate_mode = %d val = %d\n", __func__,
+	       aw86907->effect_id, aw86907->activate_mode, val);
+	/*for osc calibration*/
+	if (aw86907->osc_cali_run != 0)
+		return 0;
+
+	if (val > 0)
+		aw86907->state = 1;
+	if (val <= 0)
+		aw86907->state = 0;
+	hrtimer_cancel(&aw86907->timer);
+
+	if (aw86907->effect_type == FF_CONSTANT &&
+	    aw86907->activate_mode == AW86907_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+		aw_dbg("%s: enter cont_mode\n", __func__);
+		queue_work(aw86907->work_queue, &aw86907->vibrator_work);
+	} else if (aw86907->effect_type == FF_PERIODIC &&
+		   aw86907->activate_mode == AW86907_HAPTIC_ACTIVATE_RAM_MODE) {
+		aw_dbg("%s: enter  ram_mode\n", __func__);
+		queue_work(aw86907->work_queue, &aw86907->vibrator_work);
+	} else if ((aw86907->effect_type == FF_PERIODIC) &&
+		   aw86907->activate_mode == AW86907_HAPTIC_ACTIVATE_RTP_MODE) {
+		aw_dbg("%s: enter  rtp_mode\n", __func__);
+		queue_work(aw86907->work_queue, &aw86907->rtp_work);
+		/*if we are in the play mode, force to exit*/
+		if (val == 0) {
+			atomic_set(&aw86907->exit_in_rtp_loop, 1);
+			rb_force_exit();
+			wake_up_interruptible(&aw86907->stop_wait_q);
+		}
+	} else {
+		/*other mode */
+	}
+
+	return rc;
+}
+
+int aw86907_haptics_erase(struct input_dev *dev, int effect_id)
+{
+	struct aw86907 *aw86907 = input_get_drvdata(dev);
+	int rc = 0;
+
+	/*for osc calibration*/
+	if (aw86907->osc_cali_run != 0)
+		return 0;
+
+	aw_dbg("%s: enter\n", __func__);
+	aw86907->effect_type = 0;
+	aw86907->is_custom_wave = 0;
+	aw86907->duration = 0;
+	return rc;
+}
+
+void aw86907_haptics_set_gain_work_routine(struct work_struct *work)
+{
+	unsigned char comp_level = 0;
+	struct aw86907 *aw86907 =
+		container_of(work, struct aw86907, set_gain_work);
+
+	if (aw86907->new_gain >= 0x7FFF)
+		aw86907->level = 0x80; /*128 */
+	else if (aw86907->new_gain <= 0x3FFF)
+		aw86907->level = 0x1E; /*30 */
+	else
+		aw86907->level = (aw86907->new_gain - 16383) / 128;
+
+	if (aw86907->level < 0x1E)
+		aw86907->level = 0x1E; /*30 */
+	aw_info("%s: set_gain queue work, new_gain = %x level = %x\n", __func__,
+		aw86907->new_gain, aw86907->level);
+
+	if (aw86907->ram_vbat_comp == AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE &&
+	    aw86907->vbat) {
+		aw_dbg("%s: ref %d vbat %d ", __func__, AW_VBAT_REFER,
+		       aw86907->vbat);
+		comp_level = aw86907->level * AW_VBAT_REFER / aw86907->vbat;
+		if (comp_level > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			comp_level = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_dbg("%s: comp level limit is %d ", __func__,
+			       comp_level);
+		}
+		aw_info("%s: enable vbat comp, level = %x comp level = %x",
+			__func__, aw86907->level, comp_level);
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG2, comp_level);
+	} else {
+		aw_dbg("%s: disable compsensation, vbat=%d, vbat_min=%d, vbat_ref=%d",
+		       __func__, aw86907->vbat, AW_VBAT_MIN, AW_VBAT_REFER);
+		aw86907_i2c_write(aw86907, AW86907_REG_PLAYCFG2,
+				  aw86907->level);
+	}
+}
+
+void aw86907_haptics_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct aw86907 *aw86907 = input_get_drvdata(dev);
+
+	aw_dbg("%s enter\n", __func__);
+	aw86907->new_gain = gain;
+	queue_work(aw86907->work_queue, &aw86907->set_gain_work);
+}
\ No newline at end of file
diff --git a/drivers/input/misc/aw86927_haptic/aw86907.h b/drivers/input/misc/aw86927_haptic/aw86907.h
new file mode 100644
index 000000000000..0921b81144db
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw86907.h
@@ -0,0 +1,1106 @@
+#ifndef _AW86907_H_
+#define _AW86907_H_
+/*********************************************************
+ *
+ * aw86907.h
+ *
+ ********************************************************/
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/leds.h>
+#include <linux/atomic.h>
+#include "aw_haptic.h"
+
+/*********************************************************
+ *
+ * Normal Marco
+ *
+ ********************************************************/
+#define OSC_CALI_MAX_LENGTH 5100000
+#define AW86907_RTP_NAME_MAX 64
+#define AW86907_SEQUENCER_SIZE 8
+#define AW86907_SEQUENCER_LOOP_SIZE 4
+#define AW86907_TRIG_NUM 3
+#define AW86907_REG_MAX 0xff
+#define AW86907_MAX_BST_VOL 0x3f /* bst_vol-> six bit */
+
+/*********************************************************
+ *
+ * Enum Define
+ *
+ ********************************************************/
+enum aw86907_haptic_strength {
+	AW86907_LIGHT_MAGNITUDE = 0x3fff,
+	AW86907_MEDIUM_MAGNITUDE = 0x5fff,
+	AW86907_STRONG_MAGNITUDE = 0x7fff,
+};
+
+enum aw86907_flags {
+	AW86907_FLAG_NONR = 0,
+	AW86907_FLAG_SKIP_INTERRUPTS = 1,
+};
+
+enum aw86907_haptic_read_write {
+	AW86907_HAPTIC_CMD_READ_REG = 0,
+	AW86907_HAPTIC_CMD_WRITE_REG = 1,
+};
+
+enum aw86907_haptic_work_mode {
+	AW86907_HAPTIC_STANDBY_MODE = 0,
+	AW86907_HAPTIC_RAM_MODE = 1,
+	AW86907_HAPTIC_RTP_MODE = 2,
+	AW86907_HAPTIC_TRIG_MODE = 3,
+	AW86907_HAPTIC_CONT_MODE = 4,
+	AW86907_HAPTIC_RAM_LOOP_MODE = 5,
+};
+
+enum aw86907_haptic_bst_pc {
+	AW86907_HAPTIC_BST_PC_L1 = 0,
+	AW86907_HAPTIC_BST_PC_L2 = 1,
+};
+
+enum aw86907_haptic_activate_mode {
+	AW86907_HAPTIC_ACTIVATE_RAM_MODE = 0,
+	AW86907_HAPTIC_ACTIVATE_CONT_MODE = 1,
+	AW86907_HAPTIC_ACTIVATE_RTP_MODE = 2,
+	AW86907_HAPTIC_ACTIVATE_RAM_LOOP_MODE = 3,
+};
+
+enum aw86907_haptic_cont_vbat_comp_mode {
+	AW86907_HAPTIC_CONT_VBAT_SW_ADJUST_MODE = 0,
+	AW86907_HAPTIC_CONT_VBAT_HW_ADJUST_MODE = 1,
+};
+
+enum aw86907_haptic_ram_vbat_compensate_mode {
+	AW86907_HAPTIC_RAM_VBAT_COMP_DISABLE = 0,
+	AW86907_HAPTIC_RAM_VBAT_COMP_ENABLE = 1,
+};
+
+enum aw86907_haptic_f0_flag {
+	AW86907_HAPTIC_LRA_F0 = 0,
+	AW86907_HAPTIC_CALI_F0 = 1,
+};
+
+enum aw86907_haptic_pwm_mode {
+	AW86907_PWM_48K = 0,
+	AW86907_PWM_24K = 1,
+	AW86907_PWM_12K = 2,
+};
+
+enum aw86907_haptic_play {
+	AW86907_HAPTIC_PLAY_NULL = 0,
+	AW86907_HAPTIC_PLAY_ENABLE = 1,
+	AW86907_HAPTIC_PLAY_STOP = 2,
+	AW86907_HAPTIC_PLAY_GAIN = 8,
+};
+
+enum aw86907_haptic_cmd {
+	AW86907_HAPTIC_CMD_NULL = 0,
+	AW86907_HAPTIC_CMD_ENABLE = 1,
+	AW86907_HAPTIC_CMD_HAPTIC = 0x0f,
+	AW86907_HAPTIC_CMD_TP = 0x10,
+	AW86907_HAPTIC_CMD_SYS = 0xf0,
+	AW86907_HAPTIC_CMD_STOP = 255,
+};
+
+enum aw86907_haptic_bst_mode {
+	AW86907_HAPTIC_BST_MODE_BYPASS = 0,
+	AW86907_HAPTIC_BST_MODE_BOOST = 1,
+};
+
+enum aw86907_haptic_cali_lra {
+	WRITE_ZERO = 0,
+	F0_CALI = 1,
+	OSC_CALI = 2,
+};
+
+/*********************************************************
+ *
+ * Struct Define
+ *
+ ********************************************************/
+
+struct aw86907_trig {
+	unsigned char trig_level;
+	unsigned char trig_polar;
+	unsigned char pos_enable;
+	unsigned char pos_sequence;
+	unsigned char neg_enable;
+	unsigned char neg_sequence;
+	unsigned char trig_brk;
+	unsigned char trig_bst;
+};
+
+struct aw86907_dts_info {
+	unsigned int mode;
+	unsigned int brk_bst_md;
+	unsigned int f0_ref;
+	unsigned int f0_cali_percent;
+	unsigned int cont_drv1_lvl;
+	unsigned int cont_drv2_lvl;
+	unsigned int cont_drv1_time;
+	unsigned int cont_drv2_time;
+	unsigned int cont_wait_num;
+	unsigned int cont_brk_time;
+	unsigned int cont_track_margin;
+	unsigned int cont_tset;
+	unsigned int cont_drv_width;
+	unsigned int cont_bemf_set;
+	unsigned int cont_brk_gain;
+	unsigned int cont_bst_brk_gain;
+	unsigned int d2s_gain;
+	unsigned int bst_vol_default;
+	unsigned int bst_vol_ram;
+	unsigned int bst_vol_rtp;
+	unsigned int bstcfg[5];
+	unsigned int prctmode[3];
+	unsigned int sine_array[4];
+	unsigned int trig_config[24];
+	bool is_enabled_auto_bst;
+	bool is_enabled_i2s;
+	bool is_enabled_one_wire;
+	unsigned int effect_id_boundary;
+	unsigned int effect_max;
+	bool powerup_f0_cali;
+	unsigned int rtp_time[175];
+};
+
+struct aw86907 {
+	struct i2c_client *i2c;
+	struct device *dev;
+	struct input_dev *input;
+	struct mutex lock;
+	struct mutex rtp_lock;
+	struct work_struct vibrator_work;
+	struct work_struct rtp_work;
+	struct work_struct set_gain_work;
+	struct delayed_work ram_work;
+	struct aw86907_trig trig[AW86907_TRIG_NUM];
+	struct aw86907_dts_info info;
+	struct ram ram;
+	struct timeval start, end;
+	struct haptic_audio haptic_audio;
+
+	bool haptic_ready;
+	bool audio_ready;
+	bool f0_cali_status;
+
+	unsigned char seq[AW86907_SEQUENCER_SIZE];
+	unsigned char loop[AW86907_SEQUENCER_SIZE];
+	unsigned char rtp_init;
+	unsigned char ram_init;
+	unsigned char rtp_routine_on;
+	unsigned char max_pos_beme;
+	unsigned char max_neg_beme;
+	unsigned char ram_vbat_comp;
+	unsigned char hwen_flag;
+	unsigned char flags;
+	unsigned char chipid;
+	unsigned char play_mode;
+	unsigned char activate_mode;
+	unsigned char auto_boost;
+	unsigned char boost_mode;
+	unsigned char bst_pc;
+	u16 new_gain;
+	unsigned char level;
+
+	int reset_gpio;
+	int irq_gpio;
+	int state;
+	int duration;
+	int amplitude;
+	int index;
+	int vmax;
+	int gain;
+	int sysclk;
+	int rate;
+	int width;
+	int pstream;
+	int cstream;
+	int enable_pin_control;
+
+	unsigned int rtp_cnt;
+	unsigned int rtp_file_num;
+	unsigned int f0;
+	unsigned int cont_f0;
+	unsigned int cont_drv1_lvl;
+	unsigned int cont_drv2_lvl;
+	unsigned int cont_brk_time;
+	unsigned int cont_wait_num;
+	unsigned int cont_drv1_time;
+	unsigned int cont_drv2_time;
+	unsigned int theory_time;
+	unsigned int vbat;
+	unsigned int lra;
+	unsigned int ram_update_flag;
+	unsigned int rtp_update_flag;
+	unsigned int osc_cali_data;
+	unsigned int f0_cali_data;
+	unsigned int timeval_flags;
+	unsigned int osc_cali_flag;
+	unsigned int sys_frequency;
+	unsigned int rtp_len;
+	unsigned int gun_type;
+	unsigned int bullet_nr;
+	unsigned long int microsecond;
+	unsigned int osc_cali_run;
+	unsigned int rtp_num_max;
+
+	atomic_t is_in_rtp_loop;
+	atomic_t exit_in_rtp_loop;
+	atomic_t is_in_write_loop;
+	wait_queue_head_t wait_q; /*wait queue for exit irq mode */
+	wait_queue_head_t stop_wait_q; /* wait queue for stop rtp mode */
+	struct workqueue_struct *work_queue;
+
+#ifdef INPUT_DEV
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct input_dev *input_dev;
+	struct pwm_device *pwm_dev;
+	struct qti_hap_config config;
+	struct qti_hap_play_info play;
+	struct qti_hap_effect *predefined;
+	struct qti_hap_effect constant;
+	struct regulator *vdd_supply;
+	struct hrtimer stop_timer;
+	struct hrtimer hap_disable_timer;
+	struct hrtimer timer; /*test used  ,del */
+	struct dentry *hap_debugfs;
+	spinlock_t bus_lock;
+	ktime_t last_sc_time;
+	int play_irq;
+	int sc_irq;
+	int effects_count;
+	int sc_det_count;
+	u16 reg_base;
+	bool perm_disable;
+	bool play_irq_en;
+	bool vdd_enabled;
+	int effect_type;
+	int effect_id;
+	int test_val;
+	int is_custom_wave;
+#endif
+};
+
+struct aw86907_container {
+	int len;
+	unsigned char data[];
+};
+
+/********************************************
+ * Register List
+ *******************************************/
+#define AW86907_REG_ID 0x00
+#define AW86907_REG_SYSST 0x01
+#define AW86907_REG_SYSINT 0x02
+#define AW86907_REG_SYSINTM 0x03
+#define AW86907_REG_SYSST2 0x04
+#define AW86907_REG_SYSER 0x05
+#define AW86907_REG_PLAYCFG1 0x06
+#define AW86907_REG_PLAYCFG2 0x07
+#define AW86907_REG_PLAYCFG3 0x08
+#define AW86907_REG_PLAYCFG4 0x09
+#define AW86907_REG_WAVCFG1 0x0A
+#define AW86907_REG_WAVCFG2 0x0B
+#define AW86907_REG_WAVCFG3 0x0C
+#define AW86907_REG_WAVCFG4 0x0D
+#define AW86907_REG_WAVCFG5 0x0E
+#define AW86907_REG_WAVCFG6 0x0F
+#define AW86907_REG_WAVCFG7 0x10
+#define AW86907_REG_WAVCFG8 0x11
+#define AW86907_REG_WAVCFG9 0x12
+#define AW86907_REG_WAVCFG10 0x13
+#define AW86907_REG_WAVCFG11 0x14
+#define AW86907_REG_WAVCFG12 0x15
+#define AW86907_REG_WAVCFG13 0x16
+#define AW86907_REG_WAVCFG14 0x17
+#define AW86907_REG_CONTCFG1 0x18
+#define AW86907_REG_CONTCFG2 0x19
+#define AW86907_REG_CONTCFG3 0x1A
+#define AW86907_REG_CONTCFG4 0x1B
+#define AW86907_REG_CONTCFG5 0x1C
+#define AW86907_REG_CONTCFG6 0x1D
+#define AW86907_REG_CONTCFG7 0x1E
+#define AW86907_REG_CONTCFG8 0x1F
+#define AW86907_REG_CONTCFG9 0x20
+#define AW86907_REG_CONTCFG10 0x21
+#define AW86907_REG_CONTCFG11 0x22
+#define AW86907_REG_CONTCFG12 0x23
+#define AW86907_REG_CONTCFG13 0x24
+#define AW86907_REG_CONTRD14 0x25
+#define AW86907_REG_CONTRD15 0x26
+#define AW86907_REG_CONTRD16 0x27
+#define AW86907_REG_CONTRD17 0x28
+#define AW86907_REG_CONTRD18 0x29
+#define AW86907_REG_CONTRD19 0x2A
+#define AW86907_REG_CONTRD20 0x2B
+#define AW86907_REG_CONTRD21 0x2C
+#define AW86907_REG_RTPCFG1 0x2D
+#define AW86907_REG_RTPCFG2 0x2E
+#define AW86907_REG_RTPCFG3 0x2F
+#define AW86907_REG_RTPCFG4 0x30
+#define AW86907_REG_RTPCFG5 0x31
+#define AW86907_REG_RTPDATA 0x32
+#define AW86907_REG_TRGCFG1 0x33
+#define AW86907_REG_TRGCFG2 0x34
+#define AW86907_REG_TRGCFG3 0x35
+#define AW86907_REG_TRGCFG4 0x36
+#define AW86907_REG_TRGCFG5 0x37
+#define AW86907_REG_TRGCFG6 0x38
+#define AW86907_REG_TRGCFG7 0x39
+#define AW86907_REG_TRGCFG8 0x3A
+#define AW86907_REG_GLBCFG1 0x3B
+#define AW86907_REG_GLBCFG2 0x3C
+#define AW86907_REG_GLBCFG3 0x3D
+#define AW86907_REG_GLBCFG4 0x3E
+#define AW86907_REG_GLBRD5 0x3F
+#define AW86907_REG_RAMADDRH 0x40
+#define AW86907_REG_RAMADDRL 0x41
+#define AW86907_REG_RAMDATA 0x42
+#define AW86907_REG_SYSCTRL1 0x43
+#define AW86907_REG_SYSCTRL2 0x44
+#define AW86907_REG_SYSCTRL3 0x45
+#define AW86907_REG_SYSCTRL4 0x46
+#define AW86907_REG_SYSCTRL5 0x47
+#define AW86907_REG_SYSCTRL6 0x48
+#define AW86907_REG_SYSCTRL7 0x49
+#define AW86907_REG_I2SCFG1 0x4A
+#define AW86907_REG_I2SCFG2 0x4B
+#define AW86907_REG_PWMCFG1 0x4C
+#define AW86907_REG_PWMCFG2 0x4D
+#define AW86907_REG_PWMCFG3 0x4E
+#define AW86907_REG_PWMCFG4 0x4F
+#define AW86907_REG_TMCFG 0x50
+#define AW86907_REG_DETCFG1 0x51
+#define AW86907_REG_DETCFG2 0x52
+#define AW86907_REG_DET_RL 0x53
+#define AW86907_REG_DET_OS 0x54
+#define AW86907_REG_DET_VBAT 0x55
+#define AW86907_REG_DET_TEST 0x56
+#define AW86907_REG_DET_LO 0x57
+#define AW86907_REG_TRIMCFG1 0x58
+#define AW86907_REG_TRIMCFG2 0x59
+#define AW86907_REG_TRIMCFG3 0x5A
+#define AW86907_REG_TRIMCFG4 0x5B
+#define AW86907_REG_PLLCFG1 0x68
+#define AW86907_REG_PLLCFG2 0x69
+#define AW86907_REG_HDRVCFG1 0x6A
+#define AW86907_REG_IOCFG1 0x6B
+#define AW86907_REG_BEMFCFG1 0x6C
+#define AW86907_REG_BSTCFG1 0x6D
+#define AW86907_REG_BSTCFG2 0x6E
+#define AW86907_REG_BSTCFG3 0x6F
+#define AW86907_REG_BSTCFG4 0x70
+#define AW86907_REG_BSTCFG5 0x71
+#define AW86907_REG_CPCFG1 0x72
+#define AW86907_REG_LDOCFG1 0x73
+#define AW86907_REG_OCCFG1 0x74
+#define AW86907_REG_ADCCFG1 0x75
+#define AW86907_REG_D2SCFG1 0x76
+
+/******************************************************
+ * Register Detail
+ *****************************************************/
+/* SYSST: reg 0x01 RO */
+#define AW86907_BIT_SYSST_BST_SCPS (1 << 7)
+#define AW86907_BIT_SYSST_BST_OVPS (1 << 6)
+#define AW86907_BIT_SYSST_UVLS (1 << 5)
+#define AW86907_BIT_SYSST_FF_AES (1 << 4)
+#define AW86907_BIT_SYSST_FF_AFS (1 << 3)
+#define AW86907_BIT_SYSST_OCDS (1 << 2)
+#define AW86907_BIT_SYSST_OTS (1 << 1)
+#define AW86907_BIT_SYSST_DONES (1 << 0)
+
+/* SYSINT: reg 0x02 RC */
+#define AW86907_BIT_SYSINT_BST_SCPI (1 << 7)
+#define AW86907_BIT_SYSINT_BST_OVPI (1 << 6)
+#define AW86907_BIT_SYSINT_UVLI (1 << 5)
+#define AW86907_BIT_SYSINT_FF_AEI (1 << 4)
+#define AW86907_BIT_SYSINT_FF_AFI (1 << 3)
+#define AW86907_BIT_SYSINT_OCDI (1 << 2)
+#define AW86907_BIT_SYSINT_OTI (1 << 1)
+#define AW86907_BIT_SYSINT_DONEI (1 << 0)
+
+/* SYSINTM: reg 0x03 RW */
+#define AW86907_BIT_SYSINTM_BST_SCPM_MASK (~(1 << 7))
+#define AW86907_BIT_SYSINTM_BST_SCPM_OFF (1 << 7)
+#define AW86907_BIT_SYSINTM_BST_SCPM_ON (0 << 7)
+#define AW86907_BIT_SYSINTM_BST_OVPM_MASK (~(1 << 6))
+#define AW86907_BIT_SYSINTM_BST_OVPM_OFF (1 << 6)
+#define AW86907_BIT_SYSINTM_BST_OVPM_ON (0 << 6)
+#define AW86907_BIT_SYSINTM_UVLM_MASK (~(1 << 5))
+#define AW86907_BIT_SYSINTM_UVLM_OFF (1 << 5)
+#define AW86907_BIT_SYSINTM_UVLM_ON (0 << 5)
+#define AW86907_BIT_SYSINTM_FF_AEM_MASK (~(1 << 4))
+#define AW86907_BIT_SYSINTM_FF_AEM_OFF (1 << 4)
+#define AW86907_BIT_SYSINTM_FF_AEM_ON (0 << 4)
+#define AW86907_BIT_SYSINTM_FF_AFM_MASK (~(1 << 3))
+#define AW86907_BIT_SYSINTM_FF_AFM_OFF (1 << 3)
+#define AW86907_BIT_SYSINTM_FF_AFM_ON (0 << 3)
+#define AW86907_BIT_SYSINTM_OCDM_MASK (~(1 << 2))
+#define AW86907_BIT_SYSINTM_OCDM_OFF (1 << 2)
+#define AW86907_BIT_SYSINTM_OCDM_ON (0 << 2)
+#define AW86907_BIT_SYSINTM_OTM_MASK (~(1 << 1))
+#define AW86907_BIT_SYSINTM_OTM_OFF (1 << 1)
+#define AW86907_BIT_SYSINTM_OTM_ON (0 << 1)
+#define AW86907_BIT_SYSINTM_DONEM_MASK (~(1 << 0))
+#define AW86907_BIT_SYSINTM_DONEM_OFF (1 << 0)
+#define AW86907_BIT_SYSINTM_DONEM_ON (0 << 0)
+
+/* SYSST2: reg 0x04 RO */
+#define AW86907_BIT_SYSST2_RAM_ADDR_ER (1 << 7)
+#define AW86907_BIT_SYSST2_TRG_ADDR_ER (1 << 6)
+#define AW86907_BIT_SYSST2_PLL_REF_OK (1 << 5)
+#define AW86907_BIT_SYSST2_BST_OK (1 << 4)
+#define AW86907_BIT_SYSST2_VBG_OK (1 << 3)
+#define AW86907_BIT_SYSST2_LDO_OK (1 << 2)
+#define AW86907_BIT_SYSST2_FF_FULL (1 << 1)
+#define AW86907_BIT_SYSST2_FF_EMPTY (1 << 0)
+
+/* SYSER: reg 0x05 RC */
+#define AW86907_BIT_SYSER_I2S_ERR (1 << 7)
+#define AW86907_BIT_SYSER_TRIG1_EVENT (1 << 6)
+#define AW86907_BIT_SYSER_TRIG2_EVENT (1 << 5)
+#define AW86907_BIT_SYSER_TRIG3_EVENT (1 << 4)
+#define AW86907_BIT_SYSER_OV (1 << 3)
+#define AW86907_BIT_SYSER_ADDR_ER (1 << 2)
+#define AW86907_BIT_SYSER_FF_ER (1 << 1)
+#define AW86907_BIT_SYSER_PLL_REF_ER (1 << 0)
+
+/* PLAYCFG1: reg 0x06 RW */
+#define AW86907_BIT_PLAYCFG1_BST_MODE_MASK (~(1 << 6))
+#define AW86907_BIT_PLAYCFG1_BST_MODE_BYPASS (0 << 6)
+#define AW86907_BIT_PLAYCFG1_BST_MODE_BOOST (1 << 6)
+#define AW86907_BIT_PLAYCFG1_BST_VOUT_RDA_MASK (~(63 << 0))
+
+/* PLAYCFG2: reg 0x07 RW */
+/* GAIN */
+
+/* PLAYCFG3: reg 0x08 RW */
+#define AW86907_BIT_PLAYCFG3_AUTO_BST_MASK (~(1 << 6))
+#define AW86907_BIT_PLAYCFG3_AUTO_BST_ENABLE (1 << 6)
+#define AW86907_BIT_PLAYCFG3_AUTO_BST_DISABLE (0 << 6)
+#define AW86907_BIT_PLAYCFG3_STOP_MODE_MASK (~(1 << 5))
+#define AW86907_BIT_PLAYCFG3_STOP_MODE_NOW (1 << 5)
+#define AW86907_BIT_PLAYCFG3_STOP_MODE_LATER (0 << 5)
+#define AW86907_BIT_PLAYCFG3_BRK_EN_MASK (~(1 << 2))
+#define AW86907_BIT_PLAYCFG3_BRK_ENABLE (1 << 2)
+#define AW86907_BIT_PLAYCFG3_BRK_DISABLE (0 << 2)
+#define AW86907_BIT_PLAYCFG3_PLAY_MODE_MASK (~(3 << 0))
+#define AW86907_BIT_PLAYCFG3_PLAY_MODE_STOP (3 << 0)
+#define AW86907_BIT_PLAYCFG3_PLAY_MODE_CONT (2 << 0)
+#define AW86907_BIT_PLAYCFG3_PLAY_MODE_RTP (1 << 0)
+#define AW86907_BIT_PLAYCFG3_PLAY_MODE_RAM (0 << 0)
+
+/* PLAYCFG4: reg 0x09 RW */
+#define AW86907_BIT_PLAYCFG4_STOP_MASK (~(1 << 1))
+#define AW86907_BIT_PLAYCFG4_STOP_ON (1 << 1)
+#define AW86907_BIT_PLAYCFG4_STOP_OFF (0 << 1)
+#define AW86907_BIT_PLAYCFG4_GO_MASK (~(1 << 0))
+#define AW86907_BIT_PLAYCFG4_GO_ON (1 << 0)
+#define AW86907_BIT_PLAYCFG4_GO_OFF (0 << 0)
+
+/* WAVCFG1-8: reg 0x0A - reg 0x11 RW */
+#define AW86907_BIT_WAVCFG_SEQWAIT_MASK (~(1 << 7))
+#define AW86907_BIT_WAVCFG_SEQWAIT_TIME (1 << 7)
+#define AW86907_BIT_WAVCFG_SEQWAIT_NUMBER (0 << 7)
+
+/* WAVCFG9-12: reg 0x12 - reg 0x15 RW */
+#define AW86907_BIT_WAVLOOP_SEQ_ODD_MASK (~(0x0F << 4))
+#define AW86907_BIT_WAVLOOP_SEQ_ODD_INIFINITELY (0x0F << 4)
+#define AW86907_BIT_WAVLOOP_SEQ_EVEN_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVLOOP_SEQ_EVEN_INIFINITELY (0x0F << 0)
+#define AW86907_BIT_WAVLOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG9: reg 0x12 RW */
+#define AW86907_BIT_WAVCFG9_SEQ1LOOP_MASK (~(0x0F << 4))
+#define AW86907_BIT_WAVCFG9_SEQ1LOOP_INIFINITELY (0x0F << 4)
+#define AW86907_BIT_WAVCFG9_SEQ2LOOP_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVCFG9_SEQ2LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG10: reg 0x13 RW */
+#define AW86907_BIT_WAVCFG10_SEQ3LOOP_MASK (~(0x0F << 4))
+#define AW86907_BIT_WAVCFG10_SEQ3LOOP_INIFINITELY (0x0F << 4)
+#define AW86907_BIT_WAVCFG10_SEQ4LOOP_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVCFG10_SEQ4LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG11: reg 0x14 RW */
+#define AW86907_BIT_WAVCFG11_SEQ5LOOP_MASK (~(0x0F << 4))
+#define AW86907_BIT_WAVCFG11_SEQ5LOOP_INIFINITELY (0x0F << 4)
+#define AW86907_BIT_WAVCFG11_SEQ6LOOP_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVCFG11_SEQ6LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG12: reg 0x15 RW */
+#define AW86907_BIT_WAVCFG12_SEQ7LOOP_MASK (~(0x0F << 4))
+#define AW86907_BIT_WAVCFG12_SEQ7LOOP_INIFINITELY (0x0F << 4)
+#define AW86907_BIT_WAVCFG12_SEQ8LOOP_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVCFG12_SEQ8LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG13: reg 0x16 RW */
+#define AW86907_BIT_WAVCFG13_WAITSLOT_MASK (~(3 << 5))
+#define AW86907_BIT_WAVCFG13_WAITSLOT_DIV_1 (0 << 5)
+#define AW86907_BIT_WAVCFG13_WAITSLOT_DIV_8 (1 << 5)
+#define AW86907_BIT_WAVCFG13_WAITSLOT_DIV_64 (2 << 5)
+#define AW86907_BIT_WAVCFG13_WAITSLOT_DIV_512 (3 << 5)
+#define AW86907_BIT_WAVCFG13_AUTO_MD_MASK (~(1 << 4))
+#define AW86907_BIT_WAVCFG13_AUTO_MD_CONT_MODE (1 << 4)
+#define AW86907_BIT_WAVCFG13_AUTO_MD_SIN_WAV (0 << 4)
+#define AW86907_BIT_WAVCFG13_MAINLOOP_MASK (~(0x0F << 0))
+#define AW86907_BIT_WAVCFG13_MAINLOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG14: reg 0x17 RW */
+/* AUTO_WAV */
+
+/***************** CONT *****************/
+/* CONTCFG1: reg 0x18 RW */
+#define AW86907_BIT_CONTCFG1_EDGE_FRE_MASK (~(0x0F << 4))
+#define AW86907_BIT_CONTCFG1_EN_F0_DET_MASK (~(1 << 3))
+#define AW86907_BIT_CONTCFG1_F0_DET_ENABLE (1 << 3)
+#define AW86907_BIT_CONTCFG1_F0_DET_DISABLE (0 << 3)
+#define AW86907_BIT_CONTCFG1_MBRK_MASK (~(1 << 2))
+#define AW86907_BIT_CONTCFG1_MBRK_ENABLE (1 << 2)
+#define AW86907_BIT_CONTCFG1_MBRK_DISABLE (0 << 2)
+#define AW86907_BIT_CONTCFG1_BRK_BST_MD_MASK (~(1 << 1))
+#define AW86907_BIT_CONTCFG1_BRK_BST_MD_ENABLE (1 << 1)
+#define AW86907_BIT_CONTCFG1_BRK_BST_MD_DISABLE (0 << 1)
+#define AW86907_BIT_CONTCFG1_SIN_MODE_MASK (~(1 << 0))
+#define AW86907_BIT_CONTCFG1_SIN_MODE_COS (1 << 0)
+#define AW86907_BIT_CONTCFG1_SIN_MODE_SINE (0 << 0)
+
+/* CONTCFG2: reg 0x19 RW */
+/* F_PRE */
+
+/* CONTCFG3: reg 0x1A RW */
+/* DRV_WIDTH */
+
+/* CONTCFG4: reg 0x1B RW */
+/* WAIT_NUM */
+
+/* CONTCFG5: reg 0x1C RW */
+#define AW86907_BIT_CONTCFG5_BST_BRK_GAIN_MASK (~(0x0F << 4))
+#define AW86907_BIT_CONTCFG5_BRK_GAIN_MASK (~(0x0F << 0))
+
+/* CONTCFG6: reg 0x1D RW */
+#define AW86907_BIT_CONTCFG6_TRACK_EN_MASK (~(1 << 7))
+#define AW86907_BIT_CONTCFG6_TRACK_ENABLE (1 << 7)
+#define AW86907_BIT_CONTCFG6_TRACK_DISABLE (0 << 7)
+#define AW86907_BIT_CONTCFG6_DRV1_LVL_MASK (~(0x7F << 0))
+
+/* CONTCFG7: reg 0x1E RW */
+#define AW86907_BIT_CONTCFG7_DRV2_LVL_MASK (~(0x7F << 0))
+
+/* CONTCFG8: reg 0x1F RW */
+/* DRV1_TIME */
+
+/* CONTCFG9: reg 0x20 RW */
+/* DRV2_TIME */
+
+/* CONTCFG10: reg 0x21 RW */
+/* BRK_TIME */
+
+/* CONTCFG11: reg 0x22 RW */
+/* TRACK_MARGIN */
+
+/* CONTCFG12: reg 0x23 RW */
+/* MBRK_TH */
+
+/* CONTCFG13: reg 0x24 RW */
+#define AW86907_BIT_CONTCFG13_TSET_MASK (~(0x0F << 4))
+#define AW86907_BIT_CONTCFG13_BEME_SET_MASK (~(0x0F << 0))
+
+/* CONTRD14: reg 0x25 RO */
+/* F_LRA_F0_H */
+
+/* CONTRD15: reg 0x26 RO */
+/* F_LRA_F0_L */
+
+/* CONTRD16: reg 0x27 RO */
+/* CONT_F0_H */
+
+/* CONTRD17: reg 0x28 RO */
+/* CONT_F0_L */
+
+/* CONTRD18: reg 0x29 RO */
+/* ACCELERATION */
+
+/* CONTRD19: reg 0x2A RO */
+/* BEMF_PEAK1 */
+
+/* CONTRD20: reg 0x2B RO */
+/* BEMF_PEAK2 */
+
+/* CONTRD21: reg 0x2C RO */
+/* BEMF_PEAK3 */
+
+/***************** RTP *****************/
+/* RTPCFG1: reg 0x2D RW */
+/* BASE_ADDR_H */
+
+/* RTPCFG2: reg 0x2E RW */
+/* BASE_ADDR_L */
+
+/* RTPCFG3: reg 0x2F RW */
+#define AW86907_BIT_RTPCFG3_FIFO_AEH_MASK (~(0x0F << 4))
+#define AW86907_BIT_RTPCFG3_FIFO_AFH_MASK (~(0x0F << 0))
+
+/* RTPCFG4: reg 0x30 RW */
+/* FIFO_AEL */
+
+/* RTPCFG5: reg 0x31 RW */
+/* FIFO_AFL */
+
+/* RTPDATA: reg 0x32 RW */
+/* FIFO_AFL */
+
+/***************** TRIGGER *****************/
+#define AW86907_BIT_TRG_ENABLE_MASK (~(1 << 7))
+#define AW86907_BIT_TRG_ENABLE (1 << 7)
+#define AW86907_BIT_TRG_DISABLE (0 << 7)
+#define AW86907_BIT_TRG_SEQ_MASK (~(0x7F << 0))
+
+/* TRGCFG1: reg 0x33 RW */
+#define AW86907_BIT_TRGCFG1_TRG1_POS_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG1_TRG1_POS_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG1_TRG1_POS_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG1_TRG1SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG2: reg 0x34 RW */
+#define AW86907_BIT_TRGCFG2_TRG2_POS_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG2_TRG2_POS_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG2_TRG2_POS_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG2_TRG2SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG3: reg 0x35 RW */
+#define AW86907_BIT_TRGCFG3_TRG3_POS_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG3_TRG3_POS_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG3_TRG3_POS_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG3_TRG3SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG4: reg 0x36 RW */
+#define AW86907_BIT_TRGCFG4_TRG1_NEG_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG4_TRG1_NEG_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG4_TRG1_NEG_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG4_TRG1SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG5: reg 0x37 RW */
+#define AW86907_BIT_TRGCFG5_TRG2_NEG_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG5_TRG2_NEG_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG5_TRG2_NEG_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG5_TRG2SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG6: reg 0x38 RW */
+#define AW86907_BIT_TRGCFG6_TRG3_NEG_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG6_TRG3_NEG_ENABLE (1 << 7)
+#define AW86907_BIT_TRGCFG6_TRG3_NEG_DISABLE (0 << 7)
+#define AW86907_BIT_TRGCFG6_TRG3SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG7: reg 0x39 RW */
+#define AW86907_BIT_TRGCFG7_TRG1_POLAR_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG7_TRG1_POLAR_NEG (1 << 7)
+#define AW86907_BIT_TRGCFG7_TRG1_POLAR_POS (0 << 7)
+#define AW86907_BIT_TRGCFG7_TRG1_MODE_MASK (~(1 << 6))
+#define AW86907_BIT_TRGCFG7_TRG1_MODE_LEVEL (1 << 6)
+#define AW86907_BIT_TRGCFG7_TRG1_MODE_EDGE (0 << 6)
+#define AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK (~(1 << 5))
+#define AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_ENABLE (1 << 5)
+#define AW86907_BIT_TRGCFG7_TRG1_AUTO_BRK_DISABLE (0 << 5)
+#define AW86907_BIT_TRGCFG7_TRG1_BST_MASK (~(1 << 4))
+#define AW86907_BIT_TRGCFG7_TRG1_BST_ENABLE (1 << 4)
+#define AW86907_BIT_TRGCFG7_TRG1_BST_DISABLE (0 << 4)
+#define AW86907_BIT_TRGCFG7_TRG2_POLAR_MASK (~(1 << 3))
+#define AW86907_BIT_TRGCFG7_TRG2_POLAR_NEG (1 << 3)
+#define AW86907_BIT_TRGCFG7_TRG2_POLAR_POS (0 << 3)
+#define AW86907_BIT_TRGCFG7_TRG2_MODE_MASK (~(1 << 2))
+#define AW86907_BIT_TRGCFG7_TRG2_MODE_LEVEL (1 << 2)
+#define AW86907_BIT_TRGCFG7_TRG2_MODE_EDGE (0 << 2)
+#define AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK (~(1 << 1))
+#define AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_ENABLE (1 << 1)
+#define AW86907_BIT_TRGCFG7_TRG2_AUTO_BRK_DISABLE (0 << 1)
+#define AW86907_BIT_TRGCFG7_TRG2_BST_MASK (~(1 << 0))
+#define AW86907_BIT_TRGCFG7_TRG2_BST_ENABLE (1 << 0)
+#define AW86907_BIT_TRGCFG7_TRG2_BST_DISABLE (0 << 0)
+
+/* TRGCFG8: reg 0x3A RW */
+#define AW86907_BIT_TRGCFG8_TRG3_POLAR_MASK (~(1 << 7))
+#define AW86907_BIT_TRGCFG8_TRG3_POLAR_NEG (1 << 7)
+#define AW86907_BIT_TRGCFG8_TRG3_POLAR_POS (0 << 7)
+#define AW86907_BIT_TRGCFG8_TRG3_MODE_MASK (~(1 << 6))
+#define AW86907_BIT_TRGCFG8_TRG3_MODE_LEVEL (1 << 6)
+#define AW86907_BIT_TRGCFG8_TRG3_MODE_EDGE (0 << 6)
+#define AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK (~(1 << 5))
+#define AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_ENABLE (1 << 5)
+#define AW86907_BIT_TRGCFG8_TRG3_AUTO_BRK_DISABLE (0 << 5)
+#define AW86907_BIT_TRGCFG8_TRG3_BST_MASK (~(1 << 4))
+#define AW86907_BIT_TRGCFG8_TRG3_BST_ENABLE (1 << 4)
+#define AW86907_BIT_TRGCFG8_TRG3_BST_DISABLE (0 << 4)
+#define AW86907_BIT_TRGCFG8_TRG_ONEWIRE_MASK (~(1 << 3))
+#define AW86907_BIT_TRGCFG8_TRG_ONEWIRE_ENABLE (1 << 3)
+#define AW86907_BIT_TRGCFG8_TRG_ONEWIRE_DISABLE (0 << 3)
+#define AW86907_BIT_TRGCFG8_TRG1_STOP_MASK (~(1 << 2))
+#define AW86907_BIT_TRGCFG8_TRG1_STOP (1 << 2)
+#define AW86907_BIT_TRGCFG8_TRG2_STOP_MASK (~(1 << 1))
+#define AW86907_BIT_TRGCFG8_TRG2_STOP (1 << 1)
+#define AW86907_BIT_TRGCFG8_TRG3_STOP_MASK (~(1 << 0))
+#define AW86907_BIT_TRGCFG8_TRG3_STOP (1 << 0)
+
+/* GLBCFG1: reg 0x3B RW */
+/* WAKE_DLY */
+
+/* GLBCFG2: reg 0x3C RW */
+/* START_DLY */
+#define AW86907_BIT_START_DLY_20US (0x01)
+#define AW86907_BIT_START_DLY_2P5MS (0x75)
+/* GLBCFG3: reg 0x3D RW */
+/* END_DLY */
+
+/* GLBCFG4: reg 0x3E RW */
+#define AW86907_BIT_GLBCFG4_GO_PRIO_MASK (~(3 << 6))
+#define AW86907_BIT_GLBCFG4_TRG3_PRIO_MASK (~(3 << 4))
+#define AW86907_BIT_GLBCFG4_TRG2_PRIO_MASK (~(3 << 2))
+#define AW86907_BIT_GLBCFG4_TRG1_PRIO_MASK (~(3 << 0))
+
+/* GLBRD5: reg 0x3F R0 */
+/* GLB_STATE [3:0] */
+#define AW86907_BIT_GLBRD5_STATE_MASK (~(15 << 0))
+#define AW86907_BIT_GLBRD5_STATE_STANDBY (0 << 0)
+#define AW86907_BIT_GLBRD5_STATE_WAKEUP (1 << 0)
+#define AW86907_BIT_GLBRD5_STATE_STARTUP (2 << 0)
+#define AW86907_BIT_GLBRD5_STATE_WAIT (3 << 0)
+#define AW86907_BIT_GLBRD5_STATE_CONT_GO (6 << 0)
+#define AW86907_BIT_GLBRD5_STATE_RAM_GO (7 << 0)
+#define AW86907_BIT_GLBRD5_STATE_RTP_GO (8 << 0)
+#define AW86907_BIT_GLBRD5_STATE_TRIG_GO (9 << 0)
+#define AW86907_BIT_GLBRD5_STATE_I2S_GO (10 << 0)
+#define AW86907_BIT_GLBRD5_STATE_BRAKE (11 << 0)
+#define AW86907_BIT_GLBRD5_STATE_END (12 << 0)
+
+/* RAMADDRH: reg 0x40 RWS */
+#define AW86907_BIT_RAMADDRH_MASK (~(63 << 0))
+
+/* RAMADDRL: reg 0x41 RWS */
+/* RAMADDRL */
+
+/* RAMDATA: reg 0x42 RWS */
+/* RAMDATA */
+
+/***************** SYSCTRL *****************/
+/* SYSCTRL1: reg 0x43 RW */
+#define AW86907_BIT_SYSCTRL1_VBAT_MODE_MASK (~(1 << 7))
+#define AW86907_BIT_SYSCTRL1_VBAT_MODE_HW (1 << 7)
+#define AW86907_BIT_SYSCTRL1_VBAT_MODE_SW (0 << 7)
+#define AW86907_BIT_SYSCTRL1_PERP_MASK (~(1 << 6))
+#define AW86907_BIT_SYSCTRL1_PERP_ON (1 << 6)
+#define AW86907_BIT_SYSCTRL1_PERP_OFF (0 << 6)
+#define AW86907_BIT_SYSCTRL1_CLK_SEL_MASK (~(3 << 4))
+#define AW86907_BIT_SYSCTRL1_CLK_SEL_OSC (1 << 4)
+#define AW86907_BIT_SYSCTRL1_CLK_SEL_AUTO (0 << 4)
+#define AW86907_BIT_SYSCTRL1_RAMINIT_MASK (~(1 << 3))
+#define AW86907_BIT_SYSCTRL1_RAMINIT_ON (1 << 3)
+#define AW86907_BIT_SYSCTRL1_RAMINIT_OFF (0 << 3)
+#define AW86907_BIT_SYSCTRL1_EN_FIR_MASK (~(1 << 2))
+#define AW86907_BIT_SYSCTRL1_FIR_ENABLE (0 << 2)
+#define AW86907_BIT_SYSCTRL1_WAKE_MODE_MASK (~(1 << 1))
+#define AW86907_BIT_SYSCTRL1_WAKE_MODE_WAKEUP (1 << 1)
+#define AW86907_BIT_SYSCTRL1_WAKE_MODE_BST (0 << 1)
+#define AW86907_BIT_SYSCTRL1_RTP_CLK_MASK (~(1 << 0))
+#define AW86907_BIT_SYSCTRL1_RTP_PLL (1 << 0)
+#define AW86907_BIT_SYSCTRL1_RTP_OSC (0 << 0)
+
+/* SYSCTRL2: reg 0x44 RW */
+#define AW86907_BIT_SYSCTRL2_WAKE_MASK (~(1 << 7))
+#define AW86907_BIT_SYSCTRL2_WAKE_ON (1 << 7)
+#define AW86907_BIT_SYSCTRL2_WAKE_OFF (0 << 7)
+#define AW86907_BIT_SYSCTRL2_STANDBY_MASK (~(1 << 6))
+#define AW86907_BIT_SYSCTRL2_STANDBY_ON (1 << 6)
+#define AW86907_BIT_SYSCTRL2_STANDBY_OFF (0 << 6)
+#define AW86907_BIT_SYSCTRL2_RTP_DLY_MASK (~(3 << 4))
+#define AW86907_BIT_SYSCTRL2_PLL_PIN_MASK (~(1 << 3))
+#define AW86907_BIT_SYSCTRL2_PLL_PIN_TEST (1 << 3)
+#define AW86907_BIT_SYSCTRL2_I2S_PIN_MASK (~(1 << 2))
+#define AW86907_BIT_SYSCTRL2_I2S_PIN_I2S (1 << 2)
+#define AW86907_BIT_SYSCTRL2_I2S_PIN_TRIG (0 << 2)
+#define AW86907_BIT_SYSCTRL2_WAVDAT_MODE_MASK (~(3 << 0))
+#define AW86907_BIT_SYSCTRL2_RATE_12K (2 << 0)
+#define AW86907_BIT_SYSCTRL2_RATE_24K (0 << 0)
+#define AW86907_BIT_SYSCTRL2_RATE_48K (1 << 0)
+
+/* SYSCTRL3: reg 0x45 RW */
+/* SIN_H */
+
+/* SYSCTRL4: reg 0x46 RW */
+/* SIN_L */
+
+/* SYSCTRL5: reg 0x47 RW */
+/* COS_H */
+
+/* SYSCTRL6: reg 0x48 RW */
+/* COS_L */
+
+/* SYSCTRL7: reg 0x49 RW */
+#define AW86907_BIT_SYSCTRL7_GAIN_BYPASS_MASK (~(1 << 6))
+#define AW86907_BIT_SYSCTRL7_GAIN_CHANGEABLE (1 << 6)
+#define AW86907_BIT_SYSCTRL7_GAIN_FIXED (0 << 6)
+
+#define AW86907_BIT_SYSCTRL7_INT_EDGE_MODE_MASK (~(1 << 5))
+#define AW86907_BIT_SYSCTRL7_INT_EDGE_MODE_POS (0 << 5)
+#define AW86907_BIT_SYSCTRL7_INT_EDGE_MODE_BOTH (1 << 5)
+#define AW86907_BIT_SYSCTRL7_INT_MODE_MASK (~(1 << 4))
+#define AW86907_BIT_SYSCTRL7_INT_MODE_EDGE (1 << 4)
+#define AW86907_BIT_SYSCTRL7_INT_MODE_LEVEL (0 << 4)
+
+#define AW86907_BIT_SYSCTRL7_INTP_MASK (~(1 << 3))
+#define AW86907_BIT_SYSCTRL7_INTP_HIGH (1 << 3)
+#define AW86907_BIT_SYSCTRL7_INTP_LOW (0 << 3)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_MASK (~(7 << 0))
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN (7 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_1 (0 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_2 (1 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_4 (2 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_8 (3 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_10 (4 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_16 (5 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_20 (6 << 0)
+#define AW86907_BIT_SYSCTRL7_D2S_GAIN_26 (7 << 0)
+
+/***************** I2S *****************/
+/* I2SCFG1: reg 0x4A RW */
+#define AW86907_BIT_I2SCFG1_I2SMD_MASK (~(3 << 6))
+#define AW86907_BIT_I2SCFG1_I2SFS_MASK (~(3 << 4))
+#define AW86907_BIT_I2SCFG1_I2SFS_16BIT (0 << 4)
+#define AW86907_BIT_I2SCFG1_I2SFS_20BIT (1 << 4)
+#define AW86907_BIT_I2SCFG1_I2SFS_24BIT (2 << 4)
+#define AW86907_BIT_I2SCFG1_I2SFS_32BIT (3 << 4)
+#define AW86907_BIT_I2SCFG1_I2SBCK_MASK (~(3 << 2))
+#define AW86907_BIT_I2SCFG1_I2SBCK_32FS (0 << 2)
+#define AW86907_BIT_I2SCFG1_I2SBCK_48FS (1 << 2)
+#define AW86907_BIT_I2SCFG1_I2SBCK_64FS (2 << 2)
+#define AW86907_BIT_I2SCFG1_RX_THRS_MASK (~(3 << 0))
+
+/* I2SCFG2: reg 0x4B RW */
+#define AW86907_BIT_I2SCFG2_WSINV_MASK (~(1 << 4))
+#define AW86907_BIT_I2SCFG2_WSINV_SWITCH (1 << 4)
+#define AW86907_BIT_I2SCFG2_WSINV_NO_SWITCH (0 << 4)
+#define AW86907_BIT_I2SCFG2_BCKINV_MASK (~(1 << 3))
+#define AW86907_BIT_I2SCFG2_BCKINV_INVERT (1 << 3)
+#define AW86907_BIT_I2SCFG2_BCKINV_NOTINVT (0 << 3)
+#define AW86907_BIT_I2SCFG2_CHSEL_MASK (~(1 << 2))
+#define AW86907_BIT_I2SCFG2_CHSEL_LEFT (1 << 2)
+#define AW86907_BIT_I2SCFG2_CHSEL_RIGHT (0 << 2)
+#define AW86907_BIT_I2SCFG2_I2S_INT_MASK (~(1 << 1))
+#define AW86907_BIT_I2SCFG2_I2S_INT_ON (1 << 1)
+#define AW86907_BIT_I2SCFG2_I2S_INT_OFF (0 << 1)
+#define AW86907_BIT_I2SCFG2_I2S_EN_MASK (~(1 << 0))
+#define AW86907_BIT_I2SCFG2_I2S_ENABLE (1 << 0)
+#define AW86907_BIT_I2SCFG2_I2S_DISABLE (0 << 0)
+
+/* PWMCFG1: reg 0x4C RW */
+#define AW86907_BIT_PWMCFG1_PRC_EN_MASK (~(1 << 7))
+#define AW86907_BIT_PWMCFG1_PRC_ENABLE (1 << 7)
+#define AW86907_BIT_PWMCFG1_PRC_DISABLE (0 << 7)
+#define AW86907_BIT_PWMCFG1_PRCTIME_MASK (~(0x7F << 0))
+
+/* PWMCFG2: reg 0x4D RW */
+#define AW86907_BIT_PWMCFG2_REF_SEL_MASK (~(1 << 5))
+#define AW86907_BIT_PWMCFG2_REF_SEL_TRIANGLE (1 << 5)
+#define AW86907_BIT_PWMCFG2_REF_SEL_SAWTOOTH (0 << 5)
+#define AW86907_BIT_PWMCFG2_PD_HWM_MASK (~(1 << 4))
+#define AW86907_BIT_PWMCFG2_PD_HWM_ON (1 << 4)
+#define AW86907_BIT_PWMCFG2_PWMOE_MASK (~(1 << 3))
+#define AW86907_BIT_PWMCFG2_PWMOE_ON (1 << 3)
+#define AW86907_BIT_PWMCFG2_PWMFRC_MASK (~(7 << 0))
+
+/* PWMCFG3: reg 0x4E RW */
+#define AW86907_BIT_PWMCFG3_PR_EN_MASK (~(1 << 7))
+#define AW86907_BIT_PWMCFG3_PR_ENABLE (1 << 7)
+#define AW86907_BIT_PWMCFG3_PR_DISABLE (0 << 7)
+#define AW86907_BIT_PWMCFG3_PRLVL_MASK (~(0x7F << 0))
+
+/* PWMCFG4: reg 0x4F RW */
+/* PRTIME */
+
+/* TMCFG: reg 0x50 RW */
+/* TM */
+
+/* DETCFG1: reg 0x51 RW */
+#define AW86907_BIT_DETCFG1_FTS_GO_MASK (~(1 << 7))
+#define AW86907_BIT_DETCFG1_FTS_GO_ENABLE (1 << 7)
+#define AW86907_BIT_DETCFG1_TEST_GO_MASK (~(1 << 6))
+#define AW86907_BIT_DETCFG1_TEST_GO_ENABLE (1 << 6)
+#define AW86907_BIT_DETCFG1_ADO_SLOT_MODE_MASK (~(1 << 5))
+#define AW86907_BIT_DETCFG1_ADO_SLOT_ADC_32 (1 << 5)
+#define AW86907_BIT_DETCFG1_ADO_SLOT_ADC_256 (0 << 5)
+#define AW86907_BIT_DETCFG1_RL_OS_MASK (~(1 << 4))
+#define AW86907_BIT_DETCFG1_RL (1 << 4)
+#define AW86907_BIT_DETCFG1_OS (0 << 4)
+#define AW86907_BIT_DETCFG1_PRCT_MODE_MASK (~(1 << 3))
+#define AW86907_BIT_DETCFG1_PRCT_MODE_INVALID (1 << 3)
+#define AW86907_BIT_DETCFG1_PRCT_MODE_VALID (0 << 3)
+#define AW86907_BIT_DETCFG1_CLK_ADC_MASK (~(7 << 0))
+#define AW86907_BIT_DETCFG1_CLK_ADC_12M (0 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_6M (1 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_3M (2 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_1M5 (3 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_M75 (4 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_M37 (5 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_M18 (6 << 0)
+#define AW86907_BIT_DETCFG1_CLK_ADC_M09 (7 << 0)
+
+/* DETCFG2: reg 0x52 RW */
+#define AW86907_BIT_DETCFG2_VBAT_GO_MASK (~(1 << 1))
+#define AW86907_BIT_DETCFG2_VABT_GO_ON (1 << 1)
+#define AW86907_BIT_DETCFG2_DIAG_GO_MASK (~(1 << 0))
+#define AW86907_BIT_DETCFG2_DIAG_GO_ON (1 << 0)
+
+/* DET_RL: reg 0x53 RW */
+/* RL */
+
+/* DET_OS: reg 0x54 RW */
+/* OS */
+
+/* DET_VBAT: reg 0x55 RW */
+/* VBAT */
+
+/* DET_TEST: reg 0x56 RW */
+/* TEST */
+
+/* DET_LO: reg 0x57 RW */
+#define AW86907_BIT_DET_LO_TEST_MASK (~(3 << 6))
+#define AW86907_BIT_DET_LO_VBAT_MASK (~(3 << 4))
+#define AW86907_BIT_DET_LO_OS_MASK (~(3 << 2))
+#define AW86907_BIT_DET_LO_RL_MASK (~(3 << 0))
+
+/* TRIMCFG1: reg:0x58 RW */
+#define AW86907_BIT_TRIMCFG1_RL_TRIM_SRC_MASK (~(1 << 6))
+#define AW86907_BIT_TRIMCFG1_RL_TRIM_SRC_REG (1 << 6)
+#define AW86907_BIT_TRIMCFG1_RL_TRIM_SRC_EFUSE (0 << 6)
+#define AW86907_BIT_TRIMCFG1_TRIM_RL_MASK (~(63 << 0))
+
+/* TRIMCFG2: reg:0x59 RW */
+#define AW86907_BIT_TRIMCFG2_BST_TRIM_SRC_MASK (~(1 << 6))
+#define AW86907_BIT_TRIMCFG2_BST_TRIM_SRC_REG (1 << 6)
+#define AW86907_BIT_TRIMCFG2_BST_TRIM_SRC_EFUSE (0 << 6)
+#define AW86907_BIT_TRIMCFG2_TRIM_BST_MASK (~(63 << 0))
+
+/* TRIMCFG3: reg:0x5A RW */
+#define AW86907_BIT_TRIMCFG3_OSC_TRIM_SRC_MASK (~(1 << 7))
+#define AW86907_BIT_TRIMCFG3_OSC_TRIM_SRC_REG (1 << 7)
+#define AW86907_BIT_TRIMCFG3_OSC_TRIM_SRC_EFUSE (0 << 7)
+#define AW86907_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK (~(1 << 6))
+#define AW86907_BIT_TRIMCFG3_LRA_TRIM_SRC_REG (1 << 6)
+#define AW86907_BIT_TRIMCFG3_LRA_TRIM_SRC_EFUSE (0 << 6)
+#define AW86907_BIT_TRIMCFG3_TRIM_LRA_MASK (~(63 << 0))
+
+/* TRIMCFG4: reg:0x5B RW */
+/* TRIM_OSC */
+
+/* PLLCFG1: reg:0x68 RW */
+#define AW86907_BIT_PLLCFG1_PLL_TEST_EN_MASK (~(1 << 6))
+#define AW86907_BIT_PLLCFG1_PLL_TEST_ENABLE (1 << 6)
+#define AW86907_BIT_PLLCFG1_PLL_TEST_DIV_MASK (~(3 << 4))
+#define AW86907_BIT_PLLCFG1_PLL_TEST_DIV_1 (0 << 4)
+#define AW86907_BIT_PLLCFG1_PLL_TEST_DIV_2 (1 << 4)
+#define AW86907_BIT_PLLCFG1_PLL_TEST_DIV_4 (2 << 4)
+#define AW86907_BIT_PLLCFG1_PLL_TEST_DIV_8 (3 << 4)
+#define AW86907_BIT_PLLCFG1_PLL_BIAS_CP1_IEN_MASK (~(1 << 3))
+#define AW86907_BIT_PLLCFG1_PLL_BIAS_CP1_IENABLE (1 << 3)
+#define AW86907_BIT_PLLCFG1_PLL_VTI_CP1_IEN_MASK (~(1 << 2))
+#define AW86907_BIT_PLLCFG1_PLL_VTI_CP1_IENABLE (1 << 2)
+#define AW86907_BIT_PLLCFG1_PLL_DELAY_SEL_MASK (~(1 << 1))
+#define AW86907_BIT_PLLCFG1_PLL_R1_SEL_MASK (~(1 << 0))
+
+/* PLLCFG2: reg:0x69 RW */
+#define AW86907_BIT_PLLCFG2_PLL_CP1_SEL_MASK (~(0x0F << 4))
+#define AW86907_BIT_PLLCFG2_PLL_CP1_40UA (4 << 4)
+#define AW86907_BIT_PLLCFG2_PLL_CP1_50UA (5 << 4)
+#define AW86907_BIT_PLLCFG2_PLL_CP1_80UA (8 << 4)
+#define AW86907_BIT_PLLCFG2_PLL_CP1_100UA (10 << 4)
+#define AW86907_BIT_PLLCFG2_PLL_CP2_SEL_MASK (~(0x0F << 0))
+#define AW86907_BIT_PLLCFG2_PLL_CP2_40NA (1 << 0)
+#define AW86907_BIT_PLLCFG2_PLL_CP2_600NA (8 << 0)
+#define AW86907_BIT_PLLCFG2_PLL_CP2_800NA (10 << 0)
+#define AW86907_BIT_PLLCFG2_PLL_CP2_1200NA (12 << 0)
+
+/* HDRVCFG1: reg:0x6A RW */
+#define AW86907_BIT_HDRVCFG1_EN_HD_LOW_MASK (~(1 << 7))
+#define AW86907_BIT_HDRVCFG1_EN_HD_HZ (0 << 7)
+#define AW86907_BIT_HDRVCFG1_EN_HD_PD (1 << 7)
+
+/* IOCFG1: reg:0x6B RW */
+#define AW86907_BIT_IOCFG1_HSEN_MASK (~(1 << 6))
+#define AW86907_BIT_IOCFG1_HS_ENABLE (1 << 6)
+#define AW86907_BIT_IOCFG1_HS_DISABLE (0 << 6)
+#define AW86907_BIT_IOCFG1_IO_FAST_MASK (~(3 << 4))
+#define AW86907_BIT_IOCFG1_ALL_IO_FAST_ENABLE (3 << 4)
+#define AW86907_BIT_IOCFG1_IIS_IO_FAST_ENABLE (2 << 4)
+#define AW86907_BIT_IOCFG1_IIC_IO_FAST_ENABLE (1 << 4)
+#define AW86907_BIT_IOCFG1_IO_FAST_DISABLE (0 << 4)
+
+/* BSTCFG1: reg:0x6D RW */
+#define AW86907_BIT_BSTCFG1_BST_PC_MASK (~(7 << 1))
+#define AW86907_BIT_BSTCFG1_PEAKCUR_4A (5 << 1)
+/* BSTCFG5: reg:0x71 RW */
+#define AW86907_BIT_BSTCFG5_BST_ADJ_MASK (~(1 << 7))
+#define AW86907_BIT_BSTCFG5_BST_ADJ_HIGH (1 << 7)
+#define AW86907_BIT_BSTCFG5_BST_ADJ_LOW (0 << 7)
+
+/* OCCFG1: reg:0x74 RW */
+#define AW86907_BIT_OCCFG1_HS_IOC_MASK (~(3 << 6))
+#define AW86907_BIT_OCCFG1_HS_IOC_3A15 (0 << 6)
+#define AW86907_BIT_OCCFG1_HS_IOC_3A65 (1 << 6)
+#define AW86907_BIT_OCCFG1_HS_IOC_4A15 (2 << 6)
+#define AW86907_BIT_OCCFG1_HS_IOC_4A65 (3 << 6)
+#define AW86907_BIT_OCCFG1_LS_IOC_MASK (~(3 << 4))
+#define AW86907_BIT_OCCFG1_LS_IOC_3A15 (0 << 4)
+#define AW86907_BIT_OCCFG1_LS_IOC_3A65 (1 << 4)
+#define AW86907_BIT_OCCFG1_LS_IOC_4A15 (2 << 4)
+#define AW86907_BIT_OCCFG1_LS_IOC_4A65 (3 << 4)
+#define AW86907_BIT_OCCFG1_OCDT_MASK (~(3 << 2))
+
+#define AW86907_BIT_OCCLK_MODE_MASK (~(3 << 0))
+
+/* ADCCFG1: reg:0x75 RW */
+#define AW86907_BIT_ADCCFG1_BST_SOFT_DLY_ADJ_MASK (~(1 << 7))
+#define AW86907_BIT_ADCCFG1_AD_SEL_HDP_MASK (~(1 << 6))
+#define AW86907_BIT_ADCCFG1_AD_SEL_HDN_MASK (~(1 << 5))
+#define AW86907_BIT_ADCCFG1_AD_SEL_PVDD_MASK (~(1 << 4))
+#define AW86907_BIT_ADCCFG1_AD_SEL_TEST_MASK (~(1 << 3))
+#define AW86907_BIT_ADCCFG1_AD_SEL_VBAT_MASK (~(1 << 2))
+#define AW86907_BIT_ADCCFG1_PD_D2S_DIV_MASK (~(1 << 1))
+#define AW86907_BIT_ADCCFG1_AD_SEL_D2S_MASK (~(1 << 0))
+
+/* D2SCFG1: reg:0x76 RW */
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_MASK (~(7 << 0))
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_48K (0 << 0)
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_24K (1 << 0)
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_12K (2 << 0)
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_6K (3 << 0)
+#define AW86907_BIT_D2SCFG1_CLK_TRIM_MODE_12M (4 << 0)
+/*********************************************************
+ *
+ * extern
+ *
+ ********************************************************/
+extern int aw86907_haptics_upload_effect(struct input_dev *dev,
+					 struct ff_effect *effect,
+					 struct ff_effect *old);
+extern int aw86907_haptics_playback(struct input_dev *dev, int effect_id,
+				    int val);
+extern int aw86907_haptics_erase(struct input_dev *dev, int effect_id);
+extern void aw86907_haptics_set_gain(struct input_dev *dev, u16 gain);
+extern void aw86907_haptics_set_gain_work_routine(struct work_struct *work);
+extern void aw86907_interrupt_setup(struct aw86907 *aw86907);
+extern int aw86907_vibrator_init(struct aw86907 *aw86907);
+extern int aw86907_haptic_init(struct aw86907 *aw86907);
+extern int aw86907_ram_init(struct aw86907 *aw86907);
+extern irqreturn_t aw86907_irq(int irq, void *data);
+extern struct attribute_group aw86907_vibrator_attribute_group;
+extern int aw86907_parse_dt(struct aw86907 *aw86907, struct device *dev,
+			    struct device_node *np);
+extern int aw86907_check_qualify(struct aw86907 *aw86907);
+#endif
\ No newline at end of file
diff --git a/drivers/input/misc/aw86927_haptic/aw86927.c b/drivers/input/misc/aw86927_haptic/aw86927.c
new file mode 100644
index 000000000000..0f8ca65ac166
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw86927.c
@@ -0,0 +1,4535 @@
+/*
+ * aw86927.c
+ *
+ *
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: <chelvming@awinic.com.cn>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/vmalloc.h>
+#include <linux/pm_qos.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw_haptic.h"
+#include "ringbuffer.h"
+#include "aw86927.h"
+#include "aw_config.h"
+
+#define AW86927_BROADCAST_ADDR (0x00)
+#define AW86927_LEFT_CHIP_ADDR (0x5A)
+#define AW86927_RIGHT_CHIP_ADDR (0x5B)
+
+static int aw86927_ram_update(struct aw86927 *aw86927);
+static int aw86927_haptic_ram_vbat_comp(struct aw86927 *aw86927, bool flag);
+static int aw86927_haptic_play_mode(struct aw86927 *aw86927,
+				    unsigned char play_mode);
+static void aw86927_haptic_play_go(struct aw86927 *aw86927);
+static int aw86927_set_base_addr(struct aw86927 *aw86927);
+static int aw86927_haptic_stop(struct aw86927 *aw86927);
+/******************************************************
+ *
+ * variable
+ *
+ ******************************************************/
+static struct pm_qos_request pm_qos_req_vb;
+static struct aw86927_container *aw86927_rtp;
+
+/******************************************************
+ *
+ * i2c write/read
+ *
+ ******************************************************/
+static int aw86927_i2c_write(struct aw86927 *aw86927, unsigned char reg_addr,
+			     unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw86927->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			aw_err("%s: i2c_write cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw86927_i2c_read(struct aw86927 *aw86927, unsigned char reg_addr,
+			    unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw86927->i2c, reg_addr);
+		if (ret < 0) {
+			aw_err("%s: i2c_read cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw86927_i2c_write_bits(struct aw86927 *aw86927,
+				  unsigned char reg_addr, unsigned int mask,
+				  unsigned char reg_data)
+{
+	unsigned char reg_val = 0;
+
+	aw86927_i2c_read(aw86927, reg_addr, &reg_val);
+	reg_val &= mask;
+	reg_val |= (reg_data & (~mask));
+	aw86927_i2c_write(aw86927, reg_addr, reg_val);
+
+	return 0;
+}
+
+static int aw86927_i2c_writes(struct aw86927 *aw86927, unsigned char reg_addr,
+			      unsigned char *buf, unsigned int len)
+{
+	int ret = -1;
+	unsigned char *data;
+
+	data = kmalloc(len + 1, GFP_KERNEL);
+
+	data[0] = reg_addr;
+	memcpy(&data[1], buf, len);
+
+	ret = i2c_master_send(aw86927->i2c, data, len + 1);
+	if (ret < 0)
+		aw_err("%s: i2c master send error\n", __func__);
+
+	kfree(data);
+
+	return ret;
+}
+
+int aw86927_i2c_reads(struct aw86927 *aw86927, unsigned char reg_addr,
+		      unsigned char *buf, unsigned int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		[0] = {
+			.addr = aw86927->i2c->addr,
+			.flags = 0,
+			.len = sizeof(uint8_t),
+			.buf = &reg_addr,
+			},
+		[1] = {
+			.addr = aw86927->i2c->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buf,
+			},
+	};
+
+	ret = i2c_transfer(aw86927->i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		aw_err("%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != 2) {
+		aw_err("%s: transfer failed(size error).", __func__);
+		return -ENXIO;
+	}
+
+	return ret;
+}
+
+static void aw86927_select_edge_int_mode(struct aw86927 *aw86927)
+{
+	aw_info("%s enter!\n", __func__);
+	/* edge int mode */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+			       AW86927_BIT_SYSCTRL4_INT_MODE_MASK,
+			       AW86927_BIT_SYSCTRL4_INT_MODE_EDGE);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+			       AW86927_BIT_SYSCTRL4_INT_EDGE_MODE_MASK,
+			       AW86927_BIT_SYSCTRL4_INT_EDGE_MODE_POS);
+}
+static int aw86927_set_cont_wait_num(struct aw86927 *aw86927, unsigned char val)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG4, val);
+	return 0;
+}
+
+static int aw86927_set_cont_drv_lvl(struct aw86927 *aw86927,
+				    unsigned char drv1_lvl,
+				    unsigned char drv2_lvl)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG6,
+			       AW86927_BIT_CONTCFG6_DRV1_LVL_MASK, drv1_lvl);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG7, drv2_lvl);
+	return 0;
+}
+
+static int aw86927_set_cont_drv_time(struct aw86927 *aw86927,
+				     unsigned char drv1_time,
+				     unsigned char drv2_time)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG8, drv1_time);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG9, drv2_time);
+	return 0;
+}
+
+static int aw86927_set_cont_brk_time(struct aw86927 *aw86927, unsigned char val)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG10, val);
+	return 0;
+}
+
+static int aw86927_is_enter_standby(struct aw86927 *aw86927)
+{
+	int ret = -1;
+	unsigned char reg_val = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_GLBRD5, &reg_val);
+	aw_dbg("%s glb_state = 0x%02x!\n", __func__, reg_val);
+	if (ret < 0)
+		return ret;
+	if (reg_val == AW86927_BIT_GLBRD5_STATE_STANDBY)
+		ret = 0;
+	return ret;
+}
+
+static void aw86927_force_enter_standby(struct aw86927 *aw86927)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL3,
+			       AW86927_BIT_SYSCTRL3_STANDBY_MASK,
+			       AW86927_BIT_SYSCTRL3_STANDBY_ON);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL3,
+			       AW86927_BIT_SYSCTRL3_STANDBY_MASK,
+			       AW86927_BIT_SYSCTRL3_STANDBY_OFF);
+}
+
+static int aw86927_haptic_wait_enter_standby(struct aw86927 *aw86927,
+					     unsigned int cnt)
+{
+	int ret = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	while (cnt) {
+		ret = aw86927_is_enter_standby(aw86927);
+		if (!ret) {
+			aw_info("%s: entered standby!\n", __func__);
+			break;
+		}
+		cnt--;
+		aw_info("%s: wait for standby\n", __func__);
+
+		usleep_range(2000, 2500);
+	}
+	if (!cnt)
+		ret = -1;
+	return ret;
+}
+
+static void aw86927_haptic_auto_break_mode(struct aw86927 *aw86927, bool flag)
+{
+	aw_info("%s enter!\n", __func__);
+	if (flag) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_BRK_EN_MASK,
+				       AW86927_BIT_PLAYCFG3_BRK_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_BRK_EN_MASK,
+				       AW86927_BIT_PLAYCFG3_BRK_DISABLE);
+	}
+}
+
+static int aw86927_haptic_read_lra_f0(struct aw86927 *aw86927)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_info("%s enter\n", __func__);
+	/* F_LRA_F0_H */
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_CONTCFG14, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	/* F_LRA_F0_L */
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_CONTCFG15, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_err("%s didn't get lra f0 because f0_reg value is 0!\n",
+		       __func__);
+		aw86927->f0 = 0;
+		aw86927->f0_cali_status = false;
+		return ret;
+	}
+	aw86927->f0_cali_status = true;
+	f0_tmp = 384000 * 10 / f0_reg;
+	aw86927->f0 = (unsigned int)f0_tmp;
+	aw_info("%s lra_f0=%d\n", __func__, aw86927->f0);
+
+	return ret;
+}
+
+static void aw86927_haptic_f0_detect(struct aw86927 *aw86927, bool flag)
+{
+	aw_info("%s enter!\n", __func__);
+	if (flag) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG1,
+				       AW86927_BIT_CONTCFG1_EN_F0_DET_MASK,
+				       AW86927_BIT_CONTCFG1_F0_DET_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG1,
+				       AW86927_BIT_CONTCFG1_EN_F0_DET_MASK,
+				       AW86927_BIT_CONTCFG1_F0_DET_DISABLE);
+	}
+}
+
+static void aw86927_haptic_trig1_param_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86927->trig[0].trig_level = aw86927->info.trig_config[0];
+	aw86927->trig[0].trig_polar = aw86927->info.trig_config[1];
+	aw86927->trig[0].pos_enable = aw86927->info.trig_config[2];
+	aw86927->trig[0].pos_sequence = aw86927->info.trig_config[3];
+	aw86927->trig[0].neg_enable = aw86927->info.trig_config[4];
+	aw86927->trig[0].neg_sequence = aw86927->info.trig_config[5];
+	aw86927->trig[0].trig_brk = aw86927->info.trig_config[6];
+	aw86927->trig[0].trig_bst = aw86927->info.trig_config[7];
+}
+
+static void aw86927_haptic_trig2_param_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86927->trig[1].trig_level = aw86927->info.trig_config[8 + 0];
+	aw86927->trig[1].trig_polar = aw86927->info.trig_config[8 + 1];
+	aw86927->trig[1].pos_enable = aw86927->info.trig_config[8 + 2];
+	aw86927->trig[1].pos_sequence = aw86927->info.trig_config[8 + 3];
+	aw86927->trig[1].neg_enable = aw86927->info.trig_config[8 + 4];
+	aw86927->trig[1].neg_sequence = aw86927->info.trig_config[8 + 5];
+	aw86927->trig[1].trig_brk = aw86927->info.trig_config[8 + 6];
+	aw86927->trig[1].trig_bst = aw86927->info.trig_config[8 + 7];
+}
+
+static void aw86927_haptic_trig3_param_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+	aw86927->trig[2].trig_level = aw86927->info.trig_config[16 + 0];
+	aw86927->trig[2].trig_polar = aw86927->info.trig_config[16 + 1];
+	aw86927->trig[2].pos_enable = aw86927->info.trig_config[16 + 2];
+	aw86927->trig[2].pos_sequence = aw86927->info.trig_config[16 + 3];
+	aw86927->trig[2].neg_enable = aw86927->info.trig_config[16 + 4];
+	aw86927->trig[2].neg_sequence = aw86927->info.trig_config[16 + 5];
+	aw86927->trig[2].trig_brk = aw86927->info.trig_config[16 + 6];
+	aw86927->trig[2].trig_bst = aw86927->info.trig_config[16 + 7];
+}
+
+static void aw86927_haptic_trig1_param_config(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86927->trig[0].trig_level) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_MODE_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_MODE_LEVEL);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_MODE_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_MODE_EDGE);
+	}
+	if (aw86927->trig[0].trig_polar) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_POLAR_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_POLAR_NEG);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_POLAR_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_POLAR_POS);
+	}
+	if (aw86927->trig[0].pos_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG1,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG1,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[0].neg_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG4,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG4,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[0].pos_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG1,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[0].pos_sequence);
+	}
+	if (aw86927->trig[0].neg_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG4,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[0].neg_sequence);
+	}
+	if (aw86927->trig[0].trig_brk) {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG7,
+			AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG7,
+			AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_DISABLE);
+	}
+	if (aw86927->trig[0].trig_bst) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_BST_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_BST_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG1_BST_MASK,
+				       AW86927_BIT_TRGCFG7_TRG1_BST_DISABLE);
+	}
+}
+
+static void aw86927_haptic_trig2_param_config(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86927->trig[1].trig_level) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_MODE_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_MODE_LEVEL);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_MODE_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_MODE_EDGE);
+	}
+	if (aw86927->trig[1].trig_polar) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_POLAR_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_POLAR_NEG);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_POLAR_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_POLAR_POS);
+	}
+	if (aw86927->trig[1].pos_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG2,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG2,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[1].neg_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG5,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG5,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[1].pos_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG2,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[1].pos_sequence);
+	}
+	if (aw86927->trig[1].neg_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG5,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[1].neg_sequence);
+	}
+	if (aw86927->trig[1].trig_brk) {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG7,
+			AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG7,
+			AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_DISABLE);
+	}
+	if (aw86927->trig[1].trig_bst) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_BST_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_BST_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG7,
+				       AW86927_BIT_TRGCFG7_TRG2_BST_MASK,
+				       AW86927_BIT_TRGCFG7_TRG2_BST_DISABLE);
+	}
+}
+
+static void aw86927_haptic_trig3_param_config(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+	if (aw86927->trig[2].trig_level) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_MODE_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_MODE_LEVEL);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_MODE_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_MODE_EDGE);
+	}
+	if (aw86927->trig[2].trig_polar) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_POLAR_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_POLAR_NEG);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_POLAR_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_POLAR_POS);
+	}
+	if (aw86927->trig[2].pos_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG3,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG3,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[2].neg_enable) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG6,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG6,
+				       AW86927_BIT_TRG_ENABLE_MASK,
+				       AW86927_BIT_TRG_DISABLE);
+	}
+	if (aw86927->trig[2].pos_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG3,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[2].pos_sequence);
+	}
+	if (aw86927->trig[2].neg_sequence) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG6,
+				       AW86927_BIT_TRG_SEQ_MASK,
+				       aw86927->trig[2].neg_sequence);
+	}
+	if (aw86927->trig[2].trig_brk) {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG8,
+			AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(
+			aw86927, AW86927_REG_TRGCFG8,
+			AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK,
+			AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_DISABLE);
+	}
+	if (aw86927->trig[2].trig_bst) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_BST_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_BST_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_TRGCFG8,
+				       AW86927_BIT_TRGCFG8_TRG3_BST_MASK,
+				       AW86927_BIT_TRGCFG8_TRG3_BST_DISABLE);
+	}
+}
+
+int aw86927_check_qualify(struct aw86927 *aw86927)
+{
+	int ret = -1;
+	unsigned char reg_val = 0;
+
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_EFCFG6, &reg_val);
+	if (ret < 0)
+		return ret;
+	if (!(reg_val & AW86927_BIT_EFCFG6_MASK)) {
+		aw_err("unqualified chip!");
+		return -ERANGE;
+	}
+	return 0;
+}
+
+static void aw86927_haptic_set_rtp_aei(struct aw86927 *aw86927, bool flag)
+{
+	aw_dbg("%s enter!\n", __func__);
+	if (flag) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+				       AW86927_BIT_SYSINTM_FF_AEM_MASK,
+				       AW86927_BIT_SYSINTM_FF_AEM_ON);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+				       AW86927_BIT_SYSINTM_FF_AEM_MASK,
+				       AW86927_BIT_SYSINTM_FF_AEM_OFF);
+	}
+}
+
+static unsigned char aw86927_haptic_rtp_get_fifo_afs(struct aw86927 *aw86927)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	aw86927->i2c->addr = (u16)AW86927_LEFT_CHIP_ADDR;
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSST, &reg_val);
+	reg_val &= AW86927_BIT_SYSST_FF_AFS;
+	ret = reg_val >> 3;
+	return ret;
+}
+
+static int aw86927_write_rtp_data(struct aw86927 *aw86927, unsigned char *val,
+				  unsigned size)
+{
+	aw_dbg("%s enter!\n", __func__);
+	aw86927_i2c_writes(aw86927, AW86927_REG_RTPDATA, val, size);
+	return 0;
+}
+
+static int aw86927_set_fifo_addr(struct aw86927 *aw86927)
+{
+	unsigned int base_addr = 0;
+	unsigned int ae_addr_h = 0;
+	unsigned int ae_addr_l = 0;
+	unsigned int af_addr_h = 0;
+	unsigned int af_addr_l = 0;
+
+	aw_info("%s enter!\n", __func__);
+	base_addr = aw86927->ram.base_addr;
+	ae_addr_h = ((base_addr >> 1) >> 4) & 0xF0;
+	ae_addr_l = (base_addr >> 1) & 0x00FF;
+
+	af_addr_h = ((base_addr - (base_addr >> 2)) >> 8) & 0x0F;
+	af_addr_l = (base_addr - (base_addr >> 2)) & 0x00FF;
+	/* FIFO_AEH */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_RTPCFG3,
+			       AW86927_BIT_RTPCFG3_FIFO_AEH_MASK,
+			       (unsigned char)ae_addr_h);
+	/* FIFO AEL */
+	aw86927_i2c_write(aw86927, AW86927_REG_RTPCFG4,
+			  (unsigned char)ae_addr_l);
+	/* FIFO_AFH */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_RTPCFG3,
+			       AW86927_BIT_RTPCFG3_FIFO_AFH_MASK,
+			       (unsigned char)af_addr_h);
+	/* FIFO_AFL */
+	aw86927_i2c_write(aw86927, AW86927_REG_RTPCFG5,
+			  (unsigned char)af_addr_l);
+	return 0;
+}
+
+static int aw86927_get_fifo_addr(struct aw86927 *aw86927)
+{
+	unsigned int temp = 0;
+	unsigned char reg_val = 0;
+
+	/*
+*	unsigned int temp
+*	HIGH<byte4 byte3 byte2 byte1>LOW
+*	|_ _ _ _AF-12BIT_ _ _ _AE-12BIT|
+*/
+
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_RTPCFG3, &reg_val);
+	temp = ((reg_val & 0x0f) << 24) | ((reg_val & 0xf0) << 4);
+	aw86927_i2c_read(aw86927, AW86927_REG_RTPCFG4, &reg_val);
+	temp = temp | reg_val;
+	aw_info("%s: almost_empty_threshold = %d\n", __func__,
+		(unsigned short)temp);
+	aw86927_i2c_read(aw86927, AW86927_REG_RTPCFG5, &reg_val);
+	temp = temp | (reg_val << 16);
+	aw_info("%s: almost_full_threshold = %d\n", __func__, temp >> 16);
+	return 0;
+}
+
+static int aw86927_write_ram_data(struct aw86927 *aw86927,
+				  struct aw86927_container *aw86927_cont)
+{
+	int i = 0;
+	int len = 0;
+
+	aw_info("%s enter!\n", __func__);
+	i = aw86927->ram.ram_shift;
+	aw86927_set_base_addr(aw86927);
+	while (i < aw86927_cont->len) {
+		if ((aw86927_cont->len - i) < AW_RAMDATA_WR_BUFFER_SIZE)
+			len = aw86927_cont->len - i;
+		else
+			len = AW_RAMDATA_WR_BUFFER_SIZE;
+		aw86927_i2c_writes(aw86927, AW86927_REG_RAMDATA,
+				   &aw86927_cont->data[i], len);
+		i += len;
+	}
+	return 0;
+}
+
+static int aw86927_read_ram_data(struct aw86927 *aw86927,
+				 unsigned char *reg_val)
+{
+	aw_dbg("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_RAMDATA, reg_val);
+	return 0;
+}
+
+static int aw86927_set_base_addr(struct aw86927 *aw86927)
+{
+	int ret = -1;
+
+	aw_info("%s enter!\n", __func__);
+	if (!aw86927->ram.base_addr) {
+		aw_err("%s:aw86927 ram base addr is error\n", __func__);
+		return ret;
+	}
+	/* rtp */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_RTPCFG1, /*ADDRH*/
+			       AW86927_BIT_RTPCFG1_BASE_ADDR_H_MASK,
+			       (unsigned char)(aw86927->ram.base_addr >> 8));
+	aw86927_i2c_write(aw86927, AW86927_REG_RTPCFG2, /*ADDRL*/
+			  (unsigned char)(aw86927->ram.base_addr & 0x00ff));
+	/* ram */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_RAMADDRH,
+			       AW86927_BIT_RAMADDRH_MASK,
+			       (unsigned char)(aw86927->ram.base_addr >> 8));
+	aw86927_i2c_write(aw86927, AW86927_REG_RAMADDRL,
+			  (unsigned char)(aw86927->ram.base_addr & 0x00ff));
+	return 0;
+}
+
+static void aw86927_haptic_raminit(struct aw86927 *aw86927, bool flag)
+{
+	aw_info("%s enter!\n", __func__);
+	if (flag) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL3,
+				       AW86927_BIT_SYSCTRL3_EN_RAMINIT_MASK,
+				       AW86927_BIT_SYSCTRL3_EN_RAMINIT_ON);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL3,
+				       AW86927_BIT_SYSCTRL3_EN_RAMINIT_MASK,
+				       AW86927_BIT_SYSCTRL3_EN_RAMINIT_OFF);
+	}
+}
+
+#ifdef AW_CHECK_RAM_DATA
+static int aw86927_check_ram_data(struct aw86927 *aw86927,
+				  unsigned char *cont_data,
+				  unsigned char *ram_data, unsigned int len)
+{
+	int i = 0;
+
+	for (i = 0; i < len; i++) {
+		if (ram_data[i] != cont_data[i]) {
+			aw_err("%s: check ramdata error, addr=0x%04x, ram_data=0x%02x, file_data=0x%02x\n",
+			       __func__, i, ram_data[i], cont_data[i]);
+			return -ERANGE;
+		}
+	}
+	return 0;
+}
+#endif
+
+static int aw86927_haptic_cont_play(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+
+	/* work mode */
+	aw86927_haptic_play_mode(aw86927, AW86927_CONT_MODE);
+
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG6,
+			       AW86927_BIT_CONTCFG6_TRACK_EN_MASK,
+			       AW86927_BIT_CONTCFG6_TRACK_ENABLE);
+	/* f0 driver level */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG6,
+			       AW86927_BIT_CONTCFG6_DRV1_LVL_MASK,
+			       aw86927->info.cont_drv1_lvl);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG7,
+			  aw86927->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	/* aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG8, 0xFF); */
+	/* DRV2_TIME */
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG9, 0xFF);
+	/* cont play go */
+	aw86927_haptic_play_go(aw86927);
+	return 0;
+}
+
+void aw86927_interrupt_setup(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSINT, &reg_val);
+
+	aw_info("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	/* edge mode */
+	aw86927_select_edge_int_mode(aw86927);
+	/* int enable */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+			       AW86927_BIT_SYSINTM_BST_SCPM_MASK,
+			       AW86927_BIT_SYSINTM_BST_SCPM_ON);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+			       AW86927_BIT_SYSINTM_BST_OVPM_MASK,
+			       AW86927_BIT_SYSINTM_BST_OVPM_OFF);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+			       AW86927_BIT_SYSINTM_UVLM_MASK,
+			       AW86927_BIT_SYSINTM_UVLM_ON);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+			       AW86927_BIT_SYSINTM_OCDM_MASK,
+			       AW86927_BIT_SYSINTM_OCDM_ON);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSINTM,
+			       AW86927_BIT_SYSINTM_OTM_MASK,
+			       AW86927_BIT_SYSINTM_OTM_ON);
+}
+
+static void aw86927_interrupt_clear(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+
+	aw_dbg("%s enter\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+}
+
+static int aw86927_get_irq_state(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+	int ret = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	if (ret < 0)
+		return ret;
+	if (reg_val & AW86927_BIT_SYSINT_BST_OVPI) {
+		aw_err("%s chip ov int error\n", __func__);
+		ret = AW86927_SYSINT_ERROR;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_UVLI) {
+		aw_err("%s chip uvlo int error\n", __func__);
+		ret = AW86927_SYSINT_ERROR;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_OCDI) {
+		aw_err("%s chip over current int error\n", __func__);
+		ret = AW86927_SYSINT_ERROR;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_OTI) {
+		aw_err("%s chip over temperature int error\n", __func__);
+		ret = AW86927_SYSINT_ERROR;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_DONEI) {
+		aw_info("%s chip playback done\n", __func__);
+		ret = AW86927_SYSINT_ERROR;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_FF_AEI) {
+		aw_info("%s aw86927 rtp fifo almost empty\n", __func__);
+		ret |= AW86927_SYSINT_FF_AEI;
+	}
+	if (reg_val & AW86927_BIT_SYSINT_FF_AFI) {
+		aw_info("%s aw86927 rtp fifo almost full\n", __func__);
+		ret |= AW86927_SYSINT_FF_AFI;
+	}
+	return ret;
+}
+
+static int aw86927_haptic_read_cont_f0(struct aw86927 *aw86927)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_info("%s enter\n", __func__);
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_CONTCFG16, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	ret = aw86927_i2c_read(aw86927, AW86927_REG_CONTCFG17, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_err("%s didn't get cont f0 because f0_reg value is 0!\n",
+		       __func__);
+		aw86927->cont_f0 = aw86927->info.f0_pre;
+		return ret;
+	}
+	f0_tmp = 384000 * 10 / f0_reg;
+	aw86927->cont_f0 = (unsigned int)f0_tmp;
+	aw_info("%s cont_f0=%d\n", __func__, aw86927->cont_f0);
+	return ret;
+}
+
+static int aw86927_haptic_cont_get_f0(struct aw86927 *aw86927)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned char brk_en_default = 0;
+	unsigned char d2s_gain_default = 0;
+
+	aw_info("%s enter\n", __func__);
+	aw86927->f0 = aw86927->info.f0_pre;
+	/* enter standby mode */
+	aw86927_haptic_stop(aw86927);
+	/* config max d2s_gain */
+	aw86927_i2c_read(aw86927, AW86927_REG_DETCFG2, &reg_val);
+	d2s_gain_default = reg_val & AW86927_BIT_DETCFG2_D2S_GAIN;
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG2,
+			       AW86927_BIT_DETCFG2_D2S_GAIN_MASK,
+			       AW86927_BIT_DETCFG2_D2S_GAIN_40);
+	/* f0 calibrate work mode */
+	aw86927_haptic_play_mode(aw86927, AW86927_CONT_MODE);
+	/* enable f0 detect */
+	aw86927_haptic_f0_detect(aw86927, true);
+	/* cont config */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG6,
+			       AW86927_BIT_CONTCFG6_TRACK_EN_MASK,
+			       AW86927_BIT_CONTCFG6_TRACK_ENABLE);
+	/* enable auto break */
+	aw86927_i2c_read(aw86927, AW86927_REG_PLAYCFG3, &reg_val);
+	brk_en_default = 0x04 & reg_val;
+	aw86927_haptic_auto_break_mode(aw86927, true);
+
+	/* f0 driver level */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG6,
+			       AW86927_BIT_CONTCFG6_DRV1_LVL_MASK,
+			       aw86927->info.cont_drv1_lvl);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG7,
+			  aw86927->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG8,
+			  aw86927->info.cont_drv1_time);
+	/* DRV2_TIME */
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG9,
+			  aw86927->info.cont_drv2_time);
+	/* TRACK_MARGIN */
+	if (!aw86927->info.cont_track_margin) {
+		aw_err("%s aw86927->info.cont_track_margin = 0!\n", __func__);
+	} else {
+		aw86927_i2c_write(
+			aw86927, AW86927_REG_CONTCFG11,
+			(unsigned char)aw86927->info.cont_track_margin);
+	}
+	/* DRV_WIDTH */
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG3,
+			  aw86927->info.cont_drv_width);
+
+	/* cont play go */
+	aw86927_haptic_play_go(aw86927);
+	usleep_range(20000, 20500);
+	/* 300ms */
+	ret = aw86927_haptic_wait_enter_standby(aw86927, 1000);
+	if (!ret) {
+		aw86927_haptic_read_lra_f0(aw86927);
+		aw86927_haptic_read_cont_f0(aw86927);
+	} else {
+		aw_err("%s enter standby mode failed, stop reading f0!\n",
+		       __func__);
+	}
+	/* restore d2s_gain config */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG2,
+			       AW86927_BIT_DETCFG2_D2S_GAIN_MASK,
+			       d2s_gain_default);
+	/* restore default config */
+	aw86927_haptic_f0_detect(aw86927, false);
+	/* recover auto break config */
+	if (brk_en_default)
+		aw86927_haptic_auto_break_mode(aw86927, true);
+	else
+		aw86927_haptic_auto_break_mode(aw86927, false);
+
+	return ret;
+}
+
+static void aw86927_haptic_upload_lra(struct aw86927 *aw86927,
+				      unsigned int flag)
+{
+	unsigned char reg_val;
+
+	aw_dbg("%s enter!\n", __func__);
+
+	/* Unlock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_UNLOCK);
+	switch (flag) {
+	case AW86927_WRITE_ZERO:
+		aw_info("%s write zero to trim_lra!\n", __func__);
+		reg_val = 0x00;
+		break;
+	case AW86927_F0_CALI:
+		aw_info("%s write f0_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw86927->f0_calib_data);
+		reg_val = (char)aw86927->f0_calib_data &
+			  AW86927_BIT_ANACFG20_TRIM_LRA;
+		break;
+	case AW86927_OSC_CALI:
+		aw_info("%s write lra_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw86927->lra_calib_data);
+		reg_val = (char)aw86927->lra_calib_data &
+			  AW86927_BIT_ANACFG20_TRIM_LRA;
+		break;
+	default:
+		reg_val = 0x00;
+		break;
+	}
+	aw86927_i2c_write(aw86927, AW86927_REG_ANACFG20, reg_val);
+	/* Lock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_LOCK);
+}
+
+static unsigned char aw86927_haptic_osc_read_status(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSST2, &reg_val);
+	return reg_val;
+}
+
+static unsigned int aw86927_haptic_get_theory_time(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSCTRL4, &reg_val);
+	fre_val = (reg_val & 0x03) >> 5;
+
+	if (fre_val == 2 || fre_val == 3)
+		theory_time = (aw86927->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 0)
+		theory_time = (aw86927->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1)
+		theory_time = (aw86927->rtp_len / 48000) * 1000000; /*48K */
+	return theory_time;
+}
+
+static int aw86927_haptic_get_vbat(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+	unsigned int vbat_code = 0;
+
+	aw_info("%s enter!\n", __func__);
+	aw86927_haptic_stop(aw86927);
+	aw86927_haptic_raminit(aw86927, true);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG2,
+			       AW86927_BIT_DETCFG2_DET_SEQ0_MASK,
+			       AW86927_BIT_DETCFG2_DET_SEQ0_VBAT);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_DET_GO_MASK,
+			       AW86927_BIT_DETCFG1_DET_GO_DET_SEQ0);
+	usleep_range(3000, 3500);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_DET_GO_MASK,
+			       AW86927_BIT_DETCFG1_DET_GO_NA);
+
+	aw86927_i2c_read(aw86927, AW86927_REG_DETRD1, &reg_val);
+	vbat_code = ((reg_val & 0x03) * 256);
+	aw86927_i2c_read(aw86927, AW86927_REG_DETRD2, &reg_val);
+	vbat_code = vbat_code + reg_val;
+	aw86927->vbat = 5 * 1215 * vbat_code / 1024;
+	if (aw86927->vbat > AW_VBAT_MAX) {
+		aw86927->vbat = AW_VBAT_MAX;
+		aw_info("%s vbat max limit = %dmV\n", __func__, aw86927->vbat);
+	}
+	if (aw86927->vbat < AW_VBAT_MIN) {
+		aw86927->vbat = AW_VBAT_MIN;
+		aw_info("%s vbat min limit = %dmV\n", __func__, aw86927->vbat);
+	}
+	aw_info("%s aw86927->vbat=%dmV, vbat_code=0x%02X\n", __func__,
+		aw86927->vbat, vbat_code);
+	aw86927_haptic_raminit(aw86927, false);
+	return 0;
+}
+
+static int aw86927_select_d2s_gain(struct aw86927 *aw86927, unsigned char reg)
+{
+	int d2s_gain = 0;
+
+	switch (reg) {
+	case AW86927_BIT_DETCFG2_D2S_GAIN_1:
+		d2s_gain = 1;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_2:
+		d2s_gain = 2;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_4:
+		d2s_gain = 4;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_8:
+		d2s_gain = 8;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_10:
+		d2s_gain = 10;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_16:
+		d2s_gain = 16;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_20:
+		d2s_gain = 20;
+		break;
+	case AW86927_BIT_DETCFG2_D2S_GAIN_40:
+		d2s_gain = 40;
+		break;
+	default:
+		d2s_gain = -1;
+		break;
+	}
+	return d2s_gain;
+}
+
+static int aw86927_haptic_get_lra_resistance(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+	unsigned char adc_fs_default = 0;
+	unsigned int lra_code = 0;
+	unsigned char d2s_gain = 0;
+
+	aw_info("%s enter!\n", __func__);
+	aw86927_haptic_raminit(aw86927, true);
+	aw86927_haptic_stop(aw86927);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG2,
+			       AW86927_BIT_DETCFG2_DET_SEQ0_MASK,
+			       AW86927_BIT_DETCFG2_DET_SEQ0_RL);
+	aw86927_i2c_read(aw86927, AW86927_REG_DETCFG1, &reg_val);
+	adc_fs_default = reg_val & 0x0C;
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_ADC_FS_MASK,
+			       AW86927_BIT_DETCFG1_ADC_FS_96KHZ);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_DET_GO_MASK,
+			       AW86927_BIT_DETCFG1_DET_GO_DET_SEQ0);
+	usleep_range(3000, 3500);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_DET_GO_MASK,
+			       AW86927_BIT_DETCFG1_DET_GO_NA);
+	/* restore default config*/
+	aw86927_haptic_raminit(aw86927, false);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG1,
+			       AW86927_BIT_DETCFG1_ADC_FS_MASK, adc_fs_default);
+	aw86927_i2c_read(aw86927, AW86927_REG_DETCFG2, &reg_val);
+	reg_val &= 0x07;
+	d2s_gain = aw86927_select_d2s_gain(aw86927, reg_val);
+	if (d2s_gain < 0) {
+		aw_err("%s d2s_gain is error\n", __func__);
+		return -ERANGE;
+	}
+	aw86927_i2c_read(aw86927, AW86927_REG_DETRD1, &reg_val);
+	lra_code = ((reg_val & 0x03) * 256);
+	aw86927_i2c_read(aw86927, AW86927_REG_DETRD2, &reg_val);
+	lra_code = lra_code + reg_val;
+	aw86927->lra = (6075 * 100 * lra_code) / (1024 * d2s_gain);
+	return 0;
+}
+
+void aw86927_vibrate_params_init(struct aw86927 *aw86927)
+{
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter!\n", __func__);
+	aw86927->activate_mode = aw86927->info.mode;
+	aw86927->ram_vbat_comp = AW86927_RAM_VBAT_COMP_ENABLE;
+	aw86927_i2c_read(aw86927, AW86927_REG_WAVCFG1, &reg_val);
+	aw86927->index = reg_val & 0x7F;
+	aw86927_i2c_read(aw86927, AW86927_REG_PLAYCFG2, &reg_val);
+	aw86927->gain = reg_val & 0xFF;
+	aw_info("%s aw86927->gain =0x%02X\n", __func__, aw86927->gain);
+	aw86927_i2c_read(aw86927, AW86927_REG_PLAYCFG1, &reg_val);
+	if (aw86927->info.bst_vol_default > 0)
+		aw86927->vmax = aw86927->info.bst_vol_default;
+	else
+		aw86927->vmax = reg_val & AW86927_BIT_PLAYCFG1_BST_VOUT_VREFSET;
+
+	for (i = 0; i < AW86927_SEQUENCER_SIZE; i++) {
+		aw86927_i2c_read(aw86927, AW86927_REG_WAVCFG1 + i, &reg_val);
+		aw86927->seq[i] = reg_val;
+	}
+}
+
+static enum hrtimer_restart qti_hap_stop_timer(struct hrtimer *timer)
+{
+	struct aw86927 *aw86927 =
+		container_of(timer, struct aw86927, stop_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	aw86927->play.length_us = 0;
+	rc = aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG4,
+			       AW86927_BIT_PLAYCFG4_STOP_ON);
+	if (rc < 0)
+		aw_err("Stop playing failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart qti_hap_disable_timer(struct hrtimer *timer)
+{
+	struct aw86927 *aw86927 =
+		container_of(timer, struct aw86927, hap_disable_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	rc = aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG4,
+			       AW86927_BIT_PLAYCFG4_STOP_ON);
+	if (rc < 0)
+		aw_err("Disable haptics module failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw86927_haptic_misc_para_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter!\n", __func__);
+
+	aw86927->f0_cali_status = true;
+	aw86927->rtp_routine_on = 0;
+	aw86927->rtp_num_max = awinic_rtp_name_len;
+	hrtimer_init(&aw86927->stop_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw86927->stop_timer.function = qti_hap_stop_timer;
+	hrtimer_init(&aw86927->hap_disable_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw86927->hap_disable_timer.function = qti_hap_disable_timer;
+	/* Unlock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_UNLOCK);
+
+	aw86927_i2c_write(aw86927, AW86927_REG_SYSCTRL5,
+			  AW86927_BIR_SYSCTRL5_INIT_VAL);
+
+	/* Close boost skip */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_ANACFG12,
+			       AW86927_BIT_ANACFG12_BST_SKIP_MASK,
+			       AW86927_BIT_ANACFG12_BST_SKIP_SHUTDOWN);
+
+	/* Open adaptive ipeak current limiting */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_ANACFG15,
+			       AW86927_BIT_ANACFG15_BST_PEAK_MODE_MASK,
+			       AW86927_BIT_ANACFG15_BST_PEAK_BACK);
+
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_ANACFG16,
+			       AW86927_BIT_ANACFG16_BST_SRC_MASK,
+			       AW86927_BIT_ANACFG16_BST_SRC_3NS);
+
+	aw86927_i2c_write(aw86927, AW86927_REG_PWMCFG1,
+			  AW86927_BIT_PWMCFG1_INIT_VAL);
+
+	/* brk_bst_md */
+	if (!aw86927->info.brk_bst_md)
+		aw_err("%s aw86927->info.brk_bst_md = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG1,
+			       AW86927_BIT_CONTCFG1_BRK_BST_MD_MASK,
+			       (aw86927->info.brk_bst_md << 6));
+	/* cont_brk_time */
+	if (!aw86927->info.cont_brk_time)
+		aw_err("%s aw86927->info.cont_brk_time = 0!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_CONTCFG10,
+			  aw86927->info.cont_brk_time);
+	/* cont_tset */
+	if (!aw86927->info.cont_tset)
+		aw_err("%s aw86927->info.cont_tset = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG13,
+			       AW86927_BIT_CONTCFG13_TSET_MASK,
+			       (aw86927->info.cont_tset << 4));
+	/* cont_bemf_set */
+	if (!aw86927->info.cont_bemf_set)
+		aw_err("%s aw86927->info.cont_bemf_set = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG13,
+			       AW86927_BIT_CONTCFG13_BEME_SET_MASK,
+			       aw86927->info.cont_bemf_set);
+	/* cont_bst_brk_gain */
+	if (!aw86927->info.cont_bst_brk_gain)
+		aw_err("%s aw86927->info.cont_bst_brk_gain = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG5,
+			       AW86927_BIT_CONTCFG5_BST_BRK_GAIN_MASK,
+			       aw86927->info.cont_bst_brk_gain << 4);
+	/* cont_brk_gain */
+	if (!aw86927->info.cont_brk_gain)
+		aw_err("%s aw86927->info.cont_brk_gain = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_CONTCFG5,
+			       AW86927_BIT_CONTCFG5_BRK_GAIN_MASK,
+			       aw86927->info.cont_brk_gain);
+	/* d2s_gain */
+	if (!aw86927->info.d2s_gain)
+		aw_err("%s aw86927->info.d2s_gain = 0!\n", __func__);
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_DETCFG2,
+			       AW86927_BIT_DETCFG2_D2S_GAIN_MASK,
+			       aw86927->info.d2s_gain);
+	/* Lock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_LOCK);
+	/* GAIN_BYPASS config */
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+			       AW86927_BIT_SYSCTRL4_GAIN_BYPASS_MASK,
+			       AW86927_BIT_SYSCTRL4_GAIN_CHANGEABLE);
+}
+
+static int aw86927_haptic_set_bst_peak_cur(struct aw86927 *aw86927,
+					   unsigned char peak_cur)
+{
+	aw_info("%s enter!\n", __func__);
+
+	/* Unlock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_UNLOCK);
+	if (peak_cur > AW86927_BSTCFG_PEAKCUR_LIMIT)
+		peak_cur = AW86927_BSTCFG_PEAKCUR_LIMIT;
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_ANACFG13,
+			       AW86927_BIT_ANACFG13_PEAKCUR_MASK, peak_cur);
+	/* Lock register */
+	aw86927_i2c_write(aw86927, AW86927_REG_TMCFG,
+			  AW86927_BIT_TMCFG_TM_LOCK);
+
+	return 0;
+}
+
+static int aw86927_haptic_vbat_mode_config(struct aw86927 *aw86927,
+					   unsigned char flag)
+{
+	aw_info("%s enter!\n", __func__);
+	if (flag == AW86927_VBAT_HW_ADJUST_MODE) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_VBATCTRL,
+				       AW86927_BIT_VBATCTRL_VBAT_MODE_MASK,
+				       AW86927_BIT_VBATCTRL_VBAT_MODE_HW);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_VBATCTRL,
+				       AW86927_BIT_VBATCTRL_VBAT_MODE_MASK,
+				       AW86927_BIT_VBATCTRL_VBAT_MODE_SW);
+	}
+	return 0;
+}
+
+static int aw86927_trig_config(struct aw86927 *aw86927)
+{
+	aw86927_haptic_trig1_param_init(aw86927);
+	aw86927_haptic_trig1_param_config(aw86927);
+	aw86927_haptic_trig2_param_init(aw86927);
+	aw86927_haptic_trig3_param_init(aw86927);
+	aw86927_haptic_trig2_param_config(aw86927);
+	aw86927_haptic_trig3_param_config(aw86927);
+	return 0;
+}
+
+static void aw86927_haptic_bst_mode_config(struct aw86927 *aw86927,
+					   unsigned char mode)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927->bst_mode = mode;
+	switch (mode) {
+	case AW86927_BST_MODE:
+		aw_info("%s haptic bst mode = bst\n", __func__);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG1,
+				       AW86927_BIT_PLAYCFG1_BST_MODE_MASK,
+				       AW86927_BIT_PLAYCFG1_BST_MODE);
+		break;
+	case AW86927_BST_MODE_BYPASS:
+		aw_info("%s haptic bst mode = bypass\n", __func__);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG1,
+				       AW86927_BIT_PLAYCFG1_BST_MODE_MASK,
+				       AW86927_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		break;
+	default:
+		aw_err("%s: bst = %d error", __func__, mode);
+		break;
+	}
+}
+
+static int aw86927_haptic_set_bst_vol(struct aw86927 *aw86927,
+				      unsigned char bst_vol)
+{
+	aw_dbg("%s enter!\n", __func__);
+	if (bst_vol > AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V)
+		bst_vol = AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V;
+	if (bst_vol < AW86927_BIT_PLAYCFG1_BST_VOUT_6V)
+		bst_vol = AW86927_BIT_PLAYCFG1_BST_VOUT_6V;
+	aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG1,
+			       AW86927_BIT_PLAYCFG1_BST_VOUT_VREFSET_MASK,
+			       bst_vol);
+	return 0;
+}
+
+static int aw86927_haptic_set_pwm(struct aw86927 *aw86927, unsigned char mode)
+{
+	aw_info("%s enter!\n", __func__);
+	switch (mode) {
+	case AW86927_PWM_48K:
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_MODE_MASK,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_48K);
+		break;
+	case AW86927_PWM_24K:
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_MODE_MASK,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_24K);
+		break;
+	case AW86927_PWM_12K:
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_SYSCTRL4,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_MODE_MASK,
+				       AW86927_BIT_SYSCTRL4_WAVDAT_12K);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int aw86927_haptic_swicth_motor_protect_config(struct aw86927 *aw86927,
+						      unsigned char addr,
+						      unsigned char val)
+{
+	aw_info("%s enter\n", __func__);
+	if (addr == 1) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG2,
+				       AW86927_BIT_PWMCFG2_PRCT_MODE_MASK,
+				       AW86927_BIT_PWMCFG2_PRCT_MODE_VALID);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG1,
+				       AW86927_BIT_PWMCFG1_PRC_EN_MASK,
+				       AW86927_BIT_PWMCFG1_PRC_ENABLE);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG3,
+				       AW86927_BIT_PWMCFG3_PR_EN_MASK,
+				       AW86927_BIT_PWMCFG3_PR_ENABLE);
+	} else if (addr == 0) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG2,
+				       AW86927_BIT_PWMCFG2_PRCT_MODE_MASK,
+				       AW86927_BIT_PWMCFG2_PRCT_MODE_INVALID);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG1,
+				       AW86927_BIT_PWMCFG1_PRC_EN_MASK,
+				       AW86927_BIT_PWMCFG1_PRC_DISABLE);
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG3,
+				       AW86927_BIT_PWMCFG3_PR_EN_MASK,
+				       AW86927_BIT_PWMCFG3_PR_DISABLE);
+	} else if (addr == AW86927_REG_PWMCFG1) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG1,
+				       AW86927_BIT_PWMCFG1_PRCTIME_MASK, val);
+	} else if (addr == AW86927_REG_PWMCFG3) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PWMCFG3,
+				       AW86927_BIT_PWMCFG3_PRLVL_MASK, val);
+	} else if (addr == AW86927_REG_PWMCFG4) {
+		aw86927_i2c_write(aw86927, AW86927_REG_PWMCFG4, val);
+	}
+	return 0;
+}
+
+static int aw86927_get_prctmode(struct aw86927 *aw86927)
+{
+	unsigned char reg_val = 0;
+	int prctmode = 0;
+
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_PWMCFG2, &reg_val);
+	prctmode = (int)(reg_val & 0x08);
+
+	return prctmode;
+}
+
+static int aw86927_haptic_auto_bst_enable(struct aw86927 *aw86927,
+					  unsigned char flag)
+{
+	aw86927->auto_boost = flag;
+
+	aw_info("%s enter\n", __func__);
+	if (flag) {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_AUTO_BST_MASK,
+				       AW86927_BIT_PLAYCFG3_AUTO_BST_ENABLE);
+	} else {
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_AUTO_BST_MASK,
+				       AW86927_BIT_PLAYCFG3_AUTO_BST_DISABLE);
+	}
+	return 0;
+}
+
+static void aw86927_haptic_set_gain(struct aw86927 *aw86927, unsigned char gain)
+{
+	unsigned char comp_gain = 0;
+
+	aw_dbg("%s enter!\n", __func__);
+	if (aw86927->ram_vbat_comp == AW86927_RAM_VBAT_COMP_ENABLE) {
+		aw86927_haptic_get_vbat(aw86927);
+		comp_gain = gain * AW_VBAT_REFER / aw86927->vbat;
+		if (comp_gain > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			comp_gain = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_dbg("%s comp gain limit is %d\n", __func__,
+			       comp_gain);
+		}
+		aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG2, comp_gain);
+	} else {
+		aw_dbg("%s: disable compsensation, vbat=%d, vbat_min=%d, vbat_ref=%d",
+		       __func__, aw86927->vbat, AW_VBAT_MIN, AW_VBAT_REFER);
+		aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG2, gain);
+	}
+}
+
+static int aw86927_haptic_set_wav_seq(struct aw86927 *aw86927,
+				      unsigned char wav, unsigned char seq)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_WAVCFG1 + wav, seq);
+	return 0;
+}
+
+static int aw86927_haptic_get_wav_seq(struct aw86927 *aw86927,
+				      unsigned char wav, unsigned char *seq)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_WAVCFG1 + wav, seq);
+	return 0;
+}
+
+static int aw86927_haptic_set_wav_loop(struct aw86927 *aw86927,
+				       unsigned char wav, unsigned char loop)
+{
+	unsigned char tmp = 0;
+
+	aw_info("%s enter!\n", __func__);
+	if (wav % 2) {
+		tmp = loop << 0;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_WAVCFG9 + (wav / 2),
+				       AW86927_BIT_WAVLOOP_SEQ_EVEN_MASK, tmp);
+	} else {
+		tmp = loop << 4;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_WAVCFG9 + (wav / 2),
+				       AW86927_BIT_WAVLOOP_SEQ_ODD_MASK, tmp);
+	}
+	return 0;
+}
+
+static int aw86927_haptic_get_wav_loop(struct aw86927 *aw86927,
+				       unsigned char wav, unsigned char *loop)
+{
+	unsigned char tmp = 0;
+
+	aw_info("%s enter!\n", __func__);
+	if (wav % 2) {
+		aw86927_i2c_read(aw86927, AW86927_REG_WAVCFG9 + (wav / 2),
+				 &tmp);
+		*loop = (tmp >> 0) & 0x0F;
+	} else {
+		aw86927_i2c_read(aw86927, AW86927_REG_WAVCFG9 + (wav / 2),
+				 &tmp);
+		*loop = (tmp >> 4) & 0x0F;
+	}
+
+	return 0;
+}
+
+static int aw86927_haptic_get_glb_state(struct aw86927 *aw86927,
+					unsigned char *state)
+{
+	aw_dbg("%s enter!\n", __func__);
+	aw86927_i2c_read(aw86927, AW86927_REG_GLBRD5, state);
+	return 0;
+}
+
+static void aw86927_haptic_play_go(struct aw86927 *aw86927)
+{
+	aw_dbg("%s enter!\n", __func__);
+	aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG4,
+			  AW86927_BIT_PLAYCFG4_GO_ON);
+}
+
+static void aw86927_haptic_set_repeat_wav_seq(struct aw86927 *aw86927,
+					      unsigned char seq)
+{
+	aw_info("%s enter!\n", __func__);
+	aw86927_haptic_set_wav_seq(aw86927, 0x00, seq);
+	aw86927_haptic_set_wav_loop(aw86927, 0x00,
+				    AW86927_BIT_WAVLOOP_INIFINITELY);
+}
+
+static int aw86927_haptic_play_mode(struct aw86927 *aw86927,
+				    unsigned char play_mode)
+{
+	aw_dbg("%s enter!\n", __func__);
+
+	switch (play_mode) {
+	case AW86927_STANDBY_MODE:
+		aw_info("%s: enter standby mode\n", __func__);
+		aw86927->play_mode = AW86927_STANDBY_MODE;
+		aw86927_haptic_stop(aw86927);
+		break;
+	case AW86927_RAM_MODE:
+		aw_info("%s: enter ram mode\n", __func__);
+		aw86927->play_mode = AW86927_RAM_MODE;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		/* bst mode */
+		aw86927_haptic_bst_mode_config(aw86927, AW86927_BST_MODE);
+		break;
+	case AW86927_RAM_LOOP_MODE:
+		aw_info("%s: enter ram loop mode\n", __func__);
+		aw86927->play_mode = AW86927_RAM_LOOP_MODE;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		/* bst mode */
+		aw86927_haptic_bst_mode_config(aw86927,
+					       AW86927_BST_MODE_BYPASS);
+		break;
+	case AW86927_RTP_MODE:
+		aw_info("%s: enter rtp mode\n", __func__);
+		aw86927->play_mode = AW86927_RTP_MODE;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_RTP);
+		/* bst mode */
+		aw86927_haptic_bst_mode_config(aw86927, AW86927_BST_MODE);
+		break;
+	case AW86927_TRIG_MODE:
+		aw_info("%s: enter trig mode\n", __func__);
+		aw86927->play_mode = AW86927_TRIG_MODE;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		break;
+	case AW86927_CONT_MODE:
+		aw_info("%s: enter cont mode\n", __func__);
+		aw86927->play_mode = AW86927_CONT_MODE;
+		aw86927_i2c_write_bits(aw86927, AW86927_REG_PLAYCFG3,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				       AW86927_BIT_PLAYCFG3_PLAY_MODE_CONT);
+		/* bst mode */
+		aw86927_haptic_bst_mode_config(aw86927,
+					       AW86927_BST_MODE_BYPASS);
+		break;
+	default:
+		aw_err("%s: play mode %d error", __func__, play_mode);
+		break;
+	}
+	return 0;
+}
+
+static int aw86927_haptic_stop(struct aw86927 *aw86927)
+{
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+	aw86927->play_mode = AW86927_STANDBY_MODE;
+
+	aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG4,
+			  AW86927_BIT_PLAYCFG4_STOP_ON);
+	ret = aw86927_haptic_wait_enter_standby(aw86927, 40);
+
+	if (ret < 0) {
+		aw_err("%s force to enter standby mode!\n", __func__);
+		aw86927_force_enter_standby(aw86927);
+	}
+	return 0;
+}
+
+static int aw86927_haptic_get_ram_number(struct aw86927 *aw86927)
+{
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char ram_data[3];
+	unsigned int first_wave_addr = 0;
+
+	aw_info("%s enter!\n", __func__);
+	if (!aw86927->ram_init) {
+		aw_err("%s: ram init faild, ram_num = 0!\n", __func__);
+		return -EPERM;
+	}
+
+	mutex_lock(&aw86927->lock);
+	/* RAMINIT Enable */
+	aw86927_haptic_raminit(aw86927, true);
+	aw86927_haptic_stop(aw86927);
+	aw86927_set_base_addr(aw86927);
+	for (i = 0; i < 3; i++) {
+		aw86927_read_ram_data(aw86927, &reg_val);
+		ram_data[i] = reg_val;
+	}
+	first_wave_addr = (ram_data[1] << 8 | ram_data[2]);
+	aw86927->ram.ram_num =
+		(first_wave_addr - aw86927->ram.base_addr - 1) / 4;
+	aw_info("%s: ram_version = 0x%02x\n", __func__, ram_data[0]);
+	aw_info("%s: first waveform addr = 0x%04x\n", __func__,
+		first_wave_addr);
+	aw_info("%s: ram_num = %d\n", __func__, aw86927->ram.ram_num);
+	/* RAMINIT Disable */
+	aw86927_haptic_raminit(aw86927, false);
+	mutex_unlock(&aw86927->lock);
+
+	return 0;
+}
+
+static int aw86927_haptic_get_rtp_data(struct aw86927 *aw86927)
+{
+	const struct firmware *rtp_file;
+	int ret = 0;
+
+	aw_info("%s enter!\n", __func__);
+	ret = request_firmware(&rtp_file, awinic_rtp_name[0], aw86927->dev);
+	if (ret < 0) {
+		aw_err("%s: failed to read %s\n", __func__, awinic_rtp_name[0]);
+		return ret;
+	}
+
+	aw86927_haptic_stop(aw86927);
+
+	mutex_lock(&aw86927->rtp_lock);
+	vfree(aw86927_rtp);
+	aw86927_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw86927_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw86927->rtp_lock);
+		aw_err("%s: error allocating memory\n", __func__);
+		return -ERANGE;
+	}
+	aw86927_rtp->len = rtp_file->size;
+	aw86927->rtp_len = rtp_file->size;
+	aw_info("%s: rtp file:[%s] size = %dbytes\n", __func__,
+		awinic_rtp_name[0], aw86927_rtp->len);
+
+	memcpy(aw86927_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw86927->rtp_lock);
+	return 0;
+}
+
+static int aw86927_rtp_osc_calibration(struct aw86927 *aw86927)
+{
+	int ret = -1;
+	unsigned char osc_int_state = 0;
+	unsigned int buf_len = 0;
+
+	aw86927->rtp_cnt = 0;
+	aw86927->timeval_flags = 1;
+
+	aw_info("%s enter\n", __func__);
+	ret = aw86927_haptic_get_rtp_data(aw86927);
+	if (ret < 0)
+		return ret;
+	/* gain */
+	aw86927_haptic_ram_vbat_comp(aw86927, false);
+	/* rtp mode config */
+	aw86927_haptic_play_mode(aw86927, AW86927_RTP_MODE);
+	/* bst mode */
+	aw86927_haptic_bst_mode_config(aw86927, AW86927_BST_MODE_BYPASS);
+	disable_irq(gpio_to_irq(aw86927->irq_gpio));
+
+	/* haptic go */
+	aw86927_haptic_play_go(aw86927);
+	/* require latency of CPU & DMA not more then PM_QOS_VALUE_VB us */
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw86927_haptic_rtp_get_fifo_afs(aw86927)) {
+			mutex_lock(&aw86927->rtp_lock);
+			if ((aw86927_rtp->len - aw86927->rtp_cnt) <
+			    (aw86927->ram.base_addr >> 2))
+				buf_len = aw86927_rtp->len - aw86927->rtp_cnt;
+			else
+				buf_len = (aw86927->ram.base_addr >> 2);
+			if (aw86927->rtp_cnt != aw86927_rtp->len) {
+				if (aw86927->timeval_flags == 1) {
+					aw86927->kstart = ktime_get();
+					aw86927->timeval_flags = 0;
+				}
+				aw86927_write_rtp_data(
+					aw86927,
+					&aw86927_rtp->data[aw86927->rtp_cnt],
+					buf_len);
+				aw86927->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw86927->rtp_lock);
+		}
+		osc_int_state = aw86927_haptic_osc_read_status(aw86927);
+		if (osc_int_state & AW86927_BIT_SYSINT_DONEI) {
+			aw86927->kend = ktime_get();
+			aw_info("%s osc trim playback done aw86927->rtp_cnt= %d\n",
+				__func__, aw86927->rtp_cnt);
+			break;
+		}
+
+		aw86927->kend = ktime_get();
+		aw86927->microsecond =
+			ktime_to_us(ktime_sub(aw86927->kend, aw86927->kstart));
+		if (aw86927->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			aw_info("%s osc trim time out! aw86927->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw86927->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw86927->irq_gpio));
+
+	aw86927->microsecond =
+		ktime_to_us(ktime_sub(aw86927->kend, aw86927->kstart));
+	/*calibration osc */
+	aw_info("%s aw86927_microsecond: %ld\n", __func__,
+		aw86927->microsecond);
+	aw_info("%s exit\n", __func__);
+	return 0;
+}
+
+static int aw86927_osc_trim_calculation(struct aw86927 *aw86927,
+					unsigned long int theory_time,
+					unsigned long int real_time)
+{
+	unsigned int real_code = 0;
+	unsigned int lra_code = 0;
+	unsigned int DFT_LRA_TRIM_CODE = 0;
+	/*0.1 percent below no need to calibrate */
+	unsigned int osc_cali_threshold = 10;
+
+	aw_info("%s enter\n", __func__);
+	if (theory_time == real_time) {
+		aw_info("%s theory_time == real_time: %ld, no need to calibrate!\n",
+			__func__, real_time);
+		return 0;
+	} else if (theory_time < real_time) {
+		if ((real_time - theory_time) > (theory_time / 50)) {
+			aw_info("%s (real_time - theory_time) > (theory_time/50), can't calibrate!\n",
+				__func__);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		if ((real_time - theory_time) <
+		    (osc_cali_threshold * theory_time / 10000)) {
+			aw_info("%s real_time: %ld, theory_time: %ld, no need to calibrate!\n",
+				__func__, real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		real_code = ((real_time - theory_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 + real_code;
+	} else if (theory_time > real_time) {
+		if ((theory_time - real_time) > (theory_time / 50)) {
+			aw_info("%s (theory_time - real_time) > (theory_time / 50), can't calibrate!\n",
+				__func__);
+			return DFT_LRA_TRIM_CODE;
+		}
+		if ((theory_time - real_time) <
+		    (osc_cali_threshold * theory_time / 10000)) {
+			aw_info("%s real_time: %ld, theory_time: %ld, no need to calibrate!\n",
+				__func__, real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+		real_code =
+			(theory_time - real_time) / (theory_time / 100000) / 24;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 - real_code;
+	}
+	if (real_code > 31)
+		lra_code = real_code - 32;
+	else
+		lra_code = real_code + 32;
+	aw_info("%s real_time: %ld, theory_time: %ld\n", __func__, real_time,
+		theory_time);
+	aw_info("%s real_code: %02X, trim_lra: 0x%02X\n", __func__, real_code,
+		lra_code);
+	return lra_code;
+}
+
+static void aw86927_calculate_cali_step(struct aw86927 *aw86927)
+{
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter!\n", __func__);
+	f0_cali_step = 100000 * ((int)aw86927->f0 - (int)aw86927->info.f0_pre) /
+		       ((int)aw86927->f0 * 24);
+	aw_info("%s f0_cali_step = %d\n", __func__, f0_cali_step);
+
+	if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+		if (f0_cali_step % 10 >= 5)
+			f0_cali_step = 32 + (f0_cali_step / 10 + 1);
+		else
+			f0_cali_step = 32 + f0_cali_step / 10;
+	} else { /* f0_cali_step < 0 */
+		if (f0_cali_step % 10 <= -5)
+			f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+		else
+			f0_cali_step = 32 + f0_cali_step / 10;
+	}
+	if (f0_cali_step > 31)
+		f0_cali_lra = (char)f0_cali_step - 32;
+	else
+		f0_cali_lra = (char)f0_cali_step + 32;
+
+	aw86927->f0_calib_data = (int)f0_cali_lra;
+	aw_info("%s origin trim_lra = 0x%02X, f0_cali_lra = 0x%02X, final f0_calib_data = 0x%02X\n",
+		__func__, (reg_val & 0x3f), f0_cali_lra,
+		aw86927->f0_calib_data);
+}
+
+static int aw86927_rtp_trim_lra_calibration(struct aw86927 *aw86927)
+{
+	unsigned int theory_time = 0;
+	unsigned int lra_trim_code = 0;
+
+	aw_info("%s enter!\n", __func__);
+	theory_time = aw86927_haptic_get_theory_time(aw86927);
+
+	aw_info("%s microsecond:%ld  theory_time = %d\n", __func__,
+		aw86927->microsecond, theory_time);
+
+	lra_trim_code = aw86927_osc_trim_calculation(aw86927, theory_time,
+						     aw86927->microsecond);
+	if (lra_trim_code >= 0) {
+		aw86927->lra_calib_data = lra_trim_code;
+		aw86927_haptic_upload_lra(aw86927, AW86927_OSC_CALI);
+	}
+	return 0;
+}
+
+static int aw86927_haptic_is_within_cali_range(struct aw86927 *aw86927)
+{
+	unsigned int f0_cali_min = 0;
+	unsigned int f0_cali_max = 0;
+	int ret = 0;
+
+	aw_info("%s enter!\n", __func__);
+	f0_cali_min = aw86927->info.f0_pre *
+		      (100 - aw86927->info.f0_cali_percen) / 100;
+	f0_cali_max = aw86927->info.f0_pre *
+		      (100 + aw86927->info.f0_cali_percen) / 100;
+
+	aw_info("%s f0_pre = %d, f0_cali_min = %d, f0_cali_max = %d, f0 = %d\n",
+		__func__, aw86927->info.f0_pre, f0_cali_min, f0_cali_max,
+		aw86927->f0);
+
+	if ((aw86927->f0 < f0_cali_min) || aw86927->f0 > f0_cali_max) {
+		aw_err("%s f0 calibration out of range = %d!\n", __func__,
+		       aw86927->f0);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int aw86927_haptic_f0_calibration(struct aw86927 *aw86927)
+{
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	if (aw86927_haptic_cont_get_f0(aw86927)) {
+		aw_err("%s get f0 error, user defafult f0\n", __func__);
+	} else {
+		/* max and min limit */
+		ret = aw86927_haptic_is_within_cali_range(aw86927);
+		if (ret < 0)
+			return -ERANGE;
+		/* calculate cali step */
+		aw86927_calculate_cali_step(aw86927);
+	}
+	aw86927_haptic_upload_lra(aw86927, AW86927_F0_CALI);
+	/* restore standby work mode */
+	aw86927_haptic_stop(aw86927);
+	return ret;
+}
+
+/******************************************************
+ *
+ * sysfs attr
+ *
+ ******************************************************/
+static ssize_t aw86927_effect_id_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "effect_id =%d\n", aw86927->effect_id);
+}
+
+static ssize_t aw86927_effect_id_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86927->lock);
+	aw86927->effect_id = val;
+	aw86927->play.vmax_mv = AW86927_MEDIUM_MAGNITUDE;
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_f0_check_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	if (aw86927->f0_cali_status == true)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 1);
+	if (aw86927->f0_cali_status == false)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 0);
+
+	return len;
+}
+
+static ssize_t aw86927_f0_value_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw86927->f0);
+}
+
+/* return buffer size and availbe size */
+static ssize_t aw86927_custom_wave_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "period_size=%d;",
+			aw86927->ram.base_addr >> 2);
+	len += snprintf(buf + len, PAGE_SIZE - len, "max_size=%d;free_size=%d;",
+			get_rb_max_size(), get_rb_free_size());
+	len += snprintf(buf + len, PAGE_SIZE - len, "custom_wave_id=%d;",
+			CUSTOME_WAVE_ID);
+	return len;
+}
+
+static ssize_t aw86927_custom_wave_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned long buf_len, period_size, offset;
+	int ret;
+
+	period_size = (aw86927->ram.base_addr >> 2);
+	offset = 0;
+
+	aw_dbg("%swrite szie %zd, period size %lu", __func__, count,
+	       period_size);
+	if (count % period_size || count < period_size)
+		rb_end();
+	atomic_set(&aw86927->is_in_write_loop, 1);
+
+	while (count > 0) {
+		buf_len = MIN(count, period_size);
+		ret = write_rb(buf + offset, buf_len);
+		if (ret < 0)
+			goto exit;
+		count -= buf_len;
+		offset += buf_len;
+	}
+	ret = offset;
+exit:
+	atomic_set(&aw86927->is_in_write_loop, 0);
+	wake_up_interruptible(&aw86927->stop_wait_q);
+	aw_dbg(" return size %d", ret);
+	return ret;
+}
+
+static ssize_t aw86927_bst_vol_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"bst_vol_ram=%d, bst_vol_rtp=%d\n",
+			aw86927->info.bst_vol_ram, aw86927->info.bst_vol_rtp);
+	return len;
+}
+
+static ssize_t aw86927_bst_vol_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%d %d", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] < AW86927_BIT_PLAYCFG1_BST_VOUT_6V)
+			databuf[0] = AW86927_BIT_PLAYCFG1_BST_VOUT_6V;
+		if (databuf[1] < AW86927_BIT_PLAYCFG1_BST_VOUT_6V)
+			databuf[1] = AW86927_BIT_PLAYCFG1_BST_VOUT_6V;
+		if (databuf[0] > AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V)
+			databuf[0] = AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V;
+		if (databuf[1] > AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V)
+			databuf[1] = AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V;
+		aw86927->info.bst_vol_ram = databuf[0];
+		aw86927->info.bst_vol_rtp = databuf[1];
+	}
+	return count;
+}
+
+static ssize_t aw86927_cont_wait_num_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_wait_num = 0x%02X\n",
+			aw86927->info.cont_wait_num);
+	return len;
+}
+
+static ssize_t aw86927_cont_wait_num_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	int rc = 0;
+	unsigned int val = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86927->info.cont_wait_num = val;
+	aw86927_set_cont_wait_num(aw86927, val);
+
+	return count;
+}
+
+static ssize_t aw86927_cont_drv_lvl_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_lvl = 0x%02X, cont_drv2_lvl = 0x%02X\n",
+			aw86927->info.cont_drv1_lvl,
+			aw86927->info.cont_drv2_lvl);
+	return len;
+}
+
+static ssize_t aw86927_cont_drv_lvl_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw86927->info.cont_drv1_lvl = databuf[0];
+		aw86927->info.cont_drv2_lvl = databuf[1];
+		aw86927_set_cont_drv_lvl(aw86927, databuf[0], databuf[1]);
+	}
+	return count;
+}
+
+static ssize_t aw86927_cont_drv_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_time = 0x%02X, cont_drv2_time = 0x%02X\n",
+			aw86927->info.cont_drv1_time,
+			aw86927->info.cont_drv2_time);
+	return len;
+}
+
+static ssize_t aw86927_cont_drv_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw86927->info.cont_drv1_time = databuf[0];
+		aw86927->info.cont_drv2_time = databuf[1];
+		aw86927_set_cont_drv_time(aw86927, databuf[0], databuf[1]);
+	}
+	return count;
+}
+
+static ssize_t aw86927_cont_brk_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_brk_time = 0x%02X\n",
+			aw86927->info.cont_brk_time);
+	return len;
+}
+
+static ssize_t aw86927_cont_brk_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	int rc = 0;
+	unsigned int val = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86927->info.cont_brk_time = val;
+	aw86927_set_cont_brk_time(aw86927, val);
+	return count;
+}
+
+static ssize_t aw86927_trig_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+	unsigned char i = 0;
+
+	for (i = 0; i < AW86927_TRIG_NUM; i++) {
+		len += snprintf(
+			buf + len, PAGE_SIZE - len,
+			"trig%d: trig_level=%d, trig_polar=%d, pos_enable=%d, pos_sequence=%d, neg_enable=%d, neg_sequence=%d trig_brk=%d, trig_bst=%d\n",
+			i + 1, aw86927->trig[i].trig_level,
+			aw86927->trig[i].trig_polar,
+			aw86927->trig[i].pos_enable,
+			aw86927->trig[i].pos_sequence,
+			aw86927->trig[i].neg_enable,
+			aw86927->trig[i].neg_sequence,
+			aw86927->trig[i].trig_brk, aw86927->trig[i].trig_bst);
+	}
+
+	return len;
+}
+
+static ssize_t aw86927_trig_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[9] = { 0 };
+
+	if (sscanf(buf, "%d %d %d %d %d %d %d %d %d", &databuf[0], &databuf[1],
+		   &databuf[2], &databuf[3], &databuf[4], &databuf[5],
+		   &databuf[6], &databuf[7], &databuf[8]) == 9) {
+		aw_info("%s: %d, %d, %d, %d, %d, %d, %d, %d, %d\n", __func__,
+			databuf[0], databuf[1], databuf[2], databuf[3],
+			databuf[4], databuf[5], databuf[6], databuf[7],
+			databuf[8]);
+		if (databuf[0] < 1 || databuf[0] > 3) {
+			aw_info("%s: input trig_num out of range!\n", __func__);
+			return count;
+		}
+		if (!aw86927->ram_init) {
+			aw_err("%s: ram init failed, not allow to play!\n",
+			       __func__);
+			return count;
+		}
+		if (databuf[4] > aw86927->ram.ram_num ||
+		    databuf[6] > aw86927->ram.ram_num) {
+			aw_err("%s: input seq value out of range!\n", __func__);
+			return count;
+		}
+		databuf[0] -= 1;
+
+		aw86927->trig[databuf[0]].trig_level = databuf[1];
+		aw86927->trig[databuf[0]].trig_polar = databuf[2];
+		aw86927->trig[databuf[0]].pos_enable = databuf[3];
+		aw86927->trig[databuf[0]].pos_sequence = databuf[4];
+		aw86927->trig[databuf[0]].neg_enable = databuf[5];
+		aw86927->trig[databuf[0]].neg_sequence = databuf[6];
+		aw86927->trig[databuf[0]].trig_brk = databuf[7];
+		aw86927->trig[databuf[0]].trig_bst = databuf[8];
+		mutex_lock(&aw86927->lock);
+		switch (databuf[0]) {
+		case 0:
+			aw86927_haptic_trig1_param_config(aw86927);
+			break;
+		case 1:
+			aw86927_haptic_trig2_param_config(aw86927);
+			break;
+		case 2:
+			aw86927_haptic_trig3_param_config(aw86927);
+			break;
+		}
+		mutex_unlock(&aw86927->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86927_state_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "state = %d\n", aw86927->state);
+}
+
+static ssize_t aw86927_state_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86927_duration_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ktime_t time_rem;
+	s64 time_ms = 0;
+
+	if (hrtimer_active(&aw86927->timer)) {
+		time_rem = hrtimer_get_remaining(&aw86927->timer);
+		time_ms = ktime_to_ms(time_rem);
+	}
+	return snprintf(buf, PAGE_SIZE, "%lld\n", time_ms);
+}
+
+static ssize_t aw86927_duration_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	/* setting 0 on duration is NOP for now */
+	if (val <= 0)
+		return count;
+	aw86927->duration = val;
+	return count;
+}
+
+static ssize_t aw86927_activate_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw86927->state);
+}
+
+static ssize_t aw86927_activate_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw_info("%s: value = %d\n", __func__, val);
+	if (!aw86927->ram_init) {
+		aw_err("%s: ram init failed, not allow to play!\n", __func__);
+		return count;
+	}
+	mutex_lock(&aw86927->lock);
+	hrtimer_cancel(&aw86927->timer);
+	aw86927->state = val;
+	mutex_unlock(&aw86927->lock);
+	queue_work(aw86927->work_queue, &aw86927->vibrator_work);
+	return count;
+}
+
+static ssize_t aw86927_activate_mode_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "activate_mode = %d\n",
+			aw86927->activate_mode);
+}
+
+static ssize_t aw86927_activate_mode_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	mutex_lock(&aw86927->lock);
+	aw86927->activate_mode = val;
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_index_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned char seq = 0;
+
+	aw86927_haptic_get_wav_seq(aw86927, 0x00, &seq);
+	aw86927->index = seq;
+	return snprintf(buf, PAGE_SIZE, "index = %d\n", aw86927->index);
+}
+
+static ssize_t aw86927_index_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val > aw86927->ram.ram_num) {
+		aw_err("%s: input value out of range!\n", __func__);
+		return count;
+	}
+	aw_info("%s: value=%d\n", __func__, val);
+	mutex_lock(&aw86927->lock);
+	aw86927->index = val;
+	aw86927_haptic_set_repeat_wav_seq(aw86927, aw86927->index);
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_vmax_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02X\n", aw86927->vmax);
+}
+
+static ssize_t aw86927_vmax_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw_info("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86927->lock);
+	aw86927->vmax = val;
+	aw86927_haptic_set_bst_vol(aw86927, aw86927->vmax);
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_gain_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02X\n", aw86927->gain);
+}
+
+static ssize_t aw86927_gain_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw_info("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw86927->lock);
+	aw86927->gain = val;
+	aw86927_haptic_set_gain(aw86927, aw86927->gain);
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_seq_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW86927_SEQUENCER_SIZE; i++) {
+		aw86927_haptic_get_wav_seq(aw86927, i, &reg_val);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d = 0x%02x\n", i + 1, reg_val);
+		aw86927->seq[i] |= reg_val;
+	}
+	return count;
+}
+
+static ssize_t aw86927_seq_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] >= AW86927_SEQUENCER_SIZE ||
+		    databuf[1] > aw86927->ram.ram_num) {
+			aw_err("%s: input value out of range!\n", __func__);
+			return count;
+		}
+		aw_info("%s: seq%d=0x%02X\n", __func__, databuf[0], databuf[1]);
+		mutex_lock(&aw86927->lock);
+		aw86927->seq[databuf[0]] = (unsigned char)databuf[1];
+		aw86927_haptic_set_wav_seq(aw86927, (unsigned char)databuf[0],
+					   aw86927->seq[databuf[0]]);
+		mutex_unlock(&aw86927->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86927_loop_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW86927_SEQUENCER_LOOP_SIZE; i++) {
+		aw86927_haptic_get_wav_loop(aw86927, i, &reg_val);
+		aw86927->loop[i] = reg_val;
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d_loop = %d\n", i, aw86927->loop[i]);
+	}
+	return count;
+}
+
+static ssize_t aw86927_loop_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw_info("%s: seq%d loop=0x%02X\n", __func__, databuf[0],
+			databuf[1]);
+		mutex_lock(&aw86927->lock);
+		aw86927->loop[databuf[0]] = (unsigned char)databuf[1];
+		aw86927_haptic_set_wav_loop(aw86927, (unsigned char)databuf[0],
+					    aw86927->loop[databuf[0]]);
+		mutex_unlock(&aw86927->lock);
+	}
+
+	return count;
+}
+
+static ssize_t aw86927_read_reg(struct aw86927 *aw86927, char *buf, ssize_t len,
+				unsigned char head_reg_addr,
+				unsigned char tail_reg_addr)
+{
+	int reg_num = 0;
+	int i = 0;
+	unsigned char reg_array[AW86927_REG_MAX] = { 0 };
+
+	reg_num = tail_reg_addr - head_reg_addr + 1;
+	aw86927_i2c_reads(aw86927, head_reg_addr, reg_array, reg_num);
+	for (i = 0; i < reg_num; i++) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"reg:0x%02X=0x%02X\n", head_reg_addr + i,
+				reg_array[i]);
+	}
+	return len;
+}
+
+static ssize_t aw86927_reg_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len = aw86927_read_reg(aw86927, buf, len, AW86927_REG_RSTCFG,
+			       AW86927_REG_RTPDATA - 1);
+	if (!len)
+		return len;
+	len = aw86927_read_reg(aw86927, buf, len, AW86927_REG_RTPDATA + 1,
+			       AW86927_REG_RAMDATA - 1);
+	if (!len)
+		return len;
+	len = aw86927_read_reg(aw86927, buf, len, AW86927_REG_RAMDATA + 1,
+			       AW86927_REG_ANACFG22);
+	return len;
+}
+
+static ssize_t aw86927_reg_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] == AW86927_REG_PLAYCFG1 &&
+		    databuf[1] < AW86927_BIT_PLAYCFG1_BST_VOUT_6V)
+			databuf[1] = AW86927_BIT_PLAYCFG1_BST_VOUT_6V;
+		if (databuf[0] == AW86927_REG_PLAYCFG1 &&
+		    databuf[1] > AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V)
+			databuf[1] = AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V;
+		aw86927_i2c_write(aw86927, (unsigned char)databuf[0],
+				  (unsigned char)databuf[1]);
+	}
+
+	return count;
+}
+
+static ssize_t aw86927_rtp_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "rtp_cnt = %d\n",
+			aw86927->rtp_cnt);
+	return len;
+}
+
+static ssize_t aw86927_rtp_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0) {
+		aw_err("%s kstrtouint fail\n", __func__);
+		return rc;
+	}
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_stop(aw86927);
+	aw86927_haptic_set_rtp_aei(aw86927, false);
+	aw86927_interrupt_clear(aw86927);
+	if (val > 0) {
+		queue_work(aw86927->work_queue, &aw86927->rtp_work);
+	} else {
+		aw_err("%s input number error:%d\n", __func__, val);
+	}
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_ram_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+
+	/* RAMINIT Enable */
+	aw86927_haptic_raminit(aw86927, true);
+	aw86927_haptic_stop(aw86927);
+	aw86927_set_base_addr(aw86927);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86927_haptic_ram:\n");
+	for (i = 0; i < aw86927->ram.len; i++) {
+		aw86927_read_ram_data(aw86927, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "%02X,", reg_val);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw86927_haptic_raminit(aw86927, false);
+	return len;
+}
+
+static ssize_t aw86927_ram_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val)
+		aw86927_ram_update(aw86927);
+	return count;
+}
+
+static ssize_t aw86927_ram_update_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+	int size = 0;
+	int i = 0;
+	int j = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+
+	/* RAMINIT Enable */
+	aw86927_haptic_raminit(aw86927, true);
+	aw86927_haptic_stop(aw86927);
+	aw86927_set_base_addr(aw86927);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86927_haptic_ram:\n");
+	while (i < aw86927->ram.len) {
+		if ((aw86927->ram.len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			size = aw86927->ram.len - i;
+		else
+			size = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw86927_i2c_reads(aw86927, AW86927_REG_RAMDATA, ram_data, size);
+		for (j = 0; j < size; j++) {
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02X,",
+					ram_data[j]);
+		}
+		i += size;
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw86927_haptic_raminit(aw86927, false);
+	return len;
+}
+
+static ssize_t aw86927_ram_update_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val)
+		aw86927_ram_update(aw86927);
+	return count;
+}
+
+static ssize_t aw86927_ram_num_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	aw86927_haptic_get_ram_number(aw86927);
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_num = %d\n",
+			aw86927->ram.ram_num);
+	return len;
+}
+
+static ssize_t aw86927_f0_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_upload_lra(aw86927, AW86927_WRITE_ZERO);
+	aw86927_haptic_cont_get_f0(aw86927);
+	mutex_unlock(&aw86927->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw86927->f0);
+	return len;
+}
+
+static ssize_t aw86927_f0_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	return count;
+}
+
+static ssize_t aw86927_cali_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_upload_lra(aw86927, AW86927_F0_CALI);
+	aw86927_haptic_cont_get_f0(aw86927);
+	mutex_unlock(&aw86927->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86927 cali f0 = %d\n",
+			aw86927->f0);
+	return len;
+}
+
+static ssize_t aw86927_cali_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val) {
+		mutex_lock(&aw86927->lock);
+		aw86927_haptic_upload_lra(aw86927, AW86927_WRITE_ZERO);
+		aw86927_haptic_f0_calibration(aw86927);
+		mutex_unlock(&aw86927->lock);
+	}
+	return count;
+}
+static ssize_t aw86927_f0_save_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw86927->f0_calib_data);
+
+	return len;
+}
+
+static ssize_t aw86927_f0_save_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86927->f0_calib_data = val;
+	return count;
+}
+
+static ssize_t aw86927_osc_cali_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw86927->lra_calib_data);
+
+	return len;
+}
+
+static ssize_t aw86927_osc_cali_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	mutex_lock(&aw86927->lock);
+	/*osc calibration flag start,Other behaviors are forbidden*/
+	aw86927->osc_cali_run = 1;
+	if (val == 3) {
+		aw86927_haptic_set_pwm(aw86927, AW86927_PWM_24K);
+		aw86927_haptic_upload_lra(aw86927, AW86927_WRITE_ZERO);
+		aw86927_rtp_osc_calibration(aw86927);
+		aw86927_rtp_trim_lra_calibration(aw86927);
+	} else if (val == 1) {
+		aw86927_haptic_set_pwm(aw86927, AW86927_PWM_24K);
+		aw86927_haptic_upload_lra(aw86927, AW86927_OSC_CALI);
+		aw86927_rtp_osc_calibration(aw86927);
+	} else {
+		aw_err("%s input value out of range\n", __func__);
+	}
+	aw86927->osc_cali_run = 0;
+	/* osc calibration flag end, other behaviors are permitted */
+	mutex_unlock(&aw86927->lock);
+
+	return count;
+}
+
+static ssize_t aw86927_osc_save_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw86927->lra_calib_data);
+
+	return len;
+}
+
+static ssize_t aw86927_osc_save_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw86927->lra_calib_data = val;
+	aw_info("%s load osa cal: %d\n", __func__, val);
+	return count;
+}
+
+static ssize_t aw86927_cont_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_read_cont_f0(aw86927);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw86927 cont f0 = %d\n",
+			aw86927->cont_f0);
+	mutex_unlock(&aw86927->lock);
+	return len;
+}
+
+static ssize_t aw86927_cont_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_stop(aw86927);
+	if (val) {
+		aw86927_haptic_upload_lra(aw86927, AW86927_F0_CALI);
+		aw86927_haptic_cont_play(aw86927);
+	}
+	mutex_unlock(&aw86927->lock);
+	return count;
+}
+
+static ssize_t aw86927_vbat_monitor_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_get_vbat(aw86927);
+	len += snprintf(buf + len, PAGE_SIZE - len, "vbat=%dmv\n",
+			aw86927->vbat);
+	mutex_unlock(&aw86927->lock);
+
+	return len;
+}
+
+static ssize_t aw86927_vbat_monitor_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86927_lra_resistance_show(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	aw86927_haptic_get_lra_resistance(aw86927);
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw86927->lra);
+	return len;
+}
+
+static ssize_t aw86927_lra_resistance_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw86927_auto_boost_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "auto_boost=%d\n",
+			aw86927->auto_boost);
+
+	return len;
+}
+
+static ssize_t aw86927_auto_boost_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_stop(aw86927);
+	aw86927_haptic_auto_bst_enable(aw86927, val);
+	mutex_unlock(&aw86927->lock);
+
+	return count;
+}
+
+static ssize_t aw86927_prctmode_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	aw86927_get_prctmode(aw86927);
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "prctmode=%d\n",
+			reg_val & 0x08);
+	return len;
+}
+
+static ssize_t aw86927_prctmode_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int databuf[2] = { 0, 0 };
+	unsigned int addr = 0;
+	unsigned int val = 0;
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		addr = databuf[0];
+		val = databuf[1];
+		mutex_lock(&aw86927->lock);
+		aw86927_haptic_swicth_motor_protect_config(aw86927, addr, val);
+		mutex_unlock(&aw86927->lock);
+	}
+	return count;
+}
+
+static ssize_t aw86927_ram_vbat_comp_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_vbat_comp=%d\n",
+			aw86927->ram_vbat_comp);
+
+	return len;
+}
+
+static ssize_t aw86927_ram_vbat_comp_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw86927 *aw86927 = awinic->aw86927;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw86927->lock);
+	if (val)
+		aw86927->ram_vbat_comp = AW86927_RAM_VBAT_COMP_ENABLE;
+	else
+		aw86927->ram_vbat_comp = AW86927_RAM_VBAT_COMP_DISABLE;
+	mutex_unlock(&aw86927->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(effect_id, S_IWUSR | S_IRUGO, aw86927_effect_id_show,
+		   aw86927_effect_id_store);
+static DEVICE_ATTR(f0_check, S_IRUGO, aw86927_f0_check_show, NULL);
+static DEVICE_ATTR(f0_value, S_IRUGO, aw86927_f0_value_show, NULL);
+static DEVICE_ATTR(custom_wave, S_IWUSR | S_IRUGO, aw86927_custom_wave_show,
+		   aw86927_custom_wave_store);
+static DEVICE_ATTR(bst_vol, S_IWUSR | S_IRUGO, aw86927_bst_vol_show,
+		   aw86927_bst_vol_store);
+static DEVICE_ATTR(cont_wait_num, S_IWUSR | S_IRUGO, aw86927_cont_wait_num_show,
+		   aw86927_cont_wait_num_store);
+static DEVICE_ATTR(cont_drv_lvl, S_IWUSR | S_IRUGO, aw86927_cont_drv_lvl_show,
+		   aw86927_cont_drv_lvl_store);
+static DEVICE_ATTR(cont_drv_time, S_IWUSR | S_IRUGO, aw86927_cont_drv_time_show,
+		   aw86927_cont_drv_time_store);
+static DEVICE_ATTR(cont_brk_time, S_IWUSR | S_IRUGO, aw86927_cont_brk_time_show,
+		   aw86927_cont_brk_time_store);
+static DEVICE_ATTR(trig, S_IWUSR | S_IRUGO, aw86927_trig_show,
+		   aw86927_trig_store);
+static DEVICE_ATTR(state, S_IWUSR | S_IRUGO, aw86927_state_show,
+		   aw86927_state_store);
+static DEVICE_ATTR(duration, S_IWUSR | S_IRUGO, aw86927_duration_show,
+		   aw86927_duration_store);
+static DEVICE_ATTR(activate, S_IWUSR | S_IRUGO, aw86927_activate_show,
+		   aw86927_activate_store);
+static DEVICE_ATTR(activate_mode, S_IWUSR | S_IRUGO, aw86927_activate_mode_show,
+		   aw86927_activate_mode_store);
+static DEVICE_ATTR(index, S_IWUSR | S_IRUGO, aw86927_index_show,
+		   aw86927_index_store);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO, aw86927_vmax_show,
+		   aw86927_vmax_store);
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO, aw86927_gain_show,
+		   aw86927_gain_store);
+static DEVICE_ATTR(seq, S_IWUSR | S_IRUGO, aw86927_seq_show, aw86927_seq_store);
+static DEVICE_ATTR(loop, S_IWUSR | S_IRUGO, aw86927_loop_show,
+		   aw86927_loop_store);
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO, aw86927_reg_show, aw86927_reg_store);
+
+static DEVICE_ATTR(rtp, S_IWUSR | S_IRUGO, aw86927_rtp_show, aw86927_rtp_store);
+static DEVICE_ATTR(ram, S_IWUSR | S_IRUGO, aw86927_ram_show, aw86927_ram_store);
+static DEVICE_ATTR(ram_update, S_IWUSR | S_IRUGO, aw86927_ram_update_show,
+		   aw86927_ram_update_store);
+static DEVICE_ATTR(ram_num, S_IWUSR | S_IRUGO, aw86927_ram_num_show, NULL);
+static DEVICE_ATTR(f0, S_IWUSR | S_IRUGO, aw86927_f0_show, aw86927_f0_store);
+static DEVICE_ATTR(cali, S_IWUSR | S_IRUGO, aw86927_cali_show,
+		   aw86927_cali_store);
+static DEVICE_ATTR(f0_save, S_IWUSR | S_IRUGO, aw86927_f0_save_show,
+		   aw86927_f0_save_store);
+static DEVICE_ATTR(osc_cali, S_IWUSR | S_IRUGO, aw86927_osc_cali_show,
+		   aw86927_osc_cali_store);
+static DEVICE_ATTR(osc_save, S_IWUSR | S_IRUGO, aw86927_osc_save_show,
+		   aw86927_osc_save_store);
+static DEVICE_ATTR(cont, S_IWUSR | S_IRUGO, aw86927_cont_show,
+		   aw86927_cont_store);
+static DEVICE_ATTR(vbat_monitor, S_IWUSR | S_IRUGO, aw86927_vbat_monitor_show,
+		   aw86927_vbat_monitor_store);
+static DEVICE_ATTR(lra_resistance, S_IWUSR | S_IRUGO,
+		   aw86927_lra_resistance_show, aw86927_lra_resistance_store);
+static DEVICE_ATTR(auto_boost, S_IWUSR | S_IRUGO, aw86927_auto_boost_show,
+		   aw86927_auto_boost_store);
+static DEVICE_ATTR(prctmode, S_IWUSR | S_IRUGO, aw86927_prctmode_show,
+		   aw86927_prctmode_store);
+static DEVICE_ATTR(ram_vbat_comp, S_IWUSR | S_IRUGO, aw86927_ram_vbat_comp_show,
+		   aw86927_ram_vbat_comp_store);
+static struct attribute *aw86927_vibrator_attributes[] = {
+	&dev_attr_effect_id.attr,
+	&dev_attr_f0_check.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_custom_wave.attr,
+	&dev_attr_bst_vol.attr,
+	&dev_attr_cont_wait_num.attr,
+	&dev_attr_cont_drv_lvl.attr,
+	&dev_attr_cont_drv_time.attr,
+	&dev_attr_cont_brk_time.attr,
+	&dev_attr_trig.attr,
+	&dev_attr_state.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_ram_num.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	NULL
+};
+
+struct attribute_group aw86927_vibrator_attribute_group = {
+	.attrs = aw86927_vibrator_attributes
+};
+
+/*****************************************************
+ *
+ * Extern function : parse dts
+ *
+ *****************************************************/
+int aw86927_parse_dt(struct aw86927 *aw86927, struct device *dev,
+		     struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int trig_config_temp[24] = { 1, 0, 1, 1, 1, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0 };
+	struct qti_hap_config *config = &aw86927->config;
+	struct device_node *child_node;
+	struct qti_hap_effect *effect;
+	int rc = 0, tmp, i = 0, j;
+	unsigned int rtp_time[175];
+
+	val = of_property_read_u32(np, "aw86927_vib_mode", &aw86927->info.mode);
+	if (val != 0)
+		aw_info("%s vib_mode not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_f0_pre",
+				   &aw86927->info.f0_pre);
+	if (val != 0)
+		aw_info("%s vib_f0_pre not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_f0_cali_percen",
+				   &aw86927->info.f0_cali_percen);
+	if (val != 0)
+		aw_info("%s vib_f0_cali_percen not found\n", __func__);
+
+	val = of_property_read_u32(np, "aw86927_vib_cont_drv1_lvl",
+				   &aw86927->info.cont_drv1_lvl);
+	if (val != 0)
+		aw_info("%s vib_cont_drv1_lvl not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_drv2_lvl",
+				   &aw86927->info.cont_drv2_lvl);
+	if (val != 0)
+		aw_info("%s vib_cont_drv2_lvl not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_drv1_time",
+				   &aw86927->info.cont_drv1_time);
+	if (val != 0)
+		aw_info("%s vib_cont_drv1_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_drv2_time",
+				   &aw86927->info.cont_drv2_time);
+	if (val != 0)
+		aw_info("%s vib_cont_drv2_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_drv_width",
+				   &aw86927->info.cont_drv_width);
+	if (val != 0)
+		aw_info("%s vib_cont_drv_width not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_wait_num",
+				   &aw86927->info.cont_wait_num);
+	if (val != 0)
+		aw_info("%s vib_cont_wait_num not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_brk_time",
+				   &aw86927->info.cont_brk_time);
+	if (val != 0)
+		aw_info("%s vib_cont_brk_time not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_track_margin",
+				   &aw86927->info.cont_track_margin);
+	if (val != 0)
+		aw_info("%s vib_cont_track_margin not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_brk_bst_md",
+				   &aw86927->info.brk_bst_md);
+	if (val != 0)
+		aw_info("%s vib_brk_bst_md not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_tset",
+				   &aw86927->info.cont_tset);
+	if (val != 0)
+		aw_info("%s vib_cont_tset not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_bemf_set",
+				   &aw86927->info.cont_bemf_set);
+	if (val != 0)
+		aw_info("%s vib_cont_bemf_set not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_bst_brk_gain",
+				   &aw86927->info.cont_bst_brk_gain);
+	if (val != 0)
+		aw_info("%s vib_cont_bst_brk_gain not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_cont_brk_gain",
+				   &aw86927->info.cont_brk_gain);
+	if (val != 0)
+		aw_info("%s vib_cont_brk_gain not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_d2s_gain",
+				   &aw86927->info.d2s_gain);
+	if (val != 0)
+		aw_info("%s vib_d2s_gain not found\n", __func__);
+	val = of_property_read_u32_array(np, "aw86927_vib_trig_config",
+					 trig_config_temp,
+					 ARRAY_SIZE(trig_config_temp));
+	if (val != 0)
+		aw_info("%s vib_trig_config not found\n", __func__);
+	memcpy(aw86927->info.trig_config, trig_config_temp,
+	       sizeof(trig_config_temp));
+	val = of_property_read_u32(np, "aw86927_vib_bst_vol_default",
+				   &aw86927->info.bst_vol_default);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_default not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_bst_vol_ram",
+				   &aw86927->info.bst_vol_ram);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_ram not found\n", __func__);
+	val = of_property_read_u32(np, "aw86927_vib_bst_vol_rtp",
+				   &aw86927->info.bst_vol_rtp);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_rtp not found\n", __func__);
+
+	val = of_property_read_u32(np, "vib_effect_id_boundary",
+				   &aw86927->info.effect_id_boundary);
+	if (val != 0)
+		aw_info("%s vib_effect_id_boundary not found\n", __func__);
+	val = of_property_read_u32(np, "vib_effect_max",
+				   &aw86927->info.effect_max);
+	if (val != 0)
+		aw_info("%s vib_effect_max not found\n", __func__);
+	val = of_property_read_u32_array(np, "vib_rtp_time", rtp_time,
+					 ARRAY_SIZE(rtp_time));
+	if (val != 0)
+		aw_info("%s vib_rtp_time not found\n", __func__);
+	memcpy(aw86927->info.rtp_time, rtp_time, sizeof(rtp_time));
+	config->play_rate_us = HAP_PLAY_RATE_US_DEFAULT;
+	rc = of_property_read_u32(np, "play-rate-us", &tmp);
+	if (!rc)
+		config->play_rate_us = (tmp >= HAP_PLAY_RATE_US_MAX) ?
+					       HAP_PLAY_RATE_US_MAX :
+					       tmp;
+
+	aw86927->constant.pattern = devm_kcalloc(
+		aw86927->dev, HAP_WAVEFORM_BUFFER_MAX, sizeof(u8), GFP_KERNEL);
+	if (!aw86927->constant.pattern)
+		return -ENOMEM;
+
+	tmp = of_get_available_child_count(np);
+	aw86927->predefined = devm_kcalloc(
+		aw86927->dev, tmp, sizeof(*aw86927->predefined), GFP_KERNEL);
+	if (!aw86927->predefined)
+		return -ENOMEM;
+
+	aw86927->effects_count = tmp;
+	for_each_available_child_of_node (np, child_node) {
+		effect = &aw86927->predefined[i++];
+		rc = of_property_read_u32(child_node, "mtk,effect-id",
+					  &effect->id);
+		if (rc != 0)
+			aw_info("%s Read mtk,effect-id failed\n", __func__);
+
+		effect->vmax_mv = config->vmax_mv;
+		rc = of_property_read_u32(child_node, "mtk,wf-vmax-mv", &tmp);
+		if (rc != 0)
+			aw_info("%s  Read mtk,wf-vmax-mv failed !\n", __func__);
+		else
+			effect->vmax_mv = tmp;
+
+		aw_info("%s ---%d effect->vmax_mv =%d\n", __func__, __LINE__,
+			effect->vmax_mv);
+		rc = of_property_count_elems_of_size(
+			child_node, "mtk,wf-pattern", sizeof(u8));
+		if (rc < 0) {
+			aw_info("%s Count mtk,wf-pattern property failed !\n",
+				__func__);
+		} else if (rc == 0) {
+			aw_info("%s mtk,wf-pattern has no data\n", __func__);
+		}
+		aw_info("%s ---%d\n", __func__, __LINE__);
+
+		effect->pattern_length = rc;
+		effect->pattern =
+			devm_kcalloc(aw86927->dev, effect->pattern_length,
+				     sizeof(u8), GFP_KERNEL);
+
+		rc = of_property_read_u8_array(child_node, "mtk,wf-pattern",
+					       effect->pattern,
+					       effect->pattern_length);
+		if (rc < 0) {
+			aw_info("%s Read mtk,wf-pattern property failed !\n",
+				__func__);
+		}
+
+		effect->play_rate_us = config->play_rate_us;
+		rc = of_property_read_u32(child_node, "mtk,wf-play-rate-us",
+					  &tmp);
+		if (rc < 0)
+			aw_info("%s Read mtk,wf-play-rate-us failed !\n",
+				__func__);
+		else
+			effect->play_rate_us = tmp;
+
+		rc = of_property_read_u32(child_node, "mtk,wf-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_repeat); j++)
+				if (tmp <= wf_repeat[j])
+					break;
+
+			effect->wf_repeat_n = j;
+		}
+
+		rc = of_property_read_u32(child_node, "mtk,wf-s-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-s-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_s_repeat); j++)
+				if (tmp <= wf_s_repeat[j])
+					break;
+
+			effect->wf_s_repeat_n = j;
+		}
+
+		effect->lra_auto_res_disable = of_property_read_bool(
+			child_node, "mtk,lra-auto-resonance-disable");
+
+		tmp = of_property_count_elems_of_size(
+			child_node, "mtk,wf-brake-pattern", sizeof(u8));
+		if (tmp <= 0)
+			continue;
+
+		if (tmp > HAP_BRAKE_PATTERN_MAX) {
+			aw_info("%s wf-brake-pattern shouldn't be more than %d bytes\n",
+				__func__, HAP_BRAKE_PATTERN_MAX);
+		}
+
+		rc = of_property_read_u8_array(
+			child_node, "mtk,wf-brake-pattern", effect->brake, tmp);
+		if (rc < 0) {
+			aw_info("%s Failed to get wf-brake-pattern !\n",
+				__func__);
+		}
+
+		effect->brake_pattern_length = tmp;
+	}
+
+	aw_info("%s aw86927->info.brk_bst_md: %d\n", __func__,
+		aw86927->info.brk_bst_md);
+	aw_info("%s aw86927->info.bst_vol_default: %d\n", __func__,
+		aw86927->info.bst_vol_default);
+	aw_info("%s aw86927->info.bst_vol_ram: %d\n", __func__,
+		aw86927->info.bst_vol_ram);
+	aw_info("%s aw86927->info.bst_vol_rtp: %d\n", __func__,
+		aw86927->info.bst_vol_rtp);
+
+	return 0;
+}
+
+static int aw86927_haptic_ram_vbat_comp(struct aw86927 *aw86927, bool flag)
+{
+	aw_dbg("%s enter!\n", __func__);
+	if (flag)
+		aw86927->ram_vbat_comp = AW86927_RAM_VBAT_COMP_ENABLE;
+	else
+		aw86927->ram_vbat_comp = AW86927_RAM_VBAT_COMP_DISABLE;
+	return 0;
+}
+
+static int aw86927_haptic_effect_strength(struct aw86927 *aw86927)
+{
+	aw_dbg("%s enter\n", __func__);
+	aw_dbg("%s: aw86927->play.vmax_mv =0x%x\n", __func__,
+	       aw86927->play.vmax_mv);
+#if 0
+	switch (aw86927->play.vmax_mv) {
+	case AW86927_LIGHT_MAGNITUDE:
+		aw86927->level = 0x80;
+		break;
+	case AW86927_MEDIUM_MAGNITUDE:
+		aw86927->level = 0x50;
+		break;
+	case AW86927_STRONG_MAGNITUDE:
+		aw86927->level = 0x30;
+		break;
+	default:
+		break;
+	}
+#else
+	if (aw86927->play.vmax_mv >= 0x7FFF)
+		aw86927->level = 0x80; /*128*/
+	else if (aw86927->play.vmax_mv <= 0x3FFF)
+		aw86927->level = 0x1E; /*30*/
+	else
+		aw86927->level = (aw86927->play.vmax_mv - 16383) / 128;
+	if (aw86927->level < 0x1E)
+		aw86927->level = 0x1E; /*30*/
+#endif
+
+	aw_info("%s: aw86927->level =0x%x\n", __func__, aw86927->level);
+	return 0;
+}
+
+static int aw86927_haptic_play_effect_seq(struct aw86927 *aw86927,
+					  unsigned char flag)
+{
+	if (aw86927->effect_id > aw86927->info.effect_id_boundary)
+		return 0;
+
+	if (flag) {
+		if (aw86927->activate_mode == AW86927_ACTIVATE_RAM_MODE) {
+			aw86927_haptic_set_wav_seq(
+				aw86927, 0x00, (char)aw86927->effect_id + 1);
+			aw86927_haptic_set_wav_seq(aw86927, 0x01, 0x00);
+			aw86927_haptic_set_wav_loop(aw86927, 0x00, 0x00);
+			aw86927_haptic_play_mode(aw86927, AW86927_RAM_MODE);
+			if (aw86927->info.bst_vol_ram <= AW86927_MAX_BST_VO)
+				aw86927_haptic_set_bst_vol(
+					aw86927, aw86927->info.bst_vol_ram);
+			else
+				aw86927_haptic_set_bst_vol(aw86927,
+							   aw86927->vmax);
+			aw86927_haptic_effect_strength(aw86927);
+			aw86927_haptic_set_gain(aw86927, aw86927->level);
+			aw86927_haptic_play_go(aw86927);
+		}
+		if (aw86927->activate_mode == AW86927_ACTIVATE_RAM_LOOP_MODE) {
+			aw86927_haptic_play_mode(aw86927,
+						 AW86927_RAM_LOOP_MODE);
+			aw86927_haptic_set_repeat_wav_seq(
+				aw86927,
+				(aw86927->info.effect_id_boundary + 1));
+			aw86927_haptic_set_gain(aw86927, aw86927->level);
+			aw86927_haptic_play_go(aw86927);
+		}
+	}
+
+	return 0;
+}
+
+static enum hrtimer_restart
+aw86927_haptic_audio_timer_func(struct hrtimer *timer)
+{
+	struct aw86927 *aw86927 =
+		container_of(timer, struct aw86927, haptic_audio.timer);
+
+	aw_dbg("%s enter\n", __func__);
+	queue_work(aw86927->work_queue, &aw86927->haptic_audio.work);
+
+	hrtimer_start(
+		&aw86927->haptic_audio.timer,
+		ktime_set(aw86927->haptic_audio.timer_val / 1000000,
+			  (aw86927->haptic_audio.timer_val % 1000000) * 1000),
+		HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static int aw86927_haptic_juge_RTP_is_going_on(struct aw86927 *aw86927)
+{
+	unsigned char glb_state = 0;
+	unsigned char rtp_state = 0;
+
+	aw_dbg("%s enter\n", __func__);
+	aw86927_haptic_get_glb_state(aw86927, &glb_state);
+	if (aw86927->rtp_routine_on ||
+	    (glb_state == AW86927_BIT_GLBRD5_STATE_RTP_GO)) {
+		rtp_state = 1; /* is going on */
+		aw_info("%s: rtp_routine_on\n", __func__);
+	}
+	return rtp_state;
+}
+
+static void aw86927_haptic_audio_work_routine(struct work_struct *work)
+{
+	struct aw86927 *aw86927 =
+		container_of(work, struct aw86927, haptic_audio.work);
+	int rtp_is_going_on = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	mutex_lock(&aw86927->haptic_audio.lock);
+	/* rtp mode jump */
+	rtp_is_going_on = aw86927_haptic_juge_RTP_is_going_on(aw86927);
+	if (rtp_is_going_on) {
+		mutex_unlock(&aw86927->haptic_audio.lock);
+		return;
+	}
+	memcpy(&aw86927->haptic_audio.ctr,
+	       &aw86927->haptic_audio.data[aw86927->haptic_audio.cnt],
+	       sizeof(struct haptic_ctr));
+	aw_dbg("%s: cnt=%d, cmd=%d, play=%d, wavseq=%d, loop=%d, gain=%d\n",
+	       __func__, aw86927->haptic_audio.cnt,
+	       aw86927->haptic_audio.ctr.cmd, aw86927->haptic_audio.ctr.play,
+	       aw86927->haptic_audio.ctr.wavseq, aw86927->haptic_audio.ctr.loop,
+	       aw86927->haptic_audio.ctr.gain);
+	mutex_unlock(&aw86927->haptic_audio.lock);
+	if (aw86927->haptic_audio.ctr.cmd == AW86927_HAPTIC_CMD_ENABLE) {
+		if (aw86927->haptic_audio.ctr.play ==
+		    AW86927_HAPTIC_PLAY_ENABLE) {
+			aw_info("%s: haptic_audio_play_start\n", __func__);
+			mutex_lock(&aw86927->lock);
+			aw86927_haptic_stop(aw86927);
+			aw86927_haptic_play_mode(aw86927, AW86927_RAM_MODE);
+
+			aw86927_haptic_set_wav_seq(
+				aw86927, 0x00,
+				aw86927->haptic_audio.ctr.wavseq);
+			aw86927_haptic_set_wav_seq(aw86927, 0x01, 0x00);
+
+			aw86927_haptic_set_wav_loop(
+				aw86927, 0x00, aw86927->haptic_audio.ctr.loop);
+
+			aw86927_haptic_set_gain(aw86927,
+						aw86927->haptic_audio.ctr.gain);
+
+			aw86927_haptic_play_go(aw86927);
+			mutex_unlock(&aw86927->lock);
+		} else if (AW86927_HAPTIC_PLAY_STOP ==
+			   aw86927->haptic_audio.ctr.play) {
+			mutex_lock(&aw86927->lock);
+			aw86927_haptic_stop(aw86927);
+			mutex_unlock(&aw86927->lock);
+		} else if (AW86927_HAPTIC_PLAY_GAIN ==
+			   aw86927->haptic_audio.ctr.play) {
+			mutex_lock(&aw86927->lock);
+			aw86927_haptic_set_gain(aw86927,
+						aw86927->haptic_audio.ctr.gain);
+			mutex_unlock(&aw86927->lock);
+		}
+		mutex_lock(&aw86927->haptic_audio.lock);
+		memset(&aw86927->haptic_audio.data[aw86927->haptic_audio.cnt],
+		       0, sizeof(struct haptic_ctr));
+		mutex_unlock(&aw86927->haptic_audio.lock);
+	}
+	mutex_lock(&aw86927->haptic_audio.lock);
+	aw86927->haptic_audio.cnt++;
+	if (aw86927->haptic_audio.data[aw86927->haptic_audio.cnt].cmd == 0) {
+		aw86927->haptic_audio.cnt = 0;
+		aw_dbg("%s: haptic play buffer restart\n", __func__);
+	}
+	mutex_unlock(&aw86927->haptic_audio.lock);
+}
+
+static void aw86927_haptic_audio_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw86927->haptic_audio.delay_val = 1;
+	aw86927->haptic_audio.timer_val = 21318;
+	hrtimer_init(&aw86927->haptic_audio.timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw86927->haptic_audio.timer.function = aw86927_haptic_audio_timer_func;
+	INIT_WORK(&aw86927->haptic_audio.work,
+		  aw86927_haptic_audio_work_routine);
+	mutex_init(&aw86927->haptic_audio.lock);
+}
+
+static int aw86927_container_update(struct aw86927 *aw86927,
+				    struct aw86927_container *aw86927_cont)
+{
+	unsigned int shift = 0;
+	int ret = 0;
+#ifdef AW_CHECK_RAM_DATA
+	int i = 0;
+	int len = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+#endif
+
+	aw_info("%s enter\n", __func__);
+	mutex_lock(&aw86927->lock);
+	aw86927->ram.baseaddr_shift = 2;
+	aw86927->ram.ram_shift = 4;
+	/* RAMINIT Enable */
+	aw86927_haptic_raminit(aw86927, true);
+	/* Enter standby mode */
+	aw86927_haptic_stop(aw86927);
+	/* base addr */
+	shift = aw86927->ram.baseaddr_shift;
+	aw86927->ram.base_addr =
+		(unsigned int)((aw86927_cont->data[0 + shift] << 8) |
+			       (aw86927_cont->data[1 + shift]));
+	aw_info("%s: base_addr = %d\n", __func__, aw86927->ram.base_addr);
+
+	aw86927_set_base_addr(aw86927);
+	aw86927_set_fifo_addr(aw86927);
+	aw86927_get_fifo_addr(aw86927);
+	aw86927_write_ram_data(aw86927, aw86927_cont);
+
+#ifdef AW_CHECK_RAM_DATA
+	aw86927_set_base_addr(aw86927);
+	i = aw86927->ram.ram_shift;
+	while (i < aw86927_cont->len) {
+		if ((aw86927_cont->len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			len = aw86927_cont->len - i;
+		else
+			len = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw86927_i2c_reads(aw86927, AW86927_REG_RAMDATA, ram_data, len);
+		ret = aw86927_check_ram_data(aw86927, &aw86927_cont->data[i],
+					     ram_data, len);
+
+		if (ret < 0)
+			break;
+		i += len;
+	}
+	if (ret)
+		aw_err("%s: ram data check sum error\n", __func__);
+	else
+		aw_info("%s: ram data check sum pass\n", __func__);
+#endif
+	/* RAMINIT Disable */
+	aw86927_haptic_raminit(aw86927, false);
+	mutex_unlock(&aw86927->lock);
+	aw_info("%s exit\n", __func__);
+
+	return ret;
+}
+
+static void aw86927_ram_loaded(const struct firmware *cont, void *context)
+{
+	struct aw86927 *aw86927 = context;
+	struct aw86927_container *aw86927_fw;
+	int i = 0;
+	int ret = 0;
+	unsigned short check_sum = 0;
+
+	aw_info("%s enter\n", __func__);
+	if (!cont) {
+		aw_err("%s: failed to read %s\n", __func__, awinic_ram_name);
+		release_firmware(cont);
+		return;
+	}
+	aw_info("%s: loaded %s - size: %zu bytes\n", __func__, awinic_ram_name,
+		cont ? cont->size : 0);
+	/*
+ *	for(i=0; i < cont->size; i++) {
+ *		aw_info("%s: addr: 0x%04x, data: 0x%02X\n",
+ *			__func__, i, *(cont->data+i));
+ *	}
+ */
+	/* check sum */
+	for (i = 2; i < cont->size; i++)
+		check_sum += cont->data[i];
+	if (check_sum !=
+	    (unsigned short)((cont->data[0] << 8) | (cont->data[1]))) {
+		aw_err("%s: check sum err: check_sum=0x%04x\n", __func__,
+		       check_sum);
+		release_firmware(cont);
+		return;
+	}
+	aw_info("%s: check sum pass: 0x%04x\n", __func__, check_sum);
+	aw86927->ram.check_sum = check_sum;
+
+	/* aw86927 ram update less then 128kB */
+	aw86927_fw = kzalloc(cont->size + sizeof(int), GFP_KERNEL);
+	if (!aw86927_fw) {
+		release_firmware(cont);
+		aw_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw86927_fw->len = cont->size;
+	memcpy(aw86927_fw->data, cont->data, cont->size);
+	release_firmware(cont);
+	ret = aw86927_container_update(aw86927, aw86927_fw);
+	if (ret) {
+		aw_err("%s: ram firmware update failed!\n", __func__);
+	} else {
+		aw86927->ram_init = 1;
+		aw86927_trig_config(aw86927);
+		aw86927_haptic_get_ram_number(aw86927);
+		aw_info("%s: ram firmware update complete!\n", __func__);
+	}
+	aw86927->ram.len = aw86927_fw->len - aw86927->ram.ram_shift;
+	kfree(aw86927_fw);
+}
+
+static int aw86927_ram_update(struct aw86927 *aw86927)
+{
+	aw86927->ram_init = 0;
+	aw86927->rtp_init = 0;
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       awinic_ram_name, aw86927->dev,
+				       GFP_KERNEL, aw86927, aw86927_ram_loaded);
+}
+
+#ifdef AW_RAM_UPDATE_DELAY
+static void aw86927_ram_work_routine(struct work_struct *work)
+{
+	struct aw86927 *aw86927 =
+		container_of(work, struct aw86927, ram_work.work);
+
+	aw_info("%s enter\n", __func__);
+
+	aw86927_ram_update(aw86927);
+}
+#endif
+
+static int aw86927_haptic_rtp_play(struct aw86927 *aw86927)
+{
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw86927->ram.base_addr >> 2;
+
+	aw_info("%s enter\n", __func__);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	aw86927->rtp_cnt = 0;
+	disable_irq(gpio_to_irq(aw86927->irq_gpio));
+	while ((!aw86927_haptic_rtp_get_fifo_afs(aw86927)) &&
+	       (aw86927->play_mode == AW86927_RTP_MODE) &&
+	       !atomic_read(&aw86927->exit_in_rtp_loop)) {
+		if (aw86927->is_custom_wave == 0) {
+			if ((aw86927_rtp->len - aw86927->rtp_cnt) <
+			    (aw86927->ram.base_addr >> 2)) {
+				buf_len = aw86927_rtp->len - aw86927->rtp_cnt;
+			} else {
+				buf_len = (aw86927->ram.base_addr >> 2);
+			}
+			aw86927_i2c_writes(aw86927, AW86927_REG_RTPDATA,
+					   &aw86927_rtp->data[aw86927->rtp_cnt],
+					   buf_len);
+			aw86927->rtp_cnt += buf_len;
+			if (aw86927->rtp_cnt == aw86927_rtp->len) {
+				aw86927->rtp_cnt = 0;
+				aw86927_haptic_set_rtp_aei(aw86927, false);
+				break;
+			}
+		} else {
+			buf_len = read_rb(aw86927_rtp->data, period_size);
+			aw86927_i2c_writes(aw86927, AW86927_REG_RTPDATA,
+					   aw86927_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				aw_info("%s: custom rtp update complete\n",
+					__func__);
+				aw86927->rtp_cnt = 0;
+				aw86927_haptic_set_rtp_aei(aw86927, false);
+				break;
+			}
+		}
+	}
+	enable_irq(gpio_to_irq(aw86927->irq_gpio));
+	if (aw86927->play_mode == AW86927_RTP_MODE &&
+	    !atomic_read(&aw86927->exit_in_rtp_loop)) {
+		aw86927_haptic_set_rtp_aei(aw86927, true);
+	}
+	aw_info("%s: exit\n", __func__);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+
+static void aw86927_rtp_work_routine(struct work_struct *work)
+{
+	bool rtp_work_flag = false;
+	unsigned char reg_val = 0;
+	unsigned int cnt = 200;
+	const struct firmware *rtp_file;
+	int ret = -1;
+
+	struct aw86927 *aw86927 = container_of(work, struct aw86927, rtp_work);
+
+	if ((aw86927->effect_id < aw86927->info.effect_id_boundary) &&
+	    (aw86927->effect_id > aw86927->info.effect_max))
+		return;
+
+	aw_info("%s: effect_id = %d state=%d activate_mode = %d\n", __func__,
+		aw86927->effect_id, aw86927->state, aw86927->activate_mode);
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_upload_lra(aw86927, AW86927_OSC_CALI);
+	aw86927_haptic_set_rtp_aei(aw86927, false);
+	aw86927_interrupt_clear(aw86927);
+	/* wait for irq to exit */
+	atomic_set(&aw86927->exit_in_rtp_loop, 1);
+	while (atomic_read(&aw86927->is_in_rtp_loop)) {
+		aw_info("%s  goint to waiting irq exit\n", __func__);
+		mutex_unlock(&aw86927->lock);
+		ret = wait_event_interruptible(
+			aw86927->wait_q,
+			atomic_read(&aw86927->is_in_rtp_loop) == 0);
+		aw_info("%s  wakeup\n", __func__);
+		mutex_lock(&aw86927->lock);
+		if (ret == -ERESTARTSYS) {
+			atomic_set(&aw86927->exit_in_rtp_loop, 0);
+			wake_up_interruptible(&aw86927->stop_wait_q);
+			mutex_unlock(&aw86927->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return;
+		}
+	}
+
+	atomic_set(&aw86927->exit_in_rtp_loop, 0);
+	wake_up_interruptible(&aw86927->stop_wait_q);
+
+	/* how to force exit this call */
+	if (aw86927->is_custom_wave == 1 && aw86927->state) {
+		aw_err("%s buffer size %d, availbe size %d\n", __func__,
+		       aw86927->ram.base_addr >> 2, get_rb_avalible_size());
+		while (get_rb_avalible_size() < aw86927->ram.base_addr &&
+		       !rb_shoule_exit()) {
+			mutex_unlock(&aw86927->lock);
+			ret = wait_event_interruptible(
+				aw86927->stop_wait_q,
+				(get_rb_avalible_size() >=
+				 aw86927->ram.base_addr) ||
+					rb_shoule_exit());
+			aw_info("%s  wakeup\n", __func__);
+			aw_err("%s after wakeup sbuffer size %d, availbe size %d\n",
+			       __func__, aw86927->ram.base_addr >> 2,
+			       get_rb_avalible_size());
+			if (ret == -ERESTARTSYS) {
+				aw_err("%s wake up by signal return erro\n",
+				       __func__);
+				return;
+			}
+			mutex_lock(&aw86927->lock);
+		}
+	}
+
+	aw86927_haptic_stop(aw86927);
+	if (aw86927->state) {
+		pm_stay_awake(aw86927->dev);
+		/* boost voltage */
+		if (aw86927->info.bst_vol_ram <= AW86927_MAX_BST_VO)
+			aw86927_haptic_set_bst_vol(aw86927,
+						   aw86927->info.bst_vol_rtp);
+		else
+			aw86927_haptic_set_bst_vol(aw86927, aw86927->vmax);
+		/* gain */
+		aw86927_haptic_ram_vbat_comp(aw86927, false);
+		aw86927_haptic_effect_strength(aw86927);
+		aw86927_haptic_set_gain(aw86927, aw86927->level);
+		aw86927->rtp_init = 0;
+		if (aw86927->is_custom_wave == 0) {
+			aw86927->rtp_file_num =
+				aw86927->effect_id -
+				aw86927->info.effect_id_boundary;
+			aw_info("%s: aw86927->rtp_file_num =%d\n", __func__,
+				aw86927->rtp_file_num);
+			if (aw86927->rtp_file_num < 0)
+				aw86927->rtp_file_num = 0;
+			if (aw86927->rtp_file_num > (awinic_rtp_name_len - 1))
+				aw86927->rtp_file_num = awinic_rtp_name_len - 1;
+			aw86927->rtp_routine_on = 1;
+			/* fw loaded */
+			ret = request_firmware(
+				&rtp_file,
+				awinic_rtp_name[aw86927->rtp_file_num],
+				aw86927->dev);
+			if (ret < 0) {
+				aw_err("%s: failed to read %s\n", __func__,
+				       awinic_rtp_name[aw86927->rtp_file_num]);
+				aw86927->rtp_routine_on = 0;
+				pm_relax(aw86927->dev);
+				mutex_unlock(&aw86927->lock);
+				return;
+			}
+			vfree(aw86927_rtp);
+			aw86927_rtp = vmalloc(rtp_file->size + sizeof(int));
+			if (!aw86927_rtp) {
+				release_firmware(rtp_file);
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				aw86927->rtp_routine_on = 0;
+				pm_relax(aw86927->dev);
+				mutex_unlock(&aw86927->lock);
+				return;
+			}
+			aw86927_rtp->len = rtp_file->size;
+			aw_info("%s: rtp file:[%s] size = %dbytes\n", __func__,
+				awinic_rtp_name[aw86927->rtp_file_num],
+				aw86927_rtp->len);
+			memcpy(aw86927_rtp->data, rtp_file->data,
+			       rtp_file->size);
+			release_firmware(rtp_file);
+		} else {
+			vfree(aw86927_rtp);
+			aw86927_rtp = vmalloc(aw86927->ram.base_addr >> 2);
+			if (!aw86927_rtp) {
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw86927->dev);
+				mutex_unlock(&aw86927->lock);
+				return;
+			}
+		}
+		aw86927->rtp_init = 1;
+		/* rtp mode config */
+		aw86927_haptic_play_mode(aw86927, AW86927_RTP_MODE);
+		/* haptic go */
+		aw86927_haptic_play_go(aw86927);
+		usleep_range(2000, 2500);
+		while (cnt) {
+			aw86927_haptic_get_glb_state(aw86927, &reg_val);
+			if ((reg_val & 0x0f) ==
+			    AW86927_BIT_GLBRD5_STATE_RTP_GO) {
+				cnt = 0;
+				rtp_work_flag = true;
+				aw_info("%s RTP_GO! glb_state=0x08\n",
+					__func__);
+			} else {
+				cnt--;
+				aw_dbg("%s wait for RTP_GO, glb_state=0x%02X\n",
+				       __func__, reg_val);
+			}
+			usleep_range(2000, 2500);
+		}
+		if (rtp_work_flag) {
+			aw86927_haptic_rtp_play(aw86927);
+		} else {
+			/* enter standby mode */
+			aw86927_haptic_stop(aw86927);
+			aw_err("%s failed to enter RTP_GO status!\n", __func__);
+		}
+		aw86927->rtp_routine_on = 0;
+	} else {
+		aw86927->rtp_cnt = 0;
+		aw86927->rtp_init = 0;
+		pm_relax(aw86927->dev);
+	}
+	mutex_unlock(&aw86927->lock);
+}
+
+static enum hrtimer_restart aw86927_vibrator_timer_func(struct hrtimer *timer)
+{
+	struct aw86927 *aw86927 = container_of(timer, struct aw86927, timer);
+
+	aw_info("%s enter\n", __func__);
+
+	aw86927->state = 0;
+	queue_work(aw86927->work_queue, &aw86927->vibrator_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw86927_vibrator_work_routine(struct work_struct *work)
+{
+	struct aw86927 *aw86927 =
+		container_of(work, struct aw86927, vibrator_work);
+
+	aw_dbg("%s enter\n", __func__);
+	aw_info("%s: effect_id = %d state=%d activate_mode = %d duration = %d\n",
+		__func__, aw86927->effect_id, aw86927->state,
+		aw86927->activate_mode, aw86927->duration);
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_upload_lra(aw86927, AW86927_F0_CALI);
+	aw86927_haptic_stop(aw86927);
+	if (aw86927->state) {
+		if (aw86927->activate_mode == AW86927_ACTIVATE_RAM_MODE) {
+			aw86927_haptic_ram_vbat_comp(aw86927, false);
+			aw86927_haptic_play_effect_seq(aw86927, true);
+		} else if (aw86927->activate_mode ==
+			   AW86927_ACTIVATE_RAM_LOOP_MODE) {
+			aw86927->level = 0x80;
+			aw86927_haptic_ram_vbat_comp(aw86927, true);
+			aw86927_haptic_play_effect_seq(aw86927, true);
+			hrtimer_start(
+				&aw86927->timer,
+				ktime_set(aw86927->duration / 1000,
+					  (aw86927->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else if (aw86927->activate_mode ==
+			   AW86927_ACTIVATE_CONT_MODE) {
+			aw86927_haptic_cont_play(aw86927);
+			hrtimer_start(
+				&aw86927->timer,
+				ktime_set(aw86927->duration / 1000,
+					  (aw86927->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else {
+			/*other mode */
+		}
+	}
+	mutex_unlock(&aw86927->lock);
+}
+
+irqreturn_t aw86927_irq(int irq, void *data)
+{
+	struct aw86927 *aw86927 = data;
+	unsigned char glb_state_val = 0;
+	unsigned char reg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw86927->ram.base_addr >> 2;
+	int ret = 0;
+
+	atomic_set(&aw86927->is_in_rtp_loop, 1);
+	aw_info("%s enter\n", __func__);
+	ret = aw86927_get_irq_state(aw86927);
+	if (ret < 0)
+		return IRQ_HANDLED;
+	if (ret & AW86927_SYSINT_ERROR)
+		aw86927->rtp_routine_on = 0;
+	if ((ret & AW86927_SYSINT_FF_AEI) && aw86927->rtp_init) {
+		aw_dbg("%s: aw86927 rtp fifo almost empty\n", __func__);
+		while ((!aw86927_haptic_rtp_get_fifo_afs(aw86927)) &&
+		       (aw86927->play_mode == AW86927_RTP_MODE) &&
+		       !atomic_read(&aw86927->exit_in_rtp_loop)) {
+			mutex_lock(&aw86927->rtp_lock);
+			if (!aw86927_rtp) {
+				aw_info("%s:aw86927_rtp is null, break!\n",
+					__func__);
+				mutex_unlock(&aw86927->rtp_lock);
+				break;
+			}
+			if (aw86927->is_custom_wave == 1) {
+				buf_len =
+					read_rb(aw86927_rtp->data, period_size);
+				aw86927_i2c_writes(aw86927, AW86927_REG_RTPDATA,
+						   aw86927_rtp->data, buf_len);
+				if (buf_len < period_size) {
+					aw_info("%s: rtp update complete\n",
+						__func__);
+					aw86927_haptic_set_rtp_aei(aw86927,
+								   false);
+					aw86927->rtp_cnt = 0;
+					aw86927->rtp_init = 0;
+					mutex_unlock(&aw86927->rtp_lock);
+					break;
+				}
+			} else {
+				if ((aw86927_rtp->len - aw86927->rtp_cnt) <
+				    period_size) {
+					buf_len = aw86927_rtp->len -
+						  aw86927->rtp_cnt;
+				} else {
+					buf_len = period_size;
+				}
+				aw86927_i2c_writes(
+					aw86927, AW86927_REG_RTPDATA,
+					&aw86927_rtp->data[aw86927->rtp_cnt],
+					buf_len);
+				aw86927->rtp_cnt += buf_len;
+				aw86927_haptic_get_glb_state(aw86927,
+							     &glb_state_val);
+				if ((glb_state_val & 0x0f) == 0) {
+					if (aw86927->rtp_cnt !=
+					    aw86927_rtp->len)
+						aw_err("%s: rtp play suspend!\n",
+						       __func__);
+					else
+						aw_info("%s: rtp update complete!\n",
+							__func__);
+					aw86927->rtp_routine_on = 0;
+					aw86927_haptic_set_rtp_aei(aw86927,
+								   false);
+					aw86927->rtp_cnt = 0;
+					aw86927->rtp_init = 0;
+					mutex_unlock(&aw86927->rtp_lock);
+					break;
+				}
+			}
+			mutex_unlock(&aw86927->rtp_lock);
+		}
+	}
+
+	if (ret & AW86927_SYSINT_FF_AFI)
+		aw_info("%s: aw86927 rtp mode fifo almost full!\n", __func__);
+
+	if (aw86927->play_mode != AW86927_RTP_MODE ||
+	    atomic_read(&aw86927->exit_in_rtp_loop))
+		aw86927_haptic_set_rtp_aei(aw86927, false);
+
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%x\n", __func__, reg_val);
+	aw86927_i2c_read(aw86927, AW86927_REG_SYSST, &reg_val);
+	aw_dbg("%s: reg SYSST=0x%x\n", __func__, reg_val);
+	atomic_set(&aw86927->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw86927->wait_q);
+	aw_info("%s exit\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+int aw86927_vibrator_init(struct aw86927 *aw86927)
+{
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+	ret = sysfs_create_group(&aw86927->i2c->dev.kobj,
+				 &aw86927_vibrator_attribute_group);
+	if (ret < 0) {
+		aw_info("%s error creating sysfs attr files\n", __func__);
+		return ret;
+	}
+
+	hrtimer_init(&aw86927->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw86927->timer.function = aw86927_vibrator_timer_func;
+	INIT_WORK(&aw86927->vibrator_work, aw86927_vibrator_work_routine);
+	INIT_WORK(&aw86927->rtp_work, aw86927_rtp_work_routine);
+	mutex_init(&aw86927->lock);
+	mutex_init(&aw86927->rtp_lock);
+	atomic_set(&aw86927->is_in_rtp_loop, 0);
+	atomic_set(&aw86927->exit_in_rtp_loop, 0);
+	atomic_set(&aw86927->is_in_write_loop, 0);
+	init_waitqueue_head(&aw86927->wait_q);
+	init_waitqueue_head(&aw86927->stop_wait_q);
+	return 0;
+}
+
+int aw86927_haptic_init(struct aw86927 *aw86927)
+{
+	aw_info("%s enter\n", __func__);
+
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_audio_init(aw86927);
+	aw86927_vibrate_params_init(aw86927);
+	aw86927_haptic_play_mode(aw86927, AW86927_STANDBY_MODE);
+	aw86927_haptic_set_pwm(aw86927, AW86927_PWM_24K);
+	aw86927_haptic_misc_para_init(aw86927);
+	aw86927_haptic_set_bst_vol(aw86927, aw86927->vmax);
+	aw86927_haptic_set_bst_peak_cur(aw86927, AW86927_DEFAULT_PEAKCUR);
+	aw86927_haptic_swicth_motor_protect_config(aw86927, AW_PROTECT_EN,
+						   AW_PROTECT_VAL);
+	aw86927_haptic_auto_bst_enable(aw86927, false);
+	aw86927_haptic_vbat_mode_config(aw86927, AW86927_VBAT_HW_ADJUST_MODE);
+	mutex_unlock(&aw86927->lock);
+	/* f0 calibration */
+#ifndef USE_CONT_F0_CALI
+	mutex_lock(&aw86927->lock);
+	aw86927_haptic_upload_lra(aw86927, AW86927_WRITE_ZERO);
+	aw86927_haptic_f0_calibration(aw86927);
+	mutex_unlock(&aw86927->lock);
+#endif
+
+	return 0;
+}
+
+int aw86927_ram_init(struct aw86927 *aw86927)
+{
+#ifdef AW_RAM_UPDATE_DELAY
+	int ram_timer_val = 5000;
+
+	aw_info("%s enter\n", __func__);
+	INIT_DELAYED_WORK(&aw86927->ram_work, aw86927_ram_work_routine);
+	queue_delayed_work(aw86927->work_queue, &aw86927->ram_work,
+			   msecs_to_jiffies(ram_timer_val));
+#else
+	aw86927_ram_update(aw86927);
+#endif
+	return 0;
+}
+
+int aw86927_haptics_upload_effect(struct input_dev *dev,
+				  struct ff_effect *effect,
+				  struct ff_effect *old)
+{
+	struct aw86927 *aw86927 = input_get_drvdata(dev);
+	struct qti_hap_play_info *play = &aw86927->play;
+	s16 data[CUSTOM_DATA_LEN];
+	ktime_t rem;
+	s64 time_us;
+	int ret;
+
+	/*for osc calibration*/
+	if (aw86927->osc_cali_run != 0)
+		return 0;
+
+	if (hrtimer_active(&aw86927->timer)) {
+		rem = hrtimer_get_remaining(&aw86927->timer);
+		time_us = ktime_to_us(rem);
+		aw_info("waiting for playing clear sequence: %lld us\n",
+			time_us);
+		usleep_range(time_us, time_us + 100);
+	}
+	aw_dbg("%s: effect->type=0x%x,FF_CONSTANT=0x%x,FF_PERIODIC=0x%x\n",
+	       __func__, effect->type, FF_CONSTANT, FF_PERIODIC);
+	aw86927->effect_type = effect->type;
+	mutex_lock(&aw86927->lock);
+	while (atomic_read(&aw86927->exit_in_rtp_loop)) {
+		aw_info("%s  goint to waiting rtp  exit\n", __func__);
+		mutex_unlock(&aw86927->lock);
+		ret = wait_event_interruptible(
+			aw86927->stop_wait_q,
+			atomic_read(&aw86927->exit_in_rtp_loop) == 0);
+		aw_info("%s wakeup\n", __func__);
+		if (ret == -ERESTARTSYS) {
+			mutex_unlock(&aw86927->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+		mutex_lock(&aw86927->lock);
+	}
+
+	if (aw86927->effect_type == FF_CONSTANT) {
+		aw_dbg("%s: effect_type is  FF_CONSTANT!\n", __func__);
+		/*cont mode set duration */
+		aw86927->duration = effect->replay.length;
+		aw86927->activate_mode = AW86927_ACTIVATE_RAM_LOOP_MODE;
+		aw86927->effect_id = aw86927->info.effect_id_boundary;
+
+	} else if (aw86927->effect_type == FF_PERIODIC) {
+		if (aw86927->effects_count == 0) {
+			mutex_unlock(&aw86927->lock);
+			return -EINVAL;
+		}
+
+		aw_dbg("%s: effect_type is  FF_PERIODIC!\n", __func__);
+		if (copy_from_user(data, effect->u.periodic.custom_data,
+				   sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw86927->lock);
+			return -EFAULT;
+		}
+
+		aw86927->effect_id = data[0];
+		aw_dbg("%s: aw86927->effect_id =%d\n", __func__,
+		       aw86927->effect_id);
+		play->vmax_mv = effect->u.periodic.magnitude; /*vmax level*/
+
+		if (aw86927->effect_id < 0 ||
+		    aw86927->effect_id > aw86927->info.effect_max) {
+			mutex_unlock(&aw86927->lock);
+			return 0;
+		}
+		aw86927->is_custom_wave = 0;
+
+		if (aw86927->effect_id < aw86927->info.effect_id_boundary) {
+			aw86927->activate_mode = AW86927_ACTIVATE_RAM_MODE;
+			aw_dbg("%s: aw86927->effect_id=%d , aw86927->activate_mode = %d\n",
+			       __func__, aw86927->effect_id,
+			       aw86927->activate_mode);
+			/*second data*/
+			data[1] = aw86927->predefined[aw86927->effect_id]
+					  .play_rate_us /
+				  1000000;
+			/*millisecond data*/
+			data[2] = aw86927->predefined[aw86927->effect_id]
+					  .play_rate_us /
+				  1000;
+		}
+		if (aw86927->effect_id >= aw86927->info.effect_id_boundary) {
+			aw86927->activate_mode = AW86927_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw86927->effect_id=%d , aw86927->activate_mode = %d\n",
+			       __func__, aw86927->effect_id,
+			       aw86927->activate_mode);
+			/*second data*/
+			data[1] = aw86927->info.rtp_time[aw86927->effect_id] /
+				  1000;
+			/*millisecond data*/
+			data[2] = aw86927->info.rtp_time[aw86927->effect_id];
+		}
+		if (aw86927->effect_id == CUSTOME_WAVE_ID) {
+			aw86927->activate_mode = AW86927_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw86927->effect_id=%d , aw86927->activate_mode = %d\n",
+			       __func__, aw86927->effect_id,
+			       aw86927->activate_mode);
+			/*second data*/
+			data[1] = aw86927->info.rtp_time[aw86927->effect_id] /
+				  1000;
+			/*millisecond data*/
+			data[2] = aw86927->info.rtp_time[aw86927->effect_id];
+			aw86927->is_custom_wave = 1;
+			rb_init();
+		}
+
+		if (copy_to_user(effect->u.periodic.custom_data, data,
+				 sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw86927->lock);
+			return -EFAULT;
+		}
+
+	} else {
+		aw_err("%s Unsupported effect type: %d\n", __func__,
+		       effect->type);
+	}
+	mutex_unlock(&aw86927->lock);
+	return 0;
+}
+
+int aw86927_haptics_playback(struct input_dev *dev, int effect_id, int val)
+{
+	struct aw86927 *aw86927 = input_get_drvdata(dev);
+	int rc = 0;
+
+	aw_dbg("%s: effect_id=%d , activate_mode = %d val = %d\n", __func__,
+	       aw86927->effect_id, aw86927->activate_mode, val);
+	/*for osc calibration*/
+	if (aw86927->osc_cali_run != 0)
+		return 0;
+
+	if (val > 0)
+		aw86927->state = 1;
+	if (val <= 0)
+		aw86927->state = 0;
+	hrtimer_cancel(&aw86927->timer);
+
+	if (aw86927->effect_type == FF_CONSTANT &&
+	    aw86927->activate_mode == AW86927_ACTIVATE_RAM_LOOP_MODE) {
+		aw_dbg("%s: enter cont_mode\n", __func__);
+		queue_work(aw86927->work_queue, &aw86927->vibrator_work);
+	} else if (aw86927->effect_type == FF_PERIODIC &&
+		   aw86927->activate_mode == AW86927_ACTIVATE_RAM_MODE) {
+		aw_dbg("%s: enter  ram_mode\n", __func__);
+		queue_work(aw86927->work_queue, &aw86927->vibrator_work);
+	} else if ((aw86927->effect_type == FF_PERIODIC) &&
+		   aw86927->activate_mode == AW86927_ACTIVATE_RTP_MODE) {
+		aw_dbg("%s: enter  rtp_mode\n", __func__);
+		queue_work(aw86927->work_queue, &aw86927->rtp_work);
+		/*if we are in the play mode, force to exit*/
+		if (val == 0) {
+			atomic_set(&aw86927->exit_in_rtp_loop, 1);
+			rb_force_exit();
+			wake_up_interruptible(&aw86927->stop_wait_q);
+		}
+	} else {
+		/*other mode */
+	}
+
+	return rc;
+}
+
+int aw86927_haptics_erase(struct input_dev *dev, int effect_id)
+{
+	struct aw86927 *aw86927 = input_get_drvdata(dev);
+	int rc = 0;
+
+	/*for osc calibration*/
+	if (aw86927->osc_cali_run != 0)
+		return 0;
+
+	aw_dbg("%s: enter\n", __func__);
+	aw86927->effect_type = 0;
+	aw86927->is_custom_wave = 0;
+	aw86927->duration = 0;
+	return rc;
+}
+
+void aw86927_haptics_set_gain_work_routine(struct work_struct *work)
+{
+	unsigned char comp_level = 0;
+	struct aw86927 *aw86927 =
+		container_of(work, struct aw86927, set_gain_work);
+
+	if (aw86927->new_gain >= 0x7FFF)
+		aw86927->level = 0x80; /*128 */
+	else if (aw86927->new_gain <= 0x3FFF)
+		aw86927->level = 0x1E; /*30 */
+	else
+		aw86927->level = (aw86927->new_gain - 16383) / 128;
+
+	if (aw86927->level < 0x1E)
+		aw86927->level = 0x1E; /*30 */
+	aw_info("%s: set_gain queue work, new_gain = %x level = %x\n", __func__,
+		aw86927->new_gain, aw86927->level);
+
+	if (aw86927->ram_vbat_comp == AW86927_RAM_VBAT_COMP_ENABLE &&
+	    aw86927->vbat) {
+		aw_dbg("%s: ref %d vbat %d ", __func__, AW_VBAT_REFER,
+		       aw86927->vbat);
+		comp_level = aw86927->level * AW_VBAT_REFER / aw86927->vbat;
+		if (comp_level > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			comp_level = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_dbg("%s: comp level limit is %d ", __func__,
+			       comp_level);
+		}
+		aw_info("%s: enable vbat comp, level = %x comp level = %x",
+			__func__, aw86927->level, comp_level);
+		aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG2, comp_level);
+	} else {
+		aw_dbg("%s: disable compsensation, vbat=%d, vbat_min=%d, vbat_ref=%d",
+		       __func__, aw86927->vbat, AW_VBAT_MIN, AW_VBAT_REFER);
+		aw86927_i2c_write(aw86927, AW86927_REG_PLAYCFG2,
+				  aw86927->level);
+	}
+}
+
+void aw86927_haptics_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct aw86927 *aw86927 = input_get_drvdata(dev);
+
+	aw_dbg("%s enter\n", __func__);
+	aw86927->new_gain = gain;
+	queue_work(aw86927->work_queue, &aw86927->set_gain_work);
+}
diff --git a/drivers/input/misc/aw86927_haptic/aw86927.h b/drivers/input/misc/aw86927_haptic/aw86927.h
new file mode 100644
index 000000000000..8464f24deb02
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw86927.h
@@ -0,0 +1,825 @@
+#ifndef _AW86927_H_
+#define _AW86927_H_
+/*********************************************************
+ *
+ * aw86927.h
+ *
+ ********************************************************/
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/leds.h>
+#include <linux/atomic.h>
+#include "aw_haptic.h"
+/*********************************************************
+ *
+ * marco
+ *
+ ********************************************************/
+#define AW86927_SEQUENCER_SIZE (8)
+#define AW86927_SEQUENCER_LOOP_SIZE (8)
+#define AW86927_TRIG_NUM (3)
+#define AW86927_MAX_BST_VO (0x7f)
+#define AW86927_REG_MAX (0Xff)
+#define AW86927_MAX_BST_VOL (0x7f) /* bst_vol-> 7 bit */
+#define AW86927_SYSINT_ERROR (1 << 0)
+#define AW86927_SYSINT_FF_AEI (1 << 1)
+#define AW86927_SYSINT_FF_AFI (1 << 2)
+
+enum aw86927_flags {
+	AW86927_FLAG_NONR = 0,
+	AW86927_FLAG_SKIP_INTERRUPTS = 1,
+};
+
+enum aw86927_haptic_cali_lra {
+	AW86927_WRITE_ZERO = 0,
+	AW86927_F0_CALI = 1,
+	AW86927_OSC_CALI = 2,
+};
+
+enum aw86927_haptic_bst_mode {
+	AW86927_BST_MODE_BYPASS = 0,
+	AW86927_BST_MODE = 1,
+};
+
+enum aw86927_haptic_cont_vbat_comp_mode {
+	AW86927_VBAT_SW_ADJUST_MODE = 0,
+	AW86927_VBAT_HW_ADJUST_MODE = 1,
+};
+enum aw86927_haptic_activate_mode {
+	AW86927_ACTIVATE_RAM_MODE = 0,
+	AW86927_ACTIVATE_CONT_MODE = 1,
+	AW86927_ACTIVATE_RTP_MODE = 2,
+	AW86927_ACTIVATE_RAM_LOOP_MODE = 3,
+};
+
+enum aw86927_haptic_cmd {
+	AW86927_HAPTIC_CMD_NULL = 0,
+	AW86927_HAPTIC_CMD_ENABLE = 1,
+	AW86927_HAPTIC_CMD_STOP = 255,
+};
+
+enum aw86927_haptic_play {
+	AW86927_HAPTIC_PLAY_NULL = 0,
+	AW86927_HAPTIC_PLAY_ENABLE = 1,
+	AW86927_HAPTIC_PLAY_STOP = 2,
+	AW86927_HAPTIC_PLAY_GAIN = 8,
+};
+
+enum aw86927_haptic_ram_vbat_compensate_mode {
+	AW86927_RAM_VBAT_COMP_DISABLE = 0,
+	AW86927_RAM_VBAT_COMP_ENABLE = 1,
+};
+
+enum aw86927_haptic_work_mode {
+	AW86927_STANDBY_MODE = 0,
+	AW86927_RAM_MODE = 1,
+	AW86927_RTP_MODE = 2,
+	AW86927_TRIG_MODE = 3,
+	AW86927_CONT_MODE = 4,
+	AW86927_RAM_LOOP_MODE = 5,
+};
+
+enum aw86927_haptic_strength {
+	AW86927_LIGHT_MAGNITUDE = 0x3fff,
+	AW86927_MEDIUM_MAGNITUDE = 0x5fff,
+	AW86927_STRONG_MAGNITUDE = 0x7fff,
+};
+
+enum aw86927_haptic_pwm_mode {
+	AW86927_PWM_48K = 0,
+	AW86927_PWM_24K = 1,
+	AW86927_PWM_12K = 2,
+};
+
+struct aw86927_dts_info {
+	unsigned int mode;
+	unsigned int f0_pre;
+	unsigned int f0_cali_percen;
+	unsigned int cont_drv1_lvl;
+	unsigned int cont_drv2_lvl;
+	unsigned int cont_drv1_time;
+	unsigned int cont_drv2_time;
+	unsigned int cont_wait_num;
+	unsigned int cont_brk_time;
+	unsigned int cont_track_margin;
+	unsigned int cont_tset;
+	unsigned int cont_drv_width;
+	unsigned int cont_bemf_set;
+	unsigned int cont_brk_gain;
+	unsigned int cont_bst_brk_gain;
+	unsigned int brk_bst_md;
+	unsigned int d2s_gain;
+	unsigned int bst_vol_default;
+	unsigned int bst_vol_ram;
+	unsigned int bst_vol_rtp;
+	unsigned int bstcfg[6];
+	unsigned int prctmode[3];
+	unsigned int sine_array[4];
+	unsigned int trig_config[24];
+	unsigned int effect_id_boundary;
+	unsigned int effect_max;
+	unsigned int rtp_time[175];
+};
+
+struct aw86927_trig {
+	unsigned char trig_level;
+	unsigned char trig_polar;
+	unsigned char pos_enable;
+	unsigned char pos_sequence;
+	unsigned char neg_enable;
+	unsigned char neg_sequence;
+	unsigned char trig_brk;
+	unsigned char trig_bst;
+};
+
+struct aw86927 {
+	struct i2c_client *i2c;
+	struct mutex lock;
+	struct mutex rtp_lock;
+	struct work_struct vibrator_work;
+	struct work_struct rtp_work;
+	struct work_struct set_gain_work;
+	struct delayed_work ram_work;
+
+	struct fileops fileops;
+	struct ram ram;
+
+	ktime_t kstart;
+	ktime_t kend;
+
+	struct timespec64 start, end;
+	unsigned int timeval_flags;
+	unsigned int osc_cali_flag;
+	unsigned long int microsecond;
+	unsigned int sys_frequency;
+	unsigned int rtp_len;
+	unsigned int lra_calib_data;
+	unsigned int f0_calib_data;
+
+	int reset_gpio;
+	int irq_gpio;
+
+	unsigned char hwen_flag;
+	unsigned char flags;
+	unsigned char chipid;
+
+	unsigned char play_mode;
+	unsigned char bst_mode;
+
+	unsigned char activate_mode;
+
+	unsigned char auto_boost;
+
+	int state;
+	int duration;
+	int amplitude;
+	int index;
+	int vmax;
+	int gain;
+	u16 new_gain;
+	unsigned char level;
+
+	unsigned char seq[AW86927_SEQUENCER_SIZE];
+	unsigned char loop[AW86927_SEQUENCER_SIZE];
+
+	unsigned int rtp_cnt;
+	unsigned int rtp_file_num;
+	unsigned int rtp_num_max;
+
+	unsigned char rtp_init;
+	unsigned char ram_init;
+	unsigned char rtp_routine_on;
+
+	unsigned int f0;
+	unsigned int cont_f0;
+	unsigned char max_pos_beme;
+	unsigned char max_neg_beme;
+	unsigned char f0_cali_flag;
+	bool f0_cali_status;
+	unsigned int osc_cali_run;
+
+	unsigned char ram_vbat_comp;
+	unsigned int vbat;
+	unsigned int lra;
+
+	struct aw86927_trig trig[AW86927_TRIG_NUM];
+
+	struct haptic_audio haptic_audio;
+	struct aw86927_dts_info info;
+	atomic_t is_in_rtp_loop;
+	atomic_t exit_in_rtp_loop;
+	atomic_t is_in_write_loop;
+	wait_queue_head_t wait_q; /*wait queue for exit irq mode */
+	wait_queue_head_t stop_wait_q; /* wait queue for stop rtp mode */
+	struct workqueue_struct *work_queue;
+
+#ifdef INPUT_DEV
+	struct platform_device *pdev;
+	struct device *dev;
+	struct regmap *regmap;
+	struct input_dev *input_dev;
+	struct pwm_device *pwm_dev;
+	struct qti_hap_config config;
+	struct qti_hap_play_info play;
+	struct qti_hap_effect *predefined;
+	struct qti_hap_effect constant;
+	struct regulator *vdd_supply;
+	struct hrtimer stop_timer;
+	struct hrtimer hap_disable_timer;
+	struct hrtimer timer; /*test used  ,del */
+	struct dentry *hap_debugfs;
+	spinlock_t bus_lock;
+	ktime_t last_sc_time;
+	int play_irq;
+	int sc_irq;
+	int effects_count;
+	int sc_det_count;
+	u16 reg_base;
+	bool perm_disable;
+	bool play_irq_en;
+	bool vdd_enabled;
+	int effect_type;
+	int effect_id;
+	int test_val;
+	int is_custom_wave;
+#endif
+};
+
+struct aw86927_container {
+	int len;
+	unsigned char data[];
+};
+
+/********************************************
+ *  AW86927 Register List
+ *******************************************/
+#define AW86927_REG_RSTCFG (0x00)
+#define AW86927_REG_SYSST (0x01)
+#define AW86927_REG_SYSINT (0x02)
+#define AW86927_REG_SYSINTM (0x03)
+#define AW86927_REG_SYSST2 (0x04)
+#define AW86927_REG_SYSER (0x05)
+#define AW86927_REG_PLAYCFG1 (0x06)
+#define AW86927_REG_PLAYCFG2 (0x07)
+#define AW86927_REG_PLAYCFG3 (0x08)
+#define AW86927_REG_PLAYCFG4 (0x09)
+#define AW86927_REG_WAVCFG1 (0x0A)
+#define AW86927_REG_WAVCFG2 (0x0B)
+#define AW86927_REG_WAVCFG3 (0x0C)
+#define AW86927_REG_WAVCFG4 (0x0D)
+#define AW86927_REG_WAVCFG5 (0x0E)
+#define AW86927_REG_WAVCFG6 (0x0F)
+#define AW86927_REG_WAVCFG7 (0x10)
+#define AW86927_REG_WAVCFG8 (0x11)
+#define AW86927_REG_WAVCFG9 (0x12)
+#define AW86927_REG_WAVCFG10 (0x13)
+#define AW86927_REG_WAVCFG11 (0x14)
+#define AW86927_REG_WAVCFG12 (0x15)
+#define AW86927_REG_WAVCFG13 (0x16)
+#define AW86927_REG_CONTCFG1 (0x18)
+#define AW86927_REG_CONTCFG2 (0x19)
+#define AW86927_REG_CONTCFG3 (0x1A)
+#define AW86927_REG_CONTCFG4 (0x1B)
+#define AW86927_REG_CONTCFG5 (0x1C)
+#define AW86927_REG_CONTCFG6 (0x1D)
+#define AW86927_REG_CONTCFG7 (0x1E)
+#define AW86927_REG_CONTCFG8 (0x1F)
+#define AW86927_REG_CONTCFG9 (0x20)
+#define AW86927_REG_CONTCFG10 (0x21)
+#define AW86927_REG_CONTCFG11 (0x22)
+#define AW86927_REG_CONTCFG12 (0x23)
+#define AW86927_REG_CONTCFG13 (0x24)
+#define AW86927_REG_CONTCFG14 (0x25)
+#define AW86927_REG_CONTCFG15 (0x26)
+#define AW86927_REG_CONTCFG16 (0x27)
+#define AW86927_REG_CONTCFG17 (0x28)
+#define AW86927_REG_CONTCFG18 (0x29)
+#define AW86927_REG_CONTCFG19 (0x2A)
+#define AW86927_REG_CONTCFG20 (0x2B)
+#define AW86927_REG_CONTCFG21 (0x2C)
+#define AW86927_REG_RTPCFG1 (0x2D)
+#define AW86927_REG_RTPCFG2 (0x2E)
+#define AW86927_REG_RTPCFG3 (0x2F)
+#define AW86927_REG_RTPCFG4 (0x30)
+#define AW86927_REG_RTPCFG5 (0x31)
+#define AW86927_REG_RTPDATA (0X32)
+#define AW86927_REG_TRGCFG1 (0x33)
+#define AW86927_REG_TRGCFG2 (0x34)
+#define AW86927_REG_TRGCFG3 (0x35)
+#define AW86927_REG_TRGCFG4 (0x36)
+#define AW86927_REG_TRGCFG5 (0x37)
+#define AW86927_REG_TRGCFG6 (0x38)
+#define AW86927_REG_TRGCFG7 (0x39)
+#define AW86927_REG_TRGCFG8 (0x3A)
+#define AW86927_REG_GLBCFG1 (0x3B)
+#define AW86927_REG_GLBCFG2 (0x3C)
+#define AW86927_REG_GLBCFG3 (0x3D)
+#define AW86927_REG_GLBCFG4 (0x3E)
+#define AW86927_REG_GLBRD5 (0x3F)
+#define AW86927_REG_RAMADDRH (0x40)
+#define AW86927_REG_RAMADDRL (0x41)
+#define AW86927_REG_RAMDATA (0x42)
+#define AW86927_REG_SYSCTRL1 (0x43)
+#define AW86927_REG_SYSCTRL2 (0x44)
+#define AW86927_REG_SYSCTRL3 (0x45)
+#define AW86927_REG_SYSCTRL4 (0x46)
+#define AW86927_REG_SYSCTRL5 (0x47)
+#define AW86927_REG_PWMCFG1 (0x48)
+#define AW86927_REG_PWMCFG2 (0x49)
+#define AW86927_REG_PWMCFG3 (0x4A)
+#define AW86927_REG_PWMCFG4 (0x4B)
+#define AW86927_REG_VBATCTRL (0x4C)
+#define AW86927_REG_DETCFG1 (0x4D)
+#define AW86927_REG_DETCFG2 (0x4E)
+#define AW86927_REG_DETRD1 (0x4F)
+#define AW86927_REG_DETRD2 (0x50)
+#define AW86927_REG_DETRD3 (0x51)
+#define AW86927_REG_TRIMCFG1 (0x52)
+#define AW86927_REG_TRIMCFG2 (0x53)
+#define AW86927_REG_TRIMCFG3 (0x54)
+#define AW86927_REG_TRIMCFG4 (0x55)
+#define AW86927_REG_IDH (0x57)
+#define AW86927_REG_IDL (0x58)
+#define AW86927_REG_TMCFG (0x5B)
+#define AW86927_REG_EFCFG6 (0x61)
+#define AW86927_REG_TESTR (0x65)
+#define AW86927_REG_ANACFG1 (0x66)
+#define AW86927_REG_ANACFG2 (0x67)
+#define AW86927_REG_ANACFG7 (0x6C)
+#define AW86927_REG_ANACFG12 (0x71)
+#define AW86927_REG_ANACFG13 (0x72)
+#define AW86927_REG_ANACFG15 (0x74)
+#define AW86927_REG_ANACFG16 (0x75)
+#define AW86927_REG_ANACFG20 (0x79)
+#define AW86927_REG_ANACFG22 (0x7C)
+
+/******************************************************
+ * AW86927 Register Detail
+ *****************************************************/
+/* SYSST: reg 0x01 RO */
+#define AW86927_BIT_SYSST_BST_SCPS (1 << 7)
+#define AW86927_BIT_SYSST_BST_OVPS (1 << 6)
+#define AW86927_BIT_SYSST_UVLS (1 << 5)
+#define AW86927_BIT_SYSST_FF_AES (1 << 4)
+#define AW86927_BIT_SYSST_FF_AFS (1 << 3)
+#define AW86927_BIT_SYSST_OCDS (1 << 2)
+#define AW86927_BIT_SYSST_OTS (1 << 1)
+#define AW86927_BIT_SYSST_DONES (1 << 0)
+/* SYSINT: reg 0x02 RC */
+#define AW86927_BIT_SYSINT_BST_SCPI (1 << 7)
+#define AW86927_BIT_SYSINT_BST_OVPI (1 << 6)
+#define AW86927_BIT_SYSINT_UVLI (1 << 5)
+#define AW86927_BIT_SYSINT_FF_AEI (1 << 4)
+#define AW86927_BIT_SYSINT_FF_AFI (1 << 3)
+#define AW86927_BIT_SYSINT_OCDI (1 << 2)
+#define AW86927_BIT_SYSINT_OTI (1 << 1)
+#define AW86927_BIT_SYSINT_DONEI (1 << 0)
+
+/* SYSINTM: reg 0x03 RW */
+#define AW86927_BIT_SYSINTM_BST_SCPM_MASK (~(1 << 7))
+#define AW86927_BIT_SYSINTM_BST_SCPM_OFF (1 << 7)
+#define AW86927_BIT_SYSINTM_BST_SCPM_ON (0 << 7)
+#define AW86927_BIT_SYSINTM_BST_OVPM_MASK (~(1 << 6))
+#define AW86927_BIT_SYSINTM_BST_OVPM_OFF (1 << 6)
+#define AW86927_BIT_SYSINTM_BST_OVPM_ON (0 << 6)
+#define AW86927_BIT_SYSINTM_UVLM_MASK (~(1 << 5))
+#define AW86927_BIT_SYSINTM_UVLM_OFF (1 << 5)
+#define AW86927_BIT_SYSINTM_UVLM_ON (0 << 5)
+#define AW86927_BIT_SYSINTM_FF_AEM_MASK (~(1 << 4))
+#define AW86927_BIT_SYSINTM_FF_AEM_OFF (1 << 4)
+#define AW86927_BIT_SYSINTM_FF_AEM_ON (0 << 4)
+#define AW86927_BIT_SYSINTM_FF_AFM_MASK (~(1 << 3))
+#define AW86927_BIT_SYSINTM_FF_AFM_OFF (1 << 3)
+#define AW86927_BIT_SYSINTM_FF_AFM_ON (0 << 3)
+#define AW86927_BIT_SYSINTM_OCDM_MASK (~(1 << 2))
+#define AW86927_BIT_SYSINTM_OCDM_OFF (1 << 2)
+#define AW86927_BIT_SYSINTM_OCDM_ON (0 << 2)
+#define AW86927_BIT_SYSINTM_OTM_MASK (~(1 << 1))
+#define AW86927_BIT_SYSINTM_OTM_OFF (1 << 1)
+#define AW86927_BIT_SYSINTM_OTM_ON (0 << 1)
+#define AW86927_BIT_SYSINTM_DONEM_MASK (~(1 << 0))
+#define AW86927_BIT_SYSINTM_DONEM_OFF (1 << 0)
+#define AW86927_BIT_SYSINTM_DONEM_ON (0 << 0)
+
+/* SYSST2: reg 0x04 RO */
+#define AW86927_BIT_SYSST2_BST_OK (1 << 4)
+#define AW86927_BIT_SYSST2_VBG_OK (1 << 3)
+#define AW86927_BIT_SYSST2_LDO_OK (1 << 2)
+#define AW86927_BIT_SYSST2_FF_FULL (1 << 1)
+#define AW86927_BIT_SYSST2_FF_EMPTY (1 << 0)
+
+/* PLAYCFG1: reg 0x06 RW */
+#define AW86927_BIT_PLAYCFG1_BST_MODE_MASK (~(1 << 7))
+#define AW86927_BIT_PLAYCFG1_BST_MODE (1 << 7)
+#define AW86927_BIT_PLAYCFG1_BST_MODE_BYPASS (0 << 7)
+#define AW86927_BIT_PLAYCFG1_BST_VOUT_VREFSET_MASK (~(0x7F << 0))
+#define AW86927_BIT_PLAYCFG1_BST_VOUT_VREFSET (0x7F)
+#define AW86927_BIT_PLAYCFG1_BST_VOUT_10P5V (0x70)
+#define AW86927_BIT_PLAYCFG1_BST_VOUT_6V (0x28)
+
+/* PLAYCFG3: reg 0x08 RW */
+#define AW86927_BIT_PLAYCFG3_ONEWIRE_COMP_MASK (~(1 << 5))
+#define AW86927_BIT_PLAYCFG3_1908_ONEWIRE_MODE (1 << 5)
+#define AW86927_BIT_PLAYCFG3_2102_ONEWIRE_MODE (0 << 5)
+#define AW86927_BIT_PLAYCFG3_AUTO_BST_MASK (~(1 << 4))
+#define AW86927_BIT_PLAYCFG3_AUTO_BST_ENABLE (1 << 4)
+#define AW86927_BIT_PLAYCFG3_AUTO_BST_DISABLE (0 << 4)
+#define AW86927_BIT_PLAYCFG3_STOP_MODE_MASK (~(1 << 3))
+#define AW86927_BIT_PLAYCFG3_STOP_MODE_NOW (1 << 3)
+#define AW86927_BIT_PLAYCFG3_STOP_MODE_LATER (0 << 3)
+#define AW86927_BIT_PLAYCFG3_BRK_EN_MASK (~(1 << 2))
+#define AW86927_BIT_PLAYCFG3_BRK_ENABLE (1 << 2)
+#define AW86927_BIT_PLAYCFG3_BRK_DISABLE (0 << 2)
+#define AW86927_BIT_PLAYCFG3_PLAY_MODE_MASK (~(3 << 0))
+#define AW86927_BIT_PLAYCFG3_PLAY_MODE_STOP (3 << 0)
+#define AW86927_BIT_PLAYCFG3_PLAY_MODE_CONT (2 << 0)
+#define AW86927_BIT_PLAYCFG3_PLAY_MODE_RTP (1 << 0)
+#define AW86927_BIT_PLAYCFG3_PLAY_MODE_RAM (0 << 0)
+
+/* PLAYCFG4: reg 0x09 RW */
+#define AW86927_BIT_PLAYCFG4_STOP_MASK (~(1 << 1))
+#define AW86927_BIT_PLAYCFG4_STOP_ON (1 << 1)
+#define AW86927_BIT_PLAYCFG4_STOP_OFF (0 << 1)
+#define AW86927_BIT_PLAYCFG4_GO_MASK (~(1 << 0))
+#define AW86927_BIT_PLAYCFG4_GO_ON (1 << 0)
+#define AW86927_BIT_PLAYCFG4_GO_OFF (0 << 0)
+
+/* WAVCFG9-12: reg 0x12 - reg 0x15 RW */
+#define AW86927_BIT_WAVLOOP_SEQ_ODD_MASK (~(0x0F << 4))
+#define AW86927_BIT_WAVLOOP_SEQ_ODD_INIFINITELY (0x0F << 4)
+#define AW86927_BIT_WAVLOOP_SEQ_EVEN_MASK (~(0x0F << 0))
+#define AW86927_BIT_WAVLOOP_SEQ_EVEN_INIFINITELY (0x0F << 0)
+#define AW86927_BIT_WAVLOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG9: reg 0x12 RW */
+#define AW86927_BIT_WAVCFG9_SEQ1LOOP_MASK (~(0x0F << 4))
+#define AW86927_BIT_WAVCFG9_SEQ1LOOP_INIFINITELY (0x0F << 4)
+#define AW86927_BIT_WAVCFG9_SEQ2LOOP_MASK (~(0x0F << 0))
+#define AW86927_BIT_WAVCFG9_SEQ2LOOP_INIFINITELY (0x0F << 0)
+
+/***************** CONT *****************/
+/* CONTCFG1: reg 0x18 RW */
+#define AW86927_BIT_CONTCFG1_BRK_BST_MD_MASK (~(1 << 6))
+#define AW86927_BIT_CONTCFG1_BRK_BST_MD_ENABLE (1 << 6)
+#define AW86927_BIT_CONTCFG1_BRK_BST_MD_DISABLE (0 << 6)
+#define AW86927_BIT_CONTCFG1_EN_F0_DET_MASK (~(1 << 5))
+#define AW86927_BIT_CONTCFG1_F0_DET_ENABLE (1 << 5)
+#define AW86927_BIT_CONTCFG1_F0_DET_DISABLE (0 << 5)
+#define AW86927_BIT_CONTCFG1_SIN_MODE_MASK (~(1 << 1))
+#define AW86927_BIT_CONTCFG1_SIN_MODE_COS (1 << 1)
+#define AW86927_BIT_CONTCFG1_SIN_MODE_SINE (0 << 1)
+#define AW86927_BIT_CONTCFG1_EDGE_FRE_MASK (~(0x0F << 0))
+
+/* CONTCFG5: reg 0x1C RW */
+#define AW86927_BIT_CONTCFG5_BST_BRK_GAIN_MASK (~(0x0F << 4))
+#define AW86927_BIT_CONTCFG5_BRK_GAIN_MASK (~(0x0F << 0))
+
+/* CONTCFG6: reg 0x1D RW */
+#define AW86927_BIT_CONTCFG6_TRACK_EN_MASK (~(1 << 7))
+#define AW86927_BIT_CONTCFG6_TRACK_ENABLE (1 << 7)
+#define AW86927_BIT_CONTCFG6_TRACK_DISABLE (0 << 7)
+#define AW86927_BIT_CONTCFG6_DRV1_LVL_MASK (~(0x7F << 0))
+
+/* CONTCFG7: reg 0x1E RW */
+#define AW86927_BIT_CONTCFG7_DRV2_LVL_MASK (~(0x7F << 0))
+/* CONTCFG13: reg 0x24 RW */
+#define AW86927_BIT_CONTCFG13_TSET_MASK (~(0x0F << 4))
+#define AW86927_BIT_CONTCFG13_BEME_SET_MASK (~(0x0F << 0))
+/***************** RTP *****************/
+/* RTPCFG1: reg 0x2D RW */
+#define AW86927_BIT_RTPCFG1_TWORTP_EN_MASK (~(1 << 6))
+#define AW86927_BIT_RTPCFG1_TWORTP_ENABLE (1 << 6)
+#define AW86927_BIT_RTPCFG1_TWORTP_DISABLE (0 << 6)
+#define AW86927_BIT_RTPCFG1_BASE_ADDR_H_MASK (~(0x1F << 0))
+
+/* RTPCFG3: reg 0x2F RW */
+#define AW86927_BIT_RTPCFG3_FIFO_AEH_MASK (~(0x0F << 4))
+#define AW86927_BIT_RTPCFG3_FIFO_AFH_MASK (~(0x0F << 0))
+
+/***************** TRIGGER *****************/
+#define AW86927_BIT_TRG_ENABLE_MASK (~(1 << 7))
+#define AW86927_BIT_TRG_ENABLE (1 << 7)
+#define AW86927_BIT_TRG_DISABLE (0 << 7)
+#define AW86927_BIT_TRG_SEQ_MASK (~(0x7F << 0))
+/* TRGCFG1: reg 0x33 RW */
+#define AW86927_BIT_TRGCFG1_TRG1_POS_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG1_TRG1_POS_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG1_TRG1_POS_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG1_TRG1SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG2: reg 0x34 RW */
+#define AW86927_BIT_TRGCFG2_TRG2_POS_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG2_TRG2_POS_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG2_TRG2_POS_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG2_TRG2SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG3: reg 0x35 RW */
+#define AW86927_BIT_TRGCFG3_TRG3_POS_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG3_TRG3_POS_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG3_TRG3_POS_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG3_TRG3SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG4: reg 0x36 RW */
+#define AW86927_BIT_TRGCFG4_TRG1_NEG_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG4_TRG1_NEG_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG4_TRG1_NEG_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG4_TRG1SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG5: reg 0x37 RW */
+#define AW86927_BIT_TRGCFG5_TRG2_NEG_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG5_TRG2_NEG_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG5_TRG2_NEG_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG5_TRG2SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG6: reg 0x38 RW */
+#define AW86927_BIT_TRGCFG6_TRG3_NEG_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG6_TRG3_NEG_ENABLE (1 << 7)
+#define AW86927_BIT_TRGCFG6_TRG3_NEG_DISABLE (0 << 7)
+#define AW86927_BIT_TRGCFG6_TRG3SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG7: reg 0x39 RW */
+#define AW86927_BIT_TRGCFG7_TRG1_POLAR_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG7_TRG1_POLAR_NEG (1 << 7)
+#define AW86927_BIT_TRGCFG7_TRG1_POLAR_POS (0 << 7)
+#define AW86927_BIT_TRGCFG7_TRG1_MODE_MASK (~(1 << 6))
+#define AW86927_BIT_TRGCFG7_TRG1_MODE_LEVEL (1 << 6)
+#define AW86927_BIT_TRGCFG7_TRG1_MODE_EDGE (0 << 6)
+#define AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK (~(1 << 5))
+#define AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_ENABLE (1 << 5)
+#define AW86927_BIT_TRGCFG7_TRG1_AUTO_BRK_DISABLE (0 << 5)
+#define AW86927_BIT_TRGCFG7_TRG1_BST_MASK (~(1 << 4))
+#define AW86927_BIT_TRGCFG7_TRG1_BST_ENABLE (1 << 4)
+#define AW86927_BIT_TRGCFG7_TRG1_BST_DISABLE (0 << 4)
+#define AW86927_BIT_TRGCFG7_TRG2_POLAR_MASK (~(1 << 3))
+#define AW86927_BIT_TRGCFG7_TRG2_POLAR_NEG (1 << 3)
+#define AW86927_BIT_TRGCFG7_TRG2_POLAR_POS (0 << 3)
+#define AW86927_BIT_TRGCFG7_TRG2_MODE_MASK (~(1 << 2))
+#define AW86927_BIT_TRGCFG7_TRG2_MODE_LEVEL (1 << 2)
+#define AW86927_BIT_TRGCFG7_TRG2_MODE_EDGE (0 << 2)
+#define AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK (~(1 << 1))
+#define AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_ENABLE (1 << 1)
+#define AW86927_BIT_TRGCFG7_TRG2_AUTO_BRK_DISABLE (0 << 1)
+#define AW86927_BIT_TRGCFG7_TRG2_BST_MASK (~(1 << 0))
+#define AW86927_BIT_TRGCFG7_TRG2_BST_ENABLE (1 << 0)
+#define AW86927_BIT_TRGCFG7_TRG2_BST_DISABLE (0 << 0)
+
+/* TRGCFG8: reg 0x3A RW */
+#define AW86927_BIT_TRGCFG8_TRG3_POLAR_MASK (~(1 << 7))
+#define AW86927_BIT_TRGCFG8_TRG3_POLAR_NEG (1 << 7)
+#define AW86927_BIT_TRGCFG8_TRG3_POLAR_POS (0 << 7)
+#define AW86927_BIT_TRGCFG8_TRG3_MODE_MASK (~(1 << 6))
+#define AW86927_BIT_TRGCFG8_TRG3_MODE_LEVEL (1 << 6)
+#define AW86927_BIT_TRGCFG8_TRG3_MODE_EDGE (0 << 6)
+#define AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK (~(1 << 5))
+#define AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_ENABLE (1 << 5)
+#define AW86927_BIT_TRGCFG8_TRG3_AUTO_BRK_DISABLE (0 << 5)
+#define AW86927_BIT_TRGCFG8_TRG3_BST_MASK (~(1 << 4))
+#define AW86927_BIT_TRGCFG8_TRG3_BST_ENABLE (1 << 4)
+#define AW86927_BIT_TRGCFG8_TRG3_BST_DISABLE (0 << 4)
+#define AW86927_BIT_TRGCFG8_TRG_ONEWIRE_MASK (~(1 << 3))
+#define AW86927_BIT_TRGCFG8_TRG_ONEWIRE_ENABLE (1 << 3)
+#define AW86927_BIT_TRGCFG8_TRG_ONEWIRE_DISABLE (0 << 3)
+#define AW86927_BIT_TRGCFG8_TRG1_STOP_MASK (~(1 << 2))
+#define AW86927_BIT_TRGCFG8_TRG1_STOP (1 << 2)
+#define AW86927_BIT_TRGCFG8_TRG2_STOP_MASK (~(1 << 1))
+#define AW86927_BIT_TRGCFG8_TRG2_STOP (1 << 1)
+#define AW86927_BIT_TRGCFG8_TRG3_STOP_MASK (~(1 << 0))
+#define AW86927_BIT_TRGCFG8_TRG3_STOP (1 << 0)
+
+/* GLBCFG2: reg 0x3C RW */
+/* START_DLY */
+#define AW86927_BIT_START_DLY_20US (0x01)
+#define AW86927_BIT_START_DLY_2P5MS (0x75)
+/* GLBCFG4: reg 0x3E RW */
+#define AW86927_BIT_GLBCFG4_GO_PRIO_MASK (~(3 << 6))
+#define AW86927_BIT_GLBCFG4_TRG3_PRIO_MASK (~(3 << 4))
+#define AW86927_BIT_GLBCFG4_TRG2_PRIO_MASK (~(3 << 2))
+#define AW86927_BIT_GLBCFG4_TRG1_PRIO_MASK (~(3 << 0))
+
+/* GLBRD5: reg 0x3F R0 */
+/* GLB_STATE [3:0] */
+#define AW86927_BIT_GLBRD5_STATE_MASK (~(15 << 0))
+#define AW86927_BIT_GLBRD5_STATE_STANDBY (0 << 0)
+#define AW86927_BIT_GLBRD5_STATE_WAKEUP (1 << 0)
+#define AW86927_BIT_GLBRD5_STATE_STARTUP (2 << 0)
+#define AW86927_BIT_GLBRD5_STATE_WAIT (3 << 0)
+#define AW86927_BIT_GLBRD5_STATE_CONT_GO (6 << 0)
+#define AW86927_BIT_GLBRD5_STATE_RAM_GO (7 << 0)
+#define AW86927_BIT_GLBRD5_STATE_RTP_GO (8 << 0)
+#define AW86927_BIT_GLBRD5_STATE_TRIG_GO (9 << 0)
+#define AW86927_BIT_GLBRD5_STATE_I2S_GO (10 << 0)
+#define AW86927_BIT_GLBRD5_STATE_BRAKE (11 << 0)
+#define AW86927_BIT_GLBRD5_STATE_END (12 << 0)
+/* RAMADDRH: reg 0x40 RWS */
+#define AW86927_BIT_RAMADDRH_MASK (~(0x1F << 0))
+/* SYSCTRL2: reg 0x44 RWS */
+#define AW86927_BIT_SYSCTRL2_SLOT_CHSEL_MASK (~(1 << 5))
+#define AW86927_BIT_SYSCTRL2_RTP_SLOT_ONE (0 << 5)
+#define AW86927_BIT_SYSCTRL2_RTP_SLOT_TWO (1 << 5)
+/* SYSCTRL3: reg 0x45 RW */
+#define AW86927_BIT_SYSCTRL3_WCK_PIN_MASK (~(1 << 7))
+#define AW86927_BIT_SYSCTRL3_WCK_PIN_ON (1 << 7)
+#define AW86927_BIT_SYSCTRL3_WCK_PIN_OFF (0 << 7)
+#define AW86927_BIT_SYSCTRL3_WAKE_MASK (~(1 << 6))
+#define AW86927_BIT_SYSCTRL3_WAKE_ON (1 << 6)
+#define AW86927_BIT_SYSCTRL3_WAKE_OFF (0 << 6)
+#define AW86927_BIT_SYSCTRL3_STANDBY_MASK (~(1 << 5))
+#define AW86927_BIT_SYSCTRL3_STANDBY_ON (1 << 5)
+#define AW86927_BIT_SYSCTRL3_STANDBY_OFF (0 << 5)
+
+#define AW86927_BIT_SYSCTRL3_RTP_DLY_MASK (~(3 << 3))
+
+#define AW86927_BIT_SYSCTRL3_EN_RAMINIT_MASK (~(1 << 2))
+#define AW86927_BIT_SYSCTRL3_EN_RAMINIT_ON (1 << 2)
+#define AW86927_BIT_SYSCTRL3_EN_RAMINIT_OFF (0 << 2)
+#define AW86927_BIT_SYSCTRL3_EN_FIR_MASK (~(1 << 1))
+#define AW86927_BIT_SYSCTRL3_EN_FIR_ON (1 << 1)
+#define AW86927_BIT_SYSCTRL3_EN_FIR_OFF (0 << 1)
+#define AW86927_BIT_SYSCTRL3_WAKE_MODE_MASK (~(1 << 0))
+#define AW86927_BIT_SYSCTRL3_WAKE_MODE_ON (1 << 0)
+#define AW86927_BIT_SYSCTRL3_WAKE_MODE_OFF (0 << 0)
+
+/* SYSCTRL4: reg 0x46 RW */
+#define AW86927_BIT_SYSCTRL4_EN_INTN_CLKOUT_MASK (~(1 << 7))
+#define AW86927_BIT_SYSCTRL4_EN_INTN_CLKOUT_ON (1 << 7)
+#define AW86927_BIT_SYSCTRL4_EN_INTN_CLKOUT_OFF (0 << 7)
+#define AW86927_BIT_SYSCTRL4_WAVDAT_MODE_MASK (~(3 << 5))
+#define AW86927_BIT_SYSCTRL4_WAVDAT_12K (2 << 5)
+#define AW86927_BIT_SYSCTRL4_WAVDAT_48K (1 << 5)
+#define AW86927_BIT_SYSCTRL4_WAVDAT_24K (0 << 5)
+#define AW86927_BIT_SYSCTRL4_INT_EDGE_MODE_MASK (~(1 << 4))
+#define AW86927_BIT_SYSCTRL4_INT_EDGE_MODE_POS (0 << 4)
+#define AW86927_BIT_SYSCTRL4_INT_EDGE_MODE_BOTH (1 << 4)
+#define AW86927_BIT_SYSCTRL4_INT_MODE_MASK (~(1 << 3))
+#define AW86927_BIT_SYSCTRL4_INT_MODE_EDGE (1 << 3)
+#define AW86927_BIT_SYSCTRL4_INT_MODE_LEVEL (0 << 3)
+#define AW86927_BIT_SYSCTRL4_GAIN_BYPASS_MASK (~(1 << 0))
+#define AW86927_BIT_SYSCTRL4_GAIN_FIXED (0 << 0)
+#define AW86927_BIT_SYSCTRL4_GAIN_CHANGEABLE (1 << 0)
+/* SYSCTRL5: reg 0x47 RW */
+#define AW86927_BIR_SYSCTRL5_INIT_VAL (0x5A)
+#define AW86927_BIT_SYSCTRL5_EN_BRO_ADDR_MASK (~(1 << 7))
+#define AW86927_BIT_SYSCTRL5_EN_BRO_ADDR_ON (1 << 7)
+#define AW86927_BIT_SYSCTRL5_EN_BRO_ADDR_OFF (0 << 7)
+#define AW86927_BIT_SYSCTRL5_BROADCAST_ADDR_MASK (~(0x7F << 0))
+
+/* PWMCFG1: reg 0x48 RW */
+#define AW86927_BIT_PWMCFG1_PRC_EN_MASK (~(1 << 7))
+#define AW86927_BIT_PWMCFG1_PRC_ENABLE (1 << 7)
+#define AW86927_BIT_PWMCFG1_PRC_DISABLE (0 << 7)
+#define AW86927_BIT_PWMCFG1_PRCTIME_MASK (~(0x7F << 0))
+#define AW86927_BIT_PWMCFG1_INIT_VAL (0xA0)
+
+/* PWMCFG2: reg 0x49 RW */
+#define AW86927_BIT_PWMCFG2_PRCT_MODE_MASK (~(1 << 6))
+#define AW86927_BIT_PWMCFG2_PRCT_MODE_VALID (0 << 6)
+#define AW86927_BIT_PWMCFG2_PRCT_MODE_INVALID (1 << 6)
+#define AW86927_BIT_PWMCFG2_REF_SEL_MASK (~(1 << 5))
+#define AW86927_BIT_PWMCFG2_REF_SEL_TRIANGLE (1 << 5)
+#define AW86927_BIT_PWMCFG2_REF_SEL_SAWTOOTH (0 << 5)
+#define AW86927_BIT_PWMCFG2_PD_HWM_MASK (~(1 << 4))
+#define AW86927_BIT_PWMCFG2_PD_HWM_ON (1 << 4)
+#define AW86927_BIT_PWMCFG2_PWMOE_MASK (~(1 << 3))
+#define AW86927_BIT_PWMCFG2_PWMOE_ON (1 << 3)
+#define AW86927_BIT_PWMCFG2_PWMFRC_MASK (~(7 << 0))
+
+/* PWMCFG3: reg 0x4A RW */
+#define AW86927_BIT_PWMCFG3_PR_EN_MASK (~(1 << 7))
+#define AW86927_BIT_PWMCFG3_PR_ENABLE (1 << 7)
+#define AW86927_BIT_PWMCFG3_PR_DISABLE (0 << 7)
+#define AW86927_BIT_PWMCFG3_PRLVL_MASK (~(0x7F << 0))
+
+/* VBATCTRL: reg 0x4C RW */
+#define AW86927_BIT_VBATCTRL_VBAT_PRO_MASK (~(1 << 7))
+#define AW86927_BIT_VBATCTRL_VBAT_PRO_ENABLE (1 << 7)
+#define AW86927_BIT_VBATCTRL_VBAT_PRO_DISABLE (0 << 7)
+
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_MASK (~(1 << 6))
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_HW (1 << 6)
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_SW (0 << 6)
+
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_CON_MASK (~(1 << 5))
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_CON_DURING (1 << 5)
+#define AW86927_BIT_VBATCTRL_VBAT_MODE_CON_BEFORE (0 << 5)
+
+#define AW86927_BIT_VBATCTRL_DELTA_VBAT_MASK (~(1 << 4))
+#define AW86927_BIT_VBATCTRL_DELTA_VBAT_0P2V (1 << 4)
+#define AW86927_BIT_VBATCTRL_DELTA_VBAT_0P1V (0 << 4)
+
+#define AW86927_BIT_VBATCTRL_REL_VBAT_MASK (~(3 << 2))
+#define AW86927_BIT_VBATCTRL_ABS_VBAT_MASK (~(3 << 0))
+
+/* DETCFG1: reg 0x4D RW */
+#define AW86927_BIT_DETCFG1_VBAT_REF_MASK (~(7 << 4))
+#define AW86927_BIT_DETCFG1_ADC_FS_MASK (~(3 << 2))
+#define AW86927_BIT_DETCFG1_ADC_FS_192KHZ (0 << 2)
+#define AW86927_BIT_DETCFG1_ADC_FS_96KHZ (1 << 2)
+#define AW86927_BIT_DETCFG1_ADC_FS_48KHZ (2 << 2)
+#define AW86927_BIT_DETCFG1_ADC_FS_24KHZ (3 << 2)
+
+#define AW86927_BIT_DETCFG1_DET_GO_MASK (~(3 << 0))
+#define AW86927_BIT_DETCFG1_DET_GO_NA (0 << 0)
+
+#define AW86927_BIT_DETCFG1_DET_GO_MASK (~(3 << 0))
+#define AW86927_BIT_DETCFG1_DET_GO_NA (0 << 0)
+#define AW86927_BIT_DETCFG1_DET_GO_DET_SEQ0 (1 << 0)
+
+/* DETCFG2: reg 0x4E RW */
+#define AW86927_BIT_DETCFG2_DET_SEQ0_MASK (~(0xF << 3))
+#define AW86927_BIT_DETCFG2_DET_SEQ0_VBAT (0 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_PVDD (1 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_TRIG1 (2 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_RL (3 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_OS (4 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_VOUT (5 << 3)
+#define AW86927_BIT_DETCFG2_DET_SEQ0_FTS (6 << 3)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_MASK (~(7 << 0))
+#define AW86927_BIT_DETCFG2_D2S_GAIN (7 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_1 (0 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_2 (1 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_4 (2 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_8 (3 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_10 (4 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_16 (5 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_20 (6 << 0)
+#define AW86927_BIT_DETCFG2_D2S_GAIN_40 (7 << 0)
+/* TRIMCFG1: reg 0x52 RW */
+#define AW86927_BIT_TRIMCFG1_RL_TRIM_SRC_MASK (~(0X01 << 7))
+#define AW86927_BIT_TRIMCFG1_RL_TRIM_SRC_EFUSE (0 << 7)
+#define AW86927_BIT_TRIMCFG1_RL_TRIM_SRC_REG (1 << 7)
+/* TMCFG: reg 0x5B RW */
+#define AW86927_BIT_TMCFG_TM_UNLOCK (0x7d)
+#define AW86927_BIT_TMCFG_TM_LOCK (0x00)
+
+/* EFCFG6: reg 0x61 */
+#define AW86927_BIT_EFCFG6_MASK (0x80)
+/* TESTR: reg 0x65 RO */
+#define AW86927_BIT_TESTR_BST_SS_FINISH (8 << 0)
+#define AW86927_BIT_TESTR_BIST_OVP2S (4 << 0)
+#define AW86927_BIT_TESTR_BIST_FAIL (2 << 0)
+#define AW86927_BIT_TESTR_BIST_DONE (1 << 0)
+
+/* ANACFG12: reg 0x71 RW */
+#define AW86927_BIT_ANACFG12_BST_SKIP_MASK (~(0x01 << 7))
+#define AW86927_BIT_ANACFG12_BST_SKIP_OPEN (0 << 7)
+#define AW86927_BIT_ANACFG12_BST_SKIP_SHUTDOWN (1 << 7)
+
+/* ANACFG13: reg 0x72 RW */
+#define AW86927_BIT_ANACFG13_PEAKCUR_MASK (~(15 << 4))
+#define AW86927_BIT_ANACFG13_PEAKCUR_4A (9 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_3P75A (8 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_3P60A (7 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_3P45A (6 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_3P25A (5 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_3P05A (4 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_2P95A (3 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_2AP75A (2 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_2P65A (1 << 4)
+#define AW86927_BIT_ANACFG13_PEAKCUR_2P45A (0 << 4)
+
+/* ANACFG15: reg 0x74 RW */
+#define AW86927_BIT_ANACFG15_BST_PEAK_MODE_MASK (~(0x01 << 7))
+#define AW86927_BIT_ANACFG15_BST_PEAK_ADP (0 << 7)
+#define AW86927_BIT_ANACFG15_BST_PEAK_BACK (1 << 7)
+
+/* ANACFG16: reg 0x75 RW */
+#define AW86927_BIT_ANACFG16_BST_SRC_MASK (~(1 << 4))
+#define AW86927_BIT_ANACFG16_BST_SRC_3NS (0 << 4)
+
+/* ANACFG20: reg 0x79 RW */
+
+#define AW86927_BIT_ANACFG20_TRIM_LRA_MASK (~(0x3F << 0))
+#define AW86927_BIT_ANACFG20_TRIM_LRA (0x3F << 0)
+
+/*****************************************************
+ *
+ * Extern function : parse dts
+ *
+ *****************************************************/
+/*********************************************************
+ *
+ * extern
+ *
+ ********************************************************/
+extern int aw86927_haptics_upload_effect(struct input_dev *dev,
+					 struct ff_effect *effect,
+					 struct ff_effect *old);
+extern int aw86927_haptics_playback(struct input_dev *dev, int effect_id,
+				    int val);
+extern int aw86927_haptics_erase(struct input_dev *dev, int effect_id);
+extern void aw86927_haptics_set_gain(struct input_dev *dev, u16 gain);
+extern void aw86927_haptics_set_gain_work_routine(struct work_struct *work);
+extern void aw86927_interrupt_setup(struct aw86927 *aw86927);
+extern int aw86927_vibrator_init(struct aw86927 *aw86927);
+extern int aw86927_haptic_init(struct aw86927 *aw86927);
+extern int aw86927_ram_init(struct aw86927 *aw86927);
+extern irqreturn_t aw86927_irq(int irq, void *data);
+extern struct attribute_group aw86927_vibrator_attribute_group;
+extern int aw86927_parse_dt(struct aw86927 *aw86927, struct device *dev,
+			    struct device_node *np);
+extern int aw86927_check_qualify(struct aw86927 *aw86927);
+#endif
diff --git a/drivers/input/misc/aw86927_haptic/aw869x.c b/drivers/input/misc/aw86927_haptic/aw869x.c
new file mode 100644
index 000000000000..6b54ae9ec4ef
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw869x.c
@@ -0,0 +1,4588 @@
+/*
+ * aw869x.c
+ *
+ *
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ *  Author: <chelvming@awinic.com.cn>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/pm_qos.h>
+#include "aw_haptic.h"
+#include "ringbuffer.h"
+#include "aw_config.h"
+#include "aw869x.h"
+
+/******************************************************
+ *
+ * variable
+ *
+ ******************************************************/
+static struct pm_qos_request pm_qos_req_vb;
+static struct aw869x_container *aw869x_rtp;
+static struct aw869x *g_aw869x;
+
+static const unsigned char aw869x_reg_access[AW869X_REG_MAX] = {
+	[AW869X_REG_ID] = REG_RD_ACCESS,
+	[AW869X_REG_SYSST] = REG_RD_ACCESS,
+	[AW869X_REG_SYSINT] = REG_RD_ACCESS,
+	[AW869X_REG_SYSINTM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_SYSCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_GO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_RTP_DATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVSEQ8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVLOOP1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVLOOP2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVLOOP3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAVLOOP4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_MAIN_LOOP] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG1_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG2_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG3_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG1_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG2_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG3_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG_PRIO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG_CFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRG_CFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DBGCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BASE_ADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BASE_ADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_FIFO_AEH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_FIFO_AEL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_FIFO_AFH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_FIFO_AFL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAKE_DLY] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_START_DLY] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_END_DLY_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_END_DLY_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DATCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_PWMDEL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_PWMPRC] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_PWMDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_LDOCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DBGSTAT] = REG_RD_ACCESS,
+	[AW869X_REG_BSTDBG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTDBG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTDBG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTCFG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_ANADBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_ANACTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_CPDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_GLBDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DATDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTDBG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTDBG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BSTDBG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_HDRVDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_PRLVL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_PRTIME] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_RAMADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_RAMADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_RAMDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_GLB_STATE] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BST_AUTO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_CONT_CTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_PRE_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_PRE_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TD_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TD_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TSET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TRIM_LRA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_R_SPARE] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_D2SCFG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DETCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_RLDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_OSDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_VBATDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TESTDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DETLO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMFDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_ADCTEST] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMFTEST] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_LRA_F0_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_LRA_F0_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_LRA_CONT_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_F_LRA_CONT_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAIT_VOL_MP] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_WAIT_VOL_MN] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VOL_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VOL_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_ZC_THRSH_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_ZC_THRSH_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VTHH_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VTHH_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VTHL_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_VTHL_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_BEMF_NUM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DRV_TIME] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_TIME_NZC] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DRV_LVL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_DRV_LVL_OV] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_NUM_F0_1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_NUM_F0_2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869X_REG_NUM_F0_3] = REG_RD_ACCESS | REG_WR_ACCESS,
+};
+/******************************************************
+ *
+ * functions
+ *
+ ******************************************************/
+static void aw869x_interrupt_clear(struct aw869x *aw869x);
+static int aw869x_haptic_trig_enable_config(struct aw869x *aw869x);
+static int aw869x_haptic_get_vbat(struct aw869x *aw869x);
+/******************************************************
+ *
+ * aw869x i2c write/read
+ *
+ ******************************************************/
+static int aw869x_i2c_write(struct aw869x *aw869x, unsigned char reg_addr,
+			    unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw869x->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			aw_err("%s: i2c_write cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw869x_i2c_read(struct aw869x *aw869x, unsigned char reg_addr,
+			   unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw869x->i2c, reg_addr);
+		if (ret < 0) {
+			aw_err("%s: i2c_read cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw869x_i2c_write_bits(struct aw869x *aw869x, unsigned char reg_addr,
+				 unsigned int mask, unsigned char reg_data)
+{
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, reg_addr, &reg_val);
+	reg_val &= mask;
+	reg_val |= (reg_data & (~mask));
+	aw869x_i2c_write(aw869x, reg_addr, reg_val);
+
+	return 0;
+}
+
+static int aw869x_i2c_writes(struct aw869x *aw869x, unsigned char reg_addr,
+			     unsigned char *buf, unsigned int len)
+{
+	int ret = -1;
+	unsigned char *data;
+
+	data = kmalloc(len + 1, GFP_KERNEL);
+
+	data[0] = reg_addr;
+	memcpy(&data[1], buf, len);
+
+	ret = i2c_master_send(aw869x->i2c, data, len + 1);
+	if (ret < 0)
+		aw_err("%s: i2c master send error\n", __func__);
+
+	kfree(data);
+
+	return ret;
+}
+
+int aw869x_i2c_reads(struct aw869x *aw869x, unsigned char reg_addr,
+		     unsigned char *buf, unsigned int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		[0] = {
+			.addr = aw869x->i2c->addr,
+			.flags = 0,
+			.len = sizeof(uint8_t),
+			.buf = &reg_addr,
+			},
+		[1] = {
+			.addr = aw869x->i2c->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = buf,
+			},
+	};
+
+	ret = i2c_transfer(aw869x->i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		aw_err("%s: transfer failed.", __func__);
+		return ret;
+	} else if (ret != 2) {
+		aw_err("%s: transfer failed(size error).", __func__);
+		return -ENXIO;
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * ram update
+ *
+ *****************************************************/
+static void aw869x_rtp_loaded(const struct firmware *cont, void *context)
+{
+	struct aw869x *aw869x = context;
+
+	aw_info("%s enter\n", __func__);
+
+	if (!cont) {
+		aw_err("%s: failed to read %s\n", __func__,
+		       awinic_rtp_name[aw869x->rtp_file_num]);
+		release_firmware(cont);
+		return;
+	}
+
+	aw_info("%s: loaded %s - size: %zu\n", __func__,
+		awinic_rtp_name[aw869x->rtp_file_num], cont ? cont->size : 0);
+
+	/* aw869x rtp update */
+	aw869x_rtp = vmalloc(cont->size + sizeof(int));
+	if (!aw869x_rtp) {
+		release_firmware(cont);
+		aw_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw869x_rtp->len = cont->size;
+	aw_info("%s: rtp size = %d\n", __func__, aw869x_rtp->len);
+	memcpy(aw869x_rtp->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	aw869x->rtp_init = 1;
+	aw_info("%s: rtp update complete\n", __func__);
+}
+
+static int aw869x_rtp_update(struct aw869x *aw869x)
+{
+	aw_info("%s enter\n", __func__);
+
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       awinic_rtp_name[aw869x->rtp_file_num],
+				       aw869x->dev, GFP_KERNEL, aw869x,
+				       aw869x_rtp_loaded);
+}
+
+#ifdef AW_CHECK_RAM_DATA
+static int aw869x_check_ram_data(struct aw869x *aw869x,
+				 unsigned char *cont_data,
+				 unsigned char *ram_data, unsigned int len)
+{
+	int i = 0;
+
+	for (i = 0; i < len; i++) {
+		if (ram_data[i] != cont_data[i]) {
+			aw_err("%s: check ramdata error, addr=0x%04x, ram_data=0x%02x, file_data=0x%02x\n",
+			       __func__, i, ram_data[i], cont_data[i]);
+			return -ERANGE;
+		}
+	}
+	return 0;
+}
+#endif
+
+static void aw869x_container_update(struct aw869x *aw869x,
+				    struct aw869x_container *aw869x_cont)
+{
+	int i = 0;
+	int len = 0;
+	unsigned int shift = 0;
+
+#ifdef AW_CHECK_RAM_DATA
+	int ret = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+#endif
+
+	aw_info("%s enter\n", __func__);
+
+	mutex_lock(&aw869x->lock);
+
+	aw869x->ram.baseaddr_shift = 2;
+	aw869x->ram.ram_shift = 4;
+
+	/* RAMINIT Enable */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_EN);
+
+	/* base addr */
+	shift = aw869x->ram.baseaddr_shift;
+	aw869x->ram.base_addr =
+		(unsigned int)((aw869x_cont->data[0 + shift] << 8) |
+			       (aw869x_cont->data[1 + shift]));
+	aw_info("%s: base_addr=0x%4x\n", __func__, aw869x->ram.base_addr);
+
+	aw869x_i2c_write(aw869x, AW869X_REG_BASE_ADDRH,
+			 aw869x_cont->data[0 + shift]);
+	aw869x_i2c_write(aw869x, AW869X_REG_BASE_ADDRL,
+			 aw869x_cont->data[1 + shift]);
+
+	aw869x_i2c_write(aw869x, AW869X_REG_FIFO_AEH,
+			 (unsigned char)((aw869x->ram.base_addr >> 2) >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_FIFO_AEL,
+			 (unsigned char)((aw869x->ram.base_addr >> 2) &
+					 0x00FF));
+	aw869x_i2c_write(aw869x, AW869X_REG_FIFO_AFH,
+			 (unsigned char)((aw869x->ram.base_addr -
+					  (aw869x->ram.base_addr >> 2)) >>
+					 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_FIFO_AFL,
+			 (unsigned char)((aw869x->ram.base_addr -
+					  (aw869x->ram.base_addr >> 2)) &
+					 0x00FF));
+
+	/* ram */
+	shift = aw869x->ram.baseaddr_shift;
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRH,
+			 aw869x_cont->data[0 + shift]);
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRL,
+			 aw869x_cont->data[1 + shift]);
+	i = aw869x->ram.ram_shift;
+	while (i < aw869x_cont->len) {
+		if ((aw869x_cont->len - i) < AW_RAMDATA_WR_BUFFER_SIZE)
+			len = aw869x_cont->len - i;
+		else
+			len = AW_RAMDATA_WR_BUFFER_SIZE;
+		aw869x_i2c_writes(aw869x, AW869X_REG_RAMDATA,
+				  &aw869x_cont->data[i], len);
+		i += len;
+	}
+
+#ifdef AW_CHECK_RAM_DATA
+	shift = aw869x->ram.baseaddr_shift;
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRH,
+			 aw869x_cont->data[0 + shift]);
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRL,
+			 aw869x_cont->data[1 + shift]);
+	i = aw869x->ram.ram_shift;
+	while (i < aw869x_cont->len) {
+		if ((aw869x_cont->len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			len = aw869x_cont->len - i;
+		else
+			len = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw869x_i2c_reads(aw869x, AW869X_REG_RAMDATA, ram_data, len);
+		ret = aw869x_check_ram_data(aw869x, &aw869x_cont->data[i],
+					    ram_data, len);
+
+		if (ret < 0)
+			break;
+		i += len;
+	}
+	if (ret)
+		aw_err("%s: ram data check sum error\n", __func__);
+	else
+		aw_info("%s: ram data check sum pass\n", __func__);
+#endif
+
+	/* RAMINIT Disable */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_OFF);
+
+	mutex_unlock(&aw869x->lock);
+
+	aw_info("%s exit\n", __func__);
+}
+
+static void aw869x_ram_loaded(const struct firmware *cont, void *context)
+{
+	struct aw869x *aw869x = context;
+	struct aw869x_container *aw869x_fw;
+	int i = 0;
+	unsigned short check_sum = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	if (!cont) {
+		aw_err("%s: failed to read %s\n", __func__, awinic_ram_name);
+		release_firmware(cont);
+		return;
+	}
+
+	aw_info("%s: loaded %s - size: %zu\n", __func__, awinic_ram_name,
+		cont ? cont->size : 0);
+	/*
+	 * for (i=0; i<cont->size; i++) {
+	 *	aw_info("%s: addr:0x%04x, data:0x%02x\n", __func__,
+	 *	i, *(cont->data+i));
+	 * }
+	 */
+
+	/* check sum */
+	for (i = 2; i < cont->size; i++)
+		check_sum += cont->data[i];
+
+	if (check_sum ==
+	    (unsigned short)((cont->data[0] << 8) | (cont->data[1]))) {
+		aw_info("%s: check sum pass : 0x%04x\n", __func__, check_sum);
+		aw869x->ram.check_sum = check_sum;
+	} else {
+		aw_err("%s: check sum err: check_sum=0x%04x\n", __func__,
+		       check_sum);
+		return;
+	}
+
+	/* aw869x ram update */
+	aw869x_fw = kzalloc(cont->size + sizeof(int), GFP_KERNEL);
+	if (!aw869x_fw) {
+		release_firmware(cont);
+		aw_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw869x_fw->len = cont->size;
+	memcpy(aw869x_fw->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	aw869x_container_update(aw869x, aw869x_fw);
+
+	aw869x->ram.len = aw869x_fw->len;
+
+	kfree(aw869x_fw);
+
+	aw869x->ram_init = 1;
+	aw_info("%s: fw update complete\n", __func__);
+
+	aw869x_haptic_trig_enable_config(aw869x);
+
+	aw869x_rtp_update(aw869x);
+}
+
+static int aw869x_ram_update(struct aw869x *aw869x)
+{
+	aw869x->ram_init = 0;
+	aw869x->rtp_init = 0;
+	aw_info("%s enter\n", __func__);
+
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       awinic_ram_name, aw869x->dev, GFP_KERNEL,
+				       aw869x, aw869x_ram_loaded);
+}
+
+#ifdef AW_RAM_UPDATE_DELAY
+static void aw869x_ram_work_routine(struct work_struct *work)
+{
+	struct aw869x *aw869x =
+		container_of(work, struct aw869x, ram_work.work);
+
+	aw_info("%s enter\n", __func__);
+
+	aw869x_ram_update(aw869x);
+}
+#endif
+/*****************************************************
+ *
+ * haptic control
+ *
+ *****************************************************/
+static int aw869x_haptic_active(struct aw869x *aw869x)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_WORK_MODE_MASK,
+			      AW869X_BIT_SYSCTRL_ACTIVE);
+	aw869x_interrupt_clear(aw869x);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_UVLO_MASK,
+			      AW869X_BIT_SYSINTM_UVLO_EN);
+	return 0;
+}
+
+static int aw869x_haptic_play_mode(struct aw869x *aw869x,
+				   unsigned char play_mode)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	switch (play_mode) {
+	case AW869X_HAPTIC_STANDBY_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_STANDBY_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+				      AW869X_BIT_SYSINTM_UVLO_MASK,
+				      AW869X_BIT_SYSINTM_UVLO_OFF);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_WORK_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_STANDBY);
+		break;
+	case AW869X_HAPTIC_RAM_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_RAM_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_RAM);
+		aw869x_haptic_active(aw869x);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_BST_MODE_BOOST);
+		break;
+	case AW869X_HAPTIC_RAM_LOOP_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_RAM_LOOP_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_RAM);
+		aw869x_haptic_active(aw869x);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_BST_MODE_BYPASS);
+		break;
+	case AW869X_HAPTIC_RTP_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_RTP_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_RTP);
+		aw869x_haptic_active(aw869x);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_BST_MODE_BOOST);
+		break;
+	case AW869X_HAPTIC_TRIG_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_TRIG_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_RAM);
+		aw869x_haptic_active(aw869x);
+		break;
+	case AW869X_HAPTIC_CONT_MODE:
+		aw869x->play_mode = AW869X_HAPTIC_CONT_MODE;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_PLAY_MODE_CONT);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+				      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+				      AW869X_BIT_SYSCTRL_BST_MODE_BYPASS);
+		aw869x_haptic_active(aw869x);
+		break;
+	default:
+		aw_err("%s: play mode %d err", __func__, play_mode);
+		break;
+	}
+	return 0;
+}
+
+static int aw869x_haptic_play_go(struct aw869x *aw869x, bool flag)
+{
+	if (flag == true) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_GO, AW869X_BIT_GO_MASK,
+				      AW869X_BIT_GO_ENABLE);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_GO, AW869X_BIT_GO_MASK,
+				      AW869X_BIT_GO_DISABLE);
+	}
+	return 0;
+}
+
+static int aw869x_haptic_stop_delay(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+	unsigned int cnt = 100;
+
+	while (cnt--) {
+		aw869x_i2c_read(aw869x, AW869X_REG_GLB_STATE, &reg_val);
+		if ((reg_val & 0x0f) == 0x00)
+			return 0;
+
+		usleep_range(2000, 2500);
+		aw_dbg("%s wait for standby, reg glb_state=0x%02x\n", __func__,
+		       reg_val);
+	}
+	aw_err("%s do not enter standby automatically\n", __func__);
+
+	return 0;
+}
+
+static int aw869x_haptic_stop(struct aw869x *aw869x)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	aw869x_haptic_play_go(aw869x, false);
+	aw869x_haptic_stop_delay(aw869x);
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_STANDBY_MODE);
+
+	return 0;
+}
+
+static int aw869x_haptic_start(struct aw869x *aw869x)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	aw869x_haptic_play_go(aw869x, true);
+
+	return 0;
+}
+
+static int aw869x_haptic_set_wav_seq(struct aw869x *aw869x, unsigned char wav,
+				     unsigned char seq)
+{
+	aw869x_i2c_write(aw869x, AW869X_REG_WAVSEQ1 + wav, seq);
+	return 0;
+}
+
+static int aw869x_haptic_set_wav_loop(struct aw869x *aw869x, unsigned char wav,
+				      unsigned char loop)
+{
+	unsigned char tmp = 0;
+
+	if (wav % 2) {
+		tmp = loop << 0;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_WAVLOOP1 + (wav / 2),
+				      AW869X_BIT_WAVLOOP_SEQNP1_MASK, tmp);
+	} else {
+		tmp = loop << 4;
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_WAVLOOP1 + (wav / 2),
+				      AW869X_BIT_WAVLOOP_SEQN_MASK, tmp);
+	}
+
+	return 0;
+}
+
+static int aw869x_haptic_set_repeat_wav_seq(struct aw869x *aw869x,
+					    unsigned char seq)
+{
+	aw869x_haptic_set_wav_seq(aw869x, 0x00, seq);
+	aw869x_haptic_set_wav_loop(aw869x, 0x00,
+				   AW869X_BIT_WAVLOOP_INIFINITELY);
+
+	return 0;
+}
+
+static int aw869x_haptic_set_bst_vol(struct aw869x *aw869x,
+				     unsigned char bst_vol)
+{
+	if (bst_vol & 0xe0)
+		bst_vol = 0x1f;
+
+	/* aw_info("%s %d --\n", __func__, __LINE__); */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_BSTDBG4,
+			      AW869X_BIT_BSTDBG4_BSTVOL_MASK, (bst_vol << 1));
+	return 0;
+}
+
+static int aw869x_haptic_set_bst_peak_cur(struct aw869x *aw869x,
+					  unsigned char peak_cur)
+{
+	peak_cur &= AW869X_BSTCFG_PEAKCUR_LIMIT;
+	aw_info("%s  %d enter\n", __func__, __LINE__);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_BSTCFG,
+			      AW869X_BIT_BSTCFG_PEAKCUR_MASK, peak_cur);
+	return 0;
+}
+
+static int aw869x_haptic_set_gain(struct aw869x *aw869x, unsigned char gain)
+{
+	unsigned char comp_gain = 0;
+
+	if (aw869x->ram_vbat_comp == AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE) {
+		aw869x_haptic_get_vbat(aw869x);
+		aw_dbg("%s: ref %d vbat %d ", __func__, AW_VBAT_REFER,
+		       aw869x->vbat);
+		comp_gain = gain * AW_VBAT_REFER / aw869x->vbat;
+		if (comp_gain > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			comp_gain = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_dbg("%s: comp gain limit is %d ", __func__,
+			       comp_gain);
+		}
+		aw_info("%s: enable vbat comp, level = %x comp level = %x",
+			__func__, gain, comp_gain);
+		aw869x_i2c_write(aw869x, AW869X_REG_DATDBG, comp_gain);
+	} else {
+		aw_dbg("%s: disable compsensation, vbat=%d, vbat_min=%d, vbat_ref=%d",
+		       __func__, aw869x->vbat, AW_VBAT_MIN, AW_VBAT_REFER);
+		aw869x_i2c_write(aw869x, AW869X_REG_DATDBG, gain);
+	}
+	return 0;
+}
+
+static int aw869x_haptic_set_pwm(struct aw869x *aw869x, unsigned char mode)
+{
+	switch (mode) {
+	case AW869X_PWM_48K:
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMDBG,
+				      AW869X_BIT_PWMDBG_PWM_MODE_MASK,
+				      AW869X_BIT_PWMDBG_PWM_48K);
+		break;
+	case AW869X_PWM_24K:
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMDBG,
+				      AW869X_BIT_PWMDBG_PWM_MODE_MASK,
+				      AW869X_BIT_PWMDBG_PWM_24K);
+		break;
+	case AW869X_PWM_12K:
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMDBG,
+				      AW869X_BIT_PWMDBG_PWM_MODE_MASK,
+				      AW869X_BIT_PWMDBG_PWM_12K);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int aw869x_haptic_play_repeat_seq(struct aw869x *aw869x,
+					 unsigned char flag)
+{
+	aw_dbg("%s enter\n", __func__);
+
+	if (flag) {
+		aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RAM_LOOP_MODE);
+		aw869x_haptic_start(aw869x);
+	}
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * motor protect
+ *
+ *****************************************************/
+static int aw869x_haptic_swicth_motorprotect_config(struct aw869x *aw869x,
+						    unsigned char addr,
+						    unsigned char val)
+{
+	aw_info("%s enter\n", __func__);
+
+	if (addr == 1) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+				      AW869X_BIT_DETCTRL_PROTECT_MASK,
+				      AW869X_BIT_DETCTRL_PROTECT_SHUTDOWN);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMPRC,
+				      AW869X_BIT_PWMPRC_PRC_MASK,
+				      AW869X_BIT_PWMPRC_PRC_ENABLE);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PRLVL,
+				      AW869X_BIT_PRLVL_PR_MASK,
+				      AW869X_BIT_PRLVL_PR_ENABLE);
+	} else if (addr == 0) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+				      AW869X_BIT_DETCTRL_PROTECT_MASK,
+				      AW869X_BIT_DETCTRL_PROTECT_NO_ACTION);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMPRC,
+				      AW869X_BIT_PWMPRC_PRC_MASK,
+				      AW869X_BIT_PWMPRC_PRC_DISABLE);
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PRLVL,
+				      AW869X_BIT_PRLVL_PR_MASK,
+				      AW869X_BIT_PRLVL_PR_DISABLE);
+	} else if (addr == 0x2d) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PWMPRC,
+				      AW869X_BIT_PWMPRC_PRCTIME_MASK, val);
+	} else if (addr == 0x3e) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PRLVL,
+				      AW869X_BIT_PRLVL_PRLVL_MASK, val);
+	} else if (addr == 0x3f) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_PRTIME,
+				      AW869X_BIT_PRTIME_PRTIME_MASK, val);
+	} else {
+		/*nothing to do; */
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * offset calibration
+ *
+ *****************************************************/
+static int aw869x_haptic_offset_calibration(struct aw869x *aw869x)
+{
+	unsigned int cont = 2000;
+	unsigned char reg_val = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+			      AW869X_BIT_DETCTRL_DIAG_GO_MASK,
+			      AW869X_BIT_DETCTRL_DIAG_GO_ENABLE);
+	while (1) {
+		aw869x_i2c_read(aw869x, AW869X_REG_DETCTRL, &reg_val);
+		if ((reg_val & 0x01) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_OFF);
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * trig config
+ *
+ *****************************************************/
+
+static int aw869x_haptic_trig_param_init(struct aw869x *aw869x)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw869x->trig[0].enable = aw869x->info.trig_config[0][0];
+	aw869x->trig[0].default_level = aw869x->info.trig_config[0][1];
+	aw869x->trig[0].dual_edge = aw869x->info.trig_config[0][2];
+	aw869x->trig[0].frist_seq = aw869x->info.trig_config[0][3];
+	aw869x->trig[0].second_seq = aw869x->info.trig_config[0][4];
+
+	aw869x->trig[1].enable = aw869x->info.trig_config[1][0];
+	aw869x->trig[1].default_level = aw869x->info.trig_config[1][1];
+	aw869x->trig[1].dual_edge = aw869x->info.trig_config[1][2];
+	aw869x->trig[1].frist_seq = aw869x->info.trig_config[1][3];
+	aw869x->trig[1].second_seq = aw869x->info.trig_config[1][4];
+
+	aw869x->trig[2].enable = aw869x->info.trig_config[2][0];
+	aw869x->trig[2].default_level = aw869x->info.trig_config[2][1];
+	aw869x->trig[2].dual_edge = aw869x->info.trig_config[2][2];
+	aw869x->trig[2].frist_seq = aw869x->info.trig_config[2][3];
+	aw869x->trig[2].second_seq = aw869x->info.trig_config[2][4];
+
+	return 0;
+}
+
+static int aw869x_haptic_trig_param_config(struct aw869x *aw869x)
+{
+	aw_info("%s enter\n", __func__);
+
+	if (aw869x->trig[0].default_level) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG1_POLAR_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG1_POLAR_POS);
+	}
+	if (aw869x->trig[1].default_level) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG2_POLAR_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG2_POLAR_POS);
+	}
+	if (aw869x->trig[2].default_level) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG3_POLAR_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW869X_BIT_TRGCFG1_TRG3_POLAR_POS);
+	}
+
+	if (aw869x->trig[0].dual_edge) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG1_EDGE_POS_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG1_EDGE_POS);
+	}
+	if (aw869x->trig[1].dual_edge) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG2_EDGE_POS_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG2_EDGE_POS);
+	}
+	if (aw869x->trig[2].dual_edge) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG3_EDGE_POS_NEG);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG1,
+				      AW869X_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW869X_BIT_TRGCFG1_TRG3_EDGE_POS);
+	}
+
+	if (aw869x->trig[0].frist_seq) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG1_WAV_P,
+				 aw869x->trig[0].frist_seq);
+	}
+	if (aw869x->trig[0].second_seq && aw869x->trig[0].dual_edge) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG1_WAV_N,
+				 aw869x->trig[0].second_seq);
+	}
+	if (aw869x->trig[1].frist_seq) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG2_WAV_P,
+				 aw869x->trig[1].frist_seq);
+	}
+	if (aw869x->trig[1].second_seq && aw869x->trig[1].dual_edge) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG2_WAV_N,
+				 aw869x->trig[1].second_seq);
+	}
+	if (aw869x->trig[2].frist_seq) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG3_WAV_P,
+				 aw869x->trig[2].frist_seq);
+	}
+	if (aw869x->trig[2].second_seq && aw869x->trig[2].dual_edge) {
+		aw869x_i2c_write(aw869x, AW869X_REG_TRG3_WAV_N,
+				 aw869x->trig[2].second_seq);
+	}
+
+	return 0;
+}
+
+static int aw869x_haptic_trig_enable_config(struct aw869x *aw869x)
+{
+	aw_info("%s enter\n", __func__);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG2,
+			      AW869X_BIT_TRGCFG2_TRG1_ENABLE_MASK,
+			      aw869x->trig[0].enable);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG2,
+			      AW869X_BIT_TRGCFG2_TRG2_ENABLE_MASK,
+			      aw869x->trig[1].enable << 1);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_TRG_CFG2,
+			      AW869X_BIT_TRGCFG2_TRG3_ENABLE_MASK,
+			      aw869x->trig[2].enable << 2);
+	return 0;
+}
+
+static int aw869x_haptic_auto_boost_config(struct aw869x *aw869x,
+					   unsigned char flag)
+{
+	aw869x->auto_boost = flag;
+	if (flag) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_BST_AUTO,
+				      AW869X_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				      AW869X_BIT_BST_AUTO_BST_AUTOMATIC_BOOST);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_BST_AUTO,
+				      AW869X_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				      AW869X_BIT_BST_AUTO_BST_MANUAL_BOOST);
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * vbat mode
+ *
+ *****************************************************/
+static int aw869x_haptic_cont_vbat_mode(struct aw869x *aw869x,
+					unsigned char flag)
+{
+	if (flag == AW869X_HAPTIC_CONT_VBAT_HW_COMP_MODE) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_ADCTEST,
+				      AW869X_BIT_ADCTEST_VBAT_MODE_MASK,
+				      AW869X_BIT_ADCTEST_VBAT_HW_COMP);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_ADCTEST,
+				      AW869X_BIT_ADCTEST_VBAT_MODE_MASK,
+				      AW869X_BIT_ADCTEST_VBAT_SW_COMP);
+	}
+	return 0;
+}
+
+static int aw869x_haptic_get_vbat(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+	unsigned char reg_val_sysctrl = 0;
+	unsigned char reg_val_detctrl = 0;
+
+	aw869x_haptic_stop(aw869x);
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSCTRL, &reg_val_sysctrl);
+	aw869x_i2c_read(aw869x, AW869X_REG_DETCTRL, &reg_val_detctrl);
+	/*step 1:EN_RAMINIT*/
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_EN);
+
+	/*step 2 :launch offset cali */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+			      AW869X_BIT_DETCTRL_DIAG_GO_MASK,
+			      AW869X_BIT_DETCTRL_DIAG_GO_ENABLE);
+	/*step 3 :delay */
+	usleep_range(2000, 2500);
+
+	/*step 4 :launch power supply testing */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+			      AW869X_BIT_DETCTRL_VBAT_GO_MASK,
+			      AW869X_BIT_DETCTRL_VABT_GO_ENABLE);
+	usleep_range(2000, 2500);
+
+	aw869x_i2c_read(aw869x, AW869X_REG_VBATDET, &reg_val);
+	aw869x->vbat = 6100 * reg_val / 256;
+	if (aw869x->vbat > AW_VBAT_MAX) {
+		aw869x->vbat = AW_VBAT_MAX;
+		aw_info("%s:vbat max limit = %dmV\n", __func__, aw869x->vbat);
+	}
+	if (aw869x->vbat < AW_VBAT_MIN) {
+		aw869x->vbat = AW_VBAT_MIN;
+		aw_info("%s:vbat min limit = %dmV\n", __func__, aw869x->vbat);
+	}
+	aw_info("%s:aw869x->vbat=%dmV\n", __func__, aw869x->vbat);
+	/*step 5: return val*/
+	aw869x_i2c_write(aw869x, AW869X_REG_SYSCTRL, reg_val_sysctrl);
+
+	return 0;
+}
+
+static int aw869x_haptic_ram_vbat_comp(struct aw869x *aw869x, bool flag)
+{
+	aw_dbg("%s: enter\n", __func__);
+	if (flag)
+		aw869x->ram_vbat_comp = AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	else
+		aw869x->ram_vbat_comp = AW869X_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	return 0;
+}
+
+/*****************************************************
+ *
+ * f0
+ *
+ *****************************************************/
+static int aw869x_haptic_set_f0_preset(struct aw869x *aw869x)
+{
+	unsigned int f0_reg = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	f0_reg = 1000000000 / (aw869x->info.f0_pre * aw869x->info.f0_coeff);
+	aw869x_i2c_write(aw869x, AW869X_REG_F_PRE_H,
+			 (unsigned char)((f0_reg >> 8) & 0xff));
+	aw869x_i2c_write(aw869x, AW869X_REG_F_PRE_L,
+			 (unsigned char)((f0_reg >> 0) & 0xff));
+
+	return 0;
+}
+
+#ifndef USE_CONT_F0_CALI
+static int aw869x_haptic_read_f0(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_F0_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_F0_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_info("%s: not get f0_reg value is 0!\n", __func__);
+		aw869x->f0_cali_status = false;
+		return 0;
+	}
+	aw869x->f0_cali_status = true;
+	f0_tmp = 1000000000 / (f0_reg * aw869x->info.f0_coeff);
+	aw869x->f0 = (unsigned int)f0_tmp;
+	aw_info("%s f0=%d\n", __func__, aw869x->f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw869x_haptic_read_cont_f0(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dbg("%s enter\n", __func__);
+
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw869x->info.f0_coeff);
+	aw869x->cont_f0 = (unsigned int)f0_tmp;
+	aw_info("%s f0=%d\n", __func__, aw869x->cont_f0);
+
+	return 0;
+}
+#else
+static int aw869x_haptic_read_cont_f0(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dbg("%s enter\n", __func__);
+
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw869x->info.f0_coeff);
+	aw869x->cont_f0 = (unsigned int)f0_tmp;
+	aw869x->cont_f0 -= 12;
+	aw869x->f0 = aw869x->cont_f0;
+	aw_info("%s f0=%d\n", __func__, aw869x->cont_f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw869x_haptic_read_beme(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+
+	aw_info("%s  %d enter\n", __func__, __LINE__);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_WAIT_VOL_MP, &reg_val);
+	aw869x->max_pos_beme = (reg_val << 0);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_WAIT_VOL_MN, &reg_val);
+	aw869x->max_neg_beme = (reg_val << 0);
+
+	aw_info("%s max_pos_beme=%d\n", __func__, aw869x->max_pos_beme);
+	aw_info("%s max_neg_beme=%d\n", __func__, aw869x->max_neg_beme);
+
+	return 0;
+}
+#else
+static int aw869x_haptic_read_cont_bemf(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int bemf = 0;
+
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_BEMF_VOL_H, &reg_val);
+	bemf |= (reg_val << 8);
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_BEMF_VOL_L, &reg_val);
+	bemf |= (reg_val << 0);
+
+	aw_info("%s bemf=%d\n", __func__, bemf);
+
+	return 0;
+}
+#endif
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static void aw869x_haptic_set_rtp_aei(struct aw869x *aw869x, bool flag)
+{
+	if (flag) {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+				      AW869X_BIT_SYSINTM_FF_AE_MASK,
+				      AW869X_BIT_SYSINTM_FF_AE_EN);
+	} else {
+		aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+				      AW869X_BIT_SYSINTM_FF_AE_MASK,
+				      AW869X_BIT_SYSINTM_FF_AE_OFF);
+	}
+}
+
+static unsigned char aw869x_haptic_rtp_get_fifo_afi(struct aw869x *aw869x)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	if (aw869x->osc_cali_flag == 1) {
+		aw869x_i2c_read(aw869x, AW869X_REG_SYSST, &reg_val);
+		reg_val &= AW869X_BIT_SYSST_FF_AFS;
+		ret = reg_val >> 3;
+	} else {
+		aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+		reg_val &= AW869X_BIT_SYSINT_FF_AFI;
+		ret = reg_val >> 3;
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static int aw869x_haptic_rtp_init(struct aw869x *aw869x)
+{
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw869x->ram.base_addr >> 2;
+
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	aw869x->rtp_cnt = 0;
+	disable_irq(gpio_to_irq(aw869x->irq_gpio));
+	while ((!aw869x_haptic_rtp_get_fifo_afi(aw869x)) &&
+	       (aw869x->play_mode == AW869X_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw869x->exit_in_rtp_loop)) {
+		if (aw869x->is_custom_wave == 0) {
+			if ((aw869x_rtp->len - aw869x->rtp_cnt) <
+			    (aw869x->ram.base_addr >> 2)) {
+				buf_len = aw869x_rtp->len - aw869x->rtp_cnt;
+			} else {
+				buf_len = (aw869x->ram.base_addr >> 2);
+			}
+			aw869x_i2c_writes(aw869x, AW869X_REG_RTP_DATA,
+					  &aw869x_rtp->data[aw869x->rtp_cnt],
+					  buf_len);
+			aw869x->rtp_cnt += buf_len;
+			if (aw869x->rtp_cnt == aw869x_rtp->len) {
+				aw869x->rtp_cnt = 0;
+				aw869x_haptic_set_rtp_aei(aw869x, false);
+				break;
+			}
+		} else {
+			buf_len = read_rb(aw869x_rtp->data, period_size);
+			aw869x_i2c_writes(aw869x, AW869X_REG_RTP_DATA,
+					  aw869x_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				aw_info("%s: custom rtp update complete\n",
+					__func__);
+				aw869x->rtp_cnt = 0;
+				aw869x_haptic_set_rtp_aei(aw869x, false);
+				break;
+			}
+		}
+	}
+	enable_irq(gpio_to_irq(aw869x->irq_gpio));
+	if (aw869x->play_mode == AW869X_HAPTIC_RTP_MODE &&
+	    !atomic_read(&aw869x->exit_in_rtp_loop) && aw869x->rtp_cnt != 0) {
+		aw869x_haptic_set_rtp_aei(aw869x, true);
+	}
+	aw_info("%s: exit\n", __func__);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+
+static int16_t aw869x_haptic_effect_strength(struct aw869x *aw869x)
+{
+	aw_dbg("%s enter\n", __func__);
+	aw_dbg("%s: aw869x->play.vmax_mv =0x%x\n", __func__,
+	       aw869x->play.vmax_mv);
+#if 0
+	switch (aw869x->play.vmax_mv) {
+	case AW869X_LIGHT_MAGNITUDE:
+		aw869x->level = 0x80;
+		break;
+	case AW869X_MEDIUM_MAGNITUDE:
+		aw869x->level = 0x50;
+		break;
+	case AW869X_STRONG_MAGNITUDE:
+		aw869x->level = 0x30;
+		break;
+	default:
+		break;
+	}
+#else
+	if (aw869x->play.vmax_mv >= 0x7FFF)
+		aw869x->level = 0x80; /*128*/
+	else if (aw869x->play.vmax_mv <= 0x3FFF)
+		aw869x->level = 0x1E; /*30*/
+	else
+		aw869x->level = (aw869x->play.vmax_mv - 16383) / 128;
+	if (aw869x->level < 0x1E)
+		aw869x->level = 0x1E; /*30*/
+#endif
+
+	aw_info("%s: aw869x->level =0x%x\n", __func__, aw869x->level);
+	return 0;
+}
+
+static int aw869x_haptic_play_effect_seq(struct aw869x *aw869x,
+					 unsigned char flag)
+{
+	if (aw869x->effect_id > aw869x->info.effect_id_boundary)
+		return 0;
+	/* aw_info("%s:aw869x->effect_id =%d\n", __func__, aw869x->effect_id);
+	 * aw_info("%s:aw869x->activate_mode =%d\n", __func__,
+	 *	  aw869x->activate_mode);
+	 */
+
+	if (flag) {
+		if (aw869x->activate_mode == AW869X_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw869x_haptic_set_wav_seq(aw869x, 0x00,
+						  (char)aw869x->effect_id + 1);
+			aw869x_haptic_set_wav_seq(aw869x, 0x01, 0x00);
+			aw869x_haptic_set_wav_loop(aw869x, 0x00, 0x00);
+			aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RAM_MODE);
+			if (aw869x->info.bst_vol_ram <= AW869X_MAX_BST_VO)
+				aw869x_haptic_set_bst_vol(
+					aw869x, aw869x->info.bst_vol_ram);
+			else
+				aw869x_haptic_set_bst_vol(aw869x, aw869x->vmax);
+			aw869x_haptic_effect_strength(aw869x);
+			aw869x_haptic_set_gain(aw869x, aw869x->level);
+			aw869x_haptic_start(aw869x);
+		}
+		if (aw869x->activate_mode ==
+		    AW869X_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw869x_haptic_set_repeat_wav_seq(
+				aw869x, (aw869x->info.effect_id_boundary + 1));
+			aw869x_haptic_set_gain(aw869x, aw869x->level);
+			aw869x_haptic_play_repeat_seq(aw869x, true);
+		}
+	}
+
+	return 0;
+}
+
+static void aw869x_haptic_upload_lra(struct aw869x *aw869x, unsigned char flag)
+{
+	switch (flag) {
+	case AW869X_WRITE_ZERO:
+		aw_info("%s: write zero to trim_lra!\n", __func__);
+		aw869x_i2c_write(aw869x, AW869X_REG_TRIM_LRA, 0x00);
+		break;
+	case AW869X_F0_CALI_LRA:
+		aw_info("%s: f0_cali_lra=%d\n", __func__,
+			aw869x->f0_calib_data);
+		aw869x_i2c_write(aw869x, AW869X_REG_TRIM_LRA,
+				 (char)aw869x->f0_calib_data);
+		break;
+	case AW869X_OSC_CALI_LRA:
+		aw_info("%s: rtp_cali_lra=%d\n", __func__,
+			aw869x->lra_calib_data);
+		aw869x_i2c_write(aw869x, AW869X_REG_TRIM_LRA,
+				 (char)aw869x->lra_calib_data);
+		break;
+	default:
+		break;
+	}
+}
+
+static int aw869x_clock_OSC_trim_calibration(unsigned long int theory_time,
+					     unsigned long int real_time)
+{
+	unsigned int real_code = 0;
+	unsigned int LRA_TRIM_CODE = 0;
+	unsigned int DFT_LRA_TRIM_CODE = 0;
+	unsigned int Not_need_cali_threshold =
+		10; /*0.1 percent not need calibrate*/
+
+	if (theory_time == real_time) {
+		aw_info("aw_osctheory_time == real_time:%ld  theory_time = %ld not need to cali\n",
+			real_time, theory_time);
+		return 0;
+	} else if (theory_time < real_time) {
+		if ((real_time - theory_time) > (theory_time / 50)) {
+			aw_info("aw_osc(real_time - theory_time) > (theory_time/50) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		if ((real_time - theory_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			aw_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		real_code = ((real_time - theory_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 + real_code;
+	} else if (theory_time > real_time) {
+		if ((theory_time - real_time) > (theory_time / 50)) {
+			aw_info("aw_osc((theory_time - real_time) > (theory_time / 50)) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+		if ((theory_time - real_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			aw_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+		real_code = ((theory_time - real_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 - real_code;
+	}
+	if (real_code > 31)
+		LRA_TRIM_CODE = real_code - 32;
+	else
+		LRA_TRIM_CODE = real_code + 32;
+	aw_info("aw_oscmicrosecond:%ld  theory_time = %ld real_code =0X%02X LRA_TRIM_CODE 0X%02X\n",
+		real_time, theory_time, real_code, LRA_TRIM_CODE);
+
+	return LRA_TRIM_CODE;
+}
+
+static int aw869x_rtp_trim_lra_calibration(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_rtim_code = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_PWMDBG, &reg_val);
+	fre_val = (reg_val & 0x006f) >> 5;
+
+	if (fre_val == 3)
+		theory_time = (aw869x->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 2)
+		theory_time = (aw869x->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1 || fre_val == 0)
+		theory_time = (aw869x->rtp_len / 48000) * 1000000; /*48K */
+
+	aw_info("microsecond:%ld  theory_time = %d\n", aw869x->microsecond,
+		theory_time);
+
+	lra_rtim_code = aw869x_clock_OSC_trim_calibration(theory_time,
+							  aw869x->microsecond);
+	if (lra_rtim_code > 0) {
+		aw869x->lra_calib_data = lra_rtim_code;
+		aw869x_i2c_write(aw869x, AW869X_REG_TRIM_LRA,
+				 (char)lra_rtim_code);
+	}
+	return 0;
+}
+static unsigned char aw869x_haptic_osc_read_int(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_DBGSTAT, &reg_val);
+	return reg_val;
+}
+
+static int aw869x_rtp_osc_calibration(struct aw869x *aw869x)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+
+	aw869x->rtp_cnt = 0;
+	aw869x->timeval_flags = 1;
+	aw869x->osc_cali_flag = 1;
+
+	aw_info("%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file,
+			       awinic_rtp_name[/*aw869x->rtp_file_num*/ 0],
+			       aw869x->dev);
+	if (ret < 0) {
+		aw_err("%s: failed to read %s\n", __func__,
+		       awinic_rtp_name[/*aw869x->rtp_file_num*/ 0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate*/
+	aw869x_haptic_stop(aw869x);
+	aw869x->rtp_init = 0;
+	mutex_lock(&aw869x->rtp_lock);
+	vfree(aw869x_rtp);
+	aw869x_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw869x_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw869x->rtp_lock);
+		aw_err("%s: error allocating memory\n", __func__);
+		return -ENOMEM;
+	}
+	aw869x_rtp->len = rtp_file->size;
+	aw869x->rtp_len = rtp_file->size;
+	aw_info("%s: rtp file [%s] size = %d\n", __func__,
+		awinic_rtp_name[/*aw869x->rtp_file_num*/ 0], aw869x_rtp->len);
+	memcpy(aw869x_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw869x->rtp_lock);
+
+	/* gain */
+	aw869x_haptic_ram_vbat_comp(aw869x, false);
+
+	/* rtp mode config */
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RTP_MODE);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DBGCTRL,
+			      AW869X_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW869X_BIT_DBGCTRL_INT_MODE_EDGE);
+	disable_irq(gpio_to_irq(aw869x->irq_gpio));
+	/* haptic start */
+	aw869x_haptic_start(aw869x);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw869x_haptic_rtp_get_fifo_afi(aw869x)) {
+			mutex_lock(&aw869x->rtp_lock);
+			if ((aw869x_rtp->len - aw869x->rtp_cnt) <
+			    (aw869x->ram.base_addr >> 2))
+				buf_len = aw869x_rtp->len - aw869x->rtp_cnt;
+			else
+				buf_len = (aw869x->ram.base_addr >> 2);
+			if (aw869x->rtp_cnt != aw869x_rtp->len) {
+				if (aw869x->timeval_flags == 1) {
+					ktime_get_real_ts64(&aw869x->start);
+					aw869x->timeval_flags = 0;
+				}
+				aw869x_i2c_writes(
+					aw869x, AW869X_REG_RTP_DATA,
+					&aw869x_rtp->data[aw869x->rtp_cnt],
+					buf_len);
+				aw869x->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw869x->rtp_lock);
+		}
+		osc_int_state = aw869x_haptic_osc_read_int(aw869x);
+		if (osc_int_state & AW869X_BIT_SYSINT_DONEI) {
+			ktime_get_real_ts64(&aw869x->end);
+			aw_info("%s vincent playback done aw869x->rtp_cnt= %d\n",
+				__func__, aw869x->rtp_cnt);
+			break;
+		}
+
+		ktime_get_real_ts64(&aw869x->end);
+		aw869x->microsecond =
+			(aw869x->end.tv_sec - aw869x->start.tv_sec) * 1000000 +
+			(aw869x->end.tv_nsec - aw869x->start.tv_nsec) / 1000000;
+		if (aw869x->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			aw_info("%s vincent time out aw869x->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw869x->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw869x->irq_gpio));
+
+	aw869x->osc_cali_flag = 0;
+	aw869x->microsecond =
+		(aw869x->end.tv_sec - aw869x->start.tv_sec) * 1000000 +
+		(aw869x->end.tv_nsec - aw869x->start.tv_nsec) / 1000000;
+	/*calibration osc*/
+	aw_info("%s 2018_microsecond:%ld\n", __func__, aw869x->microsecond);
+	aw_info("%s exit\n", __func__);
+	return 0;
+}
+
+static void aw869x_rtp_work_routine(struct work_struct *work)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	struct aw869x *aw869x = container_of(work, struct aw869x, rtp_work);
+
+	if ((aw869x->effect_id < aw869x->info.effect_id_boundary) &&
+	    (aw869x->effect_id > aw869x->info.effect_max))
+		return;
+
+	aw_info("%s: effect_id = %d state=%d activate_mode = %d\n", __func__,
+		aw869x->effect_id, aw869x->state, aw869x->activate_mode);
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_upload_lra(aw869x, AW869X_OSC_CALI_LRA);
+	aw869x_haptic_set_rtp_aei(aw869x, false);
+	aw869x_interrupt_clear(aw869x);
+	/* wait for irq to exit */
+	atomic_set(&aw869x->exit_in_rtp_loop, 1);
+	while (atomic_read(&aw869x->is_in_rtp_loop)) {
+		aw_info("%s  goint to waiting irq exit\n", __func__);
+		mutex_unlock(&aw869x->lock);
+		ret = wait_event_interruptible(
+			aw869x->wait_q,
+			atomic_read(&aw869x->is_in_rtp_loop) == 0);
+		aw_info("%s  wakeup\n", __func__);
+		mutex_lock(&aw869x->lock);
+		if (ret == -ERESTARTSYS) {
+			atomic_set(&aw869x->exit_in_rtp_loop, 0);
+			wake_up_interruptible(&aw869x->stop_wait_q);
+			mutex_unlock(&aw869x->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return;
+		}
+	}
+
+	atomic_set(&aw869x->exit_in_rtp_loop, 0);
+	wake_up_interruptible(&aw869x->stop_wait_q);
+
+	/* how to force exit this call */
+	if (aw869x->is_custom_wave == 1 && aw869x->state) {
+		aw_err("%s buffer size %d, availbe size %d\n", __func__,
+		       aw869x->ram.base_addr >> 2, get_rb_avalible_size());
+		while (get_rb_avalible_size() < aw869x->ram.base_addr &&
+		       !rb_shoule_exit()) {
+			mutex_unlock(&aw869x->lock);
+			ret = wait_event_interruptible(
+				aw869x->stop_wait_q, (get_rb_avalible_size() >=
+						      aw869x->ram.base_addr) ||
+							     rb_shoule_exit());
+			aw_info("%s  wakeup\n", __func__);
+			aw_err("%s after wakeup sbuffer size %d, availbe size %d\n",
+			       __func__, aw869x->ram.base_addr >> 2,
+			       get_rb_avalible_size());
+			if (ret == -ERESTARTSYS) {
+				aw_err("%s wake up by signal return erro\n",
+				       __func__);
+				return;
+			}
+			mutex_lock(&aw869x->lock);
+		}
+	}
+
+	aw869x_haptic_stop(aw869x);
+
+	if (aw869x->state) {
+		pm_stay_awake(aw869x->dev);
+		if (aw869x->info.bst_vol_ram <= AW869X_MAX_BST_VO)
+			aw869x_haptic_set_bst_vol(aw869x,
+						  aw869x->info.bst_vol_rtp);
+		else
+			aw869x_haptic_set_bst_vol(aw869x, aw869x->vmax);
+		aw869x_haptic_ram_vbat_comp(aw869x, false);
+		aw869x_haptic_effect_strength(aw869x);
+		aw869x_haptic_set_gain(aw869x, aw869x->level);
+		aw869x->rtp_init = 0;
+		if (aw869x->is_custom_wave == 0) {
+			aw869x->rtp_file_num = aw869x->effect_id -
+					       aw869x->info.effect_id_boundary;
+			aw_info("%s: aw869x->rtp_file_num =%d\n", __func__,
+				aw869x->rtp_file_num);
+			if (aw869x->rtp_file_num < 0)
+				aw869x->rtp_file_num = 0;
+			if (aw869x->rtp_file_num > ((awinic_rtp_name_len)-1))
+				aw869x->rtp_file_num = (awinic_rtp_name_len)-1;
+
+			/* fw loaded */
+			ret = request_firmware(
+				&rtp_file,
+				awinic_rtp_name[aw869x->rtp_file_num],
+				aw869x->dev);
+			if (ret < 0) {
+				aw_err("%s: failed to read %s\n", __func__,
+				       awinic_rtp_name[aw869x->rtp_file_num]);
+				pm_relax(aw869x->dev);
+				mutex_unlock(&aw869x->lock);
+				return;
+			}
+
+			vfree(aw869x_rtp);
+			aw869x_rtp = vmalloc(rtp_file->size + sizeof(int));
+			if (!aw869x_rtp) {
+				release_firmware(rtp_file);
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw869x->dev);
+				mutex_unlock(&aw869x->lock);
+				return;
+			}
+			aw869x_rtp->len = rtp_file->size;
+			aw_info("%s: rtp file [%s] size = %d\n", __func__,
+				awinic_rtp_name[aw869x->rtp_file_num],
+				aw869x_rtp->len);
+			memcpy(aw869x_rtp->data, rtp_file->data,
+			       rtp_file->size);
+			release_firmware(rtp_file);
+		} else {
+			vfree(aw869x_rtp);
+			aw869x_rtp = vmalloc(aw869x->ram.base_addr >> 2);
+			if (!aw869x_rtp) {
+				aw_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw869x->dev);
+				mutex_unlock(&aw869x->lock);
+				return;
+			}
+		}
+		aw869x->rtp_init = 1;
+
+		/* rtp mode config */
+		aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RTP_MODE);
+
+		/* haptic start */
+		aw869x_haptic_start(aw869x);
+
+		aw869x_haptic_rtp_init(aw869x);
+	} else {
+		aw869x->rtp_cnt = 0;
+		aw869x->rtp_init = 0;
+		pm_relax(aw869x->dev);
+	}
+	mutex_unlock(&aw869x->lock);
+}
+
+static enum hrtimer_restart
+aw869x_haptic_audio_timer_func(struct hrtimer *timer)
+{
+	struct aw869x *aw869x =
+		container_of(timer, struct aw869x, haptic_audio.timer);
+
+	aw_dbg("%s enter\n", __func__);
+	/* schedule_work(&aw869x->haptic_audio.work); */
+	queue_work(aw869x->work_queue, &aw869x->haptic_audio.work);
+
+	hrtimer_start(
+		&aw869x->haptic_audio.timer,
+		ktime_set(aw869x->haptic_audio.timer_val / 1000000,
+			  (aw869x->haptic_audio.timer_val % 1000000) * 1000),
+		HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static void aw869x_haptic_audio_work_routine(struct work_struct *work)
+{
+	struct aw869x *aw869x =
+		container_of(work, struct aw869x, haptic_audio.work);
+
+	aw_info("%s enter\n", __func__);
+
+	mutex_lock(&aw869x->haptic_audio.lock);
+	memcpy(&aw869x->haptic_audio.ctr,
+	       &aw869x->haptic_audio.data[aw869x->haptic_audio.cnt],
+	       sizeof(struct haptic_ctr));
+	aw_dbg("%s: cnt=%d, cmd=%d, play=%d, wavseq=%d, loop=%d, gain=%d\n",
+	       __func__, aw869x->haptic_audio.cnt, aw869x->haptic_audio.ctr.cmd,
+	       aw869x->haptic_audio.ctr.play, aw869x->haptic_audio.ctr.wavseq,
+	       aw869x->haptic_audio.ctr.loop, aw869x->haptic_audio.ctr.gain);
+	mutex_unlock(&aw869x->haptic_audio.lock);
+	if (aw869x->haptic_audio.ctr.cmd == AW869X_HAPTIC_CMD_ENABLE) {
+		if (AW869X_HAPTIC_PLAY_ENABLE ==
+		    aw869x->haptic_audio.ctr.play) {
+			aw_info("%s: haptic_audio_play_start\n", __func__);
+			mutex_lock(&aw869x->lock);
+			aw869x_haptic_stop(aw869x);
+			aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RAM_MODE);
+
+			aw869x_haptic_set_wav_seq(
+				aw869x, 0x00, aw869x->haptic_audio.ctr.wavseq);
+			aw869x_haptic_set_wav_seq(aw869x, 0x01, 0x00);
+
+			aw869x_haptic_set_wav_loop(
+				aw869x, 0x00, aw869x->haptic_audio.ctr.loop);
+
+			aw869x_haptic_set_gain(aw869x,
+					       aw869x->haptic_audio.ctr.gain);
+
+			aw869x_haptic_start(aw869x);
+			mutex_unlock(&aw869x->lock);
+		} else if (AW869X_HAPTIC_PLAY_STOP ==
+			   aw869x->haptic_audio.ctr.play) {
+			mutex_lock(&aw869x->lock);
+			aw869x_haptic_stop(aw869x);
+			mutex_unlock(&aw869x->lock);
+		} else if (AW869X_HAPTIC_PLAY_GAIN ==
+			   aw869x->haptic_audio.ctr.play) {
+			mutex_lock(&aw869x->lock);
+			aw869x_haptic_set_gain(aw869x,
+					       aw869x->haptic_audio.ctr.gain);
+			mutex_unlock(&aw869x->lock);
+		}
+		mutex_lock(&aw869x->haptic_audio.lock);
+		memset(&aw869x->haptic_audio.data[aw869x->haptic_audio.cnt], 0,
+		       sizeof(struct haptic_ctr));
+		mutex_unlock(&aw869x->haptic_audio.lock);
+	}
+
+	mutex_lock(&aw869x->haptic_audio.lock);
+	aw869x->haptic_audio.cnt++;
+	if (aw869x->haptic_audio.data[aw869x->haptic_audio.cnt].cmd == 0) {
+		aw869x->haptic_audio.cnt = 0;
+		aw_dbg("%s: haptic play buffer restart\n", __func__);
+	}
+	mutex_unlock(&aw869x->haptic_audio.lock);
+}
+
+/*****************************************************
+ *
+ * haptic cont
+ *
+ *****************************************************/
+static int aw869x_haptic_cont(struct aw869x *aw869x)
+{
+	aw_info("%s enter\n", __func__);
+
+	/* work mode */
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_CONT_MODE);
+
+	/* preset f0 */
+	aw869x_haptic_set_f0_preset(aw869x);
+
+	/* lpf */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+			      AW869X_BIT_DATCTRL_FC_MASK,
+			      AW869X_BIT_DATCTRL_FC_1000HZ);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+			      AW869X_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW869X_BIT_DATCTRL_LPF_ENABLE);
+
+	/* cont config */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_ZC_DETEC_MASK,
+			      AW869X_BIT_CONT_CTRL_ZC_DETEC_ENABLE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_WAIT_PERIOD_MASK,
+			      AW869X_BIT_CONT_CTRL_WAIT_1PERIOD);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_MODE_MASK,
+			      AW869X_BIT_CONT_CTRL_BY_GO_SIGNAL);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_CONT_PLAYBACK_MODE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_O2C_MASK,
+			      AW869X_BIT_CONT_CTRL_O2C_DISABLE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW869X_BIT_CONT_CTRL_AUTO_BRK_ENABLE);
+
+	/* TD time */
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_H,
+			 (unsigned char)(aw869x->info.cont_td >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_L,
+			 (unsigned char)(aw869x->info.cont_td >> 0));
+	aw869x_i2c_write(aw869x, AW869X_REG_TSET, aw869x->info.tset);
+
+	/* zero cross */
+	aw869x_i2c_write(aw869x, AW869X_REG_ZC_THRSH_H,
+			 (unsigned char)(aw869x->info.cont_zc_thr >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_ZC_THRSH_L,
+			 (unsigned char)(aw869x->info.cont_zc_thr >> 0));
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_BEMF_NUM,
+			      AW869X_BIT_BEMF_NUM_BRK_MASK,
+			      aw869x->info.cont_num_brk);
+	/* 35*171us=5.985ms */
+	aw869x_i2c_write(aw869x, AW869X_REG_TIME_NZC, 0x23);
+
+	/* f0 driver level */
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL, aw869x->info.cont_drv_lvl);
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL_OV,
+			 aw869x->info.cont_drv_lvl_ov);
+
+	/* cont play go */
+	aw869x_haptic_play_go(aw869x, true);
+
+	return 0;
+}
+static int aw869x_get_glb_state(struct aw869x *aw869x)
+{
+	unsigned char glb_state_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_GLB_STATE, &glb_state_val);
+	return glb_state_val;
+}
+
+#ifndef USE_CONT_F0_CALI
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw869x_haptic_get_f0(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char f0_pre_num = 0;
+	unsigned char f0_wait_num = 0;
+	unsigned char f0_repeat_num = 0;
+	unsigned char f0_trace_num = 0;
+	unsigned int t_f0_ms = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	aw_info("%s enter\n", __func__);
+
+	aw869x->f0 = aw869x->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw869x_haptic_stop(aw869x);
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_CONT_MODE);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_ENABLE);
+
+	/* LPF */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+			      AW869X_BIT_DATCTRL_FC_MASK,
+			      AW869X_BIT_DATCTRL_FC_1000HZ);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+			      AW869X_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW869X_BIT_DATCTRL_LPF_ENABLE);
+	/* preset f0 */
+	aw869x_haptic_set_f0_preset(aw869x);
+
+	/* f0 driver level */
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL, aw869x->info.cont_drv_lvl);
+
+	/* f0 trace parameter */
+	f0_pre_num = aw869x->info.f0_trace_parameter[0];
+	f0_wait_num = aw869x->info.f0_trace_parameter[1];
+	f0_repeat_num = aw869x->info.f0_trace_parameter[2];
+	f0_trace_num = aw869x->info.f0_trace_parameter[3];
+	aw869x_i2c_write(aw869x, AW869X_REG_NUM_F0_1,
+			 (f0_pre_num << 4) | (f0_wait_num << 0));
+	aw869x_i2c_write(aw869x, AW869X_REG_NUM_F0_2, (f0_repeat_num << 0));
+	aw869x_i2c_write(aw869x, AW869X_REG_NUM_F0_3, (f0_trace_num << 0));
+
+	/* clear aw869x interrupt */
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw869x_haptic_play_go(aw869x, true);
+
+	/* f0 trace time */
+	t_f0_ms = 1000 * 10 / aw869x->info.f0_pre;
+	t_f0_trace_ms =
+		t_f0_ms * (f0_pre_num + f0_wait_num +
+			   (f0_trace_num + f0_wait_num) * (f0_repeat_num - 1)) +
+		50;
+	usleep_range(t_f0_trace_ms * 1000, t_f0_trace_ms * 1000 + 500);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		reg_val = aw869x_get_glb_state(aw869x);
+		/* f0 calibrate done */
+		if ((reg_val & 0x0f) == 0x00) {
+			aw869x_haptic_read_f0(aw869x);
+			aw869x_haptic_read_beme(aw869x);
+			break;
+		}
+		usleep_range(10000, 10500);
+		aw_info("%s: f0 cali sleep 10ms\n", __func__);
+	}
+	if (i == f0_cali_cnt)
+		ret = -1;
+	else
+		ret = 0;
+	/* restore default config */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_CONT_PLAYBACK_MODE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#else
+/*****************************************************
+ *
+ * haptic cont mode f0 cali
+ *
+ *****************************************************/
+static int aw869x_haptic_get_f0(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	aw_info("%s enter\n", __func__);
+
+	aw869x->f0 = aw869x->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw869x_haptic_stop(aw869x);
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_CONT_MODE);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_MODE_MASK,
+			      AW869X_BIT_CONT_CTRL_BY_DRV_TIME);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_BIT_CONT_CTRL_CLOSE_PLAYBACK);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW869X_BIT_CONT_CTRL_AUTO_BRK_DISABLE);
+
+	/* LPF */
+	/*aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+	 *        AW869X_BIT_DATCTRL_FC_MASK, AW869X_BIT_DATCTRL_FC_1000HZ);
+	 *aw869x_i2c_write_bits(aw869x, AW869X_REG_DATCTRL,
+	 *			AW869X_BIT_DATCTRL_LPF_ENABLE_MASK,
+	 *			AW869X_BIT_DATCTRL_LPF_ENABLE);
+	 */
+
+	/* f0 driver level */
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL, aw869x->info.cont_drv_lvl);
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL_OV,
+			 aw869x->info.cont_drv_lvl_ov);
+
+	/* TD time */
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_H, aw869x->info.cont_td >> 8);
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_L, aw869x->info.cont_td);
+	aw869x_i2c_write(aw869x, AW869X_REG_TSET, aw869x->info.tset);
+
+	/* drive time  */
+	aw869x_i2c_write(aw869x, AW869X_REG_DRV_TIME, 0x75);
+
+	/* preset f0 */
+	aw869x_haptic_set_f0_preset(aw869x);
+
+	/* clear aw869x interrupt */
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw869x_haptic_play_go(aw869x, true);
+
+	/* f0 trace time */
+	t_f0_trace_ms = 0xfe * 684 / 1000;
+	msleep(t_f0_trace_ms);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		ret = aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+		/* f0 calibrate done */
+		if (reg_val & 0x01) {
+			aw869x_haptic_read_cont_f0(aw869x);
+			aw869x_haptic_read_cont_bemf(aw869x);
+			break;
+		}
+		msleep(10);
+		aw_info("%s f0 cali sleep 10ms\n", __func__);
+	}
+
+	if (i == f0_cali_cnt)
+		ret = -1;
+	else
+		ret = 0;
+
+	/* restore default config */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW869X_CONT_PLAYBACK_MODE);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_CONT_CTRL,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW869X_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#endif
+
+static int aw869x_haptic_f0_calibration(struct aw869x *aw869x)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	if (aw869x_haptic_get_f0(aw869x)) {
+		aw_err("%s get f0 error, user defafult f0\n", __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw869x->f0;
+		if (aw869x->f0 * 100 <
+		    aw869x->info.f0_pre * (100 - aw869x->info.f0_cali_percen)) {
+			f0_limit = aw869x->info.f0_pre;
+		}
+		if (aw869x->f0 * 100 >
+		    aw869x->info.f0_pre * (100 + aw869x->info.f0_cali_percen)) {
+			f0_limit = aw869x->info.f0_pre;
+		}
+
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw869x->info.f0_pre) /
+			       ((int)f0_limit * 25);
+		aw_info("%s  line=%d f0_cali_step=%d\n", __func__, __LINE__,
+			f0_cali_step);
+		aw_info("%s line=%d  f0_limit=%d\n", __func__, __LINE__,
+			(int)f0_limit);
+		aw_info("%s line=%d  aw869x->info.f0_pre=%d\n", __func__,
+			__LINE__, (int)aw869x->info.f0_pre);
+
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5)
+				f0_cali_step = f0_cali_step / 10 + 1 + 32;
+			else
+				f0_cali_step = f0_cali_step / 10 + 32;
+
+		} else { /*f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5)
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		}
+
+		if (f0_cali_step > 31)
+			f0_cali_lra = (char)f0_cali_step - 32;
+		else
+			f0_cali_lra = (char)f0_cali_step + 32;
+
+		aw869x->f0_calib_data = (int)f0_cali_lra;
+		aw_info("%s f0_cali_lra=%d\n", __func__, (int)f0_cali_lra);
+
+		/* update cali step */
+		aw869x_i2c_write(aw869x, AW869X_REG_TRIM_LRA,
+				 (char)f0_cali_lra);
+		aw869x_i2c_read(aw869x, AW869X_REG_TRIM_LRA, &reg_val);
+		aw_info("%s final trim_lra=0x%02x\n", __func__, reg_val);
+	}
+
+	/* restore default work mode */
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_STANDBY_MODE);
+	aw869x->play_mode = AW869X_HAPTIC_RAM_MODE;
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_PLAY_MODE_MASK,
+			      AW869X_BIT_SYSCTRL_PLAY_MODE_RAM);
+	aw869x_haptic_stop(aw869x);
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * haptic fops
+ *
+ *****************************************************/
+static int aw869x_file_open(struct inode *inode, struct file *file)
+{
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
+	aw_info("%s enter\n", __func__);
+	file->private_data = (void *)g_aw869x;
+
+	return 0;
+}
+
+static int aw869x_file_release(struct inode *inode, struct file *file)
+{
+	file->private_data = (void *)NULL;
+	aw_info("%s enter\n", __func__);
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+static long aw869x_file_unlocked_ioctl(struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	struct aw869x *aw869x = (struct aw869x *)file->private_data;
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+	aw_info("%s: cmd=0x%x, arg=0x%lx\n", __func__, cmd, arg);
+
+	mutex_lock(&aw869x->lock);
+
+	if (_IOC_TYPE(cmd) != AW869X_HAPTIC_IOCTL_MAGIC) {
+		aw_err("%s: cmd magic err\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	default:
+		aw_err("%s, unknown cmd\n", __func__);
+		break;
+	}
+
+	mutex_unlock(&aw869x->lock);
+
+	return ret;
+}
+
+static ssize_t aw869x_file_read(struct file *filp, char *buff, size_t len,
+				loff_t *offset)
+{
+	struct aw869x *aw869x = (struct aw869x *)filp->private_data;
+	int ret = 0;
+	int i = 0;
+	unsigned char reg_val = 0;
+	unsigned char *pbuff = NULL;
+
+	aw_info("%s enter\n", __func__);
+	mutex_lock(&aw869x->lock);
+
+	aw_info("%s: len=%zu\n", __func__, len);
+
+	switch (aw869x->fileops.cmd) {
+	case AW869X_HAPTIC_CMD_READ_REG:
+		pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+		if (pbuff != NULL) {
+			for (i = 0; i < len; i++) {
+				aw869x_i2c_read(aw869x, aw869x->fileops.reg + i,
+						&reg_val);
+				pbuff[i] = reg_val;
+			}
+			for (i = 0; i < len; i++) {
+				aw_info("%s: pbuff[%d]=0x%02x\n", __func__, i,
+					pbuff[i]);
+			}
+			ret = copy_to_user(buff, pbuff, len);
+			if (ret) {
+				aw_err("%s: copy to user fail\n", __func__);
+			}
+			kfree(pbuff);
+		} else {
+			aw_err("%s: alloc memory fail\n", __func__);
+		}
+		break;
+	default:
+		aw_err("%s, unknown cmd %d\n", __func__, aw869x->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw869x->lock);
+
+	return len;
+}
+
+static ssize_t aw869x_file_write(struct file *filp, const char *buff,
+				 size_t len, loff_t *off)
+{
+	struct aw869x *aw869x = (struct aw869x *)filp->private_data;
+	int i = 0;
+	int ret = 0;
+	unsigned char *pbuff = NULL;
+
+	aw_info("%s enter\n", __func__);
+	pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+	if (pbuff == NULL) {
+		aw_err("%s: alloc memory fail\n", __func__);
+		return len;
+	}
+	ret = copy_from_user(pbuff, buff, len);
+	if (ret) {
+		aw_err("%s: copy from user fail\n", __func__);
+		return len;
+	}
+
+	for (i = 0; i < len; i++) {
+		aw_info("%s: pbuff[%d]=0x%02x\n", __func__, i, pbuff[i]);
+	}
+
+	mutex_lock(&aw869x->lock);
+
+	aw869x->fileops.cmd = pbuff[0];
+
+	switch (aw869x->fileops.cmd) {
+	case AW869X_HAPTIC_CMD_READ_REG:
+		if (len == 2) {
+			aw869x->fileops.reg = pbuff[1];
+		} else {
+			aw_err("%s: read cmd len %zu err\n", __func__, len);
+		}
+		break;
+	case AW869X_HAPTIC_CMD_WRITE_REG:
+		if (len > 2) {
+			for (i = 0; i < len - 2; i++) {
+				aw_info("%s: write reg0x%02x=0x%02x\n",
+					__func__, pbuff[1] + i, pbuff[i + 2]);
+				aw869x_i2c_write(aw869x, pbuff[1] + i,
+						 pbuff[2 + i]);
+			}
+		} else {
+			aw_err("%s: write cmd len %zu err\n", __func__, len);
+		}
+		break;
+	default:
+		aw_err("%s, unknown cmd %d\n", __func__, aw869x->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw869x->lock);
+
+	if (pbuff != NULL)
+		kfree(pbuff);
+
+	return len;
+}
+
+static const struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.read = aw869x_file_read,
+	.write = aw869x_file_write,
+	.unlocked_ioctl = aw869x_file_unlocked_ioctl,
+	.open = aw869x_file_open,
+	.release = aw869x_file_release,
+};
+
+struct miscdevice aw869x_haptic_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = AW_HAPTIC_NAME,
+	.fops = &fops,
+};
+
+/*****************************************************
+ *
+ * vibrator
+ *
+ *****************************************************/
+static enum hrtimer_restart qti_hap_stop_timer(struct hrtimer *timer)
+{
+	struct aw869x *aw869x = container_of(timer, struct aw869x, stop_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	aw869x->play.length_us = 0;
+	/* qti_haptics_play(aw869x, false); */
+	rc = aw869x_haptic_play_go(aw869x, false);
+	if (rc < 0)
+		aw_err("Stop playing failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart qti_hap_disable_timer(struct hrtimer *timer)
+{
+	struct aw869x *aw869x =
+		container_of(timer, struct aw869x, hap_disable_timer);
+	int rc;
+
+	aw_info("%s enter\n", __func__);
+	/* qti_haptics_module_en(aw869x, false); */
+	rc = aw869x_haptic_play_go(aw869x, false);
+	if (rc < 0)
+		aw_err("Disable haptics module failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart aw869x_vibrator_timer_func(struct hrtimer *timer)
+{
+	struct aw869x *aw869x = container_of(timer, struct aw869x, timer);
+
+	aw_info("%s enter\n", __func__);
+
+	aw869x->state = 0;
+	/* schedule_work(&aw869x->vibrator_work); */
+	queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw869x_vibrator_work_routine(struct work_struct *work)
+{
+	struct aw869x *aw869x =
+		container_of(work, struct aw869x, vibrator_work);
+
+	aw_dbg("%s enter\n", __func__);
+	aw_info("%s: effect_id=%d state=%d activate_mode=%d duration=%d\n",
+		__func__, aw869x->effect_id, aw869x->state,
+		aw869x->activate_mode, aw869x->duration);
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_upload_lra(aw869x, AW869X_F0_CALI_LRA);
+	aw869x_haptic_stop(aw869x);
+	if (aw869x->state) {
+		if (aw869x->activate_mode == AW869X_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw869x_haptic_ram_vbat_comp(aw869x, false);
+			aw869x_haptic_play_effect_seq(aw869x, true);
+		} else if (aw869x->activate_mode ==
+			   AW869X_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw869x->level = 0x80;
+			aw869x_haptic_ram_vbat_comp(aw869x, true);
+			aw869x_haptic_play_effect_seq(aw869x, true);
+			hrtimer_start(
+				&aw869x->timer,
+				ktime_set(aw869x->duration / 1000,
+					  (aw869x->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else if (aw869x->activate_mode ==
+			   AW869X_HAPTIC_ACTIVATE_CONT_MODE) {
+			aw869x_haptic_cont(aw869x);
+			hrtimer_start(
+				&aw869x->timer,
+				ktime_set(aw869x->duration / 1000,
+					  (aw869x->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else {
+			/*other mode */
+		}
+	}
+	mutex_unlock(&aw869x->lock);
+}
+
+/******************************************************
+ *
+ * irq
+ *
+ ******************************************************/
+static void aw869x_interrupt_clear(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+}
+
+void aw869x_interrupt_setup(struct aw869x *aw869x)
+{
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+
+	/* edge int mode */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DBGCTRL,
+			      AW869X_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW869X_BIT_DBGCTRL_INT_MODE_EDGE);
+
+	/* int enable */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_BSTERR_MASK,
+			      AW869X_BIT_SYSINTM_BSTERR_OFF);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_OV_MASK,
+			      AW869X_BIT_SYSINTM_OV_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_UVLO_MASK,
+			      AW869X_BIT_SYSINTM_UVLO_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_OCD_MASK,
+			      AW869X_BIT_SYSINTM_OCD_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSINTM,
+			      AW869X_BIT_SYSINTM_OT_MASK,
+			      AW869X_BIT_SYSINTM_OT_EN);
+}
+
+irqreturn_t aw869x_irq(int irq, void *data)
+{
+	struct aw869x *aw869x = data;
+	unsigned char reg_val = 0;
+	unsigned char dbg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw869x->ram.base_addr >> 2;
+
+	atomic_set(&aw869x->is_in_rtp_loop, 1);
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+	/* aw_info("%s: reg SYSINT=0x%x\n", __func__, reg_val); */
+	aw869x_i2c_read(aw869x, AW869X_REG_DBGSTAT, &dbg_val);
+	/* aw_info("%s: reg DBGSTAT=0x%x\n", __func__, dbg_val); */
+
+	if (reg_val & AW869X_BIT_SYSINT_OVI)
+		aw_err("%s chip ov int error\n", __func__);
+
+	if (reg_val & AW869X_BIT_SYSINT_UVLI)
+		aw_err("%s chip uvlo int error\n", __func__);
+
+	if (reg_val & AW869X_BIT_SYSINT_OCDI)
+		aw_err("%s chip over current int error\n", __func__);
+
+	if (reg_val & AW869X_BIT_SYSINT_OTI)
+		aw_err("%s chip over temperature int error\n", __func__);
+
+	if (reg_val & AW869X_BIT_SYSINT_DONEI)
+		aw_info("%s chip playback done\n", __func__);
+
+	if (reg_val & AW869X_BIT_SYSINT_FF_AEI) {
+		aw_dbg("%s: aw869x rtp fifo almost empty int\n", __func__);
+		if (aw869x->rtp_init) {
+			while ((!aw869x_haptic_rtp_get_fifo_afi(aw869x)) &&
+			       (aw869x->play_mode == AW869X_HAPTIC_RTP_MODE) &&
+			       !atomic_read(&aw869x->exit_in_rtp_loop)) {
+				mutex_lock(&aw869x->rtp_lock);
+				if (!aw869x_rtp) {
+					aw_info("%s:aw869x_rtp is null break\n",
+						__func__);
+					mutex_unlock(&aw869x->rtp_lock);
+					break;
+				}
+
+				if (aw869x->is_custom_wave == 1) {
+					buf_len = read_rb(aw869x_rtp->data,
+							  period_size);
+					aw869x_i2c_writes(aw869x,
+							  AW869X_REG_RTP_DATA,
+							  aw869x_rtp->data,
+							  buf_len);
+					if (buf_len < period_size) {
+						aw_info("%s: rtp update complete\n",
+							__func__);
+						aw869x_haptic_set_rtp_aei(
+							aw869x, false);
+						aw869x->rtp_cnt = 0;
+						aw869x->rtp_init = 0;
+						mutex_unlock(&aw869x->rtp_lock);
+						break;
+					}
+				} else {
+					if ((aw869x_rtp->len -
+					     aw869x->rtp_cnt) < period_size) {
+						buf_len = aw869x_rtp->len -
+							  aw869x->rtp_cnt;
+					} else {
+						buf_len = period_size;
+					}
+					aw869x_i2c_writes(
+						aw869x, AW869X_REG_RTP_DATA,
+						&aw869x_rtp
+							 ->data[aw869x->rtp_cnt],
+						buf_len);
+					aw869x->rtp_cnt += buf_len;
+					if (aw869x->rtp_cnt ==
+					    aw869x_rtp->len) {
+						aw_info("%s: rtp update complete\n",
+							__func__);
+						aw869x_haptic_set_rtp_aei(
+							aw869x, false);
+						aw869x->rtp_cnt = 0;
+						aw869x->rtp_init = 0;
+						mutex_unlock(&aw869x->rtp_lock);
+						break;
+					}
+				}
+				mutex_unlock(&aw869x->rtp_lock);
+			}
+		} else {
+			aw_err("%s: aw869x rtp init = %d, init error\n",
+			       __func__, aw869x->rtp_init);
+		}
+	}
+
+	if (reg_val & AW869X_BIT_SYSINT_FF_AFI)
+		aw_dbg("%s: aw869x rtp mode fifo full empty\n", __func__);
+
+	if (aw869x->play_mode != AW869X_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw869x->exit_in_rtp_loop))
+		aw869x_haptic_set_rtp_aei(aw869x, false);
+
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSINT, &reg_val);
+	aw_dbg("%s: reg SYSINT=0x%x\n", __func__, reg_val);
+	aw869x_i2c_read(aw869x, AW869X_REG_SYSST, &reg_val);
+	aw_dbg("%s: reg SYSST=0x%x\n", __func__, reg_val);
+	atomic_set(&aw869x->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw869x->wait_q);
+	aw_dbg("%s exit\n", __func__);
+	return IRQ_HANDLED;
+}
+
+/*****************************************************
+ *
+ * device tree
+ *
+ *****************************************************/
+int aw869x_parse_dt(struct device *dev, struct aw869x *aw869x,
+		    struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int bstdbg[6];
+	unsigned int f0_trace_parameter[4];
+	unsigned int bemf_config[4];
+	unsigned int rtp_time[175];
+	unsigned int trig_config[15];
+	struct qti_hap_config *config = &aw869x->config;
+	struct device_node *child_node;
+	struct qti_hap_effect *effect;
+	int rc = 0, tmp, i = 0, j;
+
+	val = of_property_read_u32(np, "aw869x_vib_mode", &aw869x->info.mode);
+	if (val != 0)
+		aw_info("aw869x_vib_mode not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_f0_pre",
+				   &aw869x->info.f0_pre);
+	if (val != 0)
+		aw_info("aw869x_vib_f0_pre not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_f0_cali_percen",
+				   &aw869x->info.f0_cali_percen);
+	if (val != 0)
+		aw_info("aw869x_vib_f0_cali_percen not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_cont_drv_lev",
+				   &aw869x->info.cont_drv_lvl);
+	if (val != 0)
+		aw_info("aw869x_vib_cont_drv_lev not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_cont_drv_lvl_ov",
+				   &aw869x->info.cont_drv_lvl_ov);
+	if (val != 0)
+		aw_info("aw869x_vib_cont_drv_lvl_ov not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_cont_td",
+				   &aw869x->info.cont_td);
+	if (val != 0)
+		aw_info("aw869x_vib_cont_td not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_cont_zc_thr",
+				   &aw869x->info.cont_zc_thr);
+	if (val != 0)
+		aw_info("aw869x_vib_cont_zc_thr not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_cont_num_brk",
+				   &aw869x->info.cont_num_brk);
+	if (val != 0)
+		aw_info("aw869x_vib_cont_num_brk not found\n");
+	val = of_property_read_u32(np, "aw869x_vib_f0_coeff",
+				   &aw869x->info.f0_coeff);
+	if (val != 0)
+		aw_info("aw869x_vib_f0_coeff not found\n");
+
+	val = of_property_read_u32(np, "aw869x_vib_tset", &aw869x->info.tset);
+	if (val != 0)
+		aw_info("%s vib_tset not found\n", __func__);
+	val = of_property_read_u32(np, "aw869x_vib_r_spare",
+				   &aw869x->info.r_spare);
+	if (val != 0)
+		aw_info("%s vib_r_spare not found\n", __func__);
+	val = of_property_read_u32_array(np, "aw869x_vib_bstdbg", bstdbg,
+					 ARRAY_SIZE(bstdbg));
+	if (val != 0)
+		aw_info("%s vib_bstdbg not found\n", __func__);
+	memcpy(aw869x->info.bstdbg, bstdbg, sizeof(bstdbg));
+
+	val = of_property_read_u32_array(np, "aw869x_vib_f0_trace_parameter",
+					 f0_trace_parameter,
+					 ARRAY_SIZE(f0_trace_parameter));
+	if (val != 0)
+		aw_info("%s vib_f0_trace_parameter not found\n", __func__);
+	memcpy(aw869x->info.f0_trace_parameter, f0_trace_parameter,
+	       sizeof(f0_trace_parameter));
+	val = of_property_read_u32_array(np, "aw869x_vib_bemf_config",
+					 bemf_config, ARRAY_SIZE(bemf_config));
+	if (val != 0)
+		aw_info("%s vib_bemf_config not found\n", __func__);
+	memcpy(aw869x->info.bemf_config, bemf_config, sizeof(bemf_config));
+
+	val = of_property_read_u32_array(np, "aw869x_vib_trig_config",
+					 trig_config, ARRAY_SIZE(trig_config));
+	if (val != 0)
+		aw_info("%s vib_trig_config not found\n", __func__);
+	memcpy(aw869x->info.trig_config, trig_config, sizeof(trig_config));
+	val = of_property_read_u32(np, "aw869x_vib_bst_vol_default",
+				   &aw869x->info.bst_vol_default);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_default not found\n", __func__);
+	val = of_property_read_u32(np, "aw869x_vib_bst_vol_ram",
+				   &aw869x->info.bst_vol_ram);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_ram not found\n", __func__);
+	val = of_property_read_u32(np, "aw869x_vib_bst_vol_rtp",
+				   &aw869x->info.bst_vol_rtp);
+	if (val != 0)
+		aw_info("%s vib_bst_vol_rtp not found\n", __func__);
+
+	val = of_property_read_u32(np, "vib_effect_id_boundary",
+				   &aw869x->info.effect_id_boundary);
+	if (val != 0)
+		aw_info("%s vib_effect_id_boundary not found\n", __func__);
+	val = of_property_read_u32(np, "vib_effect_max",
+				   &aw869x->info.effect_max);
+	if (val != 0)
+		aw_info("%s vib_effect_max not found\n", __func__);
+	val = of_property_read_u32_array(np, "vib_rtp_time", rtp_time,
+					 ARRAY_SIZE(rtp_time));
+	if (val != 0)
+		aw_info("%s vib_rtp_time not found\n", __func__);
+	memcpy(aw869x->info.rtp_time, rtp_time, sizeof(rtp_time));
+	config->play_rate_us = HAP_PLAY_RATE_US_DEFAULT;
+	rc = of_property_read_u32(np, "play-rate-us", &tmp);
+	if (!rc)
+		config->play_rate_us = (tmp >= HAP_PLAY_RATE_US_MAX) ?
+					       HAP_PLAY_RATE_US_MAX :
+					       tmp;
+
+	aw869x->constant.pattern = devm_kcalloc(
+		aw869x->dev, HAP_WAVEFORM_BUFFER_MAX, sizeof(u8), GFP_KERNEL);
+	if (!aw869x->constant.pattern)
+		return -ENOMEM;
+
+	tmp = of_get_available_child_count(np);
+	aw869x->predefined = devm_kcalloc(
+		aw869x->dev, tmp, sizeof(*aw869x->predefined), GFP_KERNEL);
+	if (!aw869x->predefined)
+		return -ENOMEM;
+
+	aw869x->effects_count = tmp;
+	for_each_available_child_of_node (np, child_node) {
+		effect = &aw869x->predefined[i++];
+		rc = of_property_read_u32(child_node, "mtk,effect-id",
+					  &effect->id);
+		if (rc != 0)
+			aw_info("%s Read mtk,effect-id failed\n", __func__);
+
+		effect->vmax_mv = config->vmax_mv;
+		rc = of_property_read_u32(child_node, "mtk,wf-vmax-mv", &tmp);
+		if (rc != 0)
+			aw_info("%s  Read mtk,wf-vmax-mv failed !\n", __func__);
+		else
+			effect->vmax_mv = tmp;
+
+		aw_info("%s ---%d effect->vmax_mv =%d\n", __func__, __LINE__,
+			effect->vmax_mv);
+		rc = of_property_count_elems_of_size(
+			child_node, "mtk,wf-pattern", sizeof(u8));
+		if (rc < 0) {
+			aw_info("%s Count mtk,wf-pattern property failed !\n",
+				__func__);
+		} else if (rc == 0) {
+			aw_info("%s mtk,wf-pattern has no data\n", __func__);
+		}
+		aw_info("%s ---%d\n", __func__, __LINE__);
+
+		effect->pattern_length = rc;
+		effect->pattern =
+			devm_kcalloc(aw869x->dev, effect->pattern_length,
+				     sizeof(u8), GFP_KERNEL);
+
+		rc = of_property_read_u8_array(child_node, "mtk,wf-pattern",
+					       effect->pattern,
+					       effect->pattern_length);
+		if (rc < 0) {
+			aw_info("%s Read mtk,wf-pattern property failed !\n",
+				__func__);
+		}
+
+		effect->play_rate_us = config->play_rate_us;
+		rc = of_property_read_u32(child_node, "mtk,wf-play-rate-us",
+					  &tmp);
+		if (rc < 0)
+			aw_info("%s Read mtk,wf-play-rate-us failed !\n",
+				__func__);
+		else
+			effect->play_rate_us = tmp;
+
+		rc = of_property_read_u32(child_node, "mtk,wf-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_repeat); j++)
+				if (tmp <= wf_repeat[j])
+					break;
+
+			effect->wf_repeat_n = j;
+		}
+
+		rc = of_property_read_u32(child_node, "mtk,wf-s-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			aw_info("%s Read  mtk,wf-s-repeat-count failed !\n",
+				__func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_s_repeat); j++)
+				if (tmp <= wf_s_repeat[j])
+					break;
+
+			effect->wf_s_repeat_n = j;
+		}
+
+		effect->lra_auto_res_disable = of_property_read_bool(
+			child_node, "mtk,lra-auto-resonance-disable");
+
+		tmp = of_property_count_elems_of_size(
+			child_node, "mtk,wf-brake-pattern", sizeof(u8));
+		if (tmp <= 0)
+			continue;
+
+		if (tmp > HAP_BRAKE_PATTERN_MAX) {
+			aw_info("%s wf-brake-pattern shouldn't be more than %d bytes\n",
+				__func__, HAP_BRAKE_PATTERN_MAX);
+		}
+
+		rc = of_property_read_u8_array(
+			child_node, "mtk,wf-brake-pattern", effect->brake, tmp);
+		if (rc < 0) {
+			aw_info("%s Failed to get wf-brake-pattern !\n",
+				__func__);
+		}
+
+		effect->brake_pattern_length = tmp;
+	}
+
+	aw_info("bst_vol_default: 0x%x\n", aw869x->info.bst_vol_default);
+	aw_info("bst_vol_ram: 0x%x\n", aw869x->info.bst_vol_ram);
+	aw_info("bst_vol_rtp: 0x%x\n", aw869x->info.bst_vol_rtp);
+	return 0;
+}
+
+static inline void get_play_length(struct qti_hap_play_info *play,
+				   int *length_us)
+{
+	struct qti_hap_effect *effect = play->effect;
+	int tmp;
+
+	/* aw_info("%s  %d enter\n", __func__, __LINE__); */
+
+	tmp = effect->pattern_length * effect->play_rate_us;
+	tmp *= wf_s_repeat[effect->wf_s_repeat_n];
+	tmp *= wf_repeat[effect->wf_repeat_n];
+	if (effect->brake_en)
+		tmp += effect->play_rate_us * effect->brake_pattern_length;
+
+	*length_us = tmp;
+}
+
+int aw869x_haptics_upload_effect(struct input_dev *dev,
+				 struct ff_effect *effect,
+				 struct ff_effect *old)
+{
+	struct aw869x *aw869x = input_get_drvdata(dev);
+	struct qti_hap_play_info *play = &aw869x->play;
+	s16 data[CUSTOM_DATA_LEN];
+	ktime_t rem;
+	s64 time_us;
+	int ret;
+
+	/*for osc calibration*/
+	if (aw869x->osc_cali_run != 0)
+		return 0;
+
+	if (hrtimer_active(&aw869x->timer)) {
+		rem = hrtimer_get_remaining(&aw869x->timer);
+		time_us = ktime_to_us(rem);
+		aw_info("waiting for playing clear sequence: %lld us\n",
+			time_us);
+		usleep_range(time_us, time_us + 100);
+	}
+	aw_dbg("%s: effect->type=0x%x,FF_CONSTANT=0x%x,FF_PERIODIC=0x%x\n",
+	       __func__, effect->type, FF_CONSTANT, FF_PERIODIC);
+	aw869x->effect_type = effect->type;
+	mutex_lock(&aw869x->lock);
+	while (atomic_read(&aw869x->exit_in_rtp_loop)) {
+		aw_info("%s  goint to waiting rtp  exit\n", __func__);
+		mutex_unlock(&aw869x->lock);
+		ret = wait_event_interruptible(
+			aw869x->stop_wait_q,
+			atomic_read(&aw869x->exit_in_rtp_loop) == 0);
+		aw_info("%s  wakeup\n", __func__);
+		if (ret == -ERESTARTSYS) {
+			mutex_unlock(&aw869x->lock);
+			aw_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+		mutex_lock(&aw869x->lock);
+	}
+
+	if (aw869x->effect_type == FF_CONSTANT) {
+		aw_dbg("%s: effect_type is  FF_CONSTANT!\n", __func__);
+		/*cont mode set duration */
+		aw869x->duration = effect->replay.length;
+		aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RAM_LOOP_MODE;
+		aw869x->effect_id = aw869x->info.effect_id_boundary;
+
+	} else if (aw869x->effect_type == FF_PERIODIC) {
+		if (aw869x->effects_count == 0) {
+			mutex_unlock(&aw869x->lock);
+			return -EINVAL;
+		}
+
+		aw_dbg("%s: effect_type is  FF_PERIODIC!\n", __func__);
+		if (copy_from_user(data, effect->u.periodic.custom_data,
+				   sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw869x->lock);
+			return -EFAULT;
+		}
+
+		aw869x->effect_id = data[0];
+		aw_dbg("%s: aw869x->effect_id =%d\n", __func__,
+		       aw869x->effect_id);
+		play->vmax_mv = effect->u.periodic.magnitude; /*vmax level*/
+
+		if (aw869x->effect_id < 0 ||
+		    aw869x->effect_id > aw869x->info.effect_max) {
+			mutex_unlock(&aw869x->lock);
+			return 0;
+		}
+		aw869x->is_custom_wave = 0;
+
+		if (aw869x->effect_id < aw869x->info.effect_id_boundary) {
+			aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RAM_MODE;
+			aw_dbg("%s: aw869x->effect_id=%d, aw869x->activate_mode = %d\n",
+			       __func__, aw869x->effect_id,
+			       aw869x->activate_mode);
+			/*second data*/
+			data[1] = aw869x->predefined[aw869x->effect_id]
+					  .play_rate_us /
+				  1000000;
+			/*millisecond data*/
+			data[2] = aw869x->predefined[aw869x->effect_id]
+					  .play_rate_us /
+				  1000;
+		}
+		if (aw869x->effect_id >= aw869x->info.effect_id_boundary) {
+			aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw869x->effect_id=%d , aw869x->activate_mode = %d\n",
+			       __func__, aw869x->effect_id,
+			       aw869x->activate_mode);
+			/*second data*/
+			data[1] =
+				aw869x->info.rtp_time[aw869x->effect_id] / 1000;
+			/*millisecond data*/
+			data[2] = aw869x->info.rtp_time[aw869x->effect_id];
+		}
+		if (aw869x->effect_id == CUSTOME_WAVE_ID) {
+			aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RTP_MODE;
+			aw_dbg("%s: aw869x->effect_id=%d , aw869x->activate_mode = %d\n",
+			       __func__, aw869x->effect_id,
+			       aw869x->activate_mode);
+			/*second data*/
+			data[1] =
+				aw869x->info.rtp_time[aw869x->effect_id] / 1000;
+			/*millisecond data*/
+			data[2] = aw869x->info.rtp_time[aw869x->effect_id];
+			aw869x->is_custom_wave = 1;
+			rb_init();
+		}
+
+		if (copy_to_user(effect->u.periodic.custom_data, data,
+				 sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw869x->lock);
+			return -EFAULT;
+		}
+
+	} else {
+		aw_err("%s Unsupported effect type: %d\n", __func__,
+		       effect->type);
+	}
+	mutex_unlock(&aw869x->lock);
+	return 0;
+}
+
+int aw869x_haptics_playback(struct input_dev *dev, int effect_id, int val)
+{
+	struct aw869x *aw869x = input_get_drvdata(dev);
+	int rc = 0;
+
+	/* aw_info("%s effect_id=%d , val = %d\n", __func__, effect_id, val);
+	 * aw_info("%s aw869x->effect_id=%d , aw869x->activate_mode = %d\n",
+	 *   __func__, aw869x->effect_id, aw869x->activate_mode);
+	 */
+
+	aw_dbg("%s: effect_id=%d , activate_mode = %d val = %d\n", __func__,
+	       aw869x->effect_id, aw869x->activate_mode, val);
+	/*for osc calibration*/
+	if (aw869x->osc_cali_run != 0)
+		return 0;
+
+	if (val > 0)
+		aw869x->state = 1;
+	if (val <= 0)
+		aw869x->state = 0;
+	hrtimer_cancel(&aw869x->timer);
+
+	if (aw869x->effect_type == FF_CONSTANT &&
+	    aw869x->activate_mode == AW869X_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+		aw_dbg("%s: enter cont_mode\n", __func__);
+		/* schedule_work(&aw869x->vibrator_work); */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	} else if (aw869x->effect_type == FF_PERIODIC &&
+		   aw869x->activate_mode == AW869X_HAPTIC_ACTIVATE_RAM_MODE) {
+		aw_dbg("%s: enter  ram_mode\n", __func__);
+		/* schedule_work(&aw869x->vibrator_work) */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	} else if ((aw869x->effect_type == FF_PERIODIC) &&
+		   aw869x->activate_mode == AW869X_HAPTIC_ACTIVATE_RTP_MODE) {
+		aw_dbg("%s: enter  rtp_mode\n", __func__);
+		/* schedule_work(&aw869x->rtp_work); */
+		queue_work(aw869x->work_queue, &aw869x->rtp_work);
+		/* if we are in the play mode, force to exit */
+		if (val == 0) {
+			atomic_set(&aw869x->exit_in_rtp_loop, 1);
+			rb_force_exit();
+			wake_up_interruptible(&aw869x->stop_wait_q);
+		}
+	} else {
+		/*other mode */
+	}
+
+	return rc;
+}
+
+int aw869x_haptics_erase(struct input_dev *dev, int effect_id)
+{
+	struct aw869x *aw869x = input_get_drvdata(dev);
+	int rc = 0;
+
+	/*for osc calibration*/
+	if (aw869x->osc_cali_run != 0)
+		return 0;
+
+	aw_dbg("%s: enter\n", __func__);
+	aw869x->effect_type = 0;
+	aw869x->is_custom_wave = 0;
+	aw869x->duration = 0;
+	return rc;
+}
+
+void aw869x_haptics_set_gain_work_routine(struct work_struct *work)
+{
+	unsigned char comp_level = 0;
+	struct aw869x *aw869x =
+		container_of(work, struct aw869x, set_gain_work);
+
+	if (aw869x->new_gain >= 0x7FFF)
+		aw869x->level = 0x80; /*128 */
+	else if (aw869x->new_gain <= 0x3FFF)
+		aw869x->level = 0x1E; /*30 */
+	else
+		aw869x->level = (aw869x->new_gain - 16383) / 128;
+
+	if (aw869x->level < 0x1E)
+		aw869x->level = 0x1E; /*30 */
+	aw_info("%s: set_gain queue work, new_gain = %x level = %x\n", __func__,
+		aw869x->new_gain, aw869x->level);
+
+	if (aw869x->ram_vbat_comp == AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE &&
+	    aw869x->vbat) {
+		aw_dbg("%s: ref %d vbat %d ", __func__, AW_VBAT_REFER,
+		       aw869x->vbat);
+		comp_level = aw869x->level * AW_VBAT_REFER / aw869x->vbat;
+		if (comp_level > (128 * AW_VBAT_REFER / AW_VBAT_MIN)) {
+			comp_level = 128 * AW_VBAT_REFER / AW_VBAT_MIN;
+			aw_dbg("%s: comp level limit is %d ", __func__,
+			       comp_level);
+		}
+		aw_info("%s: enable vbat comp, level = %x comp level = %x",
+			__func__, aw869x->level, comp_level);
+		aw869x_i2c_write(aw869x, AW869X_REG_DATDBG, comp_level);
+	} else {
+		aw_dbg("%s: disable compsensation, vbat=%d, vbat_min=%d, vbat_ref=%d",
+		       __func__, aw869x->vbat, AW_VBAT_MIN, AW_VBAT_REFER);
+		aw869x_i2c_write(aw869x, AW869X_REG_DATDBG, aw869x->level);
+	}
+}
+
+void aw869x_haptics_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct aw869x *aw869x = input_get_drvdata(dev);
+
+	aw_dbg("%s enter\n", __func__);
+	aw869x->new_gain = gain;
+	queue_work(aw869x->work_queue, &aw869x->set_gain_work);
+}
+
+static ssize_t aw869x_activate_test_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw869x->test_val);
+}
+
+static ssize_t aw869x_activate_test_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw869x->test_val = val;
+	aw_dbg("%s: aw869x->test_val=%d\n", __func__, aw869x->test_val);
+
+	if (aw869x->test_val == 1) {
+		aw_info("%s  %d\n", __func__, __LINE__);
+		aw869x->duration = 3000;
+
+		aw869x->state = 1;
+		aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw869x->timer);
+		/* schedule_work(&aw869x->vibrator_work); */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	}
+	if (aw869x->test_val == 2) {
+		aw_info("%s  %d\n", __func__, __LINE__);
+		mutex_lock(&aw869x->lock);
+		aw869x_haptic_set_wav_seq(aw869x, 0x00, 0x01);
+		aw869x_haptic_set_wav_seq(aw869x, 0x01, 0x01);
+
+		/*step 1:  choose  loop */
+		aw869x_haptic_set_wav_loop(aw869x, 0x01, 0x01);
+		mutex_unlock(&aw869x->lock);
+
+		aw869x->state = 1;
+		aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RAM_MODE;
+		hrtimer_cancel(&aw869x->timer);
+		/* schedule_work(&aw869x->vibrator_work); */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	}
+
+	if (aw869x->test_val == 3) { /*Ram instead of Cont */
+		aw869x->duration = 10000;
+
+		aw869x->state = 1;
+		aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw869x->timer);
+		/* schedule_work(&aw869x->vibrator_work); */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	}
+
+	if (aw869x->test_val == 4) {
+		mutex_lock(&aw869x->lock);
+		aw869x_haptic_stop(aw869x);
+		aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_RAM_MODE);
+
+		aw869x_haptic_set_wav_seq(aw869x, 0x00, 0x01);
+		aw869x_haptic_set_wav_seq(aw869x, 0x01, 0x00);
+
+		aw869x_haptic_set_wav_loop(aw869x, 0x01, 0x01);
+
+		if (aw869x->info.bst_vol_ram <= AW869X_MAX_BST_VO)
+			aw869x_haptic_set_bst_vol(aw869x,
+						  aw869x->info.bst_vol_ram);
+		else
+			aw869x_haptic_set_bst_vol(aw869x, aw869x->vmax);
+
+		aw869x->activate_mode = AW869X_HAPTIC_ACTIVATE_RAM_MODE;
+		aw869x->state = 1;
+		mutex_unlock(&aw869x->lock);
+		hrtimer_cancel(&aw869x->timer);
+		/* schedule_work(&aw869x->vibrator_work); */
+		queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+	}
+
+	return count;
+}
+/******************************************************
+ *
+ * sys group attribute: reg
+ *
+ ******************************************************/
+static ssize_t aw869x_i2c_reg_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw869x_i2c_write(aw869x, (unsigned char)databuf[0],
+				 (unsigned char)databuf[1]);
+	}
+
+	return count;
+}
+
+static ssize_t aw869x_i2c_reg_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW869X_REG_MAX; i++) {
+		if (!(aw869x_reg_access[i] & REG_RD_ACCESS))
+			continue;
+		aw869x_i2c_read(aw869x, i, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"reg:0x%02x=0x%02x\n", i, reg_val);
+	}
+	return len;
+}
+
+static ssize_t aw869x_i2c_ram_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+	if (val == 1)
+		aw869x_ram_update(aw869x);
+	return count;
+}
+
+static ssize_t aw869x_i2c_ram_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+	int size = 0;
+	int i = 0;
+	int j = 0;
+	unsigned char ram_data[AW_RAMDATA_RD_BUFFER_SIZE] = { 0 };
+
+	aw869x_haptic_stop(aw869x);
+	/* RAMINIT Enable */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_EN);
+
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRH,
+			 (unsigned char)(aw869x->ram.base_addr >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_RAMADDRL,
+			 (unsigned char)(aw869x->ram.base_addr & 0x00ff));
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw869x_haptic_ram:\n");
+	while (i < aw869x->ram.len) {
+		if ((aw869x->ram.len - i) < AW_RAMDATA_RD_BUFFER_SIZE)
+			size = aw869x->ram.len - i;
+		else
+			size = AW_RAMDATA_RD_BUFFER_SIZE;
+
+		aw869x_i2c_reads(aw869x, AW869X_REG_RAMDATA, ram_data, size);
+		for (j = 0; j < size; j++) {
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02X,",
+					ram_data[j]);
+		}
+		i += size;
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_OFF);
+
+	return len;
+}
+
+static ssize_t aw869x_duration_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ktime_t time_rem;
+	s64 time_ms = 0;
+
+	if (hrtimer_active(&aw869x->timer)) {
+		time_rem = hrtimer_get_remaining(&aw869x->timer);
+		time_ms = ktime_to_ms(time_rem);
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%lld\n", time_ms);
+}
+
+static ssize_t aw869x_duration_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	/* setting 0 on duration is NOP for now */
+	if (val <= 0)
+		return count;
+
+	aw869x->duration = val;
+
+	return count;
+}
+
+static ssize_t aw869x_activate_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw869x->state);
+}
+
+static ssize_t aw869x_activate_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	if (val != 0 && val != 1)
+		return count;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw869x->lock);
+	hrtimer_cancel(&aw869x->timer);
+
+	aw869x->state = val;
+
+	mutex_unlock(&aw869x->lock);
+	/* schedule_work(&aw869x->vibrator_work); */
+	queue_work(aw869x->work_queue, &aw869x->vibrator_work);
+
+	return count;
+}
+
+static ssize_t aw869x_activate_mode_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	return snprintf(buf, PAGE_SIZE, "activate_mode=%d\n",
+			aw869x->activate_mode);
+}
+
+static ssize_t aw869x_activate_mode_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	mutex_lock(&aw869x->lock);
+	aw869x->activate_mode = val;
+	mutex_unlock(&aw869x->lock);
+	return count;
+}
+
+static ssize_t aw869x_index_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_WAVSEQ1, &reg_val);
+	aw869x->index = reg_val;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw869x->index);
+}
+
+static ssize_t aw869x_index_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw869x->lock);
+	aw869x->index = val;
+	aw869x_haptic_set_repeat_wav_seq(aw869x, aw869x->index);
+	mutex_unlock(&aw869x->lock);
+	return count;
+}
+
+static ssize_t aw869x_vmax_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw869x->vmax);
+}
+
+static ssize_t aw869x_vmax_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw869x->lock);
+	aw869x->vmax = val;
+	aw869x_haptic_set_bst_vol(aw869x, aw869x->vmax);
+	mutex_unlock(&aw869x->lock);
+	return count;
+}
+
+static ssize_t aw869x_gain_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw869x->level);
+}
+
+static ssize_t aw869x_gain_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw_dbg("%s: value=%d\n", __func__, val);
+
+	mutex_lock(&aw869x->lock);
+	aw869x->level = val;
+	aw869x_haptic_set_gain(aw869x, aw869x->level);
+	mutex_unlock(&aw869x->lock);
+	return count;
+}
+
+static ssize_t aw869x_seq_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW869X_SEQUENCER_SIZE; i++) {
+		aw869x_i2c_read(aw869x, AW869X_REG_WAVSEQ1 + i, &reg_val);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d: 0x%02x\n", i + 1, reg_val);
+		aw869x->seq[i] |= reg_val;
+	}
+	return count;
+}
+
+static ssize_t aw869x_seq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw_dbg("%s: seq%d=0x%x\n", __func__, databuf[0], databuf[1]);
+		mutex_lock(&aw869x->lock);
+		aw869x->seq[databuf[0]] = (unsigned char)databuf[1];
+		aw869x_haptic_set_wav_seq(aw869x, (unsigned char)databuf[0],
+					  aw869x->seq[databuf[0]]);
+		mutex_unlock(&aw869x->lock);
+	}
+	return count;
+}
+
+static ssize_t aw869x_loop_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	for (i = 0; i < AW869X_SEQUENCER_LOOP_SIZE; i++) {
+		aw869x_i2c_read(aw869x, AW869X_REG_WAVLOOP1 + i, &reg_val);
+		aw869x->loop[i * 2 + 0] = (reg_val >> 4) & 0x0F;
+		aw869x->loop[i * 2 + 1] = (reg_val >> 0) & 0x0F;
+
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 1,
+				  aw869x->loop[i * 2 + 0]);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 2,
+				  aw869x->loop[i * 2 + 1]);
+	}
+	return count;
+}
+
+static ssize_t aw869x_loop_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw_dbg("%s: seq%d loop=0x%x\n", __func__, databuf[0],
+		       databuf[1]);
+		mutex_lock(&aw869x->lock);
+		aw869x->loop[databuf[0]] = (unsigned char)databuf[1];
+		aw869x_haptic_set_wav_loop(aw869x, (unsigned char)databuf[0],
+					   aw869x->loop[databuf[0]]);
+		mutex_unlock(&aw869x->lock);
+	}
+
+	return count;
+}
+
+static ssize_t aw869x_rtp_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "rtp play: %d\n",
+			aw869x->rtp_cnt);
+
+	return len;
+}
+
+static ssize_t aw869x_rtp_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw869x_haptic_stop(aw869x);
+	aw869x_haptic_set_rtp_aei(aw869x, false);
+	aw869x_interrupt_clear(aw869x);
+	if (val < (awinic_rtp_name_len)) {
+		aw869x->rtp_file_num = val;
+		if (val) {
+			/* schedule_work(&aw869x->rtp_work); */
+			queue_work(aw869x->work_queue, &aw869x->rtp_work);
+		}
+	} else {
+		aw_err("%s: rtp_file_num 0x%02x over max value\n", __func__,
+		       aw869x->rtp_file_num);
+	}
+
+	return count;
+}
+
+static ssize_t aw869x_ram_update_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "sram update mode\n");
+	return len;
+}
+
+static ssize_t aw869x_ram_update_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	if (val)
+		aw869x_ram_update(aw869x);
+
+	return count;
+}
+
+static ssize_t aw869x_f0_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_upload_lra(aw869x, AW869X_WRITE_ZERO);
+	aw869x_haptic_get_f0(aw869x);
+	mutex_unlock(&aw869x->lock);
+	len +=
+		/* snprintf(buf + len, PAGE_SIZE - len, "aw869x lra f0 = %d\n", */
+		snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw869x->f0);
+	return len;
+}
+
+static ssize_t aw869x_f0_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	return count;
+}
+
+static ssize_t aw869x_cali_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_upload_lra(aw869x, AW869X_F0_CALI_LRA);
+	aw869x_haptic_get_f0(aw869x);
+	mutex_unlock(&aw869x->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw869x cali f0 = %d\n",
+			aw869x->f0);
+	return len;
+}
+
+static ssize_t aw869x_cali_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	if (val) {
+		mutex_lock(&aw869x->lock);
+		aw869x_haptic_upload_lra(aw869x, AW869X_WRITE_ZERO);
+		aw869x_haptic_f0_calibration(aw869x);
+		mutex_unlock(&aw869x->lock);
+	}
+	return count;
+}
+
+static ssize_t aw869x_cont_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	aw869x_haptic_read_cont_f0(aw869x);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw869x cont f0 = %d\n",
+			aw869x->cont_f0);
+	return len;
+}
+
+static ssize_t aw869x_cont_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw869x_haptic_stop(aw869x);
+	if (val)
+		aw869x_haptic_cont(aw869x);
+
+	return count;
+}
+
+static ssize_t aw869x_cont_td_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw869x cont delay time = 0x%04x\n",
+			aw869x->info.cont_td);
+	return len;
+}
+
+static ssize_t aw869x_cont_td_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw869x->info.cont_td = val;
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_H, (unsigned char)(val >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_TD_L, (unsigned char)(val >> 0));
+	return count;
+}
+
+static ssize_t aw869x_cont_drv_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw869x cont drv level = %d\n",
+			aw869x->info.cont_drv_lvl);
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw869x cont drv level overdrive= %d\n",
+			aw869x->info.cont_drv_lvl_ov);
+	return len;
+}
+
+static ssize_t aw869x_cont_drv_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%d %d", &databuf[0], &databuf[1]) == 2) {
+		aw869x->info.cont_drv_lvl = databuf[0];
+		aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL,
+				 aw869x->info.cont_drv_lvl);
+		aw869x->info.cont_drv_lvl_ov = databuf[1];
+		aw869x_i2c_write(aw869x, AW869X_REG_DRV_LVL_OV,
+				 aw869x->info.cont_drv_lvl_ov);
+	}
+	return count;
+}
+
+/* return buffer size and availbe size */
+static ssize_t aw869x_custom_wave_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "period_size=%d;",
+			aw869x->ram.base_addr >> 2);
+	len += snprintf(buf + len, PAGE_SIZE - len, "max_size=%d;free_size=%d;",
+			get_rb_max_size(), get_rb_free_size());
+	len += snprintf(buf + len, PAGE_SIZE - len, "custom_wave_id=%d;",
+			CUSTOME_WAVE_ID);
+	return len;
+}
+
+static ssize_t aw869x_custom_wave_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned long buf_len, period_size, offset;
+	int ret;
+
+	period_size = (aw869x->ram.base_addr >> 2);
+	offset = 0;
+
+	aw_dbg("%swrite szie %zd, period size %lu", __func__, count,
+	       period_size);
+	if (count % period_size || count < period_size)
+		rb_end();
+	atomic_set(&aw869x->is_in_write_loop, 1);
+
+	while (count > 0) {
+		buf_len = MIN(count, period_size);
+		ret = write_rb(buf + offset, buf_len);
+		if (ret < 0)
+			goto exit;
+		count -= buf_len;
+		offset += buf_len;
+	}
+	ret = offset;
+exit:
+	atomic_set(&aw869x->is_in_write_loop, 0);
+	wake_up_interruptible(&aw869x->stop_wait_q);
+	aw_dbg(" return size %d", ret);
+	return ret;
+}
+
+static ssize_t aw869x_cont_num_brk_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw869x cont break num = %d\n",
+			aw869x->info.cont_num_brk);
+	return len;
+}
+
+static ssize_t aw869x_cont_num_brk_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	aw869x->info.cont_num_brk = val;
+	if (aw869x->info.cont_num_brk > 7)
+		aw869x->info.cont_num_brk = 7;
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_BEMF_NUM,
+			      AW869X_BIT_BEMF_NUM_BRK_MASK,
+			      aw869x->info.cont_num_brk);
+	return count;
+}
+
+static ssize_t aw869x_cont_zc_thr_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw869x cont zero cross thr = 0x%04x\n",
+			aw869x->info.cont_zc_thr);
+	return len;
+}
+
+static ssize_t aw869x_cont_zc_thr_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+	aw869x->info.cont_zc_thr = val;
+	aw869x_i2c_write(aw869x, AW869X_REG_ZC_THRSH_H,
+			 (unsigned char)(val >> 8));
+	aw869x_i2c_write(aw869x, AW869X_REG_ZC_THRSH_L,
+			 (unsigned char)(val >> 0));
+	return count;
+}
+
+static ssize_t aw869x_vbat_monitor_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_stop(aw869x);
+	aw869x_haptic_get_vbat(aw869x);
+	len += snprintf(buf + len, PAGE_SIZE - len, "vbat=%dmV\n",
+			aw869x->vbat);
+	mutex_unlock(&aw869x->lock);
+
+	return len;
+}
+
+static ssize_t aw869x_vbat_monitor_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw869x_lra_resistance_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_stop(aw869x);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW869X_BIT_SYSCTRL_BST_MODE_BYPASS);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_ANACTRL,
+			      AW869X_BIT_ANACTRL_HD_PD_MASK,
+			      AW869X_BIT_ANACTRL_HD_HZ_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_D2SCFG,
+			      AW869X_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW869X_BIT_D2SCFG_CLK_ASC_1P5MHZ);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+			      AW869X_BIT_DETCTRL_RL_OS_MASK,
+			      AW869X_BIT_DETCTRL_RL_DETECT);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_DETCTRL,
+			      AW869X_BIT_DETCTRL_DIAG_GO_MASK,
+			      AW869X_BIT_DETCTRL_DIAG_GO_ENABLE);
+	usleep_range(3000, 3500);
+	aw869x_i2c_read(aw869x, AW869X_REG_RLDET, &reg_val);
+	aw869x->lra = 298 * reg_val;
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw869x->lra);
+	/* snprintf(buf + len, PAGE_SIZE - len, "r_lra=%dmohm\n",
+	     * aw869x->lra);
+	     */
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_ANACTRL,
+			      AW869X_BIT_ANACTRL_HD_PD_MASK,
+			      AW869X_BIT_ANACTRL_HD_PD_EN);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_D2SCFG,
+			      AW869X_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW869X_BIT_D2SCFG_CLK_ASC_6MHZ);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_RAMINIT_MASK,
+			      AW869X_BIT_SYSCTRL_RAMINIT_OFF);
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_SYSCTRL,
+			      AW869X_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW869X_BIT_SYSCTRL_BST_MODE_BOOST);
+	mutex_unlock(&aw869x->lock);
+
+	return len;
+}
+
+static ssize_t aw869x_lra_resistance_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw869x_auto_boost_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "auto_boost=%d\n",
+			aw869x->auto_boost);
+
+	return len;
+}
+
+static ssize_t aw869x_auto_boost_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	mutex_lock(&aw869x->lock);
+	aw869x_haptic_stop(aw869x);
+	aw869x_haptic_auto_boost_config(aw869x, val);
+	mutex_unlock(&aw869x->lock);
+
+	return count;
+}
+
+static ssize_t aw869x_prctmode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	aw869x_i2c_read(aw869x, AW869X_REG_RLDET, &reg_val);
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "prctmode=%d\n",
+			reg_val & 0x20);
+	return len;
+}
+
+static ssize_t aw869x_prctmode_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[2] = { 0, 0 };
+	unsigned int addr = 0;
+	unsigned int val = 0;
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		addr = databuf[0];
+		val = databuf[1];
+		mutex_lock(&aw869x->lock);
+		aw869x_haptic_swicth_motorprotect_config(aw869x, addr, val);
+		mutex_unlock(&aw869x->lock);
+	}
+	return count;
+}
+
+static ssize_t aw869x_trig_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+	unsigned char i = 0;
+
+	for (i = 0; i < AW869X_TRIG_NUM; i++) {
+		len += snprintf(
+			buf + len, PAGE_SIZE - len,
+			"trig%d: enable=%d, default_level=%d, dual_edge=%d, frist_seq=%d, second_seq=%d\n",
+			i + 1, aw869x->trig[i].enable,
+			aw869x->trig[i].default_level,
+			aw869x->trig[i].dual_edge, aw869x->trig[i].frist_seq,
+			aw869x->trig[i].second_seq);
+	}
+
+	return len;
+}
+
+static ssize_t aw869x_trig_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int databuf[6] = { 0 };
+
+	if (sscanf(buf, "%d %d %d %d %d %d", &databuf[0], &databuf[1],
+		   &databuf[2], &databuf[3], &databuf[4], &databuf[5]) == 6) {
+		aw_dbg("%s: %d, %d, %d, %d, %d, %d\n", __func__, databuf[0],
+		       databuf[1], databuf[2], databuf[3], databuf[4],
+		       databuf[5]);
+		if (databuf[0] > 3)
+			databuf[0] = 3;
+
+		if (databuf[0] > 0)
+			databuf[0] -= 1;
+
+		aw869x->trig[databuf[0]].enable = databuf[1];
+		aw869x->trig[databuf[0]].default_level = databuf[2];
+		aw869x->trig[databuf[0]].dual_edge = databuf[3];
+		aw869x->trig[databuf[0]].frist_seq = databuf[4];
+		aw869x->trig[databuf[0]].second_seq = databuf[5];
+		mutex_lock(&aw869x->lock);
+		aw869x_haptic_trig_param_config(aw869x);
+		aw869x_haptic_trig_enable_config(aw869x);
+		mutex_unlock(&aw869x->lock);
+	}
+	return count;
+}
+
+static ssize_t aw869x_ram_vbat_comp_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_vbat_comp=%d\n",
+			aw869x->ram_vbat_comp);
+
+	return len;
+}
+
+static ssize_t aw869x_ram_vbat_comp_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	mutex_lock(&aw869x->lock);
+	if (val)
+		aw869x->ram_vbat_comp = AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	else
+		aw869x->ram_vbat_comp = AW869X_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	mutex_unlock(&aw869x->lock);
+
+	return count;
+}
+
+static ssize_t aw869x_osc_cali_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw869x->lra_calib_data);
+
+	return len;
+}
+
+static ssize_t aw869x_osc_cali_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	mutex_lock(&aw869x->lock);
+	/*osc calibration flag start,Other behaviors are forbidden*/
+	aw869x->osc_cali_run = 1;
+	aw869x_haptic_upload_lra(aw869x, AW869X_WRITE_ZERO);
+	if (val == 3) {
+		aw869x_rtp_osc_calibration(aw869x);
+		aw869x_rtp_trim_lra_calibration(aw869x);
+	}
+	if (val == 1)
+		aw869x_rtp_osc_calibration(aw869x);
+
+	aw869x->osc_cali_run = 0;
+	/*osc calibration flag end,Other behaviors are permitted*/
+	mutex_unlock(&aw869x->lock);
+
+	return count;
+}
+
+static ssize_t aw869x_osc_save_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	aw_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+	aw869x->lra_calib_data = val;
+	aw_info("%s load osa cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw869x_f0_save_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw869x->f0_calib_data);
+
+	return len;
+}
+
+static ssize_t aw869x_f0_save_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	aw_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+	aw869x->f0_calib_data = val;
+	aw_info("%s load f0 cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw869x_f0_value_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw869x->f0);
+}
+
+static ssize_t aw869x_f0_check_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	ssize_t len = 0;
+
+	if (aw869x->f0_cali_status == true)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 1);
+	if (aw869x->f0_cali_status == false)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 0);
+
+	return len;
+}
+static ssize_t aw869x_effect_id_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+
+	return snprintf(buf, PAGE_SIZE, "effect_id =%d\n", aw869x->effect_id);
+}
+
+static ssize_t aw869x_effect_id_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct awinic *awinic = dev_get_drvdata(dev);
+	struct aw869x *aw869x = awinic->aw869x;
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return count;
+
+	mutex_lock(&aw869x->lock);
+	aw869x->effect_id = val;
+	aw869x->play.vmax_mv = AW869X_MEDIUM_MAGNITUDE;
+	mutex_unlock(&aw869x->lock);
+	return count;
+}
+
+static DEVICE_ATTR(effect_id, S_IWUSR | S_IRUGO, aw869x_effect_id_show,
+		   aw869x_effect_id_store);
+static DEVICE_ATTR(activate_test, S_IWUSR | S_IRUGO, aw869x_activate_test_show,
+		   aw869x_activate_test_store);
+
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO, aw869x_i2c_reg_show,
+		   aw869x_i2c_reg_store);
+static DEVICE_ATTR(ram, S_IWUSR | S_IRUGO, aw869x_i2c_ram_show,
+		   aw869x_i2c_ram_store);
+static DEVICE_ATTR(duration, S_IWUSR | S_IRUGO, aw869x_duration_show,
+		   aw869x_duration_store);
+static DEVICE_ATTR(activate, S_IWUSR | S_IRUGO, aw869x_activate_show,
+		   aw869x_activate_store);
+static DEVICE_ATTR(activate_mode, S_IWUSR | S_IRUGO, aw869x_activate_mode_show,
+		   aw869x_activate_mode_store);
+static DEVICE_ATTR(index, S_IWUSR | S_IRUGO, aw869x_index_show,
+		   aw869x_index_store);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO, aw869x_vmax_show,
+		   aw869x_vmax_store);
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO, aw869x_gain_show,
+		   aw869x_gain_store);
+static DEVICE_ATTR(seq, S_IWUSR | S_IRUGO, aw869x_seq_show, aw869x_seq_store);
+static DEVICE_ATTR(loop, S_IWUSR | S_IRUGO, aw869x_loop_show,
+		   aw869x_loop_store);
+static DEVICE_ATTR(rtp, S_IWUSR | S_IRUGO, aw869x_rtp_show, aw869x_rtp_store);
+static DEVICE_ATTR(ram_update, S_IWUSR | S_IRUGO, aw869x_ram_update_show,
+		   aw869x_ram_update_store);
+static DEVICE_ATTR(f0, S_IWUSR | S_IRUGO, aw869x_f0_show, aw869x_f0_store);
+static DEVICE_ATTR(cali, S_IWUSR | S_IRUGO, aw869x_cali_show,
+		   aw869x_cali_store);
+static DEVICE_ATTR(cont, S_IWUSR | S_IRUGO, aw869x_cont_show,
+		   aw869x_cont_store);
+static DEVICE_ATTR(cont_td, S_IWUSR | S_IRUGO, aw869x_cont_td_show,
+		   aw869x_cont_td_store);
+static DEVICE_ATTR(cont_drv, S_IWUSR | S_IRUGO, aw869x_cont_drv_show,
+		   aw869x_cont_drv_store);
+static DEVICE_ATTR(cont_num_brk, S_IWUSR | S_IRUGO, aw869x_cont_num_brk_show,
+		   aw869x_cont_num_brk_store);
+static DEVICE_ATTR(cont_zc_thr, S_IWUSR | S_IRUGO, aw869x_cont_zc_thr_show,
+		   aw869x_cont_zc_thr_store);
+static DEVICE_ATTR(vbat_monitor, S_IWUSR | S_IRUGO, aw869x_vbat_monitor_show,
+		   aw869x_vbat_monitor_store);
+static DEVICE_ATTR(lra_resistance, S_IWUSR | S_IRUGO,
+		   aw869x_lra_resistance_show, aw869x_lra_resistance_store);
+static DEVICE_ATTR(auto_boost, S_IWUSR | S_IRUGO, aw869x_auto_boost_show,
+		   aw869x_auto_boost_store);
+static DEVICE_ATTR(prctmode, S_IWUSR | S_IRUGO, aw869x_prctmode_show,
+		   aw869x_prctmode_store);
+static DEVICE_ATTR(trig, S_IWUSR | S_IRUGO, aw869x_trig_show,
+		   aw869x_trig_store);
+static DEVICE_ATTR(ram_vbat_comp, S_IWUSR | S_IRUGO, aw869x_ram_vbat_comp_show,
+		   aw869x_ram_vbat_comp_store);
+static DEVICE_ATTR(osc_cali, S_IWUSR | S_IRUGO, aw869x_osc_cali_show,
+		   aw869x_osc_cali_store);
+static DEVICE_ATTR(f0_check, S_IWUSR | S_IRUGO, aw869x_f0_check_show, NULL);
+static DEVICE_ATTR(f0_save, S_IWUSR | S_IRUGO, aw869x_f0_save_show,
+		   aw869x_f0_save_store);
+static DEVICE_ATTR(osc_save, S_IWUSR | S_IRUGO, aw869x_osc_cali_show,
+		   aw869x_osc_save_store);
+static DEVICE_ATTR(f0_value, S_IRUGO, aw869x_f0_value_show, NULL);
+static DEVICE_ATTR(custom_wave, S_IWUSR | S_IRUGO, aw869x_custom_wave_show,
+		   aw869x_custom_wave_store);
+static struct attribute *aw869x_vibrator_attributes[] = {
+	&dev_attr_effect_id.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_activate_test.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_td.attr,
+	&dev_attr_cont_drv.attr,
+	&dev_attr_cont_num_brk.attr,
+	&dev_attr_cont_zc_thr.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_trig.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_f0_check.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_custom_wave.attr,
+	NULL
+};
+
+struct attribute_group aw869x_vibrator_attribute_group = {
+	.attrs = aw869x_vibrator_attributes
+};
+
+int aw869x_vibrator_init(struct aw869x *aw869x)
+{
+	int ret = 0;
+
+	aw_info("%s enter\n", __func__);
+
+	ret = sysfs_create_group(&aw869x->i2c->dev.kobj,
+				 &aw869x_vibrator_attribute_group);
+	if (ret < 0) {
+		aw_info("%s error creating sysfs attr files\n", __func__);
+		return ret;
+	}
+	g_aw869x = aw869x;
+	hrtimer_init(&aw869x->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw869x->timer.function = aw869x_vibrator_timer_func;
+	INIT_WORK(&aw869x->vibrator_work, aw869x_vibrator_work_routine);
+	INIT_WORK(&aw869x->rtp_work, aw869x_rtp_work_routine);
+
+	mutex_init(&aw869x->lock);
+	mutex_init(&aw869x->rtp_lock);
+	atomic_set(&aw869x->is_in_rtp_loop, 0);
+	atomic_set(&aw869x->exit_in_rtp_loop, 0);
+	atomic_set(&aw869x->is_in_write_loop, 0);
+	init_waitqueue_head(&aw869x->wait_q);
+	init_waitqueue_head(&aw869x->stop_wait_q);
+
+	return 0;
+}
+
+int aw869x_haptic_init(struct aw869x *aw869x, unsigned char chip_name)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char bemf_config = 0;
+
+	aw_info("%s enter\n", __func__);
+	ret = misc_register(&aw869x_haptic_misc);
+	if (ret) {
+		aw_err("%s: misc fail: %d\n", __func__, ret);
+		return ret;
+	}
+
+	/* haptic audio */
+	aw869x->haptic_audio.delay_val = 1;
+	aw869x->haptic_audio.timer_val = 21318;
+	aw869x->f0_cali_status = true;
+
+	hrtimer_init(&aw869x->haptic_audio.timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw869x->haptic_audio.timer.function = aw869x_haptic_audio_timer_func;
+	INIT_WORK(&aw869x->haptic_audio.work, aw869x_haptic_audio_work_routine);
+
+	mutex_init(&aw869x->haptic_audio.lock);
+
+	hrtimer_init(&aw869x->stop_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw869x->stop_timer.function = qti_hap_stop_timer;
+	hrtimer_init(&aw869x->hap_disable_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw869x->hap_disable_timer.function = qti_hap_disable_timer;
+
+	/* haptic init */
+	mutex_lock(&aw869x->lock);
+
+	aw869x->activate_mode = aw869x->info.mode;
+	aw869x->osc_cali_run = 0;
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_WAVSEQ1, &reg_val);
+	aw869x->index = reg_val & 0x7F;
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_DATDBG, &reg_val);
+	aw869x->gain = reg_val & 0xFF;
+	ret = aw869x_i2c_read(aw869x, AW869X_REG_BSTDBG4, &reg_val);
+	aw869x->vmax = (reg_val >> 1) & 0x1F;
+	for (i = 0; i < AW869X_SEQUENCER_SIZE; i++) {
+		ret = aw869x_i2c_read(aw869x, AW869X_REG_WAVSEQ1 + i, &reg_val);
+		aw869x->seq[i] = reg_val;
+	}
+
+	aw869x_haptic_play_mode(aw869x, AW869X_HAPTIC_STANDBY_MODE);
+
+	aw869x_haptic_set_pwm(aw869x, AW869X_PWM_24K);
+	/*LRA trim source select register*/
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_ANACTRL,
+			      AW869X_BIT_ANACTRL_LRA_SRC_MASK,
+			      AW869X_BIT_ANACTRL_LRA_SRC_REG);
+	aw869x_i2c_write(aw869x, AW869X_REG_BSTDBG1, aw869x->info.bstdbg[0]);
+	aw869x_i2c_write(aw869x, AW869X_REG_BSTDBG2, aw869x->info.bstdbg[1]);
+	aw869x_i2c_write(aw869x, AW869X_REG_BSTDBG3, aw869x->info.bstdbg[2]);
+	aw869x_i2c_write(aw869x, AW869X_REG_TSET, aw869x->info.tset);
+	aw869x_i2c_write(aw869x, AW869X_REG_R_SPARE, aw869x->info.r_spare);
+
+	aw869x_i2c_write_bits(aw869x, AW869X_REG_ANADBG,
+			      AW869X_BIT_ANADBG_IOC_MASK,
+			      AW869X_BIT_ANADBG_IOC_4P65A);
+
+	if (chip_name == AW8697)
+		aw869x_haptic_set_bst_peak_cur(aw869x, AW8697_DEFAULT_PEAKCUR);
+	else if (chip_name == AW8695)
+		aw869x_haptic_set_bst_peak_cur(aw869x, AW8695_DEFAULT_PEAKCUR);
+	else
+		aw_err("chip name is error");
+
+	aw869x_haptic_swicth_motorprotect_config(aw869x, AW_PROTECT_EN,
+						 AW_PROTECT_VAL);
+
+	aw869x_haptic_auto_boost_config(aw869x, false);
+
+	if ((aw869x->info.trig_config[0][0] == 1) ||
+	    (aw869x->info.trig_config[1][0] == 1) ||
+	    (aw869x->info.trig_config[2][0] == 1)) {
+		aw869x_haptic_trig_param_init(aw869x);
+		aw869x_haptic_trig_param_config(aw869x);
+	}
+
+	aw869x_haptic_offset_calibration(aw869x);
+
+	/* vbat compensation */
+	aw869x_haptic_cont_vbat_mode(aw869x,
+				     AW869X_HAPTIC_CONT_VBAT_HW_COMP_MODE);
+	aw869x->ram_vbat_comp = AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE;
+
+	mutex_unlock(&aw869x->lock);
+
+	/* f0 calibration */
+	mutex_lock(&aw869x->lock);
+#ifndef USE_CONT_F0_CALI
+	aw869x_haptic_upload_lra(aw869x, AW869X_WRITE_ZERO);
+	aw869x_haptic_f0_calibration(aw869x);
+#endif
+	mutex_unlock(&aw869x->lock);
+	/* beme config */
+	bemf_config = aw869x->info.bemf_config[0];
+	aw869x_i2c_write(aw869x, AW869X_REG_BEMF_VTHH_H, bemf_config);
+	bemf_config = aw869x->info.bemf_config[1];
+	aw869x_i2c_write(aw869x, AW869X_REG_BEMF_VTHH_L, bemf_config);
+	bemf_config = aw869x->info.bemf_config[2];
+	aw869x_i2c_write(aw869x, AW869X_REG_BEMF_VTHL_H, bemf_config);
+	bemf_config = aw869x->info.bemf_config[3];
+	aw869x_i2c_write(aw869x, AW869X_REG_BEMF_VTHL_L, bemf_config);
+	return ret;
+}
+
+int aw869x_ram_init(struct aw869x *aw869x)
+{
+#ifdef AW_RAM_UPDATE_DELAY
+	int ram_timer_val = 5000;
+
+	aw_info("%s enter\n", __func__);
+	INIT_DELAYED_WORK(&aw869x->ram_work, aw869x_ram_work_routine);
+	/*schedule_delayed_work(&aw869x->ram_work,
+	 *			msecs_to_jiffies(ram_timer_val));
+	 */
+	queue_delayed_work(aw869x->work_queue, &aw869x->ram_work,
+			   msecs_to_jiffies(ram_timer_val));
+#else
+	aw869x_ram_update(aw869x);
+#endif
+	return 0;
+}
diff --git a/drivers/input/misc/aw86927_haptic/aw869x.h b/drivers/input/misc/aw86927_haptic/aw869x.h
new file mode 100644
index 000000000000..b6b271deb61c
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw869x.h
@@ -0,0 +1,760 @@
+#ifndef _AW869X_H_
+#define _AW869X_H_
+
+/*********************************************************
+ *
+ * aw869x.h
+ *
+ ********************************************************/
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/leds.h>
+#include <linux/atomic.h>
+#include "aw_haptic.h"
+/*********************************************************
+ *
+ * marco
+ *
+ ********************************************************/
+#define AW869X_SEQUENCER_SIZE (8)
+#define AW869X_SEQUENCER_LOOP_SIZE (4)
+#define AW869X_TRIG_NUM (3)
+#define AW869X_MAX_BST_VO (0x1f)
+#define AW869X_REG_MAX (0xff)
+
+/*
+ * trig default high level
+ * ___________         _________________
+ *           |         |
+ *           |         |
+ *           |___________|
+ *        first edge
+ *                   second edge
+ *
+ *
+ * trig default low level
+ *            ___________
+ *        |           |
+ *        |           |
+ * __________|        |_________________
+ *        first edge
+ *                   second edge
+ */
+/* trig config */
+/*dts config
+* default_level -> 1: high level; 0: low level
+* dual_edge     -> 1: dual edge; 0: first edge
+*vib_trig_config = <
+*       1   1              1          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*       1   1              2          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*       1   1              3          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*/
+
+/*********************************************************
+ *
+ * enum
+ *
+ ********************************************************/
+enum aw869x_flags {
+	AW869X_FLAG_NONR = 0,
+	AW869X_FLAG_SKIP_INTERRUPTS = 1,
+};
+
+enum aw869x_haptic_read_write {
+	AW869X_HAPTIC_CMD_READ_REG = 0,
+	AW869X_HAPTIC_CMD_WRITE_REG = 1,
+};
+
+enum aw869x_haptic_work_mode {
+	AW869X_HAPTIC_STANDBY_MODE = 0,
+	AW869X_HAPTIC_RAM_MODE = 1,
+	AW869X_HAPTIC_RTP_MODE = 2,
+	AW869X_HAPTIC_TRIG_MODE = 3,
+	AW869X_HAPTIC_CONT_MODE = 4,
+	AW869X_HAPTIC_RAM_LOOP_MODE = 5,
+};
+
+enum aw869x_haptic_bst_mode {
+	AW869X_HAPTIC_BYPASS_MODE = 0,
+	AW869X_HAPTIC_BOOST_MODE = 1,
+};
+
+enum aw869x_haptic_activate_mode {
+	AW869X_HAPTIC_ACTIVATE_RAM_MODE = 0,
+	AW869X_HAPTIC_ACTIVATE_CONT_MODE = 1,
+	AW869X_HAPTIC_ACTIVATE_RTP_MODE = 2,
+	AW869X_HAPTIC_ACTIVATE_RAM_LOOP_MODE = 3,
+};
+
+enum aw869x_haptic_cont_vbat_comp_mode {
+	AW869X_HAPTIC_CONT_VBAT_SW_COMP_MODE = 0,
+	AW869X_HAPTIC_CONT_VBAT_HW_COMP_MODE = 1,
+};
+
+enum aw869x_haptic_ram_vbat_comp_mode {
+	AW869X_HAPTIC_RAM_VBAT_COMP_DISABLE = 0,
+	AW869X_HAPTIC_RAM_VBAT_COMP_ENABLE = 1,
+};
+
+enum aw869x_haptic_f0_flag {
+	AW869X_HAPTIC_LRA_F0 = 0,
+	AW869X_HAPTIC_CALI_F0 = 1,
+};
+
+enum aw869x_haptic_pwm_mode {
+	AW869X_PWM_48K = 0,
+	AW869X_PWM_24K = 1,
+	AW869X_PWM_12K = 2,
+};
+
+enum aw869x_haptic_play {
+	AW869X_HAPTIC_PLAY_NULL = 0,
+	AW869X_HAPTIC_PLAY_ENABLE = 1,
+	AW869X_HAPTIC_PLAY_STOP = 2,
+	AW869X_HAPTIC_PLAY_GAIN = 8,
+};
+
+enum aw869x_haptic_cmd {
+	AW869X_HAPTIC_CMD_NULL = 0,
+	AW869X_HAPTIC_CMD_ENABLE = 1,
+	AW869X_HAPTIC_CMD_STOP = 255,
+};
+
+enum aw869x_haptic_strength {
+	AW869X_LIGHT_MAGNITUDE = 0x3fff,
+	AW869X_MEDIUM_MAGNITUDE = 0x5fff,
+	AW869X_STRONG_MAGNITUDE = 0x7fff,
+};
+
+enum aw869x_haptic_cali_lra {
+	AW869X_WRITE_ZERO = 0,
+	AW869X_F0_CALI_LRA = 1,
+	AW869X_OSC_CALI_LRA = 2,
+};
+/*********************************************************
+ *
+ * struct
+ *
+ ********************************************************/
+struct aw869x_trig {
+	unsigned char enable;
+	unsigned char default_level;
+	unsigned char dual_edge;
+	unsigned char frist_seq;
+	unsigned char second_seq;
+};
+
+struct aw869x_dts_info {
+	unsigned int mode;
+	unsigned int f0_pre;
+	unsigned int f0_cali_percen;
+	unsigned int cont_drv_lvl;
+	unsigned int cont_drv_lvl_ov;
+	unsigned int cont_td;
+	unsigned int cont_zc_thr;
+	unsigned int cont_num_brk;
+	unsigned int f0_coeff;
+	unsigned int f0_trace_parameter[4];
+	unsigned int bemf_config[4];
+	unsigned int sw_brake;
+	unsigned int tset;
+	unsigned int r_spare;
+	unsigned int bstdbg[6];
+	unsigned int parameter1;
+	unsigned int effect_id_boundary;
+	unsigned int effect_max;
+	unsigned int rtp_time[175];
+	unsigned int trig_config[3][5];
+	unsigned int bst_vol_default;
+	unsigned int bst_vol_ram;
+	unsigned int bst_vol_rtp;
+};
+
+struct aw869x {
+	struct i2c_client *i2c;
+	struct mutex lock;
+	struct work_struct vibrator_work;
+	struct work_struct rtp_work;
+	struct work_struct set_gain_work;
+	struct delayed_work ram_work;
+
+	struct fileops fileops;
+	struct ram ram;
+
+	struct timespec64 start, end;
+	unsigned int timeval_flags;
+	unsigned int osc_cali_flag;
+	unsigned long int microsecond;
+	unsigned int sys_frequency;
+	unsigned int rtp_len;
+	unsigned int lra_calib_data;
+	unsigned int f0_calib_data;
+
+	int reset_gpio;
+	int irq_gpio;
+
+	unsigned char hwen_flag;
+	unsigned char flags;
+	unsigned char chipid;
+
+	unsigned char play_mode;
+
+	unsigned char activate_mode;
+
+	unsigned char auto_boost;
+
+	int state;
+	int duration;
+	int amplitude;
+	int index;
+	int vmax;
+	int gain;
+	u16 new_gain;
+	unsigned char level;
+
+	unsigned char seq[AW869X_SEQUENCER_SIZE];
+	unsigned char loop[AW869X_SEQUENCER_SIZE];
+
+	unsigned int rtp_cnt;
+	unsigned int rtp_file_num;
+
+	unsigned char rtp_init;
+	unsigned char ram_init;
+
+	unsigned int f0;
+	unsigned int cont_f0;
+	unsigned char max_pos_beme;
+	unsigned char max_neg_beme;
+	unsigned char f0_cali_flag;
+	bool f0_cali_status;
+	unsigned int osc_cali_run;
+
+	unsigned char ram_vbat_comp;
+	unsigned int vbat;
+	unsigned int lra;
+
+	struct aw869x_trig trig[AW869X_TRIG_NUM];
+
+	struct haptic_audio haptic_audio;
+	struct aw869x_dts_info info;
+	atomic_t is_in_rtp_loop;
+	atomic_t exit_in_rtp_loop;
+	atomic_t is_in_write_loop;
+	wait_queue_head_t wait_q; /* wait queue for exit irq mode */
+	wait_queue_head_t stop_wait_q; /* wait queue for stop rtp mode */
+	struct workqueue_struct *work_queue;
+
+#ifdef INPUT_DEV
+	struct platform_device *pdev;
+	struct device *dev;
+	struct regmap *regmap;
+	struct input_dev *input_dev;
+	struct pwm_device *pwm_dev;
+	struct qti_hap_config config;
+	struct qti_hap_play_info play;
+	struct qti_hap_effect *predefined;
+	struct qti_hap_effect constant;
+	struct regulator *vdd_supply;
+	struct hrtimer stop_timer;
+	struct hrtimer hap_disable_timer;
+	struct hrtimer timer; /*test used,del */
+	struct dentry *hap_debugfs;
+	struct mutex rtp_lock;
+	spinlock_t bus_lock;
+	ktime_t last_sc_time;
+	int play_irq;
+	int sc_irq;
+	int effects_count;
+	int sc_det_count;
+	u16 reg_base;
+	bool perm_disable;
+	bool play_irq_en;
+	bool vdd_enabled;
+	int effect_type;
+	int effect_id;
+	int test_val;
+	int is_custom_wave;
+#endif
+};
+
+struct aw869x_container {
+	int len;
+	unsigned char data[];
+};
+
+/********************************************
+ * Register List
+ *******************************************/
+#define AW869X_REG_ID 0x00
+#define AW869X_REG_SYSST 0x01
+#define AW869X_REG_SYSINT 0x02
+#define AW869X_REG_SYSINTM 0x03
+#define AW869X_REG_SYSCTRL 0x04
+#define AW869X_REG_GO 0x05
+#define AW869X_REG_RTP_DATA 0x06
+#define AW869X_REG_WAVSEQ1 0x07
+#define AW869X_REG_WAVSEQ2 0x08
+#define AW869X_REG_WAVSEQ3 0x09
+#define AW869X_REG_WAVSEQ4 0x0a
+#define AW869X_REG_WAVSEQ5 0x0b
+#define AW869X_REG_WAVSEQ6 0x0c
+#define AW869X_REG_WAVSEQ7 0x0d
+#define AW869X_REG_WAVSEQ8 0x0e
+#define AW869X_REG_WAVLOOP1 0x0f
+#define AW869X_REG_WAVLOOP2 0x10
+#define AW869X_REG_WAVLOOP3 0x11
+#define AW869X_REG_WAVLOOP4 0x12
+#define AW869X_REG_MAIN_LOOP 0x13
+#define AW869X_REG_TRG1_WAV_P 0x14
+#define AW869X_REG_TRG2_WAV_P 0x15
+#define AW869X_REG_TRG3_WAV_P 0x16
+#define AW869X_REG_TRG1_WAV_N 0x17
+#define AW869X_REG_TRG2_WAV_N 0x18
+#define AW869X_REG_TRG3_WAV_N 0x19
+#define AW869X_REG_TRG_PRIO 0x1a
+#define AW869X_REG_TRG_CFG1 0x1b
+#define AW869X_REG_TRG_CFG2 0x1c
+#define AW869X_REG_DBGCTRL 0x20
+#define AW869X_REG_BASE_ADDRH 0x21
+#define AW869X_REG_BASE_ADDRL 0x22
+#define AW869X_REG_FIFO_AEH 0x23
+#define AW869X_REG_FIFO_AEL 0x24
+#define AW869X_REG_FIFO_AFH 0x25
+#define AW869X_REG_FIFO_AFL 0x26
+#define AW869X_REG_WAKE_DLY 0x27
+#define AW869X_REG_START_DLY 0x28
+#define AW869X_REG_END_DLY_H 0x29
+#define AW869X_REG_END_DLY_L 0x2a
+#define AW869X_REG_DATCTRL 0x2b
+#define AW869X_REG_PWMDEL 0x2c
+#define AW869X_REG_PWMPRC 0x2d
+#define AW869X_REG_PWMDBG 0x2e
+#define AW869X_REG_LDOCTRL 0x2f
+#define AW869X_REG_DBGSTAT 0x30
+#define AW869X_REG_BSTDBG1 0x31
+#define AW869X_REG_BSTDBG2 0x32
+#define AW869X_REG_BSTDBG3 0x33
+#define AW869X_REG_BSTCFG 0x34
+#define AW869X_REG_ANADBG 0x35
+#define AW869X_REG_ANACTRL 0x36
+#define AW869X_REG_CPDBG 0x37
+#define AW869X_REG_GLBDBG 0x38
+#define AW869X_REG_DATDBG 0x39
+#define AW869X_REG_BSTDBG4 0x3a
+#define AW869X_REG_BSTDBG5 0x3b
+#define AW869X_REG_BSTDBG6 0x3c
+#define AW869X_REG_HDRVDBG 0x3d
+#define AW869X_REG_PRLVL 0x3e
+#define AW869X_REG_PRTIME 0x3f
+#define AW869X_REG_RAMADDRH 0x40
+#define AW869X_REG_RAMADDRL 0x41
+#define AW869X_REG_RAMDATA 0x42
+#define AW869X_REG_GLB_STATE 0x46
+#define AW869X_REG_BST_AUTO 0x47
+#define AW869X_REG_CONT_CTRL 0x48
+#define AW869X_REG_F_PRE_H 0x49
+#define AW869X_REG_F_PRE_L 0x4a
+#define AW869X_REG_TD_H 0x4b
+#define AW869X_REG_TD_L 0x4c
+#define AW869X_REG_TSET 0x4d
+#define AW869X_REG_TRIM_LRA 0x5b
+#define AW869X_REG_R_SPARE 0x5d
+#define AW869X_REG_D2SCFG 0x5e
+#define AW869X_REG_DETCTRL 0x5f
+#define AW869X_REG_RLDET 0x60
+#define AW869X_REG_OSDET 0x61
+#define AW869X_REG_VBATDET 0x62
+#define AW869X_REG_TESTDET 0x63
+#define AW869X_REG_DETLO 0x64
+#define AW869X_REG_BEMFDBG 0x65
+#define AW869X_REG_ADCTEST 0x66
+#define AW869X_REG_BEMFTEST 0x67
+#define AW869X_REG_F_LRA_F0_H 0x68
+#define AW869X_REG_F_LRA_F0_L 0x69
+#define AW869X_REG_F_LRA_CONT_H 0x6a
+#define AW869X_REG_F_LRA_CONT_L 0x6b
+#define AW869X_REG_WAIT_VOL_MP 0x6d
+#define AW869X_REG_WAIT_VOL_MN 0x6f
+#define AW869X_REG_BEMF_VOL_H 0x70
+#define AW869X_REG_BEMF_VOL_L 0x71
+#define AW869X_REG_ZC_THRSH_H 0x72
+#define AW869X_REG_ZC_THRSH_L 0x73
+#define AW869X_REG_BEMF_VTHH_H 0x74
+#define AW869X_REG_BEMF_VTHH_L 0x75
+#define AW869X_REG_BEMF_VTHL_H 0x76
+#define AW869X_REG_BEMF_VTHL_L 0x77
+#define AW869X_REG_BEMF_NUM 0x78
+#define AW869X_REG_DRV_TIME 0x79
+#define AW869X_REG_TIME_NZC 0x7a
+#define AW869X_REG_DRV_LVL 0x7b
+#define AW869X_REG_DRV_LVL_OV 0x7c
+#define AW869X_REG_NUM_F0_1 0x7d
+#define AW869X_REG_NUM_F0_2 0x7e
+#define AW869X_REG_NUM_F0_3 0x7f
+/******************************************************
+ * Register Detail
+ *****************************************************/
+/* SYSST: reg0x01 */
+#define AW869X_BIT_SYSST_BSTERRS (1 << 7)
+#define AW869X_BIT_SYSST_OVS (1 << 6)
+#define AW869X_BIT_SYSST_UVLS (1 << 5)
+#define AW869X_BIT_SYSST_FF_AES (1 << 4)
+#define AW869X_BIT_SYSST_FF_AFS (1 << 3)
+#define AW869X_BIT_SYSST_OCDS (1 << 2)
+#define AW869X_BIT_SYSST_OTS (1 << 1)
+#define AW869X_BIT_SYSST_DONES (1 << 0)
+
+/* SYSINT: reg0x02 */
+#define AW869X_BIT_SYSINT_BSTERRI (1 << 7)
+#define AW869X_BIT_SYSINT_OVI (1 << 6)
+#define AW869X_BIT_SYSINT_UVLI (1 << 5)
+#define AW869X_BIT_SYSINT_FF_AEI (1 << 4)
+#define AW869X_BIT_SYSINT_FF_AFI (1 << 3)
+#define AW869X_BIT_SYSINT_OCDI (1 << 2)
+#define AW869X_BIT_SYSINT_OTI (1 << 1)
+#define AW869X_BIT_SYSINT_DONEI (1 << 0)
+
+/* SYSINTM: reg0x03 */
+#define AW869X_BIT_SYSINTM_BSTERR_MASK (~(1 << 7))
+#define AW869X_BIT_SYSINTM_BSTERR_OFF (1 << 7)
+#define AW869X_BIT_SYSINTM_BSTERR_EN (0 << 7)
+#define AW869X_BIT_SYSINTM_OV_MASK (~(1 << 6))
+#define AW869X_BIT_SYSINTM_OV_OFF (1 << 6)
+#define AW869X_BIT_SYSINTM_OV_EN (0 << 6)
+#define AW869X_BIT_SYSINTM_UVLO_MASK (~(1 << 5))
+#define AW869X_BIT_SYSINTM_UVLO_OFF (1 << 5)
+#define AW869X_BIT_SYSINTM_UVLO_EN (0 << 5)
+#define AW869X_BIT_SYSINTM_FF_AE_MASK (~(1 << 4))
+#define AW869X_BIT_SYSINTM_FF_AE_OFF (1 << 4)
+#define AW869X_BIT_SYSINTM_FF_AE_EN (0 << 4)
+#define AW869X_BIT_SYSINTM_FF_AF_MASK (~(1 << 3))
+#define AW869X_BIT_SYSINTM_FF_AF_OFF (1 << 3)
+#define AW869X_BIT_SYSINTM_FF_AF_EN (0 << 3)
+#define AW869X_BIT_SYSINTM_OCD_MASK (~(1 << 2))
+#define AW869X_BIT_SYSINTM_OCD_OFF (1 << 2)
+#define AW869X_BIT_SYSINTM_OCD_EN (0 << 2)
+#define AW869X_BIT_SYSINTM_OT_MASK (~(1 << 1))
+#define AW869X_BIT_SYSINTM_OT_OFF (1 << 1)
+#define AW869X_BIT_SYSINTM_OT_EN (0 << 1)
+#define AW869X_BIT_SYSINTM_DONE_MASK (~(1 << 0))
+#define AW869X_BIT_SYSINTM_DONE_OFF (1 << 0)
+#define AW869X_BIT_SYSINTM_DONE_EN (0 << 0)
+
+/* SYSCTRL: reg0x04 */
+#define AW869X_BIT_SYSCTRL_WAVDAT_MODE_MASK (~(3 << 6))
+#define AW869X_BIT_SYSCTRL_WAVDAT_MODE_4X (3 << 6)
+#define AW869X_BIT_SYSCTRL_WAVDAT_MODE_2X (0 << 6)
+#define AW869X_BIT_SYSCTRL_WAVDAT_MODE_1X (1 << 6)
+#define AW869X_BIT_SYSCTRL_RAMINIT_MASK (~(1 << 5))
+#define AW869X_BIT_SYSCTRL_RAMINIT_EN (1 << 5)
+#define AW869X_BIT_SYSCTRL_RAMINIT_OFF (0 << 5)
+#define AW869X_BIT_SYSCTRL_PLAY_MODE_MASK (~(3 << 2))
+#define AW869X_BIT_SYSCTRL_PLAY_MODE_CONT (2 << 2)
+#define AW869X_BIT_SYSCTRL_PLAY_MODE_RTP (1 << 2)
+#define AW869X_BIT_SYSCTRL_PLAY_MODE_RAM (0 << 2)
+#define AW869X_BIT_SYSCTRL_BST_MODE_MASK (~(1 << 1))
+#define AW869X_BIT_SYSCTRL_BST_MODE_BOOST (1 << 1)
+#define AW869X_BIT_SYSCTRL_BST_MODE_BYPASS (0 << 1)
+#define AW869X_BIT_SYSCTRL_WORK_MODE_MASK (~(1 << 0))
+#define AW869X_BIT_SYSCTRL_STANDBY (1 << 0)
+#define AW869X_BIT_SYSCTRL_ACTIVE (0 << 0)
+
+/* GO: reg0x05 */
+#define AW869X_BIT_GO_MASK (~(1 << 0))
+#define AW869X_BIT_GO_ENABLE (1 << 0)
+#define AW869X_BIT_GO_DISABLE (0 << 0)
+
+/* WAVSEQ1: reg0x07 */
+#define AW869X_BIT_WAVSEQ1_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ1_WAV_FRM_SEQ1_MASK (~(127 << 0))
+
+/* WAVSEQ2: reg0x08 */
+#define AW869X_BIT_WAVSEQ2_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ2_WAV_FRM_SEQ2_MASK (~(127 << 0))
+
+/* WAVSEQ3: reg0x09 */
+#define AW869X_BIT_WAVSEQ3_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ3_WAV_FRM_SEQ3_MASK (~(127 << 0))
+
+/* WAVSEQ4: reg0x0a */
+#define AW869X_BIT_WAVSEQ4_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ4_WAV_FRM_SEQ4_MASK (~(127 << 0))
+
+/* WAVSEQ5: reg0x0b */
+#define AW869X_BIT_WAVSEQ5_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ5_WAV_FRM_SEQ5_MASK (~(127 << 0))
+
+/* WAVSEQ6: reg0x0c */
+#define AW869X_BIT_WAVSEQ6_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ6_WAV_FRM_SEQ6_MASK (~(127 << 0))
+
+/* WAVSEQ7: reg0x0d */
+#define AW869X_BIT_WAVSEQ7_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ7_WAV_FRM_SEQ7_MASK (~(127 << 0))
+
+/* WAVSEQ8: reg0x0e */
+#define AW869X_BIT_WAVSEQ8_WAIT (1 << 7)
+#define AW869X_BIT_WAVSEQ8_WAV_FRM_SEQ8_MASK (~(127 << 0))
+
+/* WAVLOOP: */
+#define AW869X_BIT_WAVLOOP_SEQN_MASK (~(15 << 4))
+#define AW869X_BIT_WAVLOOP_SEQNP1_MASK (~(15 << 0))
+#define AW869X_BIT_WAVLOOP_INIFINITELY (15 << 0)
+
+/* WAVLOOP1: reg0x0f */
+#define AW869X_BIT_WAVLOOP1_SEQ1_MASK (~(15 << 4))
+#define AW869X_BIT_WAVLOOP1_SEQ2_MASK (~(15 << 0))
+
+/* WAVLOOP2: reg0x10 */
+#define AW869X_BIT_WAVLOOP2_SEQ3_MASK (~(15 << 4))
+#define AW869X_BIT_WAVLOOP2_SEQ4_MASK (~(15 << 0))
+
+/* WAVLOOP3: reg0x11 */
+#define AW869X_BIT_WAVLOOP3_SEQ5_MASK (~(15 << 4))
+#define AW869X_BIT_WAVLOOP3_SEQ6_MASK (~(15 << 0))
+
+/* WAVLOOP4: reg0x12 */
+#define AW869X_BIT_WAVLOOP4_SEQ7_MASK (~(15 << 4))
+#define AW869X_BIT_WAVLOOP4_SEQ8_MASK (~(15 << 0))
+
+/* PLAYPRIO: reg0x1a */
+#define AW869X_BIT_PLAYPRIO_GO_MASK (~(3 << 6))
+#define AW869X_BIT_PLAYPRIO_TRIG3_MASK (~(3 << 4))
+#define AW869X_BIT_PLAYPRIO_TRIG2_MASK (~(3 << 2))
+#define AW869X_BIT_PLAYPRIO_TRIG1_MASK (~(3 << 0))
+
+/* TRGCFG1: reg0x1b */
+#define AW869X_BIT_TRGCFG1_TRG3_POLAR_MASK (~(1 << 5))
+#define AW869X_BIT_TRGCFG1_TRG3_POLAR_NEG (1 << 5)
+#define AW869X_BIT_TRGCFG1_TRG3_POLAR_POS (0 << 5)
+#define AW869X_BIT_TRGCFG1_TRG3_EDGE_MASK (~(1 << 4))
+#define AW869X_BIT_TRGCFG1_TRG3_EDGE_POS (1 << 4)
+#define AW869X_BIT_TRGCFG1_TRG3_EDGE_POS_NEG (0 << 4)
+#define AW869X_BIT_TRGCFG1_TRG2_POLAR_MASK (~(1 << 3))
+#define AW869X_BIT_TRGCFG1_TRG2_POLAR_NEG (1 << 3)
+#define AW869X_BIT_TRGCFG1_TRG2_POLAR_POS (0 << 3)
+#define AW869X_BIT_TRGCFG1_TRG2_EDGE_MASK (~(1 << 2))
+#define AW869X_BIT_TRGCFG1_TRG2_EDGE_POS (1 << 2)
+#define AW869X_BIT_TRGCFG1_TRG2_EDGE_POS_NEG (0 << 2)
+#define AW869X_BIT_TRGCFG1_TRG1_POLAR_MASK (~(1 << 1))
+#define AW869X_BIT_TRGCFG1_TRG1_POLAR_NEG (1 << 1)
+#define AW869X_BIT_TRGCFG1_TRG1_POLAR_POS (0 << 1)
+#define AW869X_BIT_TRGCFG1_TRG1_EDGE_MASK (~(1 << 0))
+#define AW869X_BIT_TRGCFG1_TRG1_EDGE_POS (1 << 0)
+#define AW869X_BIT_TRGCFG1_TRG1_EDGE_POS_NEG (0 << 0)
+
+/* TRGCFG2: reg0x1c */
+#define AW869X_BIT_TRGCFG2_TRG3_ENABLE_MASK (~(1 << 2))
+#define AW869X_BIT_TRGCFG2_TRG3_ENABLE (1 << 2)
+#define AW869X_BIT_TRGCFG2_TRG3_DISABLE (0 << 2)
+#define AW869X_BIT_TRGCFG2_TRG2_ENABLE_MASK (~(1 << 1))
+#define AW869X_BIT_TRGCFG2_TRG2_ENABLE (1 << 1)
+#define AW869X_BIT_TRGCFG2_TRG2_DISABLE (0 << 1)
+#define AW869X_BIT_TRGCFG2_TRG1_ENABLE_MASK (~(1 << 0))
+#define AW869X_BIT_TRGCFG2_TRG1_ENABLE (1 << 0)
+#define AW869X_BIT_TRGCFG2_TRG1_DISABLE (0 << 0)
+
+/* DBGCTRL: reg0x20 */
+#define AW869X_BIT_DBGCTRL_INT_EDGE_MODE_MASK (~(1 << 3))
+#define AW869X_BIT_DBGCTRL_INT_EDGE_MODE_POS (1 << 3)
+#define AW869X_BIT_DBGCTRL_INT_EDGE_MODE_BOTH (0 << 3)
+#define AW869X_BIT_DBGCTRL_INT_MODE_MASK (~(1 << 2))
+#define AW869X_BIT_DBGCTRL_INT_MODE_EDGE (1 << 2)
+#define AW869X_BIT_DBGCTRL_INT_MODE_LEVEL (0 << 2)
+
+/* DATCTRL: reg0x2b */
+#define AW869X_BIT_DATCTRL_FC_MASK (~(1 << 6))
+#define AW869X_BIT_DATCTRL_FC_1000HZ (3 << 6)
+#define AW869X_BIT_DATCTRL_FC_800HZ (3 << 6)
+#define AW869X_BIT_DATCTRL_FC_600HZ (1 << 6)
+#define AW869X_BIT_DATCTRL_FC_400HZ (0 << 6)
+#define AW869X_BIT_DATCTRL_LPF_ENABLE_MASK (~(1 << 5))
+#define AW869X_BIT_DATCTRL_LPF_ENABLE (1 << 5)
+#define AW869X_BIT_DATCTRL_LPF_DISABLE (0 << 5)
+#define AW869X_BIT_DATCTRL_WAKEMODE_ENABLE_MASK (~(1 << 0))
+#define AW869X_BIT_DATCTRL_WAKEMODE_ENABLE (1 << 0)
+#define AW869X_BIT_DATCTRL_WAKEMODE_DISABLE (0 << 0)
+
+/* PWMPRC: reg0x2d */
+#define AW869X_BIT_PWMPRC_PRC_MASK (~(1 << 7))
+#define AW869X_BIT_PWMPRC_PRC_ENABLE (1 << 7)
+#define AW869X_BIT_PWMPRC_PRC_DISABLE (0 << 7)
+#define AW869X_BIT_PWMPRC_PRCTIME_MASK (~(0x7f << 0))
+
+/* PWMDBG: reg0x2e */
+#define AW869X_BIT_PWMDBG_PWM_MODE_MASK (~(3 << 5))
+#define AW869X_BIT_PWMDBG_PWM_12K (3 << 5)
+#define AW869X_BIT_PWMDBG_PWM_24K (2 << 5)
+#define AW869X_BIT_PWMDBG_PWM_48K (0 << 5)
+
+/* DBGST: reg0x30 */
+#define AW869X_BIT_DBGSTAT_FF_EMPTY (1 << 0)
+/* BSTCFG: reg0x34 */
+#define AW869X_BIT_BSTCFG_PEAKCUR_MASK (~(7 << 0))
+#define AW869X_BIT_BSTCFG_PEAKCUR_4A (7 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_3P75A (6 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_3P5A (5 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_3P25A (4 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_3A (3 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_2P5A (2 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_2A (1 << 0)
+#define AW869X_BIT_BSTCFG_PEAKCUR_1P5A (0 << 0)
+
+/* ANADBG: reg0x35 */
+#define AW869X_BIT_ANADBG_IOC_MASK (~(3 << 2))
+#define AW869X_BIT_ANADBG_IOC_4P65A (3 << 2)
+#define AW869X_BIT_ANADBG_IOC_4P15A (2 << 2)
+#define AW869X_BIT_ANADBG_IOC_3P65A (1 << 2)
+#define AW869X_BIT_ANADBG_IOC_3P15A (0 << 2)
+
+/* ANACTRL: reg0x36 */
+#define AW869X_BIT_ANACTRL_LRA_SRC_MASK (~(1 << 5))
+#define AW869X_BIT_ANACTRL_LRA_SRC_REG (1 << 5)
+#define AW869X_BIT_ANACTRL_LRA_SRC_EFUSE (0 << 5)
+#define AW869X_BIT_ANACTRL_HD_PD_MASK (~(1 << 3))
+#define AW869X_BIT_ANACTRL_HD_PD_EN (1 << 3)
+#define AW869X_BIT_ANACTRL_HD_HZ_EN (0 << 3)
+
+/* BSTDBG4: reg0x3a */
+#define AW869X_BIT_BSTDBG4_BSTVOL_MASK (~(31 << 1))
+
+/* PRLVL: reg0x3e */
+#define AW869X_BIT_PRLVL_PR_MASK (~(1 << 7))
+#define AW869X_BIT_PRLVL_PR_ENABLE (1 << 7)
+#define AW869X_BIT_PRLVL_PR_DISABLE (0 << 7)
+#define AW869X_BIT_PRLVL_PRLVL_MASK (~(0x7f << 0))
+
+/*PRTIME: reg0x3f */
+#define AW869X_BIT_PRTIME_PRTIME_MASK (~(0xff << 0))
+
+/* BST_AUTO: reg0x47 */
+#define AW869X_BIT_BST_AUTO_BST_AUTOSW_MASK (~(1 << 2))
+#define AW869X_BIT_BST_AUTO_BST_AUTOMATIC_BOOST (1 << 2)
+#define AW869X_BIT_BST_AUTO_BST_MANUAL_BOOST (0 << 2)
+#define AW869X_BIT_BST_AUTO_BST_RTP_MASK (~(1 << 1))
+#define AW869X_BIT_BST_AUTO_BST_RTP_ENABLE (1 << 1)
+#define AW869X_BIT_BST_AUTO_BST_RTP_DISABLE (0 << 1)
+#define AW869X_BIT_BST_AUTO_BST_RAM_MASK (~(1 << 0))
+#define AW869X_BIT_BST_AUTO_BST_RAM_ENABLE (1 << 0)
+#define AW869X_BIT_BST_AUTO_BST_RAM_DISABLE (0 << 0)
+
+/* CONT_CTRL: reg0x48 */
+#define AW869X_BIT_CONT_CTRL_ZC_DETEC_MASK (~(1 << 7))
+#define AW869X_BIT_CONT_CTRL_ZC_DETEC_ENABLE (1 << 7)
+#define AW869X_BIT_CONT_CTRL_ZC_DETEC_DISABLE (0 << 7)
+#define AW869X_BIT_CONT_CTRL_WAIT_PERIOD_MASK (~(3 << 5))
+#define AW869X_BIT_CONT_CTRL_WAIT_8PERIOD (3 << 5)
+#define AW869X_BIT_CONT_CTRL_WAIT_4PERIOD (2 << 5)
+#define AW869X_BIT_CONT_CTRL_WAIT_2PERIOD (1 << 5)
+#define AW869X_BIT_CONT_CTRL_WAIT_1PERIOD (0 << 5)
+#define AW869X_BIT_CONT_CTRL_MODE_MASK (~(1 << 4))
+#define AW869X_BIT_CONT_CTRL_BY_DRV_TIME (1 << 4)
+#define AW869X_BIT_CONT_CTRL_BY_GO_SIGNAL (0 << 4)
+#define AW869X_BIT_CONT_CTRL_EN_CLOSE_MASK (~(1 << 3))
+#define AW869X_BIT_CONT_CTRL_CLOSE_PLAYBACK (1 << 3)
+#define AW869X_BIT_CONT_CTRL_OPEN_PLAYBACK (0 << 3)
+#define AW869X_BIT_CONT_CTRL_F0_DETECT_MASK (~(1 << 2))
+#define AW869X_BIT_CONT_CTRL_F0_DETECT_ENABLE (1 << 2)
+#define AW869X_BIT_CONT_CTRL_F0_DETECT_DISABLE (0 << 2)
+#define AW869X_BIT_CONT_CTRL_O2C_MASK (~(1 << 1))
+#define AW869X_BIT_CONT_CTRL_O2C_ENABLE (1 << 1)
+#define AW869X_BIT_CONT_CTRL_O2C_DISABLE (0 << 1)
+#define AW869X_BIT_CONT_CTRL_AUTO_BRK_MASK (~(1 << 0))
+#define AW869X_BIT_CONT_CTRL_AUTO_BRK_ENABLE (1 << 0)
+#define AW869X_BIT_CONT_CTRL_AUTO_BRK_DISABLE (0 << 0)
+
+/* D2SCFG: reg0x5e */
+#define AW869X_BIT_D2SCFG_CLK_ADC_MASK (~(7 << 5))
+#define AW869X_BIT_D2SCFG_CLK_ASC_0P09375MHZ (7 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_0P1875MHZ (6 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_0P375MHZ (5 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_0P75MHZ (4 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_1P5MHZ (3 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_3MHZ (2 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_6MHZ (1 << 5)
+#define AW869X_BIT_D2SCFG_CLK_ASC_12MHZ (0 << 5)
+
+/* DETCTRL: reg0x5f */
+#define AW869X_BIT_DETCTRL_RL_OS_MASK (~(1 << 6))
+#define AW869X_BIT_DETCTRL_RL_DETECT (1 << 6)
+#define AW869X_BIT_DETCTRL_OS_DETECT (0 << 6)
+#define AW869X_BIT_DETCTRL_PROTECT_MASK (~(1 << 5))
+#define AW869X_BIT_DETCTRL_PROTECT_NO_ACTION (1 << 5)
+#define AW869X_BIT_DETCTRL_PROTECT_SHUTDOWN (0 << 5)
+#define AW869X_BIT_DETCTRL_ADO_SLOT_MODE_MASK (~(1 << 4))
+#define AW869X_BIT_DETCTRL_ADO_SLOT_MODE_ENABLE (1 << 4)
+#define AW869X_BIT_DETCTRL_ADO_SLOT_MODE_DISABLE (0 << 4)
+#define AW869X_BIT_DETCTRL_VBAT_GO_MASK (~(1 << 1))
+#define AW869X_BIT_DETCTRL_VABT_GO_ENABLE (1 << 1)
+#define AW869X_BIT_DETCTRL_VBAT_GO_DISBALE (0 << 1)
+#define AW869X_BIT_DETCTRL_DIAG_GO_MASK (~(1 << 0))
+#define AW869X_BIT_DETCTRL_DIAG_GO_ENABLE (1 << 0)
+#define AW869X_BIT_DETCTRL_DIAG_GO_DISABLE (0 << 0)
+
+/* ADCTEST: reg0x66 */
+#define AW869X_BIT_ADCTEST_VBAT_MODE_MASK (~(1 << 6))
+#define AW869X_BIT_ADCTEST_VBAT_HW_COMP (1 << 6)
+#define AW869X_BIT_ADCTEST_VBAT_SW_COMP (0 << 6)
+
+/* BEMF_NUM: reg0x78 */
+#define AW869X_BIT_BEMF_NUM_BRK_MASK (~(15 << 0))
+
+/*********************************************************
+ *
+ * extern
+ *
+ ********************************************************/
+extern int aw869x_parse_dt(struct device *dev, struct aw869x *aw869x,
+			   struct device_node *np);
+extern int aw869x_haptics_upload_effect(struct input_dev *dev,
+					struct ff_effect *effect,
+					struct ff_effect *old);
+extern int aw869x_haptics_playback(struct input_dev *dev, int effect_id,
+				   int val);
+extern int aw869x_haptics_erase(struct input_dev *dev, int effect_id);
+extern void aw869x_haptics_set_gain(struct input_dev *dev, u16 gain);
+extern void aw869x_haptics_set_gain_work_routine(struct work_struct *work);
+extern void aw869x_interrupt_setup(struct aw869x *aw869x);
+extern int aw869x_vibrator_init(struct aw869x *aw869x);
+extern int aw869x_haptic_init(struct aw869x *aw869x, unsigned char chip_name);
+extern int aw869x_ram_init(struct aw869x *aw869x);
+extern irqreturn_t aw869x_irq(int irq, void *data);
+extern struct attribute_group aw869x_vibrator_attribute_group;
+extern struct miscdevice aw869x_haptic_misc;
+/*********************************************************
+ *
+ * ioctl
+ *
+ ********************************************************/
+struct aw869x_seq_loop {
+	unsigned char loop[AW869X_SEQUENCER_SIZE];
+};
+
+struct aw869x_que_seq {
+	unsigned char index[AW869X_SEQUENCER_SIZE];
+};
+
+#define AW869X_HAPTIC_IOCTL_MAGIC 'h'
+
+#define AW869X_HAPTIC_SET_QUE_SEQ                                              \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 1, struct aw869x_que_seq *)
+#define AW869X_HAPTIC_SET_SEQ_LOOP                                             \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 2, struct aw869x_seq_loop *)
+#define AW869X_HAPTIC_PLAY_QUE_SEQ                                             \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 3, unsigned int)
+#define AW869X_HAPTIC_SET_BST_VOL                                              \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 4, unsigned int)
+#define AW869X_HAPTIC_SET_BST_PEAK_CUR                                         \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 5, unsigned int)
+#define AW869X_HAPTIC_SET_GAIN _IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 6, unsigned int)
+#define AW869X_HAPTIC_PLAY_REPEAT_SEQ                                          \
+	_IOWR(AW869X_HAPTIC_IOCTL_MAGIC, 7, unsigned int)
+
+#endif
diff --git a/drivers/input/misc/aw86927_haptic/aw_config.h b/drivers/input/misc/aw86927_haptic/aw_config.h
new file mode 100644
index 000000000000..0babeaa3f916
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw_config.h
@@ -0,0 +1,122 @@
+#ifndef __AW_CONFIG_H__
+#define __AW_CONFIG_H__
+
+#define AW869X_BSTCFG_PEAKCUR_LIMIT 0x07
+#define AW8695_DEFAULT_PEAKCUR AW869X_BIT_BSTCFG_PEAKCUR_2A
+#define AW8697_DEFAULT_PEAKCUR AW869X_BIT_BSTCFG_PEAKCUR_3P5A
+#define AW869X_CONT_PLAYBACK_MODE AW869X_BIT_CONT_CTRL_CLOSE_PLAYBACK
+
+#define AW86907_BSTCFG_PEAKCUR_LIMIT 0x0e
+#define AW86907_DEFAULT_PEAKCUR AW86907_BIT_BSTCFG1_PEAKCUR_4A
+
+#define AW86927_BSTCFG_PEAKCUR_LIMIT 0x90
+#define AW86927_DEFAULT_PEAKCUR AW86927_BIT_ANACFG13_PEAKCUR_3P45A
+/*#define CONFIG_DEBUG_FS*/
+
+/*#ifdef INPUT_DEV*/
+#if 1
+/* haptics module register definitions */
+#define REG_HAP_STATUS1 0x0A
+#define HAP_SC_DET_BIT BIT(3)
+#define HAP_BUSY_BIT BIT(1)
+
+#define REG_HAP_EN_CTL1 0x46
+#define HAP_EN_BIT BIT(7)
+
+#define REG_HAP_EN_CTL2 0x48
+#define HAP_AUTO_STANDBY_EN_BIT BIT(1)
+#define HAP_BRAKE_EN_BIT BIT(0)
+
+#define REG_HAP_EN_CTL3 0x4A
+#define HAP_HBRIDGE_EN_BIT BIT(7)
+#define HAP_PWM_SIGNAL_EN_BIT BIT(6)
+#define HAP_ILIM_EN_BIT BIT(5)
+#define HAP_ILIM_CC_EN_BIT BIT(4)
+#define HAP_AUTO_RES_RBIAS_EN_BIT BIT(3)
+#define HAP_DAC_EN_BIT BIT(2)
+#define HAP_ZX_HYST_EN_BIT BIT(1)
+#define HAP_PWM_CTL_EN_BIT BIT(0)
+
+#define REG_HAP_AUTO_RES_CTRL 0x4B
+#define HAP_AUTO_RES_EN_BIT BIT(7)
+#define HAP_SEL_AUTO_RES_PERIOD BIT(6)
+#define HAP_AUTO_RES_CNT_ERR_DELTA_MASK GENMASK(5, 4)
+#define HAP_AUTO_RES_CNT_ERR_DELTA_SHIFT 4
+#define HAP_AUTO_RES_ERR_RECOVERY_BIT BIT(3)
+#define HAP_AUTO_RES_EN_DLY_MASK GENMASK(2, 0)
+#define AUTO_RES_CNT_ERR_DELTA(x) (x << HAP_AUTO_RES_CNT_ERR_DELTA_SHIFT)
+#define AUTO_RES_EN_DLY(x) x
+
+#define REG_HAP_CFG1 0x4C
+#define REG_HAP_CFG2 0x4D
+#define HAP_LRA_RES_TYPE_BIT BIT(0)
+
+#define REG_HAP_SEL 0x4E
+#define HAP_WF_SOURCE_MASK GENMASK(5, 4)
+#define HAP_WF_SOURCE_SHIFT 4
+#define HAP_WF_TRIGGER_BIT BIT(0)
+#define HAP_WF_SOURCE_VMAX (0 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_BUFFER (1 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_AUDIO (2 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_PWM (3 << HAP_WF_SOURCE_SHIFT)
+
+#define REG_HAP_AUTO_RES_CFG 0x4F
+#define HAP_AUTO_RES_MODE_BIT BIT(7)
+#define HAP_AUTO_RES_MODE_SHIFT 7
+#define HAP_AUTO_RES_CAL_DURATON_MASK GENMASK(6, 5)
+#define HAP_CAL_EOP_EN_BIT BIT(3)
+#define HAP_CAL_PERIOD_MASK GENMASK(2, 0)
+#define HAP_CAL_OPT3_EVERY_8_PERIOD 2
+
+#define REG_HAP_SLEW_CFG 0x50
+#define REG_HAP_VMAX_CFG 0x51
+#define HAP_VMAX_SIGN_BIT BIT(7)
+#define HAP_VMAX_OVD_BIT BIT(6)
+#define HAP_VMAX_MV_MASK GENMASK(5, 1)
+#define HAP_VMAX_MV_SHIFT 1
+#define HAP_VMAX_MV_LSB 116
+
+#define REG_HAP_ILIM_CFG 0x52
+#define HAP_ILIM_SEL_1000MA BIT(1)
+#define HAP_ILIM_DEFAULT_SEL HAP_ILIM_SEL_1000MA
+#define REG_HAP_SC_DEB_CFG 0x53
+#define REG_HAP_RATE_CFG1 0x54
+#define REG_HAP_RATE_CFG2 0x55
+#define REG_HAP_INTERNAL_PWM 0x56
+#define REG_HAP_EXTERNAL_PWM 0x57
+#define REG_HAP_PWM 0x58
+
+#define REG_HAP_SC_CLR 0x59
+#define HAP_SC_CLR_BIT BIT(0)
+
+#define REG_HAP_ZX_CFG 0x5A
+#define HAP_ZX_DET_DEB_MASK GENMASK(2, 0)
+#define ZX_DET_DEB_10US 0
+#define ZX_DET_DEB_20US 1
+#define ZX_DET_DEB_40US 2
+#define ZX_DET_DEB_80US 3
+
+#define REG_HAP_BRAKE 0x5C
+#define HAP_BRAKE_PATTERN_MASK 0x3
+#define HAP_BRAKE_PATTERN_SHIFT 2
+
+#define REG_HAP_WF_REPEAT 0x5E
+#define HAP_WF_REPEAT_MASK GENMASK(6, 4)
+#define HAP_WF_REPEAT_SHIFT 4
+#define HAP_WF_S_REPEAT_MASK GENMASK(1, 0)
+
+#define REG_HAP_WF_S1 0x60
+#define HAP_WF_SIGN_BIT BIT(7)
+#define HAP_WF_OVD_BIT BIT(6)
+#define HAP_WF_AMP_BIT GENMASK(5, 1)
+#define HAP_WF_AMP_SHIFT 1
+
+#define REG_HAP_PLAY 0x70
+#define HAP_PLAY_BIT BIT(7)
+
+#define REG_HAP_SEC_ACCESS 0xD0
+
+static int wf_repeat[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };
+static int wf_s_repeat[4] = { 1, 2, 4, 8 };
+#endif
+#endif
diff --git a/drivers/input/misc/aw86927_haptic/aw_haptic.c b/drivers/input/misc/aw86927_haptic/aw_haptic.c
new file mode 100644
index 000000000000..cb23b5c7a76e
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw_haptic.c
@@ -0,0 +1,1130 @@
+/*
+ * aw_haptic.c
+ *
+ *
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: <chelvming@awinic.com.cn>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/pm_qos.h>
+#include "ringbuffer.h"
+#include "aw_haptic.h"
+#include "aw869x.h"
+#include "aw86927.h"
+#include "aw86907.h"
+
+#define AW_DRIVER_VERSION "v0.5.1.3"
+
+/******************************************************
+ *
+ * Value
+ *
+ ******************************************************/
+#ifdef ENABLE_PIN_CONTROL
+static const char *const pctl_names[] = {
+	"awinic_reset_low",
+	"awinic_reset_high",
+	"awinic_interrupt_high",
+};
+#endif
+
+char *awinic_ram_name = "aw8697_haptic.bin";
+
+#ifdef TEST_RTP
+char awinic_rtp_name[][AWINIC_RTP_NAME_MAX] = {
+	{ "aw86927_rtp_1.bin" },
+};
+#else
+char awinic_rtp_name[][AWINIC_RTP_NAME_MAX] = {
+	{ "aw8697_rtp_1.bin" }, /*8*/
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	/*{"aw8697_rtp_1.bin"},*/
+	/*{"aw8697_rtp_1.bin"},*/
+	{ "AcousticGuitar_RTP.bin" }, /*21*/
+	{ "Blues_RTP.bin" },
+	{ "Candy_RTP.bin" },
+	{ "Carousel_RTP.bin" },
+	{ "Celesta_RTP.bin" },
+	{ "Childhood_RTP.bin" },
+	{ "Country_RTP.bin" },
+	{ "Cowboy_RTP.bin" },
+	{ "Echo_RTP.bin" },
+	{ "Fairyland_RTP.bin" },
+	{ "Fantasy_RTP.bin" },
+	{ "Field_Trip_RTP.bin" },
+	{ "Glee_RTP.bin" },
+	{ "Glockenspiel_RTP.bin" },
+	{ "Ice_Latte_RTP.bin" },
+	{ "Kung_Fu_RTP.bin" },
+	{ "Leisure_RTP.bin" },
+	{ "Lollipop_RTP.bin" },
+	{ "MiMix2_RTP.bin" },
+	{ "Mi_RTP.bin" },
+	{ "MiHouse_RTP.bin" },
+	{ "MiJazz_RTP.bin" },
+	{ "MiRemix_RTP.bin" },
+	{ "Mountain_Spring_RTP.bin" },
+	{ "Orange_RTP.bin" },
+	{ "Raindrops_RTP.bin" },
+	{ "Space_Age_RTP.bin" },
+	{ "ToyRobot_RTP.bin" },
+	{ "Vigor_RTP.bin" },
+	{ "Bottle_RTP.bin" },
+	{ "Bubble_RTP.bin" },
+	{ "Bullfrog_RTP.bin" },
+	{ "Burst_RTP.bin" },
+	{ "Chirp_RTP.bin" },
+	{ "Clank_RTP.bin" },
+	{ "Crystal_RTP.bin" },
+	{ "FadeIn_RTP.bin" },
+	{ "FadeOut_RTP.bin" },
+	{ "Flute_RTP.bin" },
+	{ "Fresh_RTP.bin" },
+	{ "Frog_RTP.bin" },
+	{ "Guitar_RTP.bin" },
+	{ "Harp_RTP.bin" },
+	{ "IncomingMessage_RTP.bin" },
+	{ "MessageSent_RTP.bin" },
+	{ "Moment_RTP.bin" },
+	{ "NotificationXylophone_RTP.bin" },
+	{ "Potion_RTP.bin" },
+	{ "Radar_RTP.bin" },
+	{ "Spring_RTP.bin" },
+	{ "Swoosh_RTP.bin" }, /*71*/
+	{ "Gesture_UpSlide_RTP.bin" },
+	{ "FOD_Motion_Planet_RTP.bin" },
+	{ "Charge_Wire_RTP.bin" },
+	{ "Charge_Wireless_RTP.bin" },
+	{ "Unlock_Failed_RTP.bin" },
+	{ "FOD_Motion1_RTP.bin" },
+	{ "FOD_Motion2_RTP.bin" },
+	{ "FOD_Motion3_RTP.bin" },
+	{ "FOD_Motion4_RTP.bin" },
+	{ "FOD_Motion_Aurora_RTP.bin" },
+	{ "FaceID_Wrong2_RTP.bin" }, /*82*/
+	{ "uninstall_animation_rtp.bin" },
+	{ "uninstall_dialog_rtp.bin" },
+	{ "screenshot_rtp.bin" },
+	{ "lockscreen_camera_entry_rtp.bin" },
+	{ "launcher_edit_rtp.bin" },
+	{ "launcher_icon_selection_rtp.bin" },
+	{ "taskcard_remove_rtp.bin" },
+	{ "task_cleanall_rtp.bin" },
+	{ "new_iconfolder_rtp.bin" },
+	{ "notification_remove_rtp.bin" },
+	{ "notification_cleanall_rtp.bin" },
+	{ "notification_setting_rtp.bin" },
+	{ "game_turbo_rtp.bin" },
+	{ "NFC_card_rtp.bin" },
+	{ "wakeup_voice_assistant_rtp.bin" },
+	{ "NFC_card_slow_rtp.bin" },
+	{ "aw8697_rtp_1.bin" }, /*99*/
+	{ "aw8697_rtp_1.bin" }, /*100*/
+	{ "offline_countdown_RTP.bin" },
+	{ "scene_bomb_injury_RTP.bin" },
+	{ "scene_bomb_RTP.bin" }, /*103*/
+	{ "door_open_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_step_RTP.bin" }, /*106*/
+	{ "crawl_RTP.bin" },
+	{ "scope_on_RTP.bin" },
+	{ "scope_off_RTP.bin" },
+	{ "magazine_quick_RTP.bin" },
+	{ "grenade_RTP.bin" },
+	{ "scene_getshot_RTP.bin" }, /*112*/
+	{ "grenade_explosion_RTP.bin" },
+	{ "punch_RTP.bin" },
+	{ "pan_RTP.bin" },
+	{ "bandage_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_jump_RTP.bin" },
+	{ "vehicle_plane_RTP.bin" }, /*119*/
+	{ "scene_openparachute_RTP.bin" }, /*120*/
+	{ "scene_closeparachute_RTP.bin" }, /*121*/
+	{ "vehicle_collision_RTP.bin" },
+	{ "vehicle_buggy_RTP.bin" }, /*123*/
+	{ "vehicle_dacia_RTP.bin" }, /*124*/
+	{ "vehicle_moto_RTP.bin" }, /*125*/
+	{ "firearms_akm_RTP.bin" }, /*126*/
+	{ "firearms_m16a4_RTP.bin" }, /*127*/
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_awm_RTP.bin" }, /*129*/
+	{ "firearms_mini14_RTP.bin" }, /*130*/
+	{ "firearms_vss_RTP.bin" }, /*131*/
+	{ "firearms_qbz_RTP.bin" }, /*132*/
+	{ "firearms_ump9_RTP.bin" }, /*133*/
+	{ "firearms_dp28_RTP.bin" }, /*134*/
+	{ "firearms_s1897_RTP.bin" }, /*135*/
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_p18c_RTP.bin" }, /*137*/
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "CFM_KillOne_RTP.bin" },
+	{ "CFM_Headshot_RTP.bin" }, /*141*/
+	{ "CFM_MultiKill_RTP.bin" },
+	{ "CFM_KillOne_Strong_RTP.bin" },
+	{ "CFM_Headshot_Strong_RTP.bin" },
+	{ "CFM_MultiKill_Strong_RTP.bin" },
+	{ "CFM_Weapon_Grenade_Explode_RTP.bin" },
+	{ "CFM_Weapon_Grenade_KillOne_RTP.bin" },
+	{ "CFM_ImpactFlesh_Normal_RTP.bin" },
+	{ "CFM_Weapon_C4_Installed_RTP.bin" },
+	{ "CFM_Hero_Appear_RTP.bin" },
+	{ "CFM_UI_Reward_OpenBox_RTP.bin" },
+	{ "CFM_UI_Reward_Task_RTP.bin" },
+	{ "CFM_Weapon_BLT_Shoot_RTP.bin" }, /*153*/
+	{ "Atlantis_RTP.bin" },
+	{ "DigitalUniverse_RTP.bin" },
+	{ "Reveries_RTP.bin" },
+	{ "FOD_Motion_Triang_RTP.bin" },
+	{ "FOD_Motion_Flare_RTP.bin" },
+	{ "FOD_Motion_Ripple_RTP.bin" },
+	{ "FOD_Motion_Spiral_RTP.bin" },
+	{ "gamebox_launch_rtp.bin" }, /*161*/
+	{ "Gesture_Back_Pull_RTP.bin" }, /*162*/
+	{ "Gesture_Back_Release_RTP.bin" }, /*163*/
+	{ "alert_rtp.bin" }, /*164*/
+	{ "feedback_negative_light_rtp.bin" }, /*165*/
+	{ "feedback_neutral_rtp.bin" }, /*166*/
+	{ "feedback_positive_rtp.bin" }, /*167*/
+	{ "fingerprint_record_rtp.bin" }, /*168*/
+	{ "lockdown_rtp.bin" }, /*169*/
+	{ "sliding_damping_rtp.bin" }, /*170*/
+	{ "todo_alldone_rtp.bin" }, /*171*/
+	{ "uninstall_animation_icon_rtp.bin" }, /*172*/
+	{ "signal_button_highlight_rtp.bin" }, /*173*/
+	{ "signal_button_negative_rtp.bin" },
+	{ "signal_button_rtp.bin" },
+	{ "signal_clock_high_rtp.bin" }, /*176*/
+	{ "signal_clock_rtp.bin" },
+	{ "signal_clock_unit_rtp.bin" },
+	{ "signal_inputbox_rtp.bin" },
+	{ "signal_key_high_rtp.bin" },
+	{ "signal_key_unit_rtp.bin" }, /*181*/
+	{ "signal_list_highlight_rtp.bin" },
+	{ "signal_list_rtp.bin" },
+	{ "signal_picker_rtp.bin" },
+	{ "signal_popup_rtp.bin" },
+	{ "signal_seekbar_rtp.bin" }, /*186*/
+	{ "signal_switch_rtp.bin" },
+	{ "signal_tab_rtp.bin" },
+	{ "signal_text_rtp.bin" },
+	{ "signal_transition_light_rtp.bin" },
+	{ "signal_transition_rtp.bin" }, /*191*/
+	{ "haptics_video_rtp.bin" }, /*192*/
+	{ "keyboard_clicky_down_rtp.bin" },
+	{ "keyboard_clicky_up_rtp.bin" },
+	{ "keyboard_linear_down_rtp.bin" },
+	{ "keyboard_linear_up_rtp.bin" }, /*196*/
+};
+#endif
+int awinic_rtp_name_len = sizeof(awinic_rtp_name) / AWINIC_RTP_NAME_MAX;
+int CUSTOME_WAVE_ID;
+/******************************************************
+ *
+ * i2c read/write
+ *
+ ******************************************************/
+static int aw_i2c_read(struct awinic *awinic, unsigned char reg_addr,
+		       unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(awinic->i2c, reg_addr);
+		if (ret < 0) {
+			aw_err("%s: i2c_read cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw_i2c_write(struct awinic *awinic, unsigned char reg_addr,
+			unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(awinic->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			aw_err("%s: i2c_write cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+#ifdef ENABLE_PIN_CONTROL
+static int aw_select_pin_ctl(struct awinic *awinic, const char *name)
+{
+	size_t i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(awinic->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+
+		if (!strncmp(n, name, strlen(n))) {
+			rc = pinctrl_select_state(awinic->awinic_pinctrl,
+						  awinic->pinctrl_state[i]);
+			if (rc)
+				aw_err("%s: cannot select '%s'\n", __func__,
+				       name);
+			else
+				aw_err("%s: Selected '%s'\n", __func__, name);
+			goto exit;
+		}
+	}
+
+	rc = -EINVAL;
+	aw_info("%s: '%s' not found\n", __func__, name);
+
+exit:
+	return rc;
+}
+
+static int aw_set_interrupt(struct awinic *awinic)
+{
+	int rc = aw_select_pin_ctl(awinic, "awinic_interrupt_high");
+	return rc;
+}
+#endif
+
+static int aw_sw_reset(struct awinic *awinic)
+{
+	aw_info("%s enter\n", __func__);
+	aw_i2c_write(awinic, 0x00, 0xAA);
+	usleep_range(2000, 2500);
+	return 0;
+}
+
+static int aw_control_rest_pin(struct awinic *awinic)
+{
+	int ret = 0;
+
+	ret = aw_select_pin_ctl(awinic, "awinic_reset_high");
+	if (ret < 0) {
+		aw_err("%s select reset failed!\n", __func__);
+		return ret;
+	}
+	usleep_range(5000, 5500);
+	ret = aw_select_pin_ctl(awinic, "awinic_reset_low");
+	if (ret < 0) {
+		aw_err("%s select reset failed!\n", __func__);
+		return ret;
+	}
+	usleep_range(5000, 5500);
+	ret = aw_select_pin_ctl(awinic, "awinic_reset_high");
+	usleep_range(8000, 8500);
+	if (ret < 0) {
+		aw_err("%s select reset failed!\n", __func__);
+		return ret;
+	}
+	return 0;
+}
+
+static int aw_hw_reset(struct awinic *awinic)
+{
+	int rc = 0;
+
+	if (!awinic->enable_pin_control) {
+		if (awinic && gpio_is_valid(awinic->reset_gpio)) {
+			gpio_set_value_cansleep(awinic->reset_gpio, 0);
+			aw_info("%s pull down1\n", __func__);
+			usleep_range(5000, 5500);
+			gpio_set_value_cansleep(awinic->reset_gpio, 1);
+			aw_info("%s pull up1\n", __func__);
+			usleep_range(8000, 8500);
+		} else {
+			aw_err("%s:  failed\n", __func__);
+		}
+	} else {
+		rc = aw_control_rest_pin(awinic);
+		if (rc < 0)
+			return rc;
+	}
+
+	return 0;
+}
+
+/******************************************************
+ *
+ * check chip id
+ *
+ ******************************************************/
+static int aw_read_chipid(struct awinic *awinic, unsigned int *reg_val)
+{
+	unsigned char value[2] = { 0 };
+	unsigned char chipid_addr[2] = { AW_REG_IDH, AW_REG_IDL };
+	unsigned char i = 0;
+	int ret = -1;
+
+	aw_info("%s enter!\n", __func__);
+
+	/* try to read aw869x and aw86907 chip id */
+	ret = aw_i2c_read(awinic, 0x00, &value[0]);
+	if (ret < 0)
+		return ret;
+	if (value[0] == AW8695_CHIP_ID) {
+		*reg_val = value[0];
+		return 0;
+	}
+	if (value[0] == AW8697_CHIP_ID) {
+		*reg_val = value[0];
+		return 0;
+	}
+	if (value[0] == AW86907_CHIP_ID) {
+		*reg_val = value[0];
+		return 0;
+	}
+	/* try to read aw86927 chip id */
+	for (i = 0; i < 2; i++) {
+		ret = aw_i2c_read(awinic, chipid_addr[i], &value[i]);
+		if (ret < 0)
+			return ret;
+	}
+	*reg_val = value[0] << 8 | value[1];
+	return 0;
+}
+
+static int aw_parse_chipid(struct awinic *awinic)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+	unsigned int reg_val = 0;
+
+	while (cnt < AW_READ_CHIPID_RETRIES) {
+		/* hardware reset */
+		ret = aw_hw_reset(awinic);
+		if (ret < 0) {
+			aw_err("%s: hardware reset failed!\n", __func__);
+			break;
+		}
+
+		ret = aw_read_chipid(awinic, &reg_val);
+		if (ret < 0) {
+			aw_err("%s: failed to read AW_REG_ID: %d\n", __func__,
+			       ret);
+			break;
+		}
+
+		switch (reg_val) {
+		case AW8695_CHIP_ID:
+			aw_info("%s aw8695 detected\n", __func__);
+			awinic->name = AW8695;
+			aw_sw_reset(awinic);
+			return 0;
+		case AW8697_CHIP_ID:
+			aw_info("%s aw8697 detected\n", __func__);
+			awinic->name = AW8697;
+			aw_sw_reset(awinic);
+			return 0;
+		case AW86927_CHIP_ID:
+			aw_info("%s aw86927 detected\n", __func__);
+			awinic->name = AW86927;
+			aw_sw_reset(awinic);
+			return 0;
+		case AW86907_CHIP_ID:
+			aw_info("%s aw86907 detected\n", __func__);
+			awinic->name = AW86907;
+			aw_sw_reset(awinic);
+			return 0;
+		default:
+			aw_info("%s unsupported device revision (0x%x)\n",
+				__func__, reg_val);
+			break;
+		}
+		cnt++;
+
+		usleep_range(2000, 3000);
+	}
+
+	return -EINVAL;
+}
+
+/******************************************************
+ *
+ * parse dts
+ *
+ ******************************************************/
+static int aw_parse_dt(struct awinic *awinic, struct device *dev,
+		       struct device_node *np)
+{
+	awinic->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);
+	if (awinic->reset_gpio >= 0) {
+		aw_err("%s: reset gpio provided ok\n", __func__);
+	} else {
+		awinic->reset_gpio = -1;
+		aw_err("%s: no reset gpio provided, will not HW reset device\n",
+		       __func__);
+		return -ERANGE;
+	}
+
+	awinic->irq_gpio = of_get_named_gpio(np, "irq-gpio", 0);
+	if (awinic->irq_gpio < 0) {
+		aw_err("%s: no irq gpio provided.\n", __func__);
+		awinic->IsUsedIRQ = false;
+	} else {
+		aw_err("%s: irq gpio provided ok.\n", __func__);
+		awinic->IsUsedIRQ = true;
+	}
+
+	return 0;
+}
+/******************************************************
+ *
+ * i2c driver
+ *
+ ******************************************************/
+static int aw_i2c_probe(struct i2c_client *i2c, const struct i2c_device_id *id)
+{
+	struct awinic *awinic;
+	struct input_dev *input_dev;
+	struct ff_device *ff;
+	struct device_node *np = i2c->dev.of_node;
+	int effect_count_max;
+	int irq_flags = 0;
+	int ret = -1;
+	int rc = 0;
+
+#ifdef ENABLE_PIN_CONTROL
+	int i;
+#endif
+
+	aw_info("%s enter\n", __func__);
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C)) {
+		aw_err("check_functionality failed\n");
+		return -EIO;
+	}
+
+	awinic = devm_kzalloc(&i2c->dev, sizeof(struct awinic), GFP_KERNEL);
+	if (awinic == NULL)
+		return -ENOMEM;
+	input_dev = devm_input_allocate_device(&i2c->dev);
+	if (!input_dev)
+		return -ENOMEM;
+	input_dev->name = "awinic_haptic";
+	awinic->dev = &i2c->dev;
+	awinic->i2c = i2c;
+	device_init_wakeup(awinic->dev, true);
+	i2c_set_clientdata(i2c, awinic);
+
+	/* awinic rst & int */
+	if (np) {
+		ret = aw_parse_dt(awinic, &i2c->dev, np);
+		if (ret) {
+			aw_err("%s: failed to parse device tree node\n",
+			       __func__);
+			goto err_parse_dt;
+		}
+	} else {
+		awinic->reset_gpio = -1;
+		awinic->irq_gpio = -1;
+	}
+
+	awinic->enable_pin_control = 0;
+
+#ifdef ENABLE_PIN_CONTROL
+	awinic->awinic_pinctrl = devm_pinctrl_get(&i2c->dev);
+	if (IS_ERR(awinic->awinic_pinctrl)) {
+		if (PTR_ERR(awinic->awinic_pinctrl) == -EPROBE_DEFER) {
+			aw_info("%s pinctrl not ready\n", __func__);
+			rc = -EPROBE_DEFER;
+			return rc;
+		}
+		aw_info("%s Target does not use pinctrl\n", __func__);
+		awinic->awinic_pinctrl = NULL;
+		rc = -EINVAL;
+		return rc;
+	}
+	for (i = 0; i < ARRAY_SIZE(awinic->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+		struct pinctrl_state *state =
+			pinctrl_lookup_state(awinic->awinic_pinctrl, n);
+		if (!IS_ERR(state)) {
+			aw_info("%s: found pin control %s\n", __func__, n);
+			awinic->pinctrl_state[i] = state;
+			awinic->enable_pin_control = 1;
+			aw_set_interrupt(awinic);
+			continue;
+		}
+		aw_info("%s cannot find '%s'\n", __func__, n);
+	}
+#endif
+	if (!awinic->enable_pin_control) {
+		if (gpio_is_valid(awinic->reset_gpio)) {
+			ret = devm_gpio_request_one(&i2c->dev,
+						    awinic->reset_gpio,
+						    GPIOF_OUT_INIT_LOW,
+						    "awinic_rst");
+			if (ret) {
+				aw_err("%s: rst request failed\n", __func__);
+				goto err_reset_gpio_request;
+			}
+		}
+	}
+
+	if (gpio_is_valid(awinic->irq_gpio)) {
+		ret = devm_gpio_request_one(&i2c->dev, awinic->irq_gpio,
+					    GPIOF_DIR_IN, "awinic_int");
+		if (ret) {
+			aw_err("%s: int request failed\n", __func__);
+			goto err_irq_gpio_request;
+		}
+	}
+
+	ret = aw_parse_chipid(awinic);
+	if (ret < 0) {
+		aw_err("%s: read_chipid failed ret=%d\n", __func__, ret);
+		goto err_id;
+	}
+
+	/* aw869x */
+	if (awinic->name == AW8695 || awinic->name == AW8697) {
+		awinic->aw869x = devm_kzalloc(&i2c->dev, sizeof(struct aw869x),
+					      GFP_KERNEL);
+		if (awinic->aw869x == NULL) {
+			if (gpio_is_valid(awinic->irq_gpio))
+				devm_gpio_free(&i2c->dev, awinic->irq_gpio);
+			if (gpio_is_valid(awinic->reset_gpio))
+				devm_gpio_free(&i2c->dev, awinic->reset_gpio);
+			devm_kfree(&i2c->dev, awinic);
+			awinic = NULL;
+			return -ENOMEM;
+		}
+
+		awinic->aw869x->dev = awinic->dev;
+		awinic->aw869x->i2c = awinic->i2c;
+		awinic->aw869x->reset_gpio = awinic->reset_gpio;
+		awinic->aw869x->irq_gpio = awinic->irq_gpio;
+
+		/* aw869x rst & int */
+		if (np) {
+			ret = aw869x_parse_dt(&i2c->dev, awinic->aw869x, np);
+			if (ret) {
+				aw_err("%s: failed to parse device tree node\n",
+				       __func__);
+				goto err_aw869x_parse_dt;
+			}
+		}
+
+		/* aw869x irq */
+		if (gpio_is_valid(awinic->aw869x->irq_gpio) &&
+		    !(awinic->aw869x->flags & AW869X_FLAG_SKIP_INTERRUPTS)) {
+			/* register irq handler */
+			aw869x_interrupt_setup(awinic->aw869x);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev,
+				gpio_to_irq(awinic->aw869x->irq_gpio), NULL,
+				aw869x_irq, irq_flags, "aw869x",
+				awinic->aw869x);
+			if (ret != 0) {
+				aw_err("%s: failed to request IRQ %d: %d\n",
+				       __func__,
+				       gpio_to_irq(awinic->aw869x->irq_gpio),
+				       ret);
+				goto err_aw869x_irq;
+			}
+		} else {
+			aw_info("%s skipping IRQ registration\n", __func__);
+			/* disable feature support if gpio was invalid */
+			awinic->aw869x->flags |= AW869X_FLAG_SKIP_INTERRUPTS;
+			aw_info("%s: aw869x_irq failed.\n", __func__);
+		}
+
+		awinic->aw869x->work_queue = create_singlethread_workqueue(
+			"aw869x_vibrator_work_queue");
+		if (!awinic->aw869x->work_queue) {
+			aw_err("%s: Error creating aw869x_vibrator_work_queue\n",
+			       __func__);
+			goto err_aw869x_sysfs;
+		}
+
+		aw869x_vibrator_init(awinic->aw869x);
+		aw869x_haptic_init(awinic->aw869x, awinic->name);
+		aw869x_ram_init(awinic->aw869x);
+
+		CUSTOME_WAVE_ID = awinic->aw869x->info.effect_max;
+
+		/*aw869x input config*/
+		input_set_drvdata(input_dev, awinic->aw869x);
+		awinic->aw869x->input_dev = input_dev;
+		input_set_capability(input_dev, EV_FF, FF_CONSTANT);
+		input_set_capability(input_dev, EV_FF, FF_GAIN);
+		if (awinic->aw869x->effects_count != 0) {
+			input_set_capability(input_dev, EV_FF, FF_PERIODIC);
+			input_set_capability(input_dev, EV_FF, FF_CUSTOM);
+		}
+		if (awinic->aw869x->effects_count + 1 > FF_EFFECT_COUNT_MAX)
+			effect_count_max = awinic->aw869x->effects_count + 1;
+		else
+			effect_count_max = FF_EFFECT_COUNT_MAX;
+		rc = input_ff_create(input_dev, effect_count_max);
+		if (rc < 0) {
+			aw_err("%s create FF input device failed, rc=%d\n",
+			       __func__, rc);
+			goto err_aw869x_input_ff;
+		}
+		INIT_WORK(&awinic->aw869x->set_gain_work,
+			  aw869x_haptics_set_gain_work_routine);
+		ff = input_dev->ff;
+		ff->upload = aw869x_haptics_upload_effect;
+		ff->playback = aw869x_haptics_playback;
+		ff->erase = aw869x_haptics_erase;
+		ff->set_gain = aw869x_haptics_set_gain;
+		rc = input_register_device(input_dev);
+		if (rc < 0) {
+			aw_err("%s register input device failed, rc=%d\n",
+			       __func__, rc);
+			goto aw869x_destroy_ff;
+		}
+	} else if (awinic->name == AW86927) {
+		awinic->aw86927 = devm_kzalloc(
+			&i2c->dev, sizeof(struct aw86927), GFP_KERNEL);
+		if (awinic->aw86927 == NULL) {
+			if (gpio_is_valid(awinic->irq_gpio))
+				devm_gpio_free(&i2c->dev, awinic->irq_gpio);
+			if (gpio_is_valid(awinic->reset_gpio))
+				devm_gpio_free(&i2c->dev, awinic->reset_gpio);
+			devm_kfree(&i2c->dev, awinic);
+			awinic = NULL;
+			return -ENOMEM;
+		}
+
+		awinic->aw86927->dev = awinic->dev;
+		awinic->aw86927->i2c = awinic->i2c;
+		awinic->aw86927->reset_gpio = awinic->reset_gpio;
+		awinic->aw86927->irq_gpio = awinic->irq_gpio;
+		/* chip qualify */
+#ifdef AW_CHECK_QUAL
+		if (aw86927_check_qualify(awinic->aw86927)) {
+			aw_err("%s:unqualified chip!\n", __func__);
+			goto err_aw86927_check_qualify;
+		}
+#endif
+		/* aw86927 rst & int */
+		if (np) {
+			ret = aw86927_parse_dt(awinic->aw86927, &i2c->dev, np);
+			if (ret) {
+				aw_err("%s: failed to parse device tree node\n",
+				       __func__);
+				goto err_aw86927_parse_dt;
+			}
+		}
+
+		/* aw86927 irq */
+		if (gpio_is_valid(awinic->aw86927->irq_gpio) &&
+		    !(awinic->aw86927->flags & AW86927_FLAG_SKIP_INTERRUPTS)) {
+			/* register irq handler */
+			aw86927_interrupt_setup(awinic->aw86927);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev,
+				gpio_to_irq(awinic->aw86927->irq_gpio), NULL,
+				aw86927_irq, irq_flags, "aw86927",
+				awinic->aw86927);
+			if (ret != 0) {
+				aw_err("%s: failed to request IRQ %d: %d\n",
+				       __func__,
+				       gpio_to_irq(awinic->aw86927->irq_gpio),
+				       ret);
+				goto err_aw86927_irq;
+			}
+		} else {
+			aw_info("%s skipping IRQ registration\n", __func__);
+			/* disable feature support if gpio was invalid */
+			awinic->aw86927->flags |= AW86927_FLAG_SKIP_INTERRUPTS;
+			aw_info("%s: aw86927_irq failed.\n", __func__);
+		}
+
+		awinic->aw86927->work_queue = create_singlethread_workqueue(
+			"aw86927_vibrator_work_queue");
+		if (!awinic->aw86927->work_queue) {
+			aw_err("%s: Error creating aw86927_vibrator_work_queue\n",
+			       __func__);
+			goto err_aw86927_sysfs;
+		}
+
+		aw86927_vibrator_init(awinic->aw86927);
+		aw86927_haptic_init(awinic->aw86927);
+		aw86927_ram_init(awinic->aw86927);
+
+		CUSTOME_WAVE_ID = awinic->aw86927->info.effect_max;
+
+		/*aw86927 input config*/
+		input_set_drvdata(input_dev, awinic->aw86927);
+		awinic->aw86927->input_dev = input_dev;
+		input_set_capability(input_dev, EV_FF, FF_CONSTANT);
+		input_set_capability(input_dev, EV_FF, FF_GAIN);
+		if (awinic->aw86927->effects_count != 0) {
+			input_set_capability(input_dev, EV_FF, FF_PERIODIC);
+			input_set_capability(input_dev, EV_FF, FF_CUSTOM);
+		}
+		if (awinic->aw86927->effects_count + 1 > FF_EFFECT_COUNT_MAX)
+			effect_count_max = awinic->aw86927->effects_count + 1;
+		else
+			effect_count_max = FF_EFFECT_COUNT_MAX;
+		rc = input_ff_create(input_dev, effect_count_max);
+		if (rc < 0) {
+			aw_err("%s create FF input device failed, rc=%d\n",
+			       __func__, rc);
+			goto err_aw86927_input_ff;
+		}
+		INIT_WORK(&awinic->aw86927->set_gain_work,
+			  aw86927_haptics_set_gain_work_routine);
+		ff = input_dev->ff;
+		ff->upload = aw86927_haptics_upload_effect;
+		ff->playback = aw86927_haptics_playback;
+		ff->erase = aw86927_haptics_erase;
+		ff->set_gain = aw86927_haptics_set_gain;
+		rc = input_register_device(input_dev);
+		if (rc < 0) {
+			aw_err("%s register input device failed, rc=%d\n",
+			       __func__, rc);
+			goto aw86927_destroy_ff;
+		}
+
+	} else if (awinic->name == AW86907) {
+		awinic->aw86907 = devm_kzalloc(
+			&i2c->dev, sizeof(struct aw86907), GFP_KERNEL);
+		if (awinic->aw86907 == NULL) {
+			if (gpio_is_valid(awinic->irq_gpio))
+				devm_gpio_free(&i2c->dev, awinic->irq_gpio);
+			if (gpio_is_valid(awinic->reset_gpio))
+				devm_gpio_free(&i2c->dev, awinic->reset_gpio);
+			devm_kfree(&i2c->dev, awinic);
+			awinic = NULL;
+			return -ENOMEM;
+		}
+
+		awinic->aw86907->dev = awinic->dev;
+		awinic->aw86907->i2c = awinic->i2c;
+		awinic->aw86907->reset_gpio = awinic->reset_gpio;
+		awinic->aw86907->irq_gpio = awinic->irq_gpio;
+		/* chip qualify */
+#ifdef AW_CHECK_QUAL
+		if (aw86907_check_qualify(awinic->aw86907)) {
+			aw_err("%s:unqualified chip!\n", __func__);
+			goto err_aw86907_check_qualify;
+		}
+#endif
+		/* aw86907 rst & int */
+		if (np) {
+			ret = aw86907_parse_dt(awinic->aw86907, &i2c->dev, np);
+			if (ret) {
+				aw_err("%s: failed to parse device tree node\n",
+				       __func__);
+				goto err_aw86907_parse_dt;
+			}
+		}
+
+		/* aw86907 irq */
+		if (gpio_is_valid(awinic->aw86907->irq_gpio) &&
+		    !(awinic->aw86907->flags & AW86907_FLAG_SKIP_INTERRUPTS)) {
+			/* register irq handler */
+			aw86907_interrupt_setup(awinic->aw86907);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev,
+				gpio_to_irq(awinic->aw86907->irq_gpio), NULL,
+				aw86907_irq, irq_flags, "aw86907",
+				awinic->aw86907);
+			if (ret != 0) {
+				aw_err("%s: failed to request IRQ %d: %d\n",
+				       __func__,
+				       gpio_to_irq(awinic->aw86907->irq_gpio),
+				       ret);
+				goto err_aw86907_irq;
+			}
+		} else {
+			aw_info("%s skipping IRQ registration\n", __func__);
+			/* disable feature support if gpio was invalid */
+			awinic->aw86907->flags |= AW86907_FLAG_SKIP_INTERRUPTS;
+			aw_info("%s: aw86907_irq failed.\n", __func__);
+		}
+
+		awinic->aw86907->work_queue = create_singlethread_workqueue(
+			"aw86907_vibrator_work_queue");
+		if (!awinic->aw86907->work_queue) {
+			aw_err("%s: Error creating aw86907_vibrator_work_queue\n",
+			       __func__);
+			goto err_aw86907_sysfs;
+		}
+
+		aw86907_vibrator_init(awinic->aw86907);
+		aw86907_haptic_init(awinic->aw86907);
+		aw86907_ram_init(awinic->aw86907);
+
+		CUSTOME_WAVE_ID = awinic->aw86907->info.effect_max;
+
+		/*aw86907 input config*/
+		input_set_drvdata(input_dev, awinic->aw86907);
+		awinic->aw86907->input_dev = input_dev;
+		input_set_capability(input_dev, EV_FF, FF_CONSTANT);
+		input_set_capability(input_dev, EV_FF, FF_GAIN);
+		if (awinic->aw86907->effects_count != 0) {
+			input_set_capability(input_dev, EV_FF, FF_PERIODIC);
+			input_set_capability(input_dev, EV_FF, FF_CUSTOM);
+		}
+		if (awinic->aw86907->effects_count + 1 > FF_EFFECT_COUNT_MAX)
+			effect_count_max = awinic->aw86907->effects_count + 1;
+		else
+			effect_count_max = FF_EFFECT_COUNT_MAX;
+		rc = input_ff_create(input_dev, effect_count_max);
+		if (rc < 0) {
+			aw_err("%s create FF input device failed, rc=%d\n",
+			       __func__, rc);
+			goto err_aw86907_input_ff;
+		}
+		INIT_WORK(&awinic->aw86907->set_gain_work,
+			  aw86907_haptics_set_gain_work_routine);
+		ff = input_dev->ff;
+		ff->upload = aw86907_haptics_upload_effect;
+		ff->playback = aw86907_haptics_playback;
+		ff->erase = aw86907_haptics_erase;
+		ff->set_gain = aw86907_haptics_set_gain;
+		rc = input_register_device(input_dev);
+		if (rc < 0) {
+			aw_err("%s register input device failed, rc=%d\n",
+			       __func__, rc);
+			goto aw86907_destroy_ff;
+		}
+
+	} else {
+		goto err_parse_dt;
+	}
+
+	dev_set_drvdata(&i2c->dev, awinic);
+	ret = create_rb();
+	if (ret < 0) {
+		aw_info("%s error creating ringbuffer\n", __func__);
+		goto err_rb;
+	}
+	aw_info("%s probe completed successfully!\n", __func__);
+	return 0;
+
+err_rb:
+aw86907_destroy_ff:
+	if (awinic->name == AW86907)
+		input_ff_destroy(awinic->aw86907->input_dev);
+err_aw86907_input_ff:
+err_aw86907_sysfs:
+	if (awinic->name == AW86907)
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw86907->irq_gpio),
+			      awinic->aw86907);
+err_aw86907_irq:
+err_aw86907_parse_dt:
+#ifdef AW_CHECK_QUAL
+err_aw86907_check_qualify:
+#endif
+	if (awinic->name == AW86907) {
+		devm_kfree(&i2c->dev, awinic->aw86907);
+		awinic->aw86907 = NULL;
+	}
+aw86927_destroy_ff:
+	if (awinic->name == AW86927)
+		input_ff_destroy(awinic->aw86927->input_dev);
+err_aw86927_input_ff:
+err_aw86927_sysfs:
+	if (awinic->name == AW86927)
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw86927->irq_gpio),
+			      awinic->aw86927);
+err_aw86927_irq:
+err_aw86927_parse_dt:
+#ifdef AW_CHECK_QUAL
+err_aw86927_check_qualify:
+#endif
+	if (awinic->name == AW86927) {
+		devm_kfree(&i2c->dev, awinic->aw86927);
+		awinic->aw86927 = NULL;
+	}
+aw869x_destroy_ff:
+	if (awinic->name == AW8697)
+		input_ff_destroy(awinic->aw869x->input_dev);
+err_aw869x_input_ff:
+err_aw869x_sysfs:
+	if (awinic->name == AW8697)
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw869x->irq_gpio),
+			      awinic->aw869x);
+err_aw869x_irq:
+err_aw869x_parse_dt:
+	if (awinic->name == AW8697) {
+		devm_kfree(&i2c->dev, awinic->aw869x);
+		awinic->aw869x = NULL;
+	}
+err_id:
+	if (gpio_is_valid(awinic->irq_gpio))
+		devm_gpio_free(&i2c->dev, awinic->irq_gpio);
+err_irq_gpio_request:
+	if (gpio_is_valid(awinic->reset_gpio))
+		devm_gpio_free(&i2c->dev, awinic->reset_gpio);
+err_reset_gpio_request:
+err_parse_dt:
+	device_init_wakeup(awinic->dev, false);
+	devm_kfree(&i2c->dev, awinic);
+	awinic = NULL;
+	return ret;
+}
+
+static int aw_i2c_remove(struct i2c_client *i2c)
+{
+	struct awinic *awinic = i2c_get_clientdata(i2c);
+
+	aw_info("%s enter\n", __func__);
+
+	if (awinic->name == AW8695 || awinic->name == AW8697) {
+		aw_err("%s remove aw869x\n", __func__);
+		misc_deregister(&aw869x_haptic_misc);
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw869x_vibrator_attribute_group);
+
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw869x->irq_gpio),
+			      awinic->aw869x);
+		if (gpio_is_valid(awinic->aw869x->irq_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw869x->irq_gpio);
+		if (gpio_is_valid(awinic->aw869x->reset_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw869x->reset_gpio);
+		if (awinic->aw869x != NULL) {
+			flush_workqueue(awinic->aw869x->work_queue);
+			destroy_workqueue(awinic->aw869x->work_queue);
+		}
+		devm_kfree(&i2c->dev, awinic->aw869x);
+		awinic->aw869x = NULL;
+	} else if (awinic->name == AW86927) {
+		aw_err("%s remove aw86927\n", __func__);
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw86927_vibrator_attribute_group);
+
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw86927->irq_gpio),
+			      awinic->aw86927);
+		if (gpio_is_valid(awinic->aw86927->irq_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw86927->irq_gpio);
+		if (gpio_is_valid(awinic->aw86927->reset_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw86927->reset_gpio);
+		if (awinic->aw86927 != NULL) {
+			flush_workqueue(awinic->aw86927->work_queue);
+			destroy_workqueue(awinic->aw86927->work_queue);
+		}
+		devm_kfree(&i2c->dev, awinic->aw86927);
+		awinic->aw86927 = NULL;
+	} else if (awinic->name == AW86907) {
+		aw_err("%s remove aw86907\n", __func__);
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw86907_vibrator_attribute_group);
+
+		devm_free_irq(&i2c->dev, gpio_to_irq(awinic->aw86907->irq_gpio),
+			      awinic->aw86907);
+		if (gpio_is_valid(awinic->aw86907->irq_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw86907->irq_gpio);
+		if (gpio_is_valid(awinic->aw86907->reset_gpio))
+			devm_gpio_free(&i2c->dev, awinic->aw86907->reset_gpio);
+		if (awinic->aw86907 != NULL) {
+			flush_workqueue(awinic->aw86907->work_queue);
+			destroy_workqueue(awinic->aw86907->work_queue);
+		}
+		devm_kfree(&i2c->dev, awinic->aw86907);
+		awinic->aw86907 = NULL;
+	} else {
+		aw_err("%s no chip\n", __func__);
+		return -ERANGE;
+	}
+	release_rb();
+	device_init_wakeup(awinic->dev, false);
+
+	aw_info("%s exit\n", __func__);
+	return 0;
+}
+
+static const struct i2c_device_id aw_i2c_id[] = { { AW_I2C_NAME, 0 }, {} };
+
+MODULE_DEVICE_TABLE(i2c, aw_i2c_id);
+
+static const struct of_device_id aw_dt_match[] = {
+	{ .compatible = "awinic,awinic_haptic" },
+	{},
+};
+
+static struct i2c_driver aw_i2c_driver = {
+	.driver = {
+		   .name = AW_I2C_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(aw_dt_match),
+		  },
+	.probe = aw_i2c_probe,
+	.remove = aw_i2c_remove,
+	.id_table = aw_i2c_id,
+};
+
+static int __init aw_i2c_init(void)
+{
+	int ret = 0;
+
+	aw_info("%s awinic driver version %s\n", __func__, AW_DRIVER_VERSION);
+
+	ret = i2c_add_driver(&aw_i2c_driver);
+	if (ret) {
+		aw_err("%s fail to add awinic device into i2c\n", __func__);
+		return ret;
+	}
+	aw_info("%s aw_i2c_init success", __func__);
+	return 0;
+}
+
+module_init(aw_i2c_init);
+
+static void __exit aw_i2c_exit(void)
+{
+	i2c_del_driver(&aw_i2c_driver);
+}
+
+module_exit(aw_i2c_exit);
+
+MODULE_DESCRIPTION("AWinic Haptic Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/misc/aw86927_haptic/aw_haptic.h b/drivers/input/misc/aw86927_haptic/aw_haptic.h
new file mode 100644
index 000000000000..8e9584be7e62
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/aw_haptic.h
@@ -0,0 +1,225 @@
+#ifndef _AW_HAPTIC_H_
+#define _AW_HAPTIC_H_
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/syscalls.h>
+#include <linux/input.h>
+/********************************************
+ * print information control
+ *******************************************/
+#define aw_err(format, ...) pr_err("[haptic_hv]" format, ##__VA_ARGS__)
+
+#define aw_info(format, ...) pr_info("[haptic_hv]" format, ##__VA_ARGS__)
+
+#define aw_dbg(format, ...) pr_debug("[haptic_hv]" format, ##__VA_ARGS__)
+
+/*********************************************************
+*
+* normal macro
+*
+********************************************************/
+#define AW_I2C_NAME "awinic_haptic"
+#define AW_HAPTIC_NAME "awinic_haptic"
+
+#define AW8695_CHIP_ID (0x95)
+#define AW8697_CHIP_ID (0x97)
+#define AW86907_CHIP_ID (0x04)
+#define AW86927_CHIP_ID (0x9270)
+#define AW_REG_IDH (0x57)
+#define AW_REG_IDL (0x58)
+#define AW_VBAT_REFER (4200)
+#define AW_VBAT_MIN (3000)
+#define AW_VBAT_MAX (4500)
+#define AW_READ_CHIPID_RETRIES (5)
+#define AW_I2C_RETRIES (2)
+#define AW_I2C_RETRY_DELAY (2)
+#define AW_RAMDATA_WR_BUFFER_SIZE (2048)
+#define AW_RAMDATA_RD_BUFFER_SIZE (1024)
+#define AW_PROTECT_EN (0X01)
+#define AW_PROTECT_OFF (0X00)
+#define AW_PROTECT_VAL (0X00)
+#define AWINIC_RTP_NAME_MAX (64)
+#define PM_QOS_VALUE_VB (400)
+#define OSC_CALIBRATION_T_LENGTH (5100000)
+
+#define REG_NONE_ACCESS (0)
+#define REG_RD_ACCESS (1 << 0)
+#define REG_WR_ACCESS (1 << 1)
+
+#define FF_EFFECT_COUNT_MAX (32)
+#define HAP_BRAKE_PATTERN_MAX (4)
+#define HAP_WAVEFORM_BUFFER_MAX (8)
+#define HAP_PLAY_RATE_US_DEFAULT (5715)
+#define HAP_PLAY_RATE_US_MAX (20475)
+/*********************************************************
+*
+* macro control
+*
+********************************************************/
+#define INPUT_DEV
+#define DEBUG
+/* #define TEST_RTP */
+#define AW_RAM_UPDATE_DELAY
+#define ENABLE_PIN_CONTROL
+#define AW_CHECK_RAM_DATA
+#define AW_CHECK_QUAL
+/*********************************************************
+*
+* enum
+*
+********************************************************/
+
+enum awinic_chip_name {
+	AW_NULL = 0,
+	AW8697 = 1,
+	AW86927 = 2,
+	AW86907 = 3,
+	AW8695 = 4,
+};
+
+enum haptics_custom_effect_param {
+	CUSTOM_DATA_EFFECT_IDX,
+	CUSTOM_DATA_TIMEOUT_SEC_IDX,
+	CUSTOM_DATA_TIMEOUT_MSEC_IDX,
+	CUSTOM_DATA_LEN,
+};
+
+#ifdef INPUT_DEV
+enum actutor_type {
+	ACT_LRA,
+	ACT_ERM,
+};
+
+enum lra_res_sig_shape {
+	RES_SIG_SINE,
+	RES_SIG_SQUARE,
+};
+
+enum lra_auto_res_mode {
+	AUTO_RES_MODE_ZXD,
+	AUTO_RES_MODE_QWD,
+};
+
+enum wf_src {
+	INT_WF_VMAX,
+	INT_WF_BUFFER,
+	EXT_WF_AUDIO,
+	EXT_WF_PWM,
+};
+#endif
+/*********************************************************
+*
+* struct
+*
+********************************************************/
+
+#ifdef INPUT_DEV
+struct qti_hap_effect {
+	int id;
+	u8 *pattern;
+	int pattern_length;
+	u16 play_rate_us;
+	u16 vmax_mv;
+	u8 wf_repeat_n;
+	u8 wf_s_repeat_n;
+	u8 brake[HAP_BRAKE_PATTERN_MAX];
+	int brake_pattern_length;
+	bool brake_en;
+	bool lra_auto_res_disable;
+};
+
+struct qti_hap_play_info {
+	struct qti_hap_effect *effect;
+	u16 vmax_mv;
+	int length_us;
+	int playing_pos;
+	bool playing_pattern;
+};
+
+struct qti_hap_config {
+	enum actutor_type act_type;
+	enum lra_res_sig_shape lra_shape;
+	enum lra_auto_res_mode lra_auto_res_mode;
+	enum wf_src ext_src;
+	u16 vmax_mv;
+	u16 play_rate_us;
+	bool lra_allow_variable_play_rate;
+	bool use_ext_wf_src;
+};
+#endif
+
+struct fileops {
+	unsigned char cmd;
+	unsigned char reg;
+	unsigned char ram_addrh;
+	unsigned char ram_addrl;
+};
+
+/*awinic*/
+struct awinic {
+	struct i2c_client *i2c;
+	struct device *dev;
+	unsigned char name;
+	bool IsUsedIRQ;
+
+	int reset_gpio;
+	int irq_gpio;
+	int reset_gpio_ret;
+	int irq_gpio_ret;
+	int enable_pin_control;
+
+	struct aw869x *aw869x;
+	struct aw86927 *aw86927;
+	struct aw86907 *aw86907;
+#ifdef ENABLE_PIN_CONTROL
+	struct pinctrl *awinic_pinctrl;
+	struct pinctrl_state *pinctrl_state[3];
+#endif
+};
+
+struct ram {
+	unsigned char version;
+	unsigned char ram_shift;
+	unsigned char baseaddr_shift;
+	unsigned int len;
+	unsigned int check_sum;
+	unsigned int base_addr;
+	unsigned int ram_num;
+};
+
+struct haptic_ctr {
+	unsigned char cmd;
+	unsigned char play;
+	unsigned char wavseq;
+	unsigned char loop;
+	unsigned char gain;
+};
+
+struct haptic_audio {
+	struct mutex lock;
+	struct hrtimer timer;
+	struct work_struct work;
+	int delay_val;
+	int timer_val;
+	unsigned char cnt;
+	struct haptic_ctr data[256];
+	struct haptic_ctr ctr;
+	unsigned char ori_gain;
+};
+
+/*********************************************************
+*
+* extern
+*
+********************************************************/
+extern int CUSTOME_WAVE_ID;
+extern char awinic_rtp_name[][AWINIC_RTP_NAME_MAX];
+extern int awinic_rtp_name_len;
+extern char *awinic_ram_name;
+
+#endif
diff --git a/drivers/input/misc/aw86927_haptic/ringbuffer.c b/drivers/input/misc/aw86927_haptic/ringbuffer.c
new file mode 100644
index 000000000000..62ef39972725
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/ringbuffer.c
@@ -0,0 +1,221 @@
+/*
+* reader shoule NEVER block !!!, if no data is avaliable, just return zero
+* writer will block if there is no space, and wakend up by reader or force exit
+* there is 1 writer and 1 reader for each buffer, so no lock is used
+* writer shoule read rd_index to check if free size is enought, and  then fill this buffer  update wr_index
+* reader shoule read wr_index to check if avaliable size is enought, and then read the buffer and update rd_index
+* empty: wr_index==rd_index
+* full: (wr_index +1) % BUFFER_SIZE == rd_index
+* total avaliable size is BUFFER_SIZE -1
+*/
+#define DEBUG
+#include <linux/errno.h>
+#include "ringbuffer.h"
+
+#define BUFFER_SIZE (1024 * 8 + 1)
+
+struct rb {
+	char *gbuffer;
+	atomic_t wr_index;
+	atomic_t rd_index;
+	atomic_t eof;
+	volatile int32_t aval_size; // avalibale to write size.
+	atomic_t buf_condition, exit;
+	wait_queue_head_t wait_q;
+};
+
+struct rb *grb;
+
+int32_t get_free_size(int32_t tail, int32_t head)
+{
+	if (head == tail)
+		return BUFFER_SIZE - 1;
+	else if (head < tail)
+		return (head + BUFFER_SIZE - 1 - tail);
+	else
+		return (head - tail - 1);
+}
+
+int write_rb(const char *data, int32_t size)
+{
+	int32_t tail = atomic_read(&grb->wr_index);
+	int32_t head = atomic_read(&grb->rd_index);
+	int32_t part;
+	int32_t ret;
+	grb->aval_size = get_free_size(tail, head);
+
+	pr_debug("write  write index %d, read index %d, free size %d", tail,
+		 head, grb->aval_size);
+
+	while ((grb->aval_size < size) && (!atomic_read(&grb->exit))) {
+		pr_debug("no space avaliable");
+		pr_info("%s  goint to waiting irq exit\n", __func__);
+		ret = wait_event_interruptible(
+			grb->wait_q, atomic_read(&grb->buf_condition) == 1);
+		if (ret == -ERESTARTSYS) {
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+
+		atomic_set(&grb->buf_condition, 0);
+		tail = atomic_read(&grb->wr_index);
+		head = atomic_read(&grb->rd_index);
+		grb->aval_size = get_free_size(tail, head);
+	}
+	if (atomic_read(&grb->exit) == 1) {
+		pr_debug("exit write_rb");
+		return -EPERM;
+	}
+
+	part = BUFFER_SIZE - tail;
+	if (part < size) {
+		memcpy(grb->gbuffer + tail, data, part);
+		memcpy(grb->gbuffer, data + part, size - part);
+		tail = size - part;
+	} else {
+		memcpy(grb->gbuffer + tail, data, size);
+		tail += size;
+		if (tail >= BUFFER_SIZE)
+			tail = tail % BUFFER_SIZE;
+	}
+	atomic_set(&grb->wr_index, tail);
+	grb->aval_size = get_free_size(tail, head);
+	pr_debug("after write %d,  write index %d, read index %d, aval_size %d",
+		 size, tail, head, grb->aval_size);
+	return size;
+}
+
+int read_rb(char *data, int32_t size)
+{
+	int32_t tail;
+	int32_t head;
+	int32_t filled_size;
+	void *buf;
+	int32_t read_bytes, part;
+	buf = data;
+
+	pr_debug("read_rb data:%p, size %d", data, (int)size);
+
+	tail = atomic_read(&grb->wr_index);
+	head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+	filled_size = BUFFER_SIZE - 1 - grb->aval_size; // aready write size.
+
+	pr_debug("write index %d, read index %d, filled size %d", tail, head,
+		 filled_size);
+	read_bytes = MIN(size, filled_size);
+	if (size > filled_size)
+		pr_debug("buffer underrun , req size %d, filled size %d", size,
+			 filled_size);
+	part = BUFFER_SIZE - head;
+	if (part < read_bytes) {
+		memcpy(buf, grb->gbuffer + head, part);
+		memcpy((char *)buf + part, grb->gbuffer, read_bytes - part);
+		head = read_bytes - part;
+	} else {
+		memcpy(buf, grb->gbuffer + head, read_bytes);
+		head += read_bytes;
+		if (head >= BUFFER_SIZE)
+			head = head % BUFFER_SIZE;
+	}
+	atomic_set(&grb->rd_index, head);
+	grb->aval_size = get_free_size(tail, head);
+
+	//add wakeup here
+	atomic_set(&grb->buf_condition, 1);
+	wake_up_interruptible(&grb->wait_q);
+	pr_debug(
+		"read_rb: after read %d  write index %d, read index %d, aval_size %d",
+		read_bytes, tail, head, grb->aval_size);
+
+	return atomic_read(&grb->eof) ? read_bytes : size;
+}
+
+int get_rb_free_size(void)
+{
+	int32_t tail = atomic_read(&grb->wr_index);
+	int32_t head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+	return grb->aval_size;
+}
+
+int get_rb_avalible_size(void)
+{
+	return BUFFER_SIZE - 1 - get_rb_free_size();
+}
+
+int get_rb_max_size(void)
+{
+	return BUFFER_SIZE - 1;
+}
+
+void rb_force_exit(void)
+{
+	pr_debug("rb force exit");
+	atomic_set(&grb->exit, 1);
+	atomic_set(&grb->buf_condition, 1);
+	wake_up_interruptible(&grb->wait_q);
+}
+
+void rb_end(void)
+{
+	atomic_set(&grb->eof, 1);
+}
+
+int rb_shoule_exit(void)
+{
+	return atomic_read(&grb->eof) || atomic_read(&grb->exit);
+}
+
+int create_rb(void)
+{
+	int32_t tail;
+	int32_t head;
+	grb = kzalloc(sizeof(struct rb), GFP_KERNEL);
+	if (grb == NULL) {
+		goto err;
+		;
+	}
+	grb->gbuffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+	if (grb->gbuffer == NULL) {
+		goto err;
+	}
+
+	rb_init();
+
+	init_waitqueue_head(&grb->wait_q);
+	tail = atomic_read(&grb->wr_index);
+	head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+
+	return 0;
+err:
+	if (grb)
+		kfree(grb);
+	if (grb->gbuffer)
+		kfree(grb->gbuffer);
+	return -EPERM;
+}
+
+void rb_init(void)
+{
+	pr_debug("rb init");
+	atomic_set(&grb->wr_index, 0);
+	atomic_set(&grb->rd_index, 0);
+	atomic_set(&grb->buf_condition, 0);
+	atomic_set(&grb->exit, 0);
+	atomic_set(&grb->eof, 0);
+}
+
+int release_rb(void)
+{
+	if (grb != NULL) {
+		if (grb->gbuffer) {
+			kfree(grb->gbuffer);
+			grb->gbuffer = NULL;
+		}
+		kfree(grb);
+		grb = NULL;
+	}
+	return 0;
+}
diff --git a/drivers/input/misc/aw86927_haptic/ringbuffer.h b/drivers/input/misc/aw86927_haptic/ringbuffer.h
new file mode 100644
index 000000000000..fdbdc3c70402
--- /dev/null
+++ b/drivers/input/misc/aw86927_haptic/ringbuffer.h
@@ -0,0 +1,36 @@
+/*
+* reader shoule NEVER block !!!, if no data is avaliable, just return zero
+* writer will block if there is no space, and wakend up by reader or force exit
+* there is 1 writer and 1 reader for each buffer, so no lock is used
+* writer shoule read rd_index to check if free size is enought, and  then fill this buffer  update wr_index
+* reader shoule read wr_index to check if avaliable size is enought, and then read the buffer and update rd_index
+* empty: wr_index==rd_index
+* full: (wr_index +1) % BUFFER_SIZE == rd_index
+* total avaliable size is BUFFER_SIZE -1
+*/
+
+#ifndef _RINGBUFFER_H_
+#define _RINGBUFFER_H_
+
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/atomic.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+#define MIN(x, y) ((x) < (y) ? (x) : (y))
+
+int write_rb(const char *data, int32_t size);
+int read_rb(char *data, int32_t size);
+int get_rb_free_size(void);
+int get_rb_max_size(void);
+void rb_force_exit(void);
+void rb_end(void);
+int rb_shoule_exit(void);
+int create_rb(void);
+void rb_init(void);
+int release_rb(void);
+int get_rb_avalible_size(void);
+#endif
diff --git a/drivers/input/misc/aw8697_haptic/Kconfig b/drivers/input/misc/aw8697_haptic/Kconfig
new file mode 100644
index 000000000000..4d942c96d323
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/Kconfig
@@ -0,0 +1,23 @@
+#
+# Awinic aw8697 driver
+#
+
+config INPUT_AW8697_HAPTIC
+	tristate "Awinic AW8697 HAPTIC"
+	depends on I2C
+	help
+	  Say Y here if you have Awinic AW8697 haptic controller
+	  chip in your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here.
+
+config INPUT_AW8697_HAPTIC_DAGU
+	bool "Awinic AW8697 HAPTIC dagu driver"
+	depends on INPUT_AW8697_HAPTIC
+	help
+	  Say Y here if you want to use the AW8697 driver from
+	  dagu.
+
+	  If unsure, say N.
diff --git a/drivers/input/misc/aw8697_haptic/Makefile b/drivers/input/misc/aw8697_haptic/Makefile
new file mode 100755
index 000000000000..b55833e62651
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/Makefile
@@ -0,0 +1,21 @@
+ifeq ($(CONFIG_MACH_XIAOMI_LMI),y)
+CDEFINES += -DUSE_CONT_F0_CALI
+KBUILD_CPPFLAGS += $(CDEFINES)
+else ifeq ($(CONFIG_MACH_XIAOMI_UMI),y)
+CDEFINES += -DSUPPORT_RELOAD_FW
+KBUILD_CPPFLAGS += $(CDEFINES)
+endif
+
+ifeq ($(CONFIG_MACH_XIAOMI_PSYCHE),y)
+CDEFINES += -DRETRY_F0_CHECK \
+            -DRTP_SET_GAIN
+KBUILD_CPPFLAGS += $(CDEFINES)
+endif
+
+obj-$(CONFIG_INPUT_AW8697_HAPTIC)	+= aw8697-haptic.o
+ifeq ($(CONFIG_INPUT_AW8697_HAPTIC_DAGU),y)
+aw8697-haptic-objs = aw8697_dagu.o
+else
+aw8697-haptic-objs = aw8697.o
+endif
+aw8697-haptic-objs += ringbuffer.o
diff --git a/drivers/input/misc/aw8697_haptic/aw8697.c b/drivers/input/misc/aw8697_haptic/aw8697.c
new file mode 100644
index 000000000000..30013a4d4534
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw8697.c
@@ -0,0 +1,6999 @@
+/*
+ * aw8697.c   aw8697 haptic module
+ *
+ * Version: v1.1.3
+ *
+ * Copyright (c) 2019 AWINIC Technology CO., LTD
+ *
+ *  Author: Nick Li <zhangzetao@awinic.com.cn>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#define DEBUG
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/vmalloc.h>
+#include <linux/pm_qos.h>
+#include <linux/string.h>
+#include "aw8697_config.h"
+#include "aw8697_reg.h"
+#include "aw869xx_reg.h"
+#include "aw8697.h"
+#include "ringbuffer.h"
+
+/******************************************************
+ *
+ * Marco
+ *
+ ******************************************************/
+#define AW8697_I2C_NAME "aw8697_haptic"
+#define AW8697_HAPTIC_NAME "aw8697_haptic"
+
+#define AW8697_VERSION "v1.1.3"
+
+#define AWINIC_RAM_UPDATE_DELAY
+
+#define AW_I2C_RETRIES 2
+#define AW_I2C_RETRY_DELAY 2
+#define AW_READ_CHIPID_RETRIES 5
+#define AW_READ_CHIPID_RETRY_DELAY 2
+
+#define AW8697_MAX_DSP_START_TRY_COUNT 10
+
+#define AW8697_MAX_FIRMWARE_LOAD_CNT 20
+
+#define AW8697_MAX_BST_VO 0x1f
+
+#define OSC_CALIBRATION_T_LENGTH 5100000
+#define PM_QOS_VALUE_VB 400
+struct pm_qos_request pm_qos_req_vb;
+/******************************************************
+ *
+ * variable
+ *
+ ******************************************************/
+#define AW8697_RTP_NAME_MAX 64
+static char *aw8697_ram_name = "aw8697_haptic.bin";
+#ifdef SUPPORT_RELOAD_FW
+static char *aw8697_ram_name_a = "aw8697_haptic_a.bin";
+static char aw8697_rtp_name_a[AW8697_RTP_NAME_MAX];
+#endif
+#ifdef TEST_RTP
+static char aw8697_rtp_name[][AW8697_RTP_NAME_MAX] = {
+	{ "aw8697_rtp_1.bin" },
+};
+#else
+static char aw8697_rtp_name[][AW8697_RTP_NAME_MAX] = {
+	{ "aw8697_rtp_1.bin" }, //10
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	//{"aw8697_rtp_1.bin"},
+	//{"aw8697_rtp_1.bin"},
+	{ "AcousticGuitar_RTP.bin" }, //21
+	{ "Blues_RTP.bin" },
+	{ "Candy_RTP.bin" },
+	{ "Carousel_RTP.bin" },
+	{ "Celesta_RTP.bin" },
+	{ "Childhood_RTP.bin" },
+	{ "Country_RTP.bin" },
+	{ "Cowboy_RTP.bin" },
+	{ "Echo_RTP.bin" },
+	{ "Fairyland_RTP.bin" },
+	{ "Fantasy_RTP.bin" },
+	{ "Field_Trip_RTP.bin" },
+	{ "Glee_RTP.bin" },
+	{ "Glockenspiel_RTP.bin" },
+	{ "Ice_Latte_RTP.bin" },
+	{ "Kung_Fu_RTP.bin" },
+	{ "Leisure_RTP.bin" },
+	{ "Lollipop_RTP.bin" },
+	{ "MiMix2_RTP.bin" },
+	{ "Mi_RTP.bin" },
+	{ "MiHouse_RTP.bin" },
+	{ "MiJazz_RTP.bin" },
+	{ "MiRemix_RTP.bin" },
+	{ "Mountain_Spring_RTP.bin" },
+	{ "Orange_RTP.bin" },
+	{ "WindChime_RTP.bin" },
+	{ "Space_Age_RTP.bin" },
+	{ "ToyRobot_RTP.bin" },
+	{ "Vigor_RTP.bin" },
+	{ "Bottle_RTP.bin" },
+	{ "Bubble_RTP.bin" },
+	{ "Bullfrog_RTP.bin" },
+	{ "Burst_RTP.bin" },
+	{ "Chirp_RTP.bin" },
+	{ "Clank_RTP.bin" },
+	{ "Crystal_RTP.bin" },
+	{ "FadeIn_RTP.bin" },
+	{ "FadeOut_RTP.bin" },
+	{ "Flute_RTP.bin" },
+	{ "Fresh_RTP.bin" },
+	{ "Frog_RTP.bin" },
+	{ "Guitar_RTP.bin" },
+	{ "Harp_RTP.bin" },
+	{ "IncomingMessage_RTP.bin" },
+	{ "MessageSent_RTP.bin" },
+	{ "Moment_RTP.bin" },
+	{ "NotificationXylophone_RTP.bin" },
+	{ "Potion_RTP.bin" },
+	{ "Radar_RTP.bin" },
+	{ "Spring_RTP.bin" },
+	{ "Swoosh_RTP.bin" }, //71
+	{ "Gesture_UpSlide_RTP.bin" },
+	{ "FOD_Motion_Planet_RTP.bin" },
+	{ "Charge_Wire_RTP.bin" },
+	{ "Charge_Wireless_RTP.bin" },
+	{ "Unlock_Failed_RTP.bin" },
+	{ "FOD_Motion1_RTP.bin" },
+	{ "FOD_Motion2_RTP.bin" },
+	{ "FOD_Motion3_RTP.bin" },
+	{ "FOD_Motion4_RTP.bin" },
+	{ "FOD_Motion_Aurora_RTP.bin" },
+	{ "FaceID_Wrong2_RTP.bin" }, //82
+	{ "uninstall_animation_rtp.bin" },
+	{ "uninstall_dialog_rtp.bin" },
+	{ "screenshot_rtp.bin" },
+	{ "lockscreen_camera_entry_rtp.bin" },
+	{ "launcher_edit_rtp.bin" },
+	{ "launcher_icon_selection_rtp.bin" },
+	{ "taskcard_remove_rtp.bin" },
+	{ "task_cleanall_rtp.bin" },
+	{ "new_iconfolder_rtp.bin" },
+	{ "notification_remove_rtp.bin" },
+	{ "notification_cleanall_rtp.bin" },
+	{ "notification_setting_rtp.bin" },
+	{ "game_turbo_rtp.bin" },
+	{ "NFC_card_rtp.bin" },
+	{ "wakeup_voice_assistant_rtp.bin" },
+	{ "NFC_card_slow_rtp.bin" },
+	{ "aw8697_rtp_1.bin" }, //99
+	{ "aw8697_rtp_1.bin" }, //100
+	{ "offline_countdown_RTP.bin" },
+	{ "scene_bomb_injury_RTP.bin" },
+	{ "scene_bomb_RTP.bin" }, //103
+	{ "door_open_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_step_RTP.bin" }, //106
+	{ "crawl_RTP.bin" },
+	{ "scope_on_RTP.bin" },
+	{ "scope_off_RTP.bin" },
+	{ "magazine_quick_RTP.bin" },
+	{ "grenade_RTP.bin" },
+	{ "scene_getshot_RTP.bin" }, //112
+	{ "grenade_explosion_RTP.bin" },
+	{ "punch_RTP.bin" },
+	{ "pan_RTP.bin" },
+	{ "bandage_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_jump_RTP.bin" },
+	{ "vehicle_plane_RTP.bin" }, //119
+	{ "scene_openparachute_RTP.bin" }, //120
+	{ "scene_closeparachute_RTP.bin" }, //121
+	{ "vehicle_collision_RTP.bin" },
+	{ "vehicle_buggy_RTP.bin" }, //123
+	{ "vehicle_dacia_RTP.bin" }, //124
+	{ "vehicle_moto_RTP.bin" }, //125
+	{ "firearms_akm_RTP.bin" }, //126
+	{ "firearms_m16a4_RTP.bin" }, //127
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_awm_RTP.bin" }, //129
+	{ "firearms_mini14_RTP.bin" }, //130
+	{ "firearms_vss_RTP.bin" }, //131
+	{ "firearms_qbz_RTP.bin" }, //132
+	{ "firearms_ump9_RTP.bin" }, //133
+	{ "firearms_dp28_RTP.bin" }, //134
+	{ "firearms_s1897_RTP.bin" }, //135
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_p18c_RTP.bin" }, //137
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "CFM_KillOne_RTP.bin" },
+	{ "CFM_Headshot_RTP.bin" }, //141
+	{ "CFM_MultiKill_RTP.bin" },
+	{ "CFM_KillOne_Strong_RTP.bin" },
+	{ "CFM_Headshot_Strong_RTP.bin" },
+	{ "CFM_MultiKill_Strong_RTP.bin" },
+	{ "CFM_Weapon_Grenade_Explode_RTP.bin" },
+	{ "CFM_Weapon_Grenade_KillOne_RTP.bin" },
+	{ "CFM_ImpactFlesh_Normal_RTP.bin" },
+	{ "CFM_Weapon_C4_Installed_RTP.bin" },
+	{ "CFM_Hero_Appear_RTP.bin" },
+	{ "CFM_UI_Reward_OpenBox_RTP.bin" },
+	{ "CFM_UI_Reward_Task_RTP.bin" },
+	{ "CFM_Weapon_BLT_Shoot_RTP.bin" }, //153
+	{ "Atlantis_RTP.bin" },
+	{ "DigitalUniverse_RTP.bin" },
+	{ "Reveries_RTP.bin" },
+	{ "FOD_Motion_Triang_RTP.bin" },
+	{ "FOD_Motion_Flare_RTP.bin" },
+	{ "FOD_Motion_Ripple_RTP.bin" },
+	{ "FOD_Motion_Spiral_RTP.bin" },
+	{ "gamebox_launch_rtp.bin" }, // 161
+	{ "Gesture_Back_Pull_RTP.bin" }, // 162
+	{ "Gesture_Back_Release_RTP.bin" }, // 163
+	{ "alert_rtp.bin" }, // 164
+	{ "feedback_negative_light_rtp.bin" }, // 165
+	{ "feedback_neutral_rtp.bin" }, // 166
+	{ "feedback_positive_rtp.bin" }, // 167
+	{ "fingerprint_record_rtp.bin" }, // 168
+	{ "lockdown_rtp.bin" }, // 169
+	{ "sliding_damping_rtp.bin" }, // 170
+	{ "todo_alldone_rtp.bin" }, // 171
+	{ "uninstall_animation_icon_rtp.bin" }, // 172
+	{ "signal_button_highlight_rtp.bin" }, //173
+	{ "signal_button_negative_rtp.bin" },
+	{ "signal_button_rtp.bin" },
+	{ "signal_clock_high_rtp.bin" }, //176
+	{ "signal_clock_rtp.bin" },
+	{ "signal_clock_unit_rtp.bin" },
+	{ "signal_inputbox_rtp.bin" },
+	{ "signal_key_high_rtp.bin" },
+	{ "signal_key_unit_rtp.bin" }, //181
+	{ "signal_list_highlight_rtp.bin" },
+	{ "signal_list_rtp.bin" },
+	{ "signal_picker_rtp.bin" },
+	{ "signal_popup_rtp.bin" },
+	{ "signal_seekbar_rtp.bin" }, //186
+	{ "signal_switch_rtp.bin" },
+	{ "signal_tab_rtp.bin" },
+	{ "signal_text_rtp.bin" },
+	{ "signal_transition_light_rtp.bin" },
+	{ "signal_transition_rtp.bin" }, //191
+	{ "haptics_video_rtp.bin" }, //192
+};
+#endif
+static int CUSTOME_WAVE_ID;
+struct aw8697_container *aw8697_rtp;
+struct aw8697 *g_aw8697;
+
+/******************************************************
+ *
+ * functions
+ *
+ ******************************************************/
+static void aw8697_interrupt_clear(struct aw8697 *aw8697);
+static int aw8697_haptic_trig_enable_config(struct aw8697 *aw8697);
+static int aw8697_haptic_stop(struct aw8697 *aw8697);
+static unsigned char aw8697_haptic_osc_read_int(struct aw8697 *aw8697);
+/******************************************************
+ *
+ * aw8697 i2c write/read
+ *
+ ******************************************************/
+static int aw8697_i2c_write(struct aw8697 *aw8697, unsigned char reg_addr,
+			    unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw8697->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			pr_err("%s: i2c_write cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw8697_i2c_read(struct aw8697 *aw8697, unsigned char reg_addr,
+			   unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw8697->i2c, reg_addr);
+		if (ret < 0) {
+			pr_err("%s: i2c_read cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw8697_i2c_write_bits(struct aw8697 *aw8697, unsigned char reg_addr,
+				 unsigned int mask, unsigned char reg_data)
+{
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, reg_addr, &reg_val);
+	reg_val &= mask;
+	reg_val |= reg_data;
+	aw8697_i2c_write(aw8697, reg_addr, reg_val);
+
+	return 0;
+}
+
+static int aw8697_i2c_writes(struct aw8697 *aw8697, unsigned char reg_addr,
+			     unsigned char *buf, unsigned int len)
+{
+	int ret = -1;
+	unsigned char *data;
+
+	data = kmalloc(len + 1, GFP_KERNEL);
+	if (data == NULL) {
+		pr_err("%s: can not allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	data[0] = reg_addr;
+	memcpy(&data[1], buf, len);
+
+	ret = i2c_master_send(aw8697->i2c, data, len + 1);
+	if (ret < 0) {
+		pr_err("%s: i2c master send error\n", __func__);
+	}
+
+	kfree(data);
+
+	return ret;
+}
+
+static void aw8697_haptic_raminit(struct aw8697 *aw8697, bool flag)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		if (flag) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_RAMINIT_MASK,
+					      AW8697_BIT_SYSCTRL_RAMINIT_EN);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_RAMINIT_MASK,
+					      AW8697_BIT_SYSCTRL_RAMINIT_OFF);
+		}
+	} else {
+		if (flag) {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL1,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_MASK,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_ON);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL1,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_MASK,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_OFF);
+		}
+	}
+}
+
+static int aw8697_haptic_get_lra_resistance(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+			      AW8697_BIT_ANACTRL_HD_PD_MASK,
+			      AW8697_BIT_ANACTRL_HD_HZ_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_D2SCFG,
+			      AW8697_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW8697_BIT_D2SCFG_CLK_ASC_1P5MHZ);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_RL_OS_MASK,
+			      AW8697_BIT_DETCTRL_RL_DETECT);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_DIAG_GO_MASK,
+			      AW8697_BIT_DETCTRL_DIAG_GO_ENABLE);
+	msleep(3);
+	aw8697_i2c_read(aw8697, AW8697_REG_RLDET, &reg_val);
+	aw8697->lra = 298 * reg_val;
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+			      AW8697_BIT_ANACTRL_HD_PD_MASK,
+			      AW8697_BIT_ANACTRL_HD_PD_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_D2SCFG,
+			      AW8697_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW8697_BIT_D2SCFG_CLK_ASC_6MHZ);
+
+	aw8697_haptic_raminit(aw8697, false);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static int aw869xx_haptic_get_lra_resistance(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned char d2s_gain_temp = 0;
+	unsigned int lra_code = 0;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSCTRL7, &reg_val);
+	d2s_gain_temp = 0x07 & reg_val;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      aw8697->info.d2s_gain);
+	aw8697_haptic_raminit(aw8697, true);
+	/* enter standby mode */
+	aw8697_haptic_stop(aw8697);
+	usleep_range(2000, 2500);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL2,
+			      AW869XX_BIT_SYSCTRL2_STANDBY_MASK,
+			      AW869XX_BIT_SYSCTRL2_STANDBY_OFF);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG1,
+			      AW869XX_BIT_DETCFG1_RL_OS_MASK,
+			      AW869XX_BIT_DETCFG1_RL);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+			      AW869XX_BIT_DETCFG2_DIAG_GO_MASK,
+			      AW869XX_BIT_DETCFG2_DIAG_GO_ON);
+	usleep_range(30000, 35000);
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_RL, &reg_val);
+	lra_code = (lra_code | reg_val) << 2;
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_LO, &reg_val);
+	lra_code = lra_code | (reg_val & 0x03);
+	/* 2num */
+	aw8697->lra = (lra_code * 678 * 1000) / (1024 * 10);
+	aw8697_haptic_raminit(aw8697, false);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      d2s_gain_temp);
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static void aw869xx_haptic_misc_para_init(struct aw8697 *aw8697)
+{
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG1, aw8697->info.bstcfg[0]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG2, aw8697->info.bstcfg[1]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG3, aw8697->info.bstcfg[2]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG4, aw8697->info.bstcfg[3]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG5, aw8697->info.bstcfg[4]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL3,
+			 aw8697->info.sine_array[0]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL4,
+			 aw8697->info.sine_array[1]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL5,
+			 aw8697->info.sine_array[2]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL6,
+			 aw8697->info.sine_array[3]);
+
+	/* enable auto break */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK,
+			      AW869XX_BIT_PLAYCFG3_BRK_ENABLE);
+	/* d2s_gain */
+
+	if (!aw8697->info.d2s_gain)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.d2s_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      aw8697->info.d2s_gain);
+
+	/* cont_tset */
+	if (!aw8697->info.cont_tset)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_tset = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG13,
+			      AW869XX_BIT_CONTCFG13_TSET_MASK,
+			      aw8697->info.cont_tset << 4);
+
+	/* cont_bemf_set */
+	if (!aw8697->info.cont_bemf_set)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_bemf_set = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG13,
+			      AW869XX_BIT_CONTCFG13_BEME_SET_MASK,
+			      aw8697->info.cont_bemf_set);
+
+	/* cont_brk_time */
+	if (!aw8697->info.cont_brk_time)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_brk_time = 0!\n",
+			   __func__);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG10,
+			 aw8697->info.cont_brk_time);
+
+	/* cont_bst_brk_gain */
+	if (!aw8697->info.cont_bst_brk_gain)
+		aw_dev_err(aw8697->dev,
+			   "%s aw8697->info.cont_bst_brk_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG5,
+			      AW869XX_BIT_CONTCFG5_BST_BRK_GAIN_MASK,
+			      aw8697->info.cont_bst_brk_gain);
+
+	/* cont_brk_gain */
+	if (!aw8697->info.cont_brk_gain)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_brk_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG5,
+			      AW869XX_BIT_CONTCFG5_BRK_GAIN_MASK,
+			      aw8697->info.cont_brk_gain);
+}
+
+/*****************************************************
+ *
+ * ram update
+ *
+ *****************************************************/
+static void aw8697_rtp_loaded(const struct firmware *cont, void *context)
+{
+	struct aw8697 *aw8697 = context;
+	pr_info("%s enter\n", __func__);
+
+	if (!cont) {
+		pr_err("%s: failed to read %s\n", __func__,
+		       aw8697_rtp_name[aw8697->rtp_file_num]);
+		release_firmware(cont);
+		return;
+	}
+
+	pr_info("%s: loaded %s - size: %zu\n", __func__,
+		aw8697_rtp_name[aw8697->rtp_file_num], cont ? cont->size : 0);
+
+	/* aw8697 rtp update */
+	aw8697_rtp = vmalloc(cont->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(cont);
+		pr_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw8697_rtp->len = cont->size;
+	pr_info("%s: rtp size = %d\n", __func__, aw8697_rtp->len);
+	memcpy(aw8697_rtp->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	aw8697->rtp_init = 1;
+	pr_info("%s: rtp update complete\n", __func__);
+}
+
+static int aw8697_rtp_update(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       aw8697_rtp_name[aw8697->rtp_file_num],
+				       aw8697->dev, GFP_KERNEL, aw8697,
+				       aw8697_rtp_loaded);
+}
+
+static void aw8697_container_update(struct aw8697 *aw8697,
+				    struct aw8697_container *aw8697_cont)
+{
+	int i = 0;
+	unsigned int shift = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	mutex_lock(&aw8697->lock);
+
+	aw8697->ram.baseaddr_shift = 2;
+	aw8697->ram.ram_shift = 4;
+
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+
+	/* base addr */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697->ram.base_addr =
+		(unsigned int)((aw8697_cont->data[0 + shift] << 8) |
+			       (aw8697_cont->data[1 + shift]));
+	pr_info("%s: base_addr=0x%4x\n", __func__, aw8697->ram.base_addr);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_BASE_ADDRH,
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW8697_REG_BASE_ADDRL,
+			 aw8697_cont->data[1 + shift]);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AEH,
+			 (unsigned char)((aw8697->ram.base_addr >> 2) >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AEL,
+			 (unsigned char)((aw8697->ram.base_addr >> 2) &
+					 0x00FF));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AFH,
+			 (unsigned char)((aw8697->ram.base_addr -
+					  (aw8697->ram.base_addr >> 2)) >>
+					 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AFL,
+			 (unsigned char)((aw8697->ram.base_addr -
+					  (aw8697->ram.base_addr >> 2)) &
+					 0x00FF));
+
+	/* ram */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRH,
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRL,
+			 aw8697_cont->data[1 + shift]);
+	shift = aw8697->ram.ram_shift;
+	for (i = shift; i < aw8697_cont->len; i++) {
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMDATA,
+				 aw8697_cont->data[i]);
+	}
+
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+
+	mutex_unlock(&aw8697->lock);
+
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+}
+
+static void aw869xx_container_update(struct aw8697 *aw8697,
+				     struct aw8697_container *aw8697_cont)
+{
+	int i = 0;
+	unsigned int shift = 0;
+	unsigned char reg_val = 0;
+	unsigned int temp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	mutex_lock(&aw8697->lock);
+	aw8697->ram.baseaddr_shift = 2;
+	aw8697->ram.ram_shift = 4;
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+	/* Enter standby mode */
+	aw8697_haptic_stop(aw8697);
+	/* base addr */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697->ram.base_addr =
+		(unsigned int)((aw8697_cont->data[0 + shift] << 8) |
+			       (aw8697_cont->data[1 + shift]));
+	aw_dev_info(aw8697->dev, "%s: base_addr = %d\n", __func__,
+		    aw8697->ram.base_addr);
+
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG1, /*ADDRH*/
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG2, /*ADDRL*/
+			 aw8697_cont->data[1 + shift]);
+	/* FIFO_AEH */
+	aw8697_i2c_write_bits(
+		aw8697, AW869XX_REG_RTPCFG3, AW869XX_BIT_RTPCFG3_FIFO_AEH_MASK,
+		(unsigned char)(((aw8697->ram.base_addr >> 1) >> 4) & 0xF0));
+	/* FIFO AEL */
+	aw8697_i2c_write(
+		aw8697, AW869XX_REG_RTPCFG4,
+		(unsigned char)(((aw8697->ram.base_addr >> 1) & 0x00FF)));
+	/* FIFO_AFH */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_RTPCFG3,
+			      AW869XX_BIT_RTPCFG3_FIFO_AFH_MASK,
+			      (unsigned char)(((aw8697->ram.base_addr -
+						(aw8697->ram.base_addr >> 2)) >>
+					       8) &
+					      0x0F));
+	/* FIFO_AFL */
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG5,
+			 (unsigned char)(((aw8697->ram.base_addr -
+					   (aw8697->ram.base_addr >> 2)) &
+					  0x00FF)));
+	/*
+*	unsigned int temp
+*	HIGH<byte4 byte3 byte2 byte1>LOW
+*	|_ _ _ _AF-12BIT_ _ _ _AE-12BIT|
+*/
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG3, &reg_val);
+	temp = ((reg_val & 0x0f) << 24) | ((reg_val & 0xf0) << 4);
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG4, &reg_val);
+	temp = temp | reg_val;
+	aw_dev_info(aw8697->dev, "%s: almost_empty_threshold = %d\n", __func__,
+		    (unsigned short)temp);
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG5, &reg_val);
+	temp = temp | (reg_val << 16);
+	aw_dev_info(aw8697->dev, "%s: almost_full_threshold = %d\n", __func__,
+		    temp >> 16);
+	/* ram */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_RAMADDRH,
+			      AW869XX_BIT_RAMADDRH_MASK,
+			      aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_RAMADDRL,
+			 aw8697_cont->data[1 + shift]);
+	shift = aw8697->ram.ram_shift;
+	for (i = shift; i < aw8697_cont->len; i++) {
+		aw8697_i2c_write(aw8697, AW869XX_REG_RAMDATA,
+				 aw8697_cont->data[i]);
+	}
+
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+	mutex_unlock(&aw8697->lock);
+
+	pr_info("%s exit\n", __func__);
+}
+
+static void aw8697_ram_loaded(const struct firmware *cont, void *context)
+{
+	struct aw8697 *aw8697 = context;
+	struct aw8697_container *aw8697_fw;
+	int i = 0;
+	unsigned short check_sum = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	if (!cont) {
+		pr_err("%s: failed to read %s\n", __func__, aw8697->ram_name);
+		release_firmware(cont);
+		return;
+	}
+
+	pr_info("%s: loaded %s - size: %zu\n", __func__, aw8697->ram_name,
+		cont ? cont->size : 0);
+	/*
+	for(i=0; i<cont->size; i++) {
+		pr_info("%s: addr:0x%04x, data:0x%02x\n", __func__, i, *(cont->data+i));
+	}
+	*/
+	pr_info("%s: loaded %s - size: %zu bytes\n", __func__, aw8697->ram_name,
+		cont ? cont->size : 0);
+	/* check sum */
+	for (i = 2; i < cont->size; i++) {
+		check_sum += cont->data[i];
+	}
+	if (check_sum !=
+	    (unsigned short)((cont->data[0] << 8) | (cont->data[1]))) {
+		pr_err("%s: check sum err: check_sum=0x%04x\n", __func__,
+		       check_sum);
+		return;
+	} else {
+		pr_info("%s: check sum pass : 0x%04x\n", __func__, check_sum);
+		aw8697->ram.check_sum = check_sum;
+	}
+
+	/* aw8697 ram update */
+	aw8697_fw = kzalloc(cont->size + sizeof(int), GFP_KERNEL);
+	if (!aw8697_fw) {
+		release_firmware(cont);
+		pr_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw8697_fw->len = cont->size;
+	memcpy(aw8697_fw->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_container_update(aw8697, aw8697_fw);
+	} else {
+		aw869xx_container_update(aw8697, aw8697_fw);
+	}
+
+	aw8697->ram.len = aw8697_fw->len;
+
+	kfree(aw8697_fw);
+
+	aw8697->ram_init = 1;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_trig_enable_config(aw8697);
+		aw8697_rtp_update(aw8697);
+	}
+	pr_info("%s: fw update complete\n", __func__);
+}
+
+static int aw8697_ram_update(struct aw8697 *aw8697)
+{
+	aw8697->ram_init = 0;
+	aw8697->rtp_init = 0;
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       aw8697->ram_name, aw8697->dev,
+				       GFP_KERNEL, aw8697, aw8697_ram_loaded);
+}
+
+#ifdef AWINIC_RAM_UPDATE_DELAY
+static void aw8697_ram_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, ram_work.work);
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697_ram_update(aw8697);
+}
+#endif
+
+static int aw8697_ram_init(struct aw8697 *aw8697)
+{
+#ifdef AWINIC_RAM_UPDATE_DELAY
+	int ram_timer_val = 5000;
+	aw8697->ram_name = aw8697_ram_name;
+	INIT_DELAYED_WORK(&aw8697->ram_work, aw8697_ram_work_routine);
+	//schedule_delayed_work(&aw8697->ram_work,
+	//msecs_to_jiffies(ram_timer_val));
+	queue_delayed_work(aw8697->work_queue, &aw8697->ram_work,
+			   msecs_to_jiffies(ram_timer_val));
+#else
+	aw8697->ram_name = aw8697_ram_name;
+	aw8697_ram_update(aw8697);
+#endif
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic control
+ *
+ *****************************************************/
+static int aw8697_haptic_softreset(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_ID, 0xAA);
+	usleep_range(3000, 3500);
+	return 0;
+}
+
+static int aw8697_haptic_active(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_WORK_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_ACTIVE);
+	aw8697_interrupt_clear(aw8697);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_UVLO_MASK,
+			      AW8697_BIT_SYSINTM_UVLO_EN);
+	return 0;
+}
+
+static int aw8697_haptic_play_mode(struct aw8697 *aw8697,
+				   unsigned char play_mode)
+{
+	pr_debug("%s enter\n", __func__);
+
+	switch (play_mode) {
+	case AW8697_HAPTIC_STANDBY_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter standby mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_STANDBY_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_UVLO_MASK,
+					      AW8697_BIT_SYSINTM_UVLO_OFF);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_WORK_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_STANDBY);
+		} else {
+			aw8697_haptic_stop(aw8697);
+		}
+		break;
+	case AW8697_HAPTIC_RAM_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter ram mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RAM_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+			/* bst mode */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BOOST);
+		}
+
+		break;
+	case AW8697_HAPTIC_RAM_LOOP_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter ram loop mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RAM_LOOP_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		}
+
+		break;
+	case AW8697_HAPTIC_RTP_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter rtp mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RTP_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RTP);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RTP);
+			/* bst mode config */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BOOST);
+		}
+		break;
+	case AW8697_HAPTIC_TRIG_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter trig mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_TRIG_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		}
+
+		break;
+	case AW8697_HAPTIC_CONT_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter cont mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_CONT_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+				AW8697_BIT_SYSCTRL_PLAY_MODE_CONT);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+			aw8697_haptic_active(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_CONT);
+			/* bst mode */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		}
+
+		break;
+	default:
+		dev_err(aw8697->dev, "%s: play mode %d err", __func__,
+			play_mode);
+		break;
+	}
+	return 0;
+}
+
+static int aw8697_haptic_play_go(struct aw8697 *aw8697, bool flag)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		if (flag == true) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_GO,
+					      AW8697_BIT_GO_MASK,
+					      AW8697_BIT_GO_ENABLE);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_GO,
+					      AW8697_BIT_GO_MASK,
+					      AW8697_BIT_GO_DISABLE);
+		}
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG4,
+				 AW869XX_BIT_PLAYCFG4_GO_ON);
+	}
+	return 0;
+}
+
+static int aw8697_haptic_stop_delay(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int cnt = 100;
+
+	while (cnt--) {
+		aw8697_i2c_read(aw8697, AW8697_REG_GLB_STATE, &reg_val);
+		if ((reg_val & 0x0f) == 0x00) {
+			return 0;
+		}
+		msleep(2);
+		pr_debug("%s wait for standby, reg glb_state=0x%02x\n",
+			 __func__, reg_val);
+	}
+	pr_err("%s do not enter standby automatically\n", __func__);
+
+	return 0;
+}
+
+static int aw8697_haptic_stop(struct aw8697 *aw8697)
+{
+	unsigned char cnt = 40;
+	unsigned char reg_val = 0;
+	bool force_flag = true;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_play_go(aw8697, false);
+		aw8697_haptic_stop_delay(aw8697);
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	} else {
+		aw8697->play_mode = AW8697_HAPTIC_STANDBY_MODE;
+		aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == AW869XX_BIT_GLBRD5_STATE_STANDBY ||
+		    (reg_val & 0x0f) == AW869XX_BIT_GLBRD5_STATE_I2S_GO) {
+			force_flag = false;
+			aw_dev_info(
+				aw8697->dev,
+				"%s already in standby mode! glb_state=0x%02X\n",
+				__func__, reg_val);
+		} else {
+			aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG4,
+					 AW869XX_BIT_PLAYCFG4_STOP_ON);
+			while (cnt) {
+				aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+						&reg_val);
+				if ((reg_val & 0x0f) ==
+					    AW869XX_BIT_GLBRD5_STATE_STANDBY ||
+				    (reg_val & 0x0f) ==
+					    AW869XX_BIT_GLBRD5_STATE_I2S_GO) {
+					cnt = 0;
+					force_flag = false;
+					aw_dev_info(
+						aw8697->dev,
+						"%s entered standby! glb_state=0x%02X\n",
+						__func__, reg_val);
+				} else {
+					cnt--;
+					aw_dev_info(
+						aw8697->dev,
+						"%s wait for standby, glb_state=0x%02X\n",
+						__func__, reg_val);
+				}
+				usleep_range(2000, 2500);
+			}
+		}
+		if (force_flag) {
+			aw_dev_err(aw8697->dev,
+				   "%s force to enter standby mode!\n",
+				   __func__);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL2,
+					      AW869XX_BIT_SYSCTRL2_STANDBY_MASK,
+					      AW869XX_BIT_SYSCTRL2_STANDBY_ON);
+		}
+	}
+	return 0;
+}
+
+static int aw8697_haptic_start(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_haptic_play_go(aw8697, true);
+
+	return 0;
+}
+
+static int aw8697_haptic_set_wav_seq(struct aw8697 *aw8697, unsigned char wav,
+				     unsigned char seq)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_WAVSEQ1 + wav, seq);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_WAVCFG1 + wav, seq);
+	}
+	return 0;
+}
+
+static int aw8697_haptic_set_wav_loop(struct aw8697 *aw8697, unsigned char wav,
+				      unsigned char loop)
+{
+	unsigned char tmp = 0;
+
+	if (wav % 2) {
+		tmp = loop << 0;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697,
+					      AW8697_REG_WAVLOOP1 + (wav / 2),
+					      AW8697_BIT_WAVLOOP_SEQNP1_MASK,
+					      tmp);
+		} else {
+			aw8697_i2c_write_bits(aw8697,
+					      AW869XX_REG_WAVCFG9 + (wav / 2),
+					      AW869XX_BIT_WAVLOOP_SEQ_EVEN_MASK,
+					      tmp);
+		}
+	} else {
+		tmp = loop << 4;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697,
+					      AW8697_REG_WAVLOOP1 + (wav / 2),
+					      AW8697_BIT_WAVLOOP_SEQN_MASK,
+					      tmp);
+		} else {
+			aw8697_i2c_write_bits(aw8697,
+					      AW869XX_REG_WAVCFG9 + (wav / 2),
+					      AW869XX_BIT_WAVLOOP_SEQ_ODD_MASK,
+					      tmp);
+		}
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_set_repeat_wav_seq(struct aw8697 *aw8697,
+					    unsigned char seq)
+{
+	aw8697_haptic_set_wav_seq(aw8697, 0x00, seq);
+	aw8697_haptic_set_wav_loop(aw8697, 0x00,
+				   AW8697_BIT_WAVLOOP_INIFINITELY);
+
+	return 0;
+}
+
+static int aw8697_haptic_set_bst_vol(struct aw8697 *aw8697,
+				     unsigned char bst_vol)
+{
+	if (bst_vol & 0xe0) {
+		bst_vol = 0x1f;
+	}
+	//printk("%s %d --\n", __func__, __LINE__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_BSTDBG4,
+				      AW8697_BIT_BSTDBG4_BSTVOL_MASK,
+				      (bst_vol << 1));
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG1,
+				      AW869XX_BIT_PLAYCFG1_BST_VOUT_RDA_MASK,
+				      (bst_vol << 1));
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_set_bst_peak_cur(struct aw8697 *aw8697,
+					  unsigned char peak_cur)
+{
+	peak_cur &= AW8697_BSTCFG_PEAKCUR_LIMIT;
+	pr_info("%s  %d enter\n", __func__, __LINE__);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_BSTCFG,
+			      AW8697_BIT_BSTCFG_PEAKCUR_MASK, peak_cur);
+	return 0;
+}
+
+static int aw869xx_haptic_set_bst_peak_cur(struct aw8697 *aw8697)
+{
+	switch (aw8697->bst_pc) {
+	case AW869XX_HAPTIC_BST_PC_L1:
+		aw_dev_info(aw8697->dev, "%s bst pc = L1\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (0 << 1));
+		return 0;
+	case AW869XX_HAPTIC_BST_PC_L2:
+		aw_dev_info(aw8697->dev, "%s bst pc = L2\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (5 << 1));
+		return 0;
+	default:
+		aw_dev_info(aw8697->dev, "%s bst pc = L1\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (0 << 1));
+		break;
+	}
+	return 0;
+}
+static int aw8697_haptic_set_gain(struct aw8697 *aw8697, unsigned char gain)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_DATDBG, gain);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG2, gain);
+	}
+	return 0;
+}
+static int aw8697_haptic_set_pwm(struct aw8697 *aw8697, unsigned char mode)
+{
+	switch (mode) {
+	case AW8697_PWM_48K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_48K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_48K);
+		}
+
+		break;
+	case AW8697_PWM_24K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_24K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_24K);
+		}
+
+		break;
+	case AW8697_PWM_12K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_12K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_12K);
+		}
+
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int aw8697_haptic_play_repeat_seq(struct aw8697 *aw8697,
+					 unsigned char flag)
+{
+	pr_debug("%s enter\n", __func__);
+
+	if (flag) {
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_LOOP_MODE);
+		aw8697_haptic_start(aw8697);
+	}
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * motor protect
+ *
+ *****************************************************/
+static int aw8697_haptic_swicth_motorprotect_config(struct aw8697 *aw8697,
+						    unsigned char addr,
+						    unsigned char val)
+{
+	pr_info("%s enter\n", __func__);
+
+	if (addr == 1) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_DETCTRL,
+				AW8697_BIT_DETCTRL_PROTECT_MASK,
+				AW8697_BIT_DETCTRL_PROTECT_SHUTDOWN);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRC_MASK,
+					      AW8697_BIT_PWMPRC_PRC_ENABLE);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PR_MASK,
+					      AW8697_BIT_PRLVL_PR_ENABLE);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_DETCFG1,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_MASK,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_VALID);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRC_EN_MASK,
+					      AW869XX_BIT_PWMCFG1_PRC_ENABLE);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PR_EN_MASK,
+					      AW869XX_BIT_PWMCFG3_PR_ENABLE);
+		}
+
+	} else if (addr == 0) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_DETCTRL,
+				AW8697_BIT_DETCTRL_PROTECT_MASK,
+				AW8697_BIT_DETCTRL_PROTECT_NO_ACTION);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRC_MASK,
+					      AW8697_BIT_PWMPRC_PRC_DISABLE);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PR_MASK,
+					      AW8697_BIT_PRLVL_PR_DISABLE);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_DETCFG1,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_MASK,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_INVALID);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRC_EN_MASK,
+					      AW869XX_BIT_PWMCFG1_PRC_DISABLE);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PR_EN_MASK,
+					      AW869XX_BIT_PWMCFG3_PR_DISABLE);
+		}
+
+	} else if (addr == 0x2d) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRCTIME_MASK,
+					      val);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRCTIME_MASK,
+					      val);
+		}
+
+	} else if (addr == 0x3e) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PRLVL_MASK, val);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PRLVL_MASK,
+					      val);
+		}
+
+	} else if (addr == 0x3f) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRTIME,
+					      AW8697_BIT_PRTIME_PRTIME_MASK,
+					      val);
+		} else {
+			aw8697_i2c_write(aw8697, AW869XX_REG_PWMCFG4, val);
+		}
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * offset calibration
+ *
+ *****************************************************/
+static int aw8697_haptic_offset_calibration(struct aw8697 *aw8697)
+{
+	unsigned int cont = 2000;
+	unsigned char reg_val = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697_haptic_raminit(aw8697, true);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+				      AW8697_BIT_DETCTRL_DIAG_GO_MASK,
+				      AW8697_BIT_DETCTRL_DIAG_GO_ENABLE);
+		while (1) {
+			aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+			if ((reg_val & 0x01) == 0 || cont == 0)
+				break;
+			cont--;
+		}
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+				      AW869XX_BIT_DETCFG2_DIAG_GO_MASK,
+				      AW869XX_BIT_DETCFG2_DIAG_GO_ON);
+		while (1) {
+			aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG2, &reg_val);
+			if ((reg_val & AW869XX_BIT_DETCFG2_DIAG_GO_ON) == 0 ||
+			    cont == 0)
+				break;
+			cont--;
+		}
+	}
+	if (cont == 0)
+		aw_dev_err(aw8697->dev, "%s calibration offset failed!\n",
+			   __func__);
+	aw8697_haptic_raminit(aw8697, false);
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * trig config
+ *
+ *****************************************************/
+
+static int aw8697_haptic_trig_param_init(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	aw8697->trig[0].enable = aw8697->info.trig_config[0][0];
+	aw8697->trig[0].default_level = aw8697->info.trig_config[0][1];
+	aw8697->trig[0].dual_edge = aw8697->info.trig_config[0][2];
+	aw8697->trig[0].frist_seq = aw8697->info.trig_config[0][3];
+	aw8697->trig[0].second_seq = aw8697->info.trig_config[0][4];
+
+	aw8697->trig[1].enable = aw8697->info.trig_config[1][0];
+	;
+	aw8697->trig[1].default_level = aw8697->info.trig_config[1][1];
+	aw8697->trig[1].dual_edge = aw8697->info.trig_config[1][2];
+	aw8697->trig[1].frist_seq = aw8697->info.trig_config[1][3];
+	aw8697->trig[1].second_seq = aw8697->info.trig_config[1][4];
+
+	aw8697->trig[2].enable = aw8697->info.trig_config[2][0];
+	;
+	aw8697->trig[2].default_level = aw8697->info.trig_config[2][1];
+	aw8697->trig[2].dual_edge = aw8697->info.trig_config[2][2];
+	aw8697->trig[2].frist_seq = aw8697->info.trig_config[2][3];
+	aw8697->trig[2].second_seq = aw8697->info.trig_config[2][4];
+
+	return 0;
+}
+
+static int aw8697_haptic_trig_param_config(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	if (aw8697->trig[0].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_POS);
+	}
+	if (aw8697->trig[1].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_POS);
+	}
+	if (aw8697->trig[2].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_POS);
+	}
+
+	if (aw8697->trig[0].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_POS);
+	}
+	if (aw8697->trig[1].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_POS);
+	}
+	if (aw8697->trig[2].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_POS);
+	}
+
+	if (aw8697->trig[0].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG1_WAV_P,
+				 aw8697->trig[0].frist_seq);
+	}
+	if (aw8697->trig[0].second_seq && aw8697->trig[0].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG1_WAV_N,
+				 aw8697->trig[0].second_seq);
+	}
+	if (aw8697->trig[1].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG2_WAV_P,
+				 aw8697->trig[1].frist_seq);
+	}
+	if (aw8697->trig[1].second_seq && aw8697->trig[1].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG2_WAV_N,
+				 aw8697->trig[1].second_seq);
+	}
+	if (aw8697->trig[2].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG3_WAV_P,
+				 aw8697->trig[1].frist_seq);
+	}
+	if (aw8697->trig[2].second_seq && aw8697->trig[2].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG3_WAV_N,
+				 aw8697->trig[1].second_seq);
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_trig_enable_config(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG1_ENABLE_MASK,
+			      aw8697->trig[0].enable);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG2_ENABLE_MASK,
+			      aw8697->trig[1].enable);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG3_ENABLE_MASK,
+			      aw8697->trig[2].enable);
+
+	return 0;
+}
+
+static int aw8697_haptic_auto_boost_config(struct aw8697 *aw8697,
+					   unsigned char flag)
+{
+	aw8697->auto_boost = flag;
+	if (flag) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_BST_AUTO,
+				AW8697_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				AW8697_BIT_BST_AUTO_BST_AUTOMATIC_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_MASK,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_ENABLE);
+		}
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_BST_AUTO,
+				AW8697_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				AW8697_BIT_BST_AUTO_BST_MANUAL_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_MASK,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_DISABLE);
+		}
+	}
+	return 0;
+}
+/*****************************************************
+ *
+ * vbat mode
+ *
+ *****************************************************/
+static int aw8697_haptic_cont_vbat_mode(struct aw8697 *aw8697,
+					unsigned char flag)
+{
+	if (flag == AW8697_HAPTIC_CONT_VBAT_HW_COMP_MODE) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_ADCTEST,
+					      AW8697_BIT_ADCTEST_VBAT_MODE_MASK,
+					      AW8697_BIT_ADCTEST_VBAT_HW_COMP);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL1,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_HW);
+		}
+
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_ADCTEST,
+					      AW8697_BIT_ADCTEST_VBAT_MODE_MASK,
+					      AW8697_BIT_ADCTEST_VBAT_SW_COMP);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL1,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_SW);
+		}
+	}
+	return 0;
+}
+
+static int aw869xx_haptic_get_vbat(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int vbat_code = 0;
+	unsigned int cont = 2000;
+
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+			      AW869XX_BIT_DETCFG2_VBAT_GO_MASK,
+			      AW869XX_BIT_DETCFG2_VABT_GO_ON);
+
+	while (1) {
+		aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG2, &reg_val);
+		if ((reg_val & 0x02) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_VBAT, &reg_val);
+	vbat_code = (vbat_code | reg_val) << 2;
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_LO, &reg_val);
+	vbat_code = vbat_code | ((reg_val & 0x30) >> 4);
+	aw8697->vbat = 6100 * vbat_code / 1024;
+	if (aw8697->vbat > AW8697_VBAT_MAX) {
+		aw8697->vbat = AW8697_VBAT_MAX;
+		aw_dev_info(aw8697->dev, "%s vbat max limit = %dmV\n", __func__,
+			    aw8697->vbat);
+	}
+	if (aw8697->vbat < AW8697_VBAT_MIN) {
+		aw8697->vbat = AW8697_VBAT_MIN;
+		aw_dev_info(aw8697->dev, "%s vbat min limit = %dmV\n", __func__,
+			    aw8697->vbat);
+	}
+	aw_dev_info(aw8697->dev, "%s aw8697->vbat=%dmV, vbat_code=0x%02X\n",
+		    __func__, aw8697->vbat, vbat_code);
+	aw8697_haptic_raminit(aw8697, false);
+	return 0;
+}
+
+static int aw8697_haptic_get_vbat(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int cont = 2000;
+
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_VBAT_GO_MASK,
+			      AW8697_BIT_DETCTRL_VABT_GO_ENABLE);
+
+	while (1) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+		if ((reg_val & 0x02) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+
+	aw8697_i2c_read(aw8697, AW8697_REG_VBATDET, &reg_val);
+	aw8697->vbat = 6100 * reg_val / 256;
+	if (aw8697->vbat > AW8697_VBAT_MAX) {
+		aw8697->vbat = AW8697_VBAT_MAX;
+		pr_debug("%s vbat max limit = %dmV\n", __func__, aw8697->vbat);
+	}
+	if (aw8697->vbat < AW8697_VBAT_MIN) {
+		aw8697->vbat = AW8697_VBAT_MIN;
+		pr_debug("%s vbat min limit = %dmV\n", __func__, aw8697->vbat);
+	}
+
+	aw8697_haptic_raminit(aw8697, false);
+
+	return 0;
+}
+
+static int aw8697_haptic_ram_vbat_comp(struct aw8697 *aw8697, bool flag)
+{
+	int temp_gain = 0;
+	//pr_info("%s  %d enter\n", __func__, __LINE__);
+	if (flag) {
+		if (aw8697->ram_vbat_comp ==
+		    AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE) {
+			if (aw8697->chip_version == AW8697_CHIP_9X) {
+				aw8697_haptic_get_vbat(aw8697);
+			} else {
+				aw869xx_haptic_get_vbat(aw8697);
+			}
+			temp_gain =
+				aw8697->gain * AW8697_VBAT_REFER / aw8697->vbat;
+			if (temp_gain >
+			    (128 * AW8697_VBAT_REFER / AW8697_VBAT_MIN)) {
+				temp_gain = 128 * AW8697_VBAT_REFER /
+					    AW8697_VBAT_MIN;
+				pr_debug("%s gain limit=%d\n", __func__,
+					 temp_gain);
+			}
+			aw8697_haptic_set_gain(aw8697, temp_gain);
+		} else {
+			aw8697_haptic_set_gain(aw8697, aw8697->gain);
+		}
+	} else {
+		aw8697_haptic_set_gain(aw8697, aw8697->gain);
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * f0
+ *
+ *****************************************************/
+static int aw8697_haptic_set_f0_preset(struct aw8697 *aw8697)
+{
+	unsigned int f0_reg = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	f0_reg = 1000000000 / (aw8697->info.f0_pre * aw8697->info.f0_coeff);
+	aw8697_i2c_write(aw8697, AW8697_REG_F_PRE_H,
+			 (unsigned char)((f0_reg >> 8) & 0xff));
+	aw8697_i2c_write(aw8697, AW8697_REG_F_PRE_L,
+			 (unsigned char)((f0_reg >> 0) & 0xff));
+
+	return 0;
+}
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_F0_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_F0_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+#ifdef RETRY_F0_CHECK
+		aw8697->f0 = 0;
+#endif
+		aw8697->f0_cali_status = false;
+		return 0;
+	}
+	aw8697->f0_cali_status = true;
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->f0 = (unsigned int)f0_tmp;
+	pr_info("%s f0=%d\n", __func__, aw8697->f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_debug("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->cont_f0 = (unsigned int)f0_tmp;
+	pr_info("%s f0=%d\n", __func__, aw8697->cont_f0);
+
+	return 0;
+}
+#else
+static int aw8697_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_debug("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->cont_f0 = (unsigned int)f0_tmp;
+	aw8697->cont_f0 -= 12;
+	aw8697->f0 = aw8697->cont_f0;
+	pr_info("%s f0=%d\n", __func__, aw8697->cont_f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_beme(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	pr_info("%s  %d enter\n", __func__, __LINE__);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_WAIT_VOL_MP, &reg_val);
+	aw8697->max_pos_beme = (reg_val << 0);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_WAIT_VOL_MN, &reg_val);
+	aw8697->max_neg_beme = (reg_val << 0);
+
+	pr_info("%s max_pos_beme=%d\n", __func__, aw8697->max_pos_beme);
+	pr_info("%s max_neg_beme=%d\n", __func__, aw8697->max_neg_beme);
+
+	return 0;
+}
+#else
+static int aw8697_haptic_read_cont_bemf(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int bemf = 0;
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_BEMF_VOL_H, &reg_val);
+	bemf |= (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_BEMF_VOL_L, &reg_val);
+	bemf |= (reg_val << 0);
+
+	pr_info("%s bemf=%d\n", __func__, bemf);
+
+	return 0;
+}
+#endif
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static void aw8697_haptic_set_rtp_aei(struct aw8697 *aw8697, bool flag)
+{
+	if (flag) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_FF_AE_MASK,
+					      AW8697_BIT_SYSINTM_FF_AE_EN);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+					      AW869XX_BIT_SYSINTM_FF_AEM_MASK,
+					      AW869XX_BIT_SYSINTM_FF_AEM_ON);
+		}
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_FF_AE_MASK,
+					      AW8697_BIT_SYSINTM_FF_AE_OFF);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+					      AW869XX_BIT_SYSINTM_FF_AEM_MASK,
+					      AW869XX_BIT_SYSINTM_FF_AEM_OFF);
+		}
+	}
+}
+static unsigned char aw8697_haptic_rtp_get_fifo_afi(struct aw8697 *aw8697)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->osc_cali_flag == 1) {
+		aw8697_i2c_read(aw8697, AW8697_REG_SYSST, &reg_val);
+		reg_val &= AW8697_BIT_SYSST_FF_AFS;
+		ret = reg_val >> 3;
+	} else {
+		aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+		reg_val &= AW8697_BIT_SYSINT_FF_AFI;
+		ret = reg_val >> 3;
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static int aw8697_haptic_rtp_init(struct aw8697 *aw8697)
+{
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw8697->ram.base_addr >> 2;
+	bool rtp_start = true;
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	mutex_lock(&aw8697->rtp_lock);
+	aw8697->rtp_cnt = 0;
+	while ((!aw8697_haptic_rtp_get_fifo_afi(aw8697)) &&
+	       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		if (aw8697->is_custom_wave == 0) {
+			if (rtp_start) {
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    aw8697->ram.base_addr)
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				else
+					buf_len = (aw8697->ram.base_addr);
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				rtp_start = false;
+			} else {
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    (aw8697->ram.base_addr >> 2)) {
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				} else {
+					buf_len = (aw8697->ram.base_addr >> 2);
+				}
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+			}
+			aw8697->rtp_cnt += buf_len;
+			pr_info("%s update rtp_cnt = %d \n", __func__,
+				aw8697->rtp_cnt);
+			if (aw8697->rtp_cnt == aw8697_rtp->len) {
+				aw8697->rtp_cnt = 0;
+				aw8697_haptic_set_rtp_aei(aw8697, false);
+				mutex_unlock(&aw8697->rtp_lock);
+				pm_qos_remove_request(&pm_qos_req_vb);
+				return 0;
+			}
+		} else {
+			buf_len = read_rb(aw8697_rtp->data, period_size);
+			aw8697_i2c_writes(aw8697, AW8697_REG_RTP_DATA,
+					  aw8697_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				pr_info("%s: custom rtp update complete\n",
+					__func__);
+				aw8697->rtp_cnt = 0;
+				aw8697_haptic_set_rtp_aei(aw8697, false);
+				mutex_unlock(&aw8697->rtp_lock);
+				pm_qos_remove_request(&pm_qos_req_vb);
+				return 0;
+			}
+		}
+	}
+	if (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE &&
+	    !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw8697_haptic_set_rtp_aei(aw8697, true);
+	}
+	pr_info("%s: exit\n", __func__);
+	mutex_unlock(&aw8697->rtp_lock);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+static unsigned char aw869xx_haptic_rtp_get_fifo_afs(struct aw8697 *aw8697)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSST, &reg_val);
+	reg_val &= AW869XX_BIT_SYSST_FF_AFS;
+	ret = reg_val >> 3;
+	return ret;
+}
+
+static int aw869xx_haptic_rtp_init(struct aw8697 *aw8697)
+{
+	unsigned int buf_len = 0;
+	unsigned char glb_state_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	aw8697->rtp_cnt = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	while ((!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) &&
+	       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw_dev_info(aw8697->dev, "%s rtp cnt = %d\n", __func__,
+			    aw8697->rtp_cnt);
+		if (!aw8697_rtp) {
+			aw_dev_info(aw8697->dev,
+				    "%s:aw8697_rtp is null, break!\n",
+				    __func__);
+			break;
+		}
+		if (aw8697->rtp_cnt < (aw8697->ram.base_addr)) {
+			if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			    (aw8697->ram.base_addr)) {
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			} else {
+				buf_len = aw8697->ram.base_addr;
+			}
+		} else if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			   (aw8697->ram.base_addr >> 2)) {
+			buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+		} else {
+			buf_len = aw8697->ram.base_addr >> 2;
+		}
+		aw_dev_info(aw8697->dev, "%s buf_len = %d\n", __func__,
+			    buf_len);
+		aw8697_i2c_writes(aw8697, AW869XX_REG_RTPDATA,
+				  &aw8697_rtp->data[aw8697->rtp_cnt], buf_len);
+		aw8697->rtp_cnt += buf_len;
+		aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5, &glb_state_val);
+		if ((aw8697->rtp_cnt == aw8697_rtp->len) ||
+		    ((glb_state_val & 0x0f) == 0x00)) {
+			aw_dev_info(aw8697->dev, "%s: rtp update complete!\n",
+				    __func__);
+			aw8697->rtp_cnt = 0;
+			//pm_qos_remove_request(&pm_qos_req_vb);
+			//mutex_unlock(&aw8697->rtp_lock);
+			//return 0;
+			break;
+		}
+	}
+	mutex_unlock(&aw8697->rtp_lock);
+
+	if ((aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	    !atomic_read(&aw8697->exit_in_rtp_loop))
+		aw8697_haptic_set_rtp_aei(aw8697, true);
+
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+static int16_t aw8697_haptic_effect_strength(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+	pr_debug("%s: aw8697->play.vmax_mv =0x%x\n", __func__,
+		 aw8697->play.vmax_mv);
+#if 0
+	switch (aw8697->play.vmax_mv) {
+	case AW8697_LIGHT_MAGNITUDE:
+		aw8697->level = 0x80;
+		break;
+	case AW8697_MEDIUM_MAGNITUDE:
+		aw8697->level = 0x50;
+		break;
+	case AW8697_STRONG_MAGNITUDE:
+		aw8697->level = 0x30;
+		break;
+	default:
+		break;
+	}
+#else
+	if (aw8697->play.vmax_mv >= 0x7FFF)
+		aw8697->level = 0x80; /*128*/
+	else if (aw8697->play.vmax_mv <= 0x3FFF)
+		aw8697->level = 0x1E; /*30*/
+	else
+		aw8697->level = (aw8697->play.vmax_mv - 16383) / 128;
+	if (aw8697->level < 0x1E)
+		aw8697->level = 0x1E; /*30*/
+#endif
+
+	pr_info("%s: aw8697->level =0x%x\n", __func__, aw8697->level);
+	return 0;
+}
+
+static int aw8697_haptic_play_effect_seq(struct aw8697 *aw8697,
+					 unsigned char flag)
+{
+	if (aw8697->effect_id > aw8697->info.effect_id_boundary)
+		return 0;
+	//printk("%s:aw8697->effect_id =%d\n", __func__, aw8697->effect_id);
+	//printk("%s:aw8697->activate_mode =%d\n", __func__, aw8697->activate_mode);
+
+	if (flag) {
+		if (aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw8697_haptic_set_wav_seq(aw8697, 0x00,
+						  (char)aw8697->effect_id + 1);
+			aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+			aw8697_haptic_set_wav_loop(aw8697, 0x00, 0x00);
+			aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+			if (aw8697->info.bst_vol_ram <= AW8697_MAX_BST_VO)
+				aw8697_haptic_set_bst_vol(
+					aw8697, aw8697->info.bst_vol_ram);
+			else
+				aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+			aw8697_haptic_effect_strength(aw8697);
+			aw8697_haptic_set_gain(aw8697, aw8697->level);
+			aw8697_haptic_start(aw8697);
+		}
+		if (aw8697->activate_mode ==
+		    AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw8697_haptic_set_repeat_wav_seq(
+				aw8697, (aw8697->info.effect_id_boundary + 1));
+			aw8697_haptic_play_repeat_seq(aw8697, true);
+		}
+	}
+
+	return 0;
+}
+
+static void aw8697_haptic_upload_lra(struct aw8697 *aw8697, unsigned char flag)
+{
+	switch (flag) {
+	case WRITE_ZERO:
+		pr_info("%s write zero to trim_lra!\n", __func__);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK, 0x00);
+		}
+
+		break;
+	case F0_CALI:
+		pr_info("%s write f0_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw8697->f0_calib_data);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+					 (char)aw8697->f0_calib_data);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				(char)aw8697->f0_calib_data);
+		}
+		break;
+	case OSC_CALI:
+		pr_info("%s write lra_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw8697->lra_calib_data);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+					 (char)aw8697->lra_calib_data);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				(char)aw8697->lra_calib_data);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int aw8697_clock_OSC_trim_calibration(unsigned long int theory_time,
+					     unsigned long int real_time)
+{
+	unsigned int real_code = 0;
+	unsigned int LRA_TRIM_CODE = 0;
+	unsigned int DFT_LRA_TRIM_CODE = 0;
+	unsigned int Not_need_cali_threshold =
+		10; /*0.1 percent not need calibrate*/
+
+	if (theory_time == real_time) {
+		pr_info("aw_osctheory_time == real_time:%ld  theory_time = %ld not need to cali\n",
+			real_time, theory_time);
+		return 0;
+	} else if (theory_time < real_time) {
+		if ((real_time - theory_time) > (theory_time / 50)) {
+			pr_info("aw_osc(real_time - theory_time) > (theory_time/50) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		if ((real_time - theory_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			pr_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		real_code = ((real_time - theory_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 + real_code;
+	} else if (theory_time > real_time) {
+		if ((theory_time - real_time) > (theory_time / 50)) {
+			pr_info("aw_osc((theory_time - real_time) > (theory_time / 50)) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+		if ((theory_time - real_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			pr_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+		real_code = ((theory_time - real_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 - real_code;
+	}
+	if (real_code > 31)
+		LRA_TRIM_CODE = real_code - 32;
+	else
+		LRA_TRIM_CODE = real_code + 32;
+	pr_info("aw_oscmicrosecond:%ld  theory_time = %ld real_code =0X%02X LRA_TRIM_CODE 0X%02X\n",
+		real_time, theory_time, real_code, LRA_TRIM_CODE);
+
+	return LRA_TRIM_CODE;
+}
+
+static int aw869xx_rtp_trim_lra_calibration(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_trim_code = 0;
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSCTRL2, &reg_val);
+	fre_val = (reg_val & 0x03) >> 0;
+
+	if (fre_val == 2 || fre_val == 3)
+		theory_time = (aw8697->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 0)
+		theory_time = (aw8697->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1)
+		theory_time = (aw8697->rtp_len / 48000) * 1000000; /*48K */
+
+	aw_dev_info(aw8697->dev, "%s microsecond:%ld, theory_time = %d\n",
+		    __func__, aw8697->microsecond, theory_time);
+
+	lra_trim_code = aw8697_clock_OSC_trim_calibration(theory_time,
+							  aw8697->microsecond);
+	if (lra_trim_code >= 0) {
+		aw8697->lra_calib_data = lra_trim_code;
+		aw8697_haptic_upload_lra(aw8697, OSC_CALI);
+	}
+	return 0;
+}
+
+static int aw869xx_rtp_osc_calibration(struct aw8697 *aw8697)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+
+	aw8697->rtp_cnt = 0;
+	aw8697->timeval_flags = 1;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file, aw8697_rtp_name[0], aw8697->dev);
+	if (ret < 0) {
+		aw_dev_err(aw8697->dev, "%s: failed to read %s\n", __func__,
+			   aw8697_rtp_name[0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate */
+	aw8697_haptic_stop(aw8697);
+	aw8697->rtp_init = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	vfree(aw8697_rtp);
+	aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw8697->rtp_lock);
+		aw_dev_err(aw8697->dev, "%s: error allocating memory\n",
+			   __func__);
+		return -ENOMEM;
+	}
+	aw8697_rtp->len = rtp_file->size;
+	aw8697->rtp_len = rtp_file->size;
+	aw_dev_info(aw8697->dev, "%s: rtp file:[%s], size: %dbytes\n", __func__,
+		    aw8697_rtp_name[0], aw8697_rtp->len);
+
+	memcpy(aw8697_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw8697->rtp_lock);
+	/* gain */
+	aw8697_haptic_ram_vbat_comp(aw8697, false);
+	/* rtp mode config */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+	/* bst mode */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG1,
+			      AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+			      AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+	disable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	/* haptic go */
+	aw8697_haptic_play_go(aw8697, true);
+	/* require latency of CPU & DMA not more then PM_QOS_VALUE_VB us */
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) {
+			aw_dev_info(aw8697->dev,
+				    "%s not full, aw8697->rtp_cnt= %d\n",
+				    __func__, aw8697->rtp_cnt);
+			mutex_lock(&aw8697->rtp_lock);
+			if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			    (aw8697->ram.base_addr >> 2))
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			else
+				buf_len = (aw8697->ram.base_addr >> 2);
+
+			if (aw8697->rtp_cnt != aw8697_rtp->len) {
+				if (aw8697->timeval_flags == 1) {
+					do_gettimeofday(&aw8697->start);
+					aw8697->timeval_flags = 0;
+				}
+				aw8697_i2c_writes(
+					aw8697, AW869XX_REG_RTPDATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				aw8697->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw8697->rtp_lock);
+		}
+		osc_int_state = aw8697_haptic_osc_read_int(aw8697);
+		if (osc_int_state & AW869XX_BIT_SYSST2_FF_EMPTY) {
+			do_gettimeofday(&aw8697->end);
+			aw_dev_info(
+				aw8697->dev,
+				"%s osc trim playback done aw8697->rtp_cnt= %d\n",
+				__func__, aw8697->rtp_cnt);
+			break;
+		}
+		do_gettimeofday(&aw8697->end);
+		aw8697->microsecond =
+			(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+			(aw8697->end.tv_usec - aw8697->start.tv_usec);
+		if (aw8697->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			aw_dev_info(
+				aw8697->dev,
+				"%s osc trim time out! aw8697->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw8697->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	aw8697->microsecond =
+		(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+		(aw8697->end.tv_usec - aw8697->start.tv_usec);
+	/*calibration osc */
+	aw_dev_info(aw8697->dev, "%s awinic_microsecond: %ld\n", __func__,
+		    aw8697->microsecond);
+	return 0;
+}
+
+static int aw8697_rtp_trim_lra_calibration(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_rtim_code = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_PWMDBG, &reg_val);
+	fre_val = (reg_val & 0x006f) >> 5;
+
+	if (fre_val == 3)
+		theory_time = (aw8697->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 2)
+		theory_time = (aw8697->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1 || fre_val == 0)
+		theory_time = (aw8697->rtp_len / 48000) * 1000000; /*48K */
+
+	printk("microsecond:%ld  theory_time = %d\n", aw8697->microsecond,
+	       theory_time);
+
+	lra_rtim_code = aw8697_clock_OSC_trim_calibration(theory_time,
+							  aw8697->microsecond);
+	if (lra_rtim_code > 0) {
+		aw8697->lra_calib_data = lra_rtim_code;
+		aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+				 (char)lra_rtim_code);
+	}
+	return 0;
+}
+static unsigned char aw8697_haptic_osc_read_int(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DBGSTAT, &reg_val);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_SYSST2, &reg_val);
+	}
+	return reg_val;
+}
+static int aw8697_rtp_osc_calibration(struct aw8697 *aw8697)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+	aw8697->rtp_cnt = 0;
+	aw8697->timeval_flags = 1;
+	aw8697->osc_cali_flag = 1;
+
+	pr_info("%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file,
+			       aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0],
+			       aw8697->dev);
+	if (ret < 0) {
+		pr_err("%s: failed to read %s\n", __func__,
+		       aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate*/
+	aw8697_haptic_stop(aw8697);
+	aw8697->rtp_init = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	vfree(aw8697_rtp);
+	aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw8697->rtp_lock);
+		pr_err("%s: error allocating memory\n", __func__);
+		return -ENOMEM;
+	}
+	aw8697_rtp->len = rtp_file->size;
+	aw8697->rtp_len = rtp_file->size;
+	pr_info("%s: rtp file [%s] size = %d\n", __func__,
+		aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0], aw8697_rtp->len);
+	memcpy(aw8697_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw8697->rtp_lock);
+
+	/* gain */
+	aw8697_haptic_ram_vbat_comp(aw8697, false);
+
+	/* rtp mode config */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DBGCTRL,
+			      AW8697_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW8697_BIT_DBGCTRL_INT_MODE_EDGE);
+	disable_irq(gpio_to_irq(aw8697->irq_gpio));
+	/* haptic start */
+	aw8697_haptic_start(aw8697);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw8697_haptic_rtp_get_fifo_afi(aw8697)) {
+			mutex_lock(&aw8697->rtp_lock);
+			if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			    (aw8697->ram.base_addr >> 2))
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			else
+				buf_len = (aw8697->ram.base_addr >> 2);
+			if (aw8697->rtp_cnt != aw8697_rtp->len) {
+				if (aw8697->timeval_flags == 1) {
+					do_gettimeofday(&aw8697->start);
+					aw8697->timeval_flags = 0;
+				}
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				aw8697->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw8697->rtp_lock);
+		}
+		osc_int_state = aw8697_haptic_osc_read_int(aw8697);
+		if (osc_int_state & AW8697_BIT_SYSINT_DONEI) {
+			do_gettimeofday(&aw8697->end);
+			pr_info("%s vincent playback done aw8697->rtp_cnt= %d \n",
+				__func__, aw8697->rtp_cnt);
+			break;
+		}
+
+		do_gettimeofday(&aw8697->end);
+		aw8697->microsecond =
+			(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+			(aw8697->end.tv_usec - aw8697->start.tv_usec);
+		if (aw8697->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			pr_info("%s vincent time out aw8697->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw8697->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	aw8697->osc_cali_flag = 0;
+	aw8697->microsecond =
+		(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+		(aw8697->end.tv_usec - aw8697->start.tv_usec);
+	/*calibration osc*/
+	pr_info("%s 2018_microsecond:%ld \n", __func__, aw8697->microsecond);
+	pr_info("%s exit\n", __func__);
+	return 0;
+}
+
+static void aw8697_rtp_work_routine(struct work_struct *work)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	struct aw8697 *aw8697 = container_of(work, struct aw8697, rtp_work);
+	unsigned int cnt = 200;
+	unsigned char reg_val = 0;
+	bool rtp_work_flag = false;
+
+	if ((aw8697->effect_id < aw8697->info.effect_id_boundary) &&
+	    (aw8697->effect_id > aw8697->info.effect_max))
+		return;
+
+	pr_info("%s: effect_id = %d state=%d activate_mode = %d\n", __func__,
+		aw8697->effect_id, aw8697->state, aw8697->activate_mode);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_upload_lra(aw8697, OSC_CALI);
+	aw8697_haptic_set_rtp_aei(aw8697, false);
+	aw8697_interrupt_clear(aw8697);
+	//wait for irq to exit
+
+	atomic_set(&aw8697->exit_in_rtp_loop, 1);
+	while (atomic_read(&aw8697->is_in_rtp_loop)) {
+		pr_info("%s  goint to waiting irq exit\n", __func__);
+		mutex_unlock(&aw8697->lock);
+		ret = wait_event_interruptible(
+			aw8697->wait_q,
+			atomic_read(&aw8697->is_in_rtp_loop) == 0);
+		pr_info("%s  wakeup \n", __func__);
+		mutex_lock(&aw8697->lock);
+		if (ret == -ERESTARTSYS) {
+			atomic_set(&aw8697->exit_in_rtp_loop, 0);
+			wake_up_interruptible(&aw8697->stop_wait_q);
+			mutex_unlock(&aw8697->lock);
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return;
+		}
+	}
+
+	atomic_set(&aw8697->exit_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->stop_wait_q);
+
+	//how to force exit this call
+	if (aw8697->is_custom_wave == 1 && aw8697->state) {
+		pr_err("%s buffer size %d, availbe size %d \n", __func__,
+		       aw8697->ram.base_addr >> 2, get_rb_avalible_size());
+		while (get_rb_avalible_size() < aw8697->ram.base_addr &&
+		       !rb_shoule_exit()) {
+			mutex_unlock(&aw8697->lock);
+			ret = wait_event_interruptible(
+				aw8697->stop_wait_q, (get_rb_avalible_size() >=
+						      aw8697->ram.base_addr) ||
+							     rb_shoule_exit());
+			pr_info("%s  wakeup  \n", __func__);
+			pr_err("%s after wakeup sbuffer size %d, availbe size %d \n",
+			       __func__, aw8697->ram.base_addr >> 2,
+			       get_rb_avalible_size());
+			if (ret == -ERESTARTSYS) {
+				pr_err("%s wake up by signal return erro\n",
+				       __func__);
+				return;
+			}
+			mutex_lock(&aw8697->lock);
+		}
+	}
+
+	aw8697_haptic_stop(aw8697);
+
+	if (aw8697->state) {
+		pm_stay_awake(aw8697->dev);
+		if (aw8697->info.bst_vol_rtp <= AW8697_MAX_BST_VO)
+			aw8697_haptic_set_bst_vol(aw8697,
+						  aw8697->info.bst_vol_rtp);
+		else
+			aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+		aw8697_haptic_effect_strength(aw8697);
+		aw8697_haptic_set_gain(aw8697, aw8697->level);
+		aw8697->rtp_init = 0;
+		if (aw8697->is_custom_wave == 0) {
+			aw8697->rtp_file_num = aw8697->effect_id -
+					       aw8697->info.effect_id_boundary;
+			printk("%s: aw8697->rtp_file_num =%d\n", __func__,
+			       aw8697->rtp_file_num);
+			if (aw8697->rtp_file_num < 0)
+				aw8697->rtp_file_num = 0;
+			if (aw8697->rtp_file_num >
+			    ((sizeof(aw8697_rtp_name) / AW8697_RTP_NAME_MAX) -
+			     1))
+				aw8697->rtp_file_num =
+					(sizeof(aw8697_rtp_name) /
+					 AW8697_RTP_NAME_MAX) -
+					1;
+
+#ifdef SUPPORT_RELOAD_FW
+			if (aw8697->vov == 1) {
+				/* fw loaded */
+				memset(aw8697_rtp_name_a, 0,
+				       AW8697_RTP_NAME_MAX);
+				strncpy(aw8697_rtp_name_a,
+					aw8697_rtp_name[aw8697->rtp_file_num],
+					strlen(aw8697_rtp_name
+						       [aw8697->rtp_file_num]) -
+						4);
+				strcat(aw8697_rtp_name_a, "_a.bin");
+				ret = request_firmware(&rtp_file,
+						       aw8697_rtp_name_a,
+						       aw8697->dev);
+				if (ret < 0) {
+					pr_err("%s: failed to read %s\n",
+					       __func__, aw8697_rtp_name_a);
+				} else {
+					goto RTP_REQUEST_DONE;
+				}
+			}
+#endif
+			/* fw loaded */
+			ret = request_firmware(
+				&rtp_file,
+				aw8697_rtp_name[aw8697->rtp_file_num],
+				aw8697->dev);
+			if (ret < 0) {
+				pr_err("%s: failed to read %s\n", __func__,
+				       aw8697_rtp_name[aw8697->rtp_file_num]);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+#ifdef SUPPORT_RELOAD_FW
+		RTP_REQUEST_DONE:
+#endif
+			vfree(aw8697_rtp);
+			aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+			if (!aw8697_rtp) {
+				release_firmware(rtp_file);
+				pr_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+			aw8697_rtp->len = rtp_file->size;
+			pr_info("%s: rtp file [%s] size = %d\n", __func__,
+				aw8697_rtp_name[aw8697->rtp_file_num],
+				aw8697_rtp->len);
+			memcpy(aw8697_rtp->data, rtp_file->data,
+			       rtp_file->size);
+			release_firmware(rtp_file);
+		} else {
+			vfree(aw8697_rtp);
+			aw8697_rtp = vmalloc(aw8697->ram.base_addr >> 2);
+			if (!aw8697_rtp) {
+				pr_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+		}
+		aw8697->rtp_init = 1;
+
+		/* ram_vbat_compensate( */
+#ifndef RTP_SET_GAIN
+		aw8697_haptic_ram_vbat_comp(aw8697, false);
+#endif
+
+		/* rtp mode config */
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+
+		/* haptic start */
+		aw8697_haptic_start(aw8697);
+		usleep_range(2000, 2500);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_rtp_init(aw8697);
+		} else {
+			while (cnt) {
+				aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+						&reg_val);
+				if ((reg_val & 0x0f) == 0x08) {
+					cnt = 0;
+					rtp_work_flag = true;
+					aw_dev_info(
+						aw8697->dev,
+						"%s RTP_GO! glb_state=0x08\n",
+						__func__);
+				} else {
+					cnt--;
+					aw_dev_dbg(
+						aw8697->dev,
+						"%s wait for RTP_GO, glb_state=0x%02X\n",
+						__func__, reg_val);
+				}
+				usleep_range(2000, 2500);
+			}
+			if (rtp_work_flag) {
+				aw869xx_haptic_rtp_init(aw8697);
+			} else {
+				/* enter standby mode */
+				aw8697_haptic_stop(aw8697);
+				aw_dev_err(
+					aw8697->dev,
+					"%s failed to enter RTP_GO status!\n",
+					__func__);
+			}
+		}
+
+	} else {
+		aw8697->rtp_cnt = 0;
+		aw8697->rtp_init = 0;
+		pm_relax(aw8697->dev);
+	}
+	mutex_unlock(&aw8697->lock);
+}
+
+static enum hrtimer_restart
+aw8697_haptic_audio_timer_func(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 =
+		container_of(timer, struct aw8697, haptic_audio.timer);
+
+	pr_debug("%s enter\n", __func__);
+	//schedule_work(&aw8697->haptic_audio.work);
+	queue_work(aw8697->work_queue, &aw8697->haptic_audio.work);
+
+	hrtimer_start(
+		&aw8697->haptic_audio.timer,
+		ktime_set(aw8697->haptic_audio.timer_val / 1000000,
+			  (aw8697->haptic_audio.timer_val % 1000000) * 1000),
+		HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static void aw8697_haptic_audio_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, haptic_audio.work);
+
+	pr_info("%s enter\n", __func__);
+
+	mutex_lock(&aw8697->haptic_audio.lock);
+	memcpy(&aw8697->haptic_audio.ctr,
+	       &aw8697->haptic_audio.data[aw8697->haptic_audio.cnt],
+	       sizeof(struct haptic_ctr));
+	pr_debug("%s: cnt=%d, cmd=%d, play=%d, wavseq=%d, loop=%d, gain=%d\n",
+		 __func__, aw8697->haptic_audio.cnt,
+		 aw8697->haptic_audio.ctr.cmd, aw8697->haptic_audio.ctr.play,
+		 aw8697->haptic_audio.ctr.wavseq, aw8697->haptic_audio.ctr.loop,
+		 aw8697->haptic_audio.ctr.gain);
+	mutex_unlock(&aw8697->haptic_audio.lock);
+	if (AW8697_HAPTIC_CMD_ENABLE == aw8697->haptic_audio.ctr.cmd) {
+		if (AW8697_HAPTIC_PLAY_ENABLE ==
+		    aw8697->haptic_audio.ctr.play) {
+			pr_info("%s: haptic_audio_play_start\n", __func__);
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_stop(aw8697);
+			aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+
+			aw8697_haptic_set_wav_seq(
+				aw8697, 0x00, aw8697->haptic_audio.ctr.wavseq);
+			aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+
+			aw8697_haptic_set_wav_loop(
+				aw8697, 0x00, aw8697->haptic_audio.ctr.loop);
+
+			aw8697_haptic_set_gain(aw8697,
+					       aw8697->haptic_audio.ctr.gain);
+
+			aw8697_haptic_start(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else if (AW8697_HAPTIC_PLAY_STOP ==
+			   aw8697->haptic_audio.ctr.play) {
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_stop(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else if (AW8697_HAPTIC_PLAY_GAIN ==
+			   aw8697->haptic_audio.ctr.play) {
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_set_gain(aw8697,
+					       aw8697->haptic_audio.ctr.gain);
+			mutex_unlock(&aw8697->lock);
+		}
+		mutex_lock(&aw8697->haptic_audio.lock);
+		memset(&aw8697->haptic_audio.data[aw8697->haptic_audio.cnt], 0,
+		       sizeof(struct haptic_ctr));
+		mutex_unlock(&aw8697->haptic_audio.lock);
+	}
+
+	mutex_lock(&aw8697->haptic_audio.lock);
+	aw8697->haptic_audio.cnt++;
+	if (aw8697->haptic_audio.data[aw8697->haptic_audio.cnt].cmd == 0) {
+		aw8697->haptic_audio.cnt = 0;
+		pr_debug("%s: haptic play buffer restart\n", __func__);
+	}
+	mutex_unlock(&aw8697->haptic_audio.lock);
+}
+
+static int aw869xx_haptic_cont(struct aw8697 *aw8697)
+{
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+
+	/* work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+	/* cont config */
+	/* aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+	 **                     AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+	 **                     AW869XX_BIT_CONTCFG1_F0_DET_ENABLE);
+	 */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_TRACK_EN_MASK,
+			      AW869XX_BIT_CONTCFG6_TRACK_ENABLE);
+	/* f0 driver level */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+			      aw8697->info.cont_drv1_lvl);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+			 aw8697->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	/* aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8, 0xFF); */
+	/* DRV2_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9, 0xFF);
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw869xx_haptic_read_lra_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	/* F_LRA_F0_H */
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD14, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	/* F_LRA_F0_L */
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD15, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_dev_err(aw8697->dev,
+			   "%s didn't get lra f0 because f0_reg value is 0!\n",
+			   __func__);
+#ifdef RETRY_F0_CHECK
+		aw8697->f0 = 0;
+#else
+		aw8697->f0 = aw8697->info.f0_pre;
+#endif
+		return ret;
+	} else {
+		f0_tmp = 384000 * 10 / f0_reg;
+		aw8697->f0 = (unsigned int)f0_tmp;
+		aw_dev_info(aw8697->dev, "%s lra_f0=%d\n", __func__,
+			    aw8697->f0);
+	}
+
+	return ret;
+}
+
+static int aw869xx_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD16, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD17, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_dev_err(aw8697->dev,
+			   "%s didn't get cont f0 because f0_reg value is 0!\n",
+			   __func__);
+		aw8697->cont_f0 = aw8697->info.f0_pre;
+		return ret;
+	} else {
+		f0_tmp = 384000 * 10 / f0_reg;
+		aw8697->cont_f0 = (unsigned int)f0_tmp;
+		aw_dev_info(aw8697->dev, "%s cont_f0=%d\n", __func__,
+			    aw8697->cont_f0);
+	}
+	return ret;
+}
+
+static int aw869xx_haptic_cont_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int cnt = 200;
+	bool get_f0_flag = false;
+	unsigned char brk_en_temp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697->f0 = aw8697->info.f0_pre;
+	/* enter standby mode */
+	aw8697_haptic_stop(aw8697);
+#ifdef RETRY_F0_CHECK
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+			      AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK, 0x00);
+#endif
+	/* f0 calibrate work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+	/* enable f0 detect */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+			      AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+			      AW869XX_BIT_CONTCFG1_F0_DET_ENABLE);
+	/* cont config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_TRACK_EN_MASK,
+			      AW869XX_BIT_CONTCFG6_TRACK_ENABLE);
+	/* enable auto break */
+	aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG3, &reg_val);
+	brk_en_temp = 0x04 & reg_val;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK,
+			      AW869XX_BIT_PLAYCFG3_BRK_ENABLE);
+	/* LRA OSC Source */
+#ifndef RETRY_F0_CHECK
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_EFUSE);
+	}
+#endif
+
+	/* f0 driver level */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+			      aw8697->info.cont_drv1_lvl);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+			 aw8697->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8,
+			 aw8697->info.cont_drv1_time);
+	/* DRV2_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9,
+			 aw8697->info.cont_drv2_time);
+	/* TRACK_MARGIN */
+	if (!aw8697->info.cont_track_margin) {
+		aw_dev_err(aw8697->dev,
+			   "%s aw8697->info.cont_track_margin = 0!\n",
+			   __func__);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG11,
+				 (unsigned char)aw8697->info.cont_track_margin);
+	}
+	/* DRV_WIDTH */
+	/*
+	 * aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG3,
+	 *                aw8697->info.cont_drv_width);
+	 */
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+	/* 300ms */
+	while (cnt) {
+		aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == 0x00) {
+			cnt = 0;
+			get_f0_flag = true;
+			aw_dev_info(
+				aw8697->dev,
+				"%s entered standby mode! glb_state=0x%02X\n",
+				__func__, reg_val);
+#ifdef RETRY_F0_CHECK
+			break;
+#endif
+		} else {
+			cnt--;
+			aw_dev_dbg(
+				aw8697->dev,
+				"%s waitting for standby, glb_state=0x%02X\n",
+				__func__, reg_val);
+		}
+		usleep_range(10000, 10500);
+	}
+	if (get_f0_flag) {
+		aw869xx_haptic_read_lra_f0(aw8697);
+		aw869xx_haptic_read_cont_f0(aw8697);
+	} else {
+		aw_dev_err(aw8697->dev,
+			   "%s enter standby mode failed, stop reading f0!\n",
+			   __func__);
+	}
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+			      AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+			      AW869XX_BIT_CONTCFG1_F0_DET_DISABLE);
+	/* recover auto break config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK, brk_en_temp);
+	return ret;
+}
+
+static int aw869xx_haptic_f0_calibration(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+	unsigned int f0_cali_min =
+		aw8697->info.f0_pre * (100 - aw8697->info.f0_cali_percen) / 100;
+	unsigned int f0_cali_max =
+		aw8697->info.f0_pre * (100 + aw8697->info.f0_cali_percen) / 100;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+
+	aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+	if (aw869xx_haptic_cont_get_f0(aw8697)) {
+		aw_dev_err(aw8697->dev, "%s get f0 error, user defafult f0\n",
+			   __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw8697->f0;
+		aw_dev_info(aw8697->dev,
+			    "%s f0_pre = %d, f0_cali_min = %d,"
+			    " f0_cali_max = %d, f0 = %d\n",
+			    __func__, aw8697->info.f0_pre, f0_cali_min,
+			    f0_cali_max, aw8697->f0);
+
+		if ((aw8697->f0 < f0_cali_min) || aw8697->f0 > f0_cali_max) {
+			aw_dev_err(aw8697->dev,
+				   "%s f0 calibration out of range = %d!\n",
+				   __func__, aw8697->f0);
+			f0_limit = aw8697->info.f0_pre;
+			return -ERANGE;
+		}
+		aw_dev_info(aw8697->dev, "%s f0_limit = %d\n", __func__,
+			    (int)f0_limit);
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw8697->info.f0_pre) /
+			       ((int)f0_limit * 24);
+		aw_dev_info(aw8697->dev, "%s f0_cali_step = %d\n", __func__,
+			    f0_cali_step);
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5)
+				f0_cali_step = 32 + (f0_cali_step / 10 + 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		} else { /* f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5)
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		}
+		if (f0_cali_step > 31)
+			f0_cali_lra = (char)f0_cali_step - 32;
+		else
+			f0_cali_lra = (char)f0_cali_step + 32;
+		/* update cali step */
+		aw8697_i2c_read(aw8697, AW869XX_REG_TRIMCFG3, &reg_val);
+		aw8697->f0_calib_data =
+			((int)f0_cali_lra + (int)(reg_val & 0x3f)) & 0x3f;
+
+		aw_dev_info(aw8697->dev,
+			    "%s origin trim_lra = 0x%02X, f0_cali_lra = 0x%02X,"
+			    " final f0_calib_data = 0x%02X\n",
+			    __func__, (reg_val & 0x3f), f0_cali_lra,
+			    aw8697->f0_calib_data);
+		aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	}
+	/* restore standby work mode */
+	aw8697_haptic_stop(aw8697);
+	return ret;
+}
+
+/*****************************************************
+ *
+ * haptic cont
+ *
+ *****************************************************/
+static int aw8697_haptic_cont(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	/* work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* lpf */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_FC_MASK,
+			      AW8697_BIT_DATCTRL_FC_1000HZ);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* cont config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_ZC_DETEC_MASK,
+			      AW8697_BIT_CONT_CTRL_ZC_DETEC_ENABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_WAIT_PERIOD_MASK,
+			      AW8697_BIT_CONT_CTRL_WAIT_1PERIOD);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_MODE_MASK,
+			      AW8697_BIT_CONT_CTRL_BY_GO_SIGNAL);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_O2C_MASK,
+			      AW8697_BIT_CONT_CTRL_O2C_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_ENABLE);
+
+	/* TD time */
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_H,
+			 (unsigned char)(aw8697->info.cont_td >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_L,
+			 (unsigned char)(aw8697->info.cont_td >> 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+
+	/* zero cross */
+	aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_H,
+			 (unsigned char)(aw8697->info.cont_zc_thr >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_L,
+			 (unsigned char)(aw8697->info.cont_zc_thr >> 0));
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_BEMF_NUM,
+			      AW8697_BIT_BEMF_NUM_BRK_MASK,
+			      aw8697->info.cont_num_brk);
+	aw8697_i2c_write(aw8697, AW8697_REG_TIME_NZC, 0x23); // 35*171us=5.985ms
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+			 aw8697->info.cont_drv_lvl_ov);
+
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+
+	return 0;
+}
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_get_glb_state(struct aw8697 *aw8697)
+{
+	unsigned char glb_state_val = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_GLB_STATE, &glb_state_val);
+	return glb_state_val;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw8697_haptic_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char f0_pre_num = 0;
+	unsigned char f0_wait_num = 0;
+	unsigned char f0_repeat_num = 0;
+	unsigned char f0_trace_num = 0;
+	unsigned int t_f0_ms = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0 = aw8697->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw8697_haptic_stop(aw8697);
+#ifdef RETRY_F0_CHECK
+	aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+#endif
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_ENABLE);
+
+	/* LPF */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_FC_MASK,
+			      AW8697_BIT_DATCTRL_FC_1000HZ);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* LRA OSC Source */
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_EFUSE);
+	}
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+
+	/* f0 trace parameter */
+	f0_pre_num = aw8697->info.f0_trace_parameter[0];
+	f0_wait_num = aw8697->info.f0_trace_parameter[1];
+	f0_repeat_num = aw8697->info.f0_trace_parameter[2];
+	f0_trace_num = aw8697->info.f0_trace_parameter[3];
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_1,
+			 (f0_pre_num << 4) | (f0_wait_num << 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_2, (f0_repeat_num << 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_3, (f0_trace_num << 0));
+
+	/* clear aw8697 interrupt */
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw8697_haptic_play_go(aw8697, true);
+
+	/* f0 trace time */
+	t_f0_ms = 1000 * 10 / aw8697->info.f0_pre;
+	t_f0_trace_ms =
+		t_f0_ms * (f0_pre_num + f0_wait_num +
+			   (f0_trace_num + f0_wait_num) * (f0_repeat_num - 1)) +
+		50;
+	usleep_range(t_f0_trace_ms * 1000, t_f0_trace_ms * 1000 + 500);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		reg_val = aw8697_get_glb_state(aw8697);
+		/* f0 calibrate done */
+		if ((reg_val & 0x0f) == 0x00) {
+			aw8697_haptic_read_f0(aw8697);
+			aw8697_haptic_read_beme(aw8697);
+			break;
+		}
+		usleep_range(10000, 10500);
+		pr_info("%s: f0 cali sleep 10ms\n", __func__);
+	}
+
+#ifdef RETRY_F0_CHECK
+	if ((i == f0_cali_cnt) || (aw8697->f0 == 0)) { //Daniel 20210903 modify
+#else
+	if (i == f0_cali_cnt) {
+#endif
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+#ifndef RETRY_F0_CHECK
+	aw8697_haptic_read_f0(aw8697);
+	aw8697_haptic_read_beme(aw8697);
+#endif
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#else
+/*****************************************************
+ *
+ * haptic cont mode f0 cali
+ *
+ *****************************************************/
+static int aw8697_haptic_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0 = aw8697->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_MODE_MASK,
+			      AW8697_BIT_CONT_CTRL_BY_DRV_TIME);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_CLOSE_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_DISABLE);
+
+	/* LPF */
+	//aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+	//        AW8697_BIT_DATCTRL_FC_MASK, AW8697_BIT_DATCTRL_FC_1000HZ);
+	//aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+	//        AW8697_BIT_DATCTRL_LPF_ENABLE_MASK, AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* LRA OSC Source */
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_EFUSE);
+	}
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+			 aw8697->info.cont_drv_lvl_ov);
+
+	/* TD time */
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_H, aw8697->info.cont_td >> 8);
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_L, aw8697->info.cont_td);
+	aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+
+	/* drive time  */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_TIME, 0x75);
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* clear aw8697 interrupt */
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw8697_haptic_play_go(aw8697, true);
+
+	/* f0 trace time */
+	t_f0_trace_ms = 0xfe * 684 / 1000;
+	msleep(t_f0_trace_ms);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+		/* f0 calibrate done */
+		if (reg_val & 0x01) {
+			aw8697_haptic_read_cont_f0(aw8697);
+			aw8697_haptic_read_cont_bemf(aw8697);
+			break;
+		}
+		msleep(10);
+		pr_info("%s f0 cali sleep 10ms\n", __func__);
+	}
+
+	if (i == f0_cali_cnt) {
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#endif
+
+static int aw8697_haptic_f0_calibration(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+
+	aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+	if (aw8697_haptic_get_f0(aw8697)) {
+		pr_err("%s get f0 error, user defafult f0\n", __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw8697->f0;
+		if (aw8697->f0 * 100 <
+		    aw8697->info.f0_pre * (100 - aw8697->info.f0_cali_percen)) {
+			f0_limit = aw8697->info.f0_pre;
+		}
+		if (aw8697->f0 * 100 >
+		    aw8697->info.f0_pre * (100 + aw8697->info.f0_cali_percen)) {
+			f0_limit = aw8697->info.f0_pre;
+		}
+
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw8697->info.f0_pre) /
+			       ((int)f0_limit * 25);
+		pr_info("%s  line=%d f0_cali_step=%d\n", __func__, __LINE__,
+			f0_cali_step);
+		pr_info("%s line=%d  f0_limit=%d\n", __func__, __LINE__,
+			(int)f0_limit);
+		pr_info("%s line=%d  aw8697->info.f0_pre=%d\n", __func__,
+			__LINE__, (int)aw8697->info.f0_pre);
+
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5) {
+				f0_cali_step = f0_cali_step / 10 + 1 + 32;
+			} else {
+				f0_cali_step = f0_cali_step / 10 + 32;
+			}
+		} else { /*f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5) {
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			} else {
+				f0_cali_step = 32 + f0_cali_step / 10;
+			}
+		}
+
+		if (f0_cali_step > 31) {
+			f0_cali_lra = (char)f0_cali_step - 32;
+		} else {
+			f0_cali_lra = (char)f0_cali_step + 32;
+		}
+		aw8697->f0_calib_data = (int)f0_cali_lra;
+		printk("%s f0_cali_lra=%d\n", __func__, (int)f0_cali_lra);
+
+		/* update cali step */
+		aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+				 (char)f0_cali_lra);
+		aw8697_i2c_read(aw8697, AW8697_REG_TRIM_LRA, &reg_val);
+		pr_info("%s final trim_lra=0x%02x\n", __func__, reg_val);
+	}
+
+	/* restore default work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	aw8697->play_mode = AW8697_HAPTIC_RAM_MODE;
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+	aw8697_haptic_stop(aw8697);
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * haptic fops
+ *
+ *****************************************************/
+static int aw8697_file_open(struct inode *inode, struct file *file)
+{
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
+	pr_info("%s enter\n", __func__);
+	file->private_data = (void *)g_aw8697;
+
+	return 0;
+}
+
+static int aw8697_file_release(struct inode *inode, struct file *file)
+{
+	file->private_data = (void *)NULL;
+	pr_info("%s enter\n", __func__);
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+static long aw8697_file_unlocked_ioctl(struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)file->private_data;
+
+	int ret = 0;
+	pr_info("%s enter\n", __func__);
+	dev_info(aw8697->dev, "%s: cmd=0x%x, arg=0x%lx\n", __func__, cmd, arg);
+
+	mutex_lock(&aw8697->lock);
+
+	if (_IOC_TYPE(cmd) != AW8697_HAPTIC_IOCTL_MAGIC) {
+		dev_err(aw8697->dev, "%s: cmd magic err\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd\n", __func__);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	return ret;
+}
+
+static ssize_t aw8697_file_read(struct file *filp, char *buff, size_t len,
+				loff_t *offset)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)filp->private_data;
+	int ret = 0;
+	int i = 0;
+	unsigned char reg_val = 0;
+	unsigned char *pbuff = NULL;
+	pr_info("%s enter\n", __func__);
+	mutex_lock(&aw8697->lock);
+
+	dev_info(aw8697->dev, "%s: len=%zu\n", __func__, len);
+
+	switch (aw8697->fileops.cmd) {
+	case AW8697_HAPTIC_CMD_READ_REG:
+		pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+		if (pbuff != NULL) {
+			for (i = 0; i < len; i++) {
+				aw8697_i2c_read(aw8697, aw8697->fileops.reg + i,
+						&reg_val);
+				pbuff[i] = reg_val;
+			}
+			for (i = 0; i < len; i++) {
+				dev_info(aw8697->dev, "%s: pbuff[%d]=0x%02x\n",
+					 __func__, i, pbuff[i]);
+			}
+			ret = copy_to_user(buff, pbuff, len);
+			if (ret) {
+				dev_err(aw8697->dev, "%s: copy to user fail\n",
+					__func__);
+			}
+			kfree(pbuff);
+		} else {
+			dev_err(aw8697->dev, "%s: alloc memory fail\n",
+				__func__);
+		}
+		break;
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd %d \n", __func__,
+			aw8697->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	return len;
+}
+
+static ssize_t aw8697_file_write(struct file *filp, const char *buff,
+				 size_t len, loff_t *off)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)filp->private_data;
+	int i = 0;
+	int ret = 0;
+	unsigned char *pbuff = NULL;
+	pr_info("%s enter\n", __func__);
+	pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+	if (pbuff == NULL) {
+		dev_err(aw8697->dev, "%s: alloc memory fail\n", __func__);
+		return len;
+	}
+	ret = copy_from_user(pbuff, buff, len);
+	if (ret) {
+		dev_err(aw8697->dev, "%s: copy from user fail\n", __func__);
+		return len;
+	}
+
+	for (i = 0; i < len; i++) {
+		dev_info(aw8697->dev, "%s: pbuff[%d]=0x%02x\n", __func__, i,
+			 pbuff[i]);
+	}
+
+	mutex_lock(&aw8697->lock);
+
+	aw8697->fileops.cmd = pbuff[0];
+
+	switch (aw8697->fileops.cmd) {
+	case AW8697_HAPTIC_CMD_READ_REG:
+		if (len == 2) {
+			aw8697->fileops.reg = pbuff[1];
+		} else {
+			dev_err(aw8697->dev, "%s: read cmd len %zu err\n",
+				__func__, len);
+		}
+		break;
+	case AW8697_HAPTIC_CMD_WRITE_REG:
+		if (len > 2) {
+			for (i = 0; i < len - 2; i++) {
+				dev_info(aw8697->dev,
+					 "%s: write reg0x%02x=0x%02x\n",
+					 __func__, pbuff[1] + i, pbuff[i + 2]);
+				aw8697_i2c_write(aw8697, pbuff[1] + i,
+						 pbuff[2 + i]);
+			}
+		} else {
+			dev_err(aw8697->dev, "%s: write cmd len %zu err\n",
+				__func__, len);
+		}
+		break;
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd %d \n", __func__,
+			aw8697->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	if (pbuff != NULL) {
+		kfree(pbuff);
+	}
+	return len;
+}
+
+static struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.read = aw8697_file_read,
+	.write = aw8697_file_write,
+	.unlocked_ioctl = aw8697_file_unlocked_ioctl,
+	.open = aw8697_file_open,
+	.release = aw8697_file_release,
+};
+
+static struct miscdevice aw8697_haptic_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = AW8697_HAPTIC_NAME,
+	.fops = &fops,
+};
+
+static int aw8697_haptic_init(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char bemf_config = 0;
+
+	pr_info("%s enter\n", __func__);
+	ret = misc_register(&aw8697_haptic_misc);
+	if (ret) {
+		dev_err(aw8697->dev, "%s: misc fail: %d\n", __func__, ret);
+		return ret;
+	}
+
+	/* haptic audio */
+	aw8697->haptic_audio.delay_val = 1;
+	aw8697->haptic_audio.timer_val = 21318;
+	aw8697->f0_cali_status = true;
+
+	hrtimer_init(&aw8697->haptic_audio.timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw8697->haptic_audio.timer.function = aw8697_haptic_audio_timer_func;
+	INIT_WORK(&aw8697->haptic_audio.work, aw8697_haptic_audio_work_routine);
+
+	mutex_init(&aw8697->haptic_audio.lock);
+
+	/* haptic init */
+	mutex_lock(&aw8697->lock);
+
+	aw8697->activate_mode = aw8697->info.mode;
+	aw8697->osc_cali_run = 0;
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	aw8697_haptic_set_pwm(aw8697, AW8697_PWM_24K);
+	aw8697_haptic_swicth_motorprotect_config(aw8697, 0x00, 0x00);
+	/* vbat compensation */
+	aw8697_haptic_cont_vbat_mode(aw8697,
+				     AW8697_HAPTIC_CONT_VBAT_HW_COMP_MODE);
+	aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	aw8697_haptic_offset_calibration(aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1, &reg_val);
+		aw8697->index = reg_val & 0x7F;
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_DATDBG, &reg_val);
+		aw8697->gain = reg_val & 0xFF;
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_BSTDBG4, &reg_val);
+		aw8697->vmax = (reg_val >> 1) & 0x1F;
+		for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+			ret = aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1 + i,
+					      &reg_val);
+			aw8697->seq[i] = reg_val;
+		}
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG1,
+				 aw8697->info.bstdbg[0]);
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG2,
+				 aw8697->info.bstdbg[1]);
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG3,
+				 aw8697->info.bstdbg[2]);
+		aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+		aw8697_i2c_write(aw8697, AW8697_REG_R_SPARE,
+				 aw8697->info.r_spare);
+
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANADBG,
+				      AW8697_BIT_ANADBG_IOC_MASK,
+				      AW8697_BIT_ANADBG_IOC_4P65A);
+		aw8697_haptic_set_bst_peak_cur(aw8697, AW8697_DEFAULT_PEAKCUR);
+		aw8697_haptic_auto_boost_config(aw8697, false);
+
+		if ((aw8697->info.trig_config[0][0] == 1) ||
+		    (aw8697->info.trig_config[1][0] == 1) ||
+		    (aw8697->info.trig_config[2][0] == 1)) {
+			aw8697_haptic_trig_param_init(aw8697);
+			aw8697_haptic_trig_param_config(aw8697);
+		}
+		mutex_unlock(&aw8697->lock);
+
+		/* f0 calibration */
+		mutex_lock(&aw8697->lock);
+#ifndef USE_CONT_F0_CALI
+		aw8697_haptic_f0_calibration(aw8697);
+#endif
+		mutex_unlock(&aw8697->lock);
+		/* beme config */
+		bemf_config = aw8697->info.bemf_config[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHH_H, bemf_config);
+		bemf_config = aw8697->info.bemf_config[1];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHH_L, bemf_config);
+		bemf_config = aw8697->info.bemf_config[2];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHL_H, bemf_config);
+		bemf_config = aw8697->info.bemf_config[3];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHL_L, bemf_config);
+
+	} else {
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1, &reg_val);
+		aw8697->index = reg_val & 0x7F;
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG2, &reg_val);
+		aw8697->gain = reg_val & 0xFF;
+		aw_dev_info(aw8697->dev, "%s aw8697->gain =0x%02X\n", __func__,
+			    aw8697->gain);
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG1, &reg_val);
+		aw8697->vmax = (reg_val >> 1) & 0x1F;
+		for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+			ret = aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1 + i,
+					      &reg_val);
+			aw8697->seq[i] = reg_val;
+		}
+
+		/* misc value init */
+		aw869xx_haptic_misc_para_init(aw8697);
+		/* set BST_ADJ */
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG5,
+				      AW869XX_BIT_BSTCFG5_BST_ADJ_MASK,
+				      AW869XX_BIT_BSTCFG5_BST_ADJ_LOW);
+		aw869xx_haptic_set_bst_peak_cur(aw8697);
+		aw8697_haptic_auto_boost_config(
+			aw8697, aw8697->info.is_enabled_auto_bst);
+		//aw869xx_haptic_trig_param_init(aw8697);
+		//aw869xx_haptic_trig_param_config(aw8697);
+
+		mutex_unlock(&aw8697->lock);
+
+		/* f0 calibration */
+		if (aw8697->info.is_enabled_powerup_f0_cali) {
+			mutex_lock(&aw8697->lock);
+			aw869xx_haptic_f0_calibration(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else {
+			aw_dev_info(aw8697->dev,
+				    "%s powerup f0 calibration is disabled\n",
+				    __func__);
+		}
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * vibrator
+ *
+ *****************************************************/
+static enum hrtimer_restart qti_hap_stop_timer(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 = container_of(timer, struct aw8697, stop_timer);
+	int rc;
+
+	pr_info("%s enter\n", __func__);
+	aw8697->play.length_us = 0;
+	rc = aw8697_haptic_play_go(aw8697,
+				   false); // qti_haptics_play(aw8697, false);
+	if (rc < 0)
+		dev_err(aw8697->dev, "Stop playing failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart qti_hap_disable_timer(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 =
+		container_of(timer, struct aw8697, hap_disable_timer);
+	int rc;
+
+	pr_info("%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		rc = aw8697_haptic_play_go(
+			aw8697, false); //qti_haptics_module_en(aw8697, false);
+	} else {
+		rc = aw8697_haptic_stop(aw8697);
+	}
+	if (rc < 0)
+		dev_err(aw8697->dev, "Disable haptics module failed, rc=%d\n",
+			rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart aw8697_vibrator_timer_func(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 = container_of(timer, struct aw8697, timer);
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->state = 0;
+	//schedule_work(&aw8697->vibrator_work);
+	queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw8697_vibrator_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, vibrator_work);
+
+	pr_debug("%s enter\n", __func__);
+	pr_info("%s: effect_id = %d state=%d activate_mode = %d duration = %d\n",
+		__func__, aw8697->effect_id, aw8697->state,
+		aw8697->activate_mode, aw8697->duration);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	aw8697_haptic_stop(aw8697);
+	if (aw8697->state) {
+		if (aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw8697_haptic_ram_vbat_comp(aw8697, false);
+			aw8697_haptic_play_effect_seq(aw8697, true);
+		} else if (aw8697->activate_mode ==
+			   AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw8697_haptic_ram_vbat_comp(aw8697, true);
+			aw8697_haptic_play_effect_seq(aw8697, true);
+			hrtimer_start(
+				&aw8697->timer,
+				ktime_set(aw8697->duration / 1000,
+					  (aw8697->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+			pm_stay_awake(aw8697->dev);
+			aw8697->wk_lock_flag = 1;
+		} else if (aw8697->activate_mode ==
+			   AW8697_HAPTIC_ACTIVATE_CONT_MODE) {
+			if (aw8697->chip_version == AW8697_CHIP_9X) {
+				aw8697_haptic_cont(aw8697);
+			} else {
+				aw869xx_haptic_cont(aw8697);
+			}
+			hrtimer_start(
+				&aw8697->timer,
+				ktime_set(aw8697->duration / 1000,
+					  (aw8697->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else {
+			/*other mode */
+		}
+	} else {
+		if (aw8697->wk_lock_flag == 1) {
+			pm_relax(aw8697->dev);
+			aw8697->wk_lock_flag = 0;
+		}
+	}
+	mutex_unlock(&aw8697->lock);
+}
+
+static int aw8697_vibrator_init(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	hrtimer_init(&aw8697->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw8697->timer.function = aw8697_vibrator_timer_func;
+	INIT_WORK(&aw8697->vibrator_work, aw8697_vibrator_work_routine);
+	INIT_WORK(&aw8697->rtp_work, aw8697_rtp_work_routine);
+
+	mutex_init(&aw8697->lock);
+	mutex_init(&aw8697->rtp_lock);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	atomic_set(&aw8697->exit_in_rtp_loop, 0);
+	atomic_set(&aw8697->is_in_write_loop, 0);
+	init_waitqueue_head(&aw8697->wait_q);
+	init_waitqueue_head(&aw8697->stop_wait_q);
+
+	return 0;
+}
+
+/******************************************************
+ *
+ * irq
+ *
+ ******************************************************/
+static void aw8697_interrupt_clear(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+}
+
+static void aw8697_interrupt_setup(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* edge int mode */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DBGCTRL,
+			      AW8697_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW8697_BIT_DBGCTRL_INT_MODE_EDGE);
+
+	/* int enable */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_BSTERR_MASK,
+			      AW8697_BIT_SYSINTM_BSTERR_OFF);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OV_MASK,
+			      AW8697_BIT_SYSINTM_OV_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_UVLO_MASK,
+			      AW8697_BIT_SYSINTM_UVLO_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OCD_MASK,
+			      AW8697_BIT_SYSINTM_OCD_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OT_MASK,
+			      AW8697_BIT_SYSINTM_OT_EN);
+}
+
+static void aw869xx_interrupt_setup(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSINT, &reg_val);
+	aw_dev_info(aw8697->dev, "%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	/* posedge interrupt mode */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_INT_MODE_MASK,
+			      AW869XX_BIT_SYSCTRL7_INT_MODE_EDGE);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_MASK,
+			      AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_POS);
+	/* interrupts enable */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_BST_SCPM_MASK,
+			      AW869XX_BIT_SYSINTM_BST_SCPM_OFF);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_BST_OVPM_MASK,
+			      AW869XX_BIT_SYSINTM_BST_OVPM_ON);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_UVLM_MASK,
+			      AW869XX_BIT_SYSINTM_UVLM_ON);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_OCDM_MASK,
+			      AW869XX_BIT_SYSINTM_OCDM_ON);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_OTM_MASK,
+			      AW869XX_BIT_SYSINTM_OTM_ON);
+}
+
+static irqreturn_t aw869xx_irq(int irq, void *data)
+{
+	struct aw8697 *aw8697 = data;
+	unsigned char reg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned char glb_state_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	atomic_set(&aw8697->is_in_rtp_loop, 1);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSINT, &reg_val);
+	aw_dev_info(aw8697->dev, "%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	if (reg_val & AW869XX_BIT_SYSINT_BST_OVPI) {
+		aw_dev_err(aw8697->dev, "%s chip ov int error\n", __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_UVLI) {
+		aw_dev_err(aw8697->dev, "%s chip uvlo int error\n", __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_OCDI) {
+		aw_dev_err(aw8697->dev, "%s chip over current int error\n",
+			   __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_OTI) {
+		aw_dev_err(aw8697->dev, "%s chip over temperature int error\n",
+			   __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_DONEI) {
+		aw_dev_info(aw8697->dev, "%s chip playback done\n", __func__);
+	}
+
+	if (reg_val & AW869XX_BIT_SYSINT_FF_AEI) {
+		aw_dev_info(aw8697->dev, "%s: aw869xx rtp fifo almost empty\n",
+			    __func__);
+		if (aw8697->rtp_init) {
+			while ((!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) &&
+			       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+			       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+				mutex_lock(&aw8697->rtp_lock);
+				aw_dev_info(
+					aw8697->dev,
+					"%s: aw869xx rtp mode fifo update, cnt=%d\n",
+					__func__, aw8697->rtp_cnt);
+				if (!aw8697_rtp) {
+					pr_info("%s:aw8697_rtp is null, break!\n",
+						__func__);
+					mutex_unlock(&aw8697->rtp_lock);
+					break;
+				}
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    (aw8697->ram.base_addr >> 2)) {
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				} else {
+					buf_len = (aw8697->ram.base_addr >> 2);
+				}
+				aw8697_i2c_writes(
+					aw8697, AW869XX_REG_RTPDATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				aw8697->rtp_cnt += buf_len;
+				aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+						&glb_state_val);
+				if ((aw8697->rtp_cnt == aw8697_rtp->len) ||
+				    ((glb_state_val & 0x0f) == 0)) {
+					aw_dev_info(aw8697->dev,
+						    "%s: rtp update complete\n",
+						    __func__);
+					aw8697_haptic_set_rtp_aei(aw8697,
+								  false);
+					aw8697->rtp_cnt = 0;
+					aw8697->rtp_init = 0;
+					mutex_unlock(&aw8697->rtp_lock);
+					break;
+				}
+				mutex_unlock(&aw8697->rtp_lock);
+			}
+		} else {
+			aw_dev_info(aw8697->dev,
+				    "%s: aw869xx rtp init = %d, init error\n",
+				    __func__, aw8697->rtp_init);
+		}
+	}
+
+	if (reg_val & AW869XX_BIT_SYSINT_FF_AFI)
+		aw_dev_info(aw8697->dev,
+			    "%s: aw869xx rtp mode fifo almost full!\n",
+			    __func__);
+
+	if (aw8697->play_mode != AW8697_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw8697->exit_in_rtp_loop))
+		aw8697_haptic_set_rtp_aei(aw8697, false);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->wait_q);
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t aw8697_irq(int irq, void *data)
+{
+	struct aw8697 *aw8697 = data;
+	unsigned char reg_val = 0;
+	unsigned char dbg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned period_size = aw8697->ram.base_addr >> 2;
+
+	atomic_set(&aw8697->is_in_rtp_loop, 1);
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+	pr_info("%s: reg SYSINT=0x%x\n", __func__, reg_val);
+	aw8697_i2c_read(aw8697, AW8697_REG_DBGSTAT, &dbg_val);
+	pr_info("%s: reg DBGSTAT=0x%x\n", __func__, dbg_val);
+
+	if (reg_val & AW8697_BIT_SYSINT_OVI) {
+		pr_err("%s chip ov int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_UVLI) {
+		pr_err("%s chip uvlo int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_OCDI) {
+		pr_err("%s chip over current int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_OTI) {
+		pr_err("%s chip over temperature int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_DONEI) {
+		pr_info("%s chip playback done\n", __func__);
+	}
+
+	if (reg_val & AW8697_BIT_SYSINT_FF_AEI) {
+		pr_debug("%s: aw8697 rtp fifo almost empty int\n", __func__);
+		if (aw8697->rtp_init) {
+			while ((!aw8697_haptic_rtp_get_fifo_afi(aw8697)) &&
+			       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+			       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+				mutex_lock(&aw8697->rtp_lock);
+				if (!aw8697_rtp) {
+					pr_info("%s:aw8697_rtp is null break\n",
+						__func__);
+					mutex_unlock(&aw8697->rtp_lock);
+					break;
+				}
+
+				if (aw8697->is_custom_wave == 1) {
+					buf_len = read_rb(aw8697_rtp->data,
+							  period_size);
+					aw8697_i2c_writes(aw8697,
+							  AW8697_REG_RTP_DATA,
+							  aw8697_rtp->data,
+							  buf_len);
+					if (buf_len < period_size) {
+						pr_info("%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				} else {
+					if ((aw8697_rtp->len -
+					     aw8697->rtp_cnt) < period_size) {
+						buf_len = aw8697_rtp->len -
+							  aw8697->rtp_cnt;
+					} else {
+						buf_len = period_size;
+					}
+					aw8697_i2c_writes(
+						aw8697, AW8697_REG_RTP_DATA,
+						&aw8697_rtp
+							 ->data[aw8697->rtp_cnt],
+						buf_len);
+					aw8697->rtp_cnt += buf_len;
+					if (aw8697->rtp_cnt ==
+					    aw8697_rtp->len) {
+						pr_info("%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				}
+				mutex_unlock(&aw8697->rtp_lock);
+			}
+		} else {
+			pr_err("%s: aw8697 rtp init = %d, init error\n",
+			       __func__, aw8697->rtp_init);
+		}
+	}
+
+	if (reg_val & AW8697_BIT_SYSINT_FF_AFI) {
+		pr_debug("%s: aw8697 rtp mode fifo full empty\n", __func__);
+	}
+
+	if (aw8697->play_mode != AW8697_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw8697_haptic_set_rtp_aei(aw8697, false);
+	}
+
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSST, &reg_val);
+	pr_debug("%s: reg SYSST=0x%x\n", __func__, reg_val);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->wait_q);
+	pr_debug("%s exit\n", __func__);
+	return IRQ_HANDLED;
+}
+
+/*****************************************************
+ *
+ * device tree
+ *
+ *****************************************************/
+
+static int aw8697_parse_dt_common(struct device *dev, struct aw8697 *aw8697,
+				  struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int rtp_time[175];
+	struct qti_hap_config *config = &aw8697->config;
+	struct device_node *child_node;
+	struct qti_hap_effect *effect;
+	int rc = 0, tmp, i = 0, j, m;
+
+	printk("%s  %d enter\n", __func__, __LINE__);
+	aw8697->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);
+	if (aw8697->reset_gpio < 0) {
+		dev_err(dev,
+			"%s: no reset gpio provided, will not HW reset device\n",
+			__func__);
+		return -EINVAL;
+	} else {
+		dev_info(dev, "%s: reset gpio provided ok\n", __func__);
+	}
+	aw8697->irq_gpio = of_get_named_gpio(np, "irq-gpio", 0);
+	if (aw8697->irq_gpio < 0) {
+		dev_err(dev, "%s: no irq gpio provided.\n", __func__);
+	} else {
+		dev_info(dev, "%s: irq gpio provided ok.\n", __func__);
+	}
+
+	val = of_property_read_u32(np, "vib_mode", &aw8697->info.mode);
+	if (val != 0)
+		printk("vib_mode not found\n");
+	val = of_property_read_u32(np, "vib_f0_pre", &aw8697->info.f0_pre);
+	if (val != 0)
+		printk("vib_f0_pre not found\n");
+	val = of_property_read_u32(np, "vib_f0_cali_percen",
+				   &aw8697->info.f0_cali_percen);
+	if (val != 0)
+		printk("vib_f0_cali_percen not found\n");
+
+	val = of_property_read_u32_array(np, "vib_rtp_time", rtp_time,
+					 ARRAY_SIZE(rtp_time));
+	if (val != 0)
+		printk("%s vib_rtp_time not found\n", __func__);
+	memcpy(aw8697->info.rtp_time, rtp_time, sizeof(rtp_time));
+
+	val = of_property_read_u32(np, "vib_effect_id_boundary",
+				   &aw8697->info.effect_id_boundary);
+	if (val != 0)
+		printk("%s vib_effect_id_boundary not found\n", __func__);
+	val = of_property_read_u32(np, "vib_effect_max",
+				   &aw8697->info.effect_max);
+	if (val != 0)
+		printk("%s vib_effect_max not found\n", __func__);
+
+	config->play_rate_us = HAP_PLAY_RATE_US_DEFAULT;
+	rc = of_property_read_u32(np, "qcom,play-rate-us", &tmp);
+	if (!rc)
+		config->play_rate_us = (tmp >= HAP_PLAY_RATE_US_MAX) ?
+					       HAP_PLAY_RATE_US_MAX :
+					       tmp;
+
+	aw8697->constant.pattern = devm_kcalloc(
+		aw8697->dev, HAP_WAVEFORM_BUFFER_MAX, sizeof(u8), GFP_KERNEL);
+	if (!aw8697->constant.pattern)
+		return -ENOMEM;
+
+	tmp = of_get_available_child_count(np);
+	aw8697->predefined = devm_kcalloc(
+		aw8697->dev, tmp, sizeof(*aw8697->predefined), GFP_KERNEL);
+	if (!aw8697->predefined)
+		return -ENOMEM;
+
+	aw8697->effects_count = tmp;
+	printk("%s ---%d aw8697->effects_count=%d\n", __func__, __LINE__,
+	       aw8697->effects_count);
+	for_each_available_child_of_node (np, child_node) {
+		printk("%s  %d  i=%d\n", __func__, __LINE__, i);
+		effect = &aw8697->predefined[i++];
+		printk("%s  %d  i=%d\n", __func__, __LINE__, i);
+		rc = of_property_read_u32(child_node, "qcom,effect-id",
+					  &effect->id);
+		if (rc != 0) {
+			printk("%s Read qcom,effect-id failed\n", __func__);
+		}
+		printk(" 20190420_dt effect_id: %d\n", effect->id);
+
+		printk("%s ---%d \n", __func__, __LINE__);
+		effect->vmax_mv = config->vmax_mv;
+		rc = of_property_read_u32(child_node, "qcom,wf-vmax-mv", &tmp);
+		if (rc != 0)
+			printk("%s  Read qcom,wf-vmax-mv failed !\n", __func__);
+		else
+			effect->vmax_mv = tmp;
+
+		printk("%s ---%d effect->vmax_mv =%d \n", __func__, __LINE__,
+		       effect->vmax_mv);
+		rc = of_property_count_elems_of_size(
+			child_node, "qcom,wf-pattern", sizeof(u8));
+		if (rc < 0) {
+			printk("%s Count qcom,wf-pattern property failed !\n",
+			       __func__);
+		} else if (rc == 0) {
+			printk("%s qcom,wf-pattern has no data\n", __func__);
+		}
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		effect->pattern_length = rc;
+		effect->pattern =
+			devm_kcalloc(aw8697->dev, effect->pattern_length,
+				     sizeof(u8), GFP_KERNEL);
+
+		rc = of_property_read_u8_array(child_node, "qcom,wf-pattern",
+					       effect->pattern,
+					       effect->pattern_length);
+		if (rc < 0) {
+			printk("%s Read qcom,wf-pattern property failed !\n",
+			       __func__);
+		}
+		printk("%s %d  effect->pattern_length=%d  effect->pattern=%d \n",
+		       __func__, __LINE__, effect->pattern_length,
+		       (int)effect->pattern);
+
+		effect->play_rate_us = config->play_rate_us;
+		rc = of_property_read_u32(child_node, "qcom,wf-play-rate-us",
+					  &tmp);
+		if (rc < 0)
+			printk("%s Read qcom,wf-play-rate-us failed !\n",
+			       __func__);
+		else
+			effect->play_rate_us = tmp;
+		printk("%s ---%d effect->play_rate_us=%d \n", __func__,
+		       __LINE__, effect->play_rate_us);
+
+		rc = of_property_read_u32(child_node, "qcom,wf-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			printk("%s Read  qcom,wf-repeat-count failed !\n",
+			       __func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_repeat); j++)
+				if (tmp <= wf_repeat[j])
+					break;
+
+			effect->wf_repeat_n = j;
+		}
+
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		rc = of_property_read_u32(child_node, "qcom,wf-s-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			printk("%s Read  qcom,wf-s-repeat-count failed !\n",
+			       __func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_s_repeat); j++)
+				if (tmp <= wf_s_repeat[j])
+					break;
+
+			effect->wf_s_repeat_n = j;
+		}
+
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		effect->lra_auto_res_disable = of_property_read_bool(
+			child_node, "qcom,lra-auto-resonance-disable");
+
+		tmp = of_property_count_elems_of_size(
+			child_node, "qcom,wf-brake-pattern", sizeof(u8));
+		if (tmp <= 0)
+			continue;
+
+		if (tmp > HAP_BRAKE_PATTERN_MAX) {
+			printk("%s wf-brake-pattern shouldn't be more than %d bytes\n",
+			       __func__, HAP_BRAKE_PATTERN_MAX);
+		}
+
+		rc = of_property_read_u8_array(child_node,
+					       "qcom,wf-brake-pattern",
+					       effect->brake, tmp);
+		if (rc < 0) {
+			printk("%s Failed to get wf-brake-pattern !\n",
+			       __func__);
+		}
+
+		effect->brake_pattern_length = tmp;
+	}
+
+	for (j = 0; j < 175; j++)
+		aw_dev_info(aw8697->dev,
+			    " 20190420_dt aw8697->info.rtp_time[%d]: %d\n", j,
+			    aw8697->info.rtp_time[j]);
+
+	for (j = 0; j < i; j++) {
+		printk(" 20190420_dt       effect_id: %d\n",
+		       aw8697->predefined[j].id);
+		printk(" 20190420_dt       vmax: %d mv\n",
+		       aw8697->predefined[j].vmax_mv);
+		printk("20190420_dt        play_rate: %d us\n",
+		       aw8697->predefined[j].play_rate_us);
+		for (m = 0; m < aw8697->predefined[j].pattern_length; m++)
+			printk("20190420_dt     pattern[%d]: 0x%x\n", m,
+			       aw8697->predefined[j].pattern[m]);
+		for (m = 0; m < aw8697->predefined[j].brake_pattern_length; m++)
+			printk("20190420_dt     brake_pattern[%d]: 0x%x\n", m,
+			       aw8697->predefined[j].brake[m]);
+		printk("20190420_dt         brake_en: %d\n",
+		       aw8697->predefined[j].brake_en);
+		printk("20190420_dt        wf_repeat_n: %d\n",
+		       aw8697->predefined[j].wf_repeat_n);
+		printk("20190420_dt         wf_s_repeat_n: %d\n",
+		       aw8697->predefined[j].wf_s_repeat_n);
+		printk("20190420_dt         lra_auto_res_disable: %d\n",
+		       aw8697->predefined[j].lra_auto_res_disable);
+	}
+	printk(" 20190420_dt       aw8697->effects_count: %d\n",
+	       aw8697->effects_count);
+	printk(" 20190420_dt       aw8697->effect_id_boundary: %d\n",
+	       aw8697->info.effect_id_boundary);
+
+	printk(" 20190420_dt aw8697->effect_max: %d\n",
+	       aw8697->info.effect_max);
+
+	return 0;
+}
+
+static int aw8697_parse_dt_attr(struct device *dev, struct aw8697 *aw8697,
+				struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int bstdbg[6];
+	unsigned int f0_trace_parameter[4];
+	unsigned int bemf_config[4];
+	unsigned int trig_config[15];
+	int i = 0, j;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+
+	val = of_property_read_u32(np, "vib_cont_drv_lev",
+				   &aw8697->info.cont_drv_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_drv_lev not found\n");
+	val = of_property_read_u32(np, "vib_cont_drv_lvl_ov",
+				   &aw8697->info.cont_drv_lvl_ov);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_drv_lvl_ov not found\n");
+	val = of_property_read_u32(np, "vib_cont_td", &aw8697->info.cont_td);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_td not found\n");
+	val = of_property_read_u32(np, "vib_cont_zc_thr",
+				   &aw8697->info.cont_zc_thr);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_zc_thr not found\n");
+	val = of_property_read_u32(np, "vib_cont_num_brk",
+				   &aw8697->info.cont_num_brk);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_num_brk not found\n");
+	val = of_property_read_u32(np, "vib_f0_coeff", &aw8697->info.f0_coeff);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_f0_coeff not found\n");
+
+	val = of_property_read_u32(np, "vib_tset", &aw8697->info.tset);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_tset not found\n", __func__);
+	val = of_property_read_u32(np, "vib_r_spare", &aw8697->info.r_spare);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_r_spare not found\n",
+			    __func__);
+	val = of_property_read_u32_array(np, "vib_bstdbg", bstdbg,
+					 ARRAY_SIZE(bstdbg));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bstdbg not found\n", __func__);
+	memcpy(aw8697->info.bstdbg, bstdbg, sizeof(bstdbg));
+
+	val = of_property_read_u32_array(np, "vib_f0_trace_parameter",
+					 f0_trace_parameter,
+					 ARRAY_SIZE(f0_trace_parameter));
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_f0_trace_parameter not found\n", __func__);
+	memcpy(aw8697->info.f0_trace_parameter, f0_trace_parameter,
+	       sizeof(f0_trace_parameter));
+	val = of_property_read_u32_array(np, "vib_bemf_config", bemf_config,
+					 ARRAY_SIZE(bemf_config));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bemf_config not found\n",
+			    __func__);
+	memcpy(aw8697->info.bemf_config, bemf_config, sizeof(bemf_config));
+
+	val = of_property_read_u32_array(np, "vib_trig_config", trig_config,
+					 ARRAY_SIZE(trig_config));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_trig_config not found\n",
+			    __func__);
+	memcpy(aw8697->info.trig_config, trig_config, sizeof(trig_config));
+
+	val = of_property_read_u32(np, "vib_bst_vol_default_9x",
+				   &aw8697->info.bst_vol_default);
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_bst_vol_default_9x not found\n", __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_ram",
+				   &aw8697->info.bst_vol_ram);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_ram not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_rtp",
+				   &aw8697->info.bst_vol_rtp);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_rtp not found\n",
+			    __func__);
+
+	aw_dev_info(aw8697->dev, " 20190420_dt aw8697->info.cont_drv_lvl: %d\n",
+		    aw8697->info.cont_drv_lvl);
+	aw_dev_info(aw8697->dev,
+		    " 20190420_dt aw8697->info.cont_drv_lvl_ov: %d\n",
+		    aw8697->info.cont_drv_lvl_ov);
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 5; j++)
+			printk(" 20190420_dt aw8697->info.trig_config_9x[%d][%d]: %d\n",
+			       i, j, aw8697->info.trig_config[i][j]);
+
+	printk(" 20190420_dt aw8697->info.bst_vol_default_9x: 0x%x\n",
+	       aw8697->info.bst_vol_default);
+	printk(" 20190420_dt aw8697->info.bst_vol_ram_9x: 0x%x\n",
+	       aw8697->info.bst_vol_ram);
+	printk(" 20190420_dt aw8697->info.bst_vol_rtp_9x: 0x%x\n",
+	       aw8697->info.bst_vol_rtp);
+	return 0;
+}
+
+static int aw869xx_parse_dt_attr(struct device *dev, struct aw8697 *aw8697,
+				 struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int bstcfg_temp[5] = { 0x2a, 0x24, 0x9a, 0x40, 0x91 };
+	unsigned int prctmode_temp[3];
+	unsigned int sine_array_temp[4] = { 0x05, 0xB2, 0xFF, 0xEF };
+	unsigned int trig_config_temp[24] = { 1, 0, 1, 1, 1, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0 };
+
+	val = of_property_read_u32(np, "vib_cont_drv1_lvl",
+				   &aw8697->info.cont_drv1_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv1_lvl not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv2_lvl",
+				   &aw8697->info.cont_drv2_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv2_lvl not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv1_time",
+				   &aw8697->info.cont_drv1_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv1_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv2_time",
+				   &aw8697->info.cont_drv2_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv2_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv_width",
+				   &aw8697->info.cont_drv_width);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv_width not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_wait_num",
+				   &aw8697->info.cont_wait_num);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_wait_num not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_bst_brk_gain",
+				   &aw8697->info.cont_bst_brk_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_bst_brk_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_brk_gain",
+				   &aw8697->info.cont_brk_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_brk_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_tset",
+				   &aw8697->info.cont_tset);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_tset not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_bemf_set",
+				   &aw8697->info.cont_bemf_set);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_bemf_set not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_d2s_gain", &aw8697->info.d2s_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_d2s_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_brk_time",
+				   &aw8697->info.cont_brk_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_brk_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_track_margin",
+				   &aw8697->info.cont_track_margin);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_track_margin not found\n",
+			    __func__);
+	aw8697->info.is_enabled_auto_bst =
+		of_property_read_bool(np, "vib_is_enabled_auto_bst");
+	aw_dev_info(aw8697->dev, "%s aw8697->info.is_enabled_auto_bst = %d\n",
+		    __func__, aw8697->info.is_enabled_auto_bst);
+	aw8697->info.is_enabled_powerup_f0_cali =
+		of_property_read_bool(np, "vib_powerup_f0_cali");
+	aw_dev_info(aw8697->dev,
+		    "%s aw8697->info.is_enabled_powerup_f0_cali = %d\n",
+		    __func__, aw8697->info.is_enabled_powerup_f0_cali);
+	val = of_property_read_u32_array(np, "vib_bstcfg", bstcfg_temp,
+					 ARRAY_SIZE(bstcfg_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bstcfg not found\n", __func__);
+	memcpy(aw8697->info.bstcfg, bstcfg_temp, sizeof(bstcfg_temp));
+
+	val = of_property_read_u32_array(np, "vib_prctmode", prctmode_temp,
+					 ARRAY_SIZE(prctmode_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_prctmode not found\n",
+			    __func__);
+	memcpy(aw8697->info.prctmode, prctmode_temp, sizeof(prctmode_temp));
+	val = of_property_read_u32_array(np, "vib_sine_array", sine_array_temp,
+					 ARRAY_SIZE(sine_array_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_sine_array not found\n",
+			    __func__);
+	memcpy(aw8697->info.sine_array, sine_array_temp,
+	       sizeof(sine_array_temp));
+	val = of_property_read_u32_array(np, "vib_trig_config_9xx",
+					 trig_config_temp,
+					 ARRAY_SIZE(trig_config_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_trig_config_9xx not found\n",
+			    __func__);
+	memcpy(aw8697->info.trig_config_9xx, trig_config_temp,
+	       sizeof(trig_config_temp));
+
+	val = of_property_read_u32(np, "vib_bst_vol_default_9xx",
+				   &aw8697->info.bst_vol_default);
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_bst_vol_default_9xx not found\n", __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_ram_9xx",
+				   &aw8697->info.bst_vol_ram);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_ram_9xx not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_rtp_9xx",
+				   &aw8697->info.bst_vol_rtp);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_rtp_9xx not found\n",
+			    __func__);
+
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_default_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_default);
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_ram_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_ram);
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_rtp_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_rtp);
+
+	return 0;
+}
+
+static inline void get_play_length(struct qti_hap_play_info *play,
+				   int *length_us)
+{
+	struct qti_hap_effect *effect = play->effect;
+	int tmp;
+	//printk("%s  %d enter\n", __func__, __LINE__);
+
+	tmp = effect->pattern_length * effect->play_rate_us;
+	tmp *= wf_s_repeat[effect->wf_s_repeat_n];
+	tmp *= wf_repeat[effect->wf_repeat_n];
+	if (effect->brake_en)
+		tmp += effect->play_rate_us * effect->brake_pattern_length;
+
+	*length_us = tmp;
+}
+
+static int aw8697_haptics_upload_effect(struct input_dev *dev,
+					struct ff_effect *effect,
+					struct ff_effect *old)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	struct qti_hap_play_info *play = &aw8697->play;
+	s16 data[CUSTOM_DATA_LEN];
+	ktime_t rem;
+	s64 time_us;
+	int ret;
+
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	if (hrtimer_active(&aw8697->timer)) {
+		rem = hrtimer_get_remaining(&aw8697->timer);
+		time_us = ktime_to_us(rem);
+		printk("waiting for playing clear sequence: %lld us\n",
+		       time_us);
+		usleep_range(time_us, time_us + 100);
+	}
+	pr_debug("%s: effect->type=0x%x,FF_CONSTANT=0x%x,FF_PERIODIC=0x%x\n",
+		 __func__, effect->type, FF_CONSTANT, FF_PERIODIC);
+	aw8697->effect_type = effect->type;
+	mutex_lock(&aw8697->lock);
+	while (atomic_read(&aw8697->exit_in_rtp_loop)) {
+		pr_info("%s  goint to waiting rtp  exit\n", __func__);
+		mutex_unlock(&aw8697->lock);
+		ret = wait_event_interruptible(
+			aw8697->stop_wait_q,
+			atomic_read(&aw8697->exit_in_rtp_loop) == 0);
+		pr_info("%s  wakeup \n", __func__);
+		if (ret == -ERESTARTSYS) {
+			mutex_unlock(&aw8697->lock);
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+		mutex_lock(&aw8697->lock);
+	}
+
+	if (aw8697->effect_type == FF_CONSTANT) {
+		pr_debug("%s: effect_type is  FF_CONSTANT! \n", __func__);
+		/*cont mode set duration */
+		aw8697->duration = effect->replay.length;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE;
+		aw8697->effect_id = aw8697->info.effect_id_boundary;
+
+	} else if (aw8697->effect_type == FF_PERIODIC) {
+		if (aw8697->effects_count == 0) {
+			mutex_unlock(&aw8697->lock);
+			return -EINVAL;
+		}
+
+		pr_debug("%s: effect_type is  FF_PERIODIC! \n", __func__);
+		if (copy_from_user(data, effect->u.periodic.custom_data,
+				   sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw8697->lock);
+			return -EFAULT;
+		}
+
+		aw8697->effect_id = data[0];
+		pr_debug("%s: aw8697->effect_id =%d \n", __func__,
+			 aw8697->effect_id);
+		play->vmax_mv = effect->u.periodic.magnitude; /*vmax level*/
+
+		if (aw8697->effect_id < 0 ||
+		    aw8697->effect_id > aw8697->info.effect_max) {
+			mutex_unlock(&aw8697->lock);
+			return 0;
+		}
+		aw8697->is_custom_wave = 0;
+
+		if (aw8697->effect_id < aw8697->info.effect_id_boundary) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->predefined[aw8697->effect_id]
+					  .play_rate_us /
+				  1000000; /*second data*/
+			data[2] = aw8697->predefined[aw8697->effect_id]
+					  .play_rate_us /
+				  1000; /*millisecond data*/
+		}
+		if (aw8697->effect_id >= aw8697->info.effect_id_boundary) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RTP_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->info.rtp_time[aw8697->effect_id] /
+				  1000; /*second data*/
+			data[2] =
+				aw8697->info.rtp_time
+					[aw8697->effect_id]; /*millisecond data*/
+		}
+		if (aw8697->effect_id == CUSTOME_WAVE_ID) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RTP_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->info.rtp_time[aw8697->effect_id] /
+				  1000; /*second data*/
+			data[2] =
+				aw8697->info.rtp_time
+					[aw8697->effect_id]; /*millisecond data*/
+			aw8697->is_custom_wave = 1;
+			rb_init();
+		}
+
+		if (copy_to_user(effect->u.periodic.custom_data, data,
+				 sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw8697->lock);
+			return -EFAULT;
+		}
+
+	} else {
+		pr_err("%s Unsupported effect type: %d\n", __func__,
+		       effect->type);
+	}
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static int aw8697_haptics_playback(struct input_dev *dev, int effect_id,
+				   int val)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	int rc = 0;
+
+	//printk("%s effect_id=%d , val = %d\n", __func__, effect_id, val);
+	//printk("%s aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+	//     __func__, aw8697->effect_id, aw8697->activate_mode);
+
+	pr_debug("%s: effect_id=%d , activate_mode = %d val = %d\n", __func__,
+		 aw8697->effect_id, aw8697->activate_mode, val);
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	if (val > 0)
+		aw8697->state = 1;
+	if (val <= 0)
+		aw8697->state = 0;
+	hrtimer_cancel(&aw8697->timer);
+
+	if (aw8697->effect_type == FF_CONSTANT &&
+	    aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+		pr_debug("%s: enter ram_loop_mode \n", __func__);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	} else if (aw8697->effect_type == FF_PERIODIC &&
+		   aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+		pr_debug("%s: enter  ram_mode\n", __func__);
+		//schedule_work(&aw8697->vibrator_work)
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+		;
+	} else if ((aw8697->effect_type == FF_PERIODIC) &&
+		   aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RTP_MODE) {
+		pr_debug("%s: enter  rtp_mode\n", __func__);
+		//schedule_work(&aw8697->rtp_work);
+		queue_work(aw8697->work_queue, &aw8697->rtp_work);
+		//if we are in the play mode, force to exit
+		if (val == 0) {
+			atomic_set(&aw8697->exit_in_rtp_loop, 1);
+			rb_force_exit();
+			wake_up_interruptible(&aw8697->stop_wait_q);
+		}
+	} else {
+		/*other mode */
+	}
+
+	return rc;
+}
+
+static int aw8697_haptics_erase(struct input_dev *dev, int effect_id)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	int rc = 0;
+
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	pr_debug("%s: enter\n", __func__);
+	aw8697->effect_type = 0;
+	aw8697->is_custom_wave = 0;
+	aw8697->duration = 0;
+	return rc;
+}
+
+static void set_gain(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, set_gain_work);
+	pr_debug("%s enter set_gain queue work\n", __func__);
+
+	if (aw8697->new_gain >= 0x7FFF)
+		aw8697->level = 0x80; /*128*/
+	else if (aw8697->new_gain <= 0x3FFF)
+		aw8697->level = 0x1E; /*30*/
+	else
+		aw8697->level = (aw8697->new_gain - 16383) / 128;
+
+	if (aw8697->level < 0x1E)
+		aw8697->level = 0x1E; /*30*/
+
+	aw8697_haptic_set_gain(aw8697, aw8697->level);
+}
+
+static void aw8697_haptics_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	pr_debug("%s enter\n", __func__);
+	aw8697->new_gain = gain;
+	queue_work(aw8697->work_queue, &aw8697->set_gain_work);
+}
+
+static ssize_t aw8697_effect_id_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "effect_id =%d\n", aw8697->effect_id);
+}
+
+static ssize_t aw8697_effect_id_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697->effect_id = val;
+	aw8697->play.vmax_mv = AW8697_MEDIUM_MAGNITUDE;
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_bst_vol_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "bst_vol_ram=%d\nbst_vol_rtp=%d\n",
+			aw8697->info.bst_vol_ram, aw8697->info.bst_vol_rtp);
+}
+
+static ssize_t aw8697_bst_vol_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	if (2 == sscanf(buf, "%d %d", &databuf[0], &databuf[1])) {
+		aw8697->info.bst_vol_ram = databuf[0];
+		aw8697->info.bst_vol_rtp = databuf[1];
+	}
+	return count;
+}
+
+static ssize_t aw8697_activate_test_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->test_val);
+}
+
+static ssize_t aw8697_activate_test_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+	;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697->test_val = val;
+	pr_debug("%s: aw8697->test_val=%d\n", __FUNCTION__, aw8697->test_val);
+
+	if (aw8697->test_val == 1) {
+		printk("%s  %d  \n", __func__, __LINE__);
+		aw8697->duration = 3000;
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+	if (aw8697->test_val == 2) {
+		printk("%s  %d  \n", __func__, __LINE__);
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_set_wav_seq(aw8697, 0x00, 0x01);
+		aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x01);
+
+		/*step 1:  choose  loop */
+		aw8697_haptic_set_wav_loop(aw8697, 0x01, 0x01);
+		mutex_unlock(&aw8697->lock);
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	if (aw8697->test_val == 3) { /*Ram instead of Cont */
+		aw8697->duration = 10000;
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	if (aw8697->test_val == 4) {
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_stop(aw8697);
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+
+		aw8697_haptic_set_wav_seq(aw8697, 0x00, 0x01);
+		aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+
+		aw8697_haptic_set_wav_loop(aw8697, 0x01, 0x01);
+
+		if (aw8697->info.bst_vol_ram <= AW8697_MAX_BST_VO)
+			aw8697_haptic_set_bst_vol(aw8697,
+						  aw8697->info.bst_vol_ram);
+		else
+			aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+		aw8697->state = 1;
+		mutex_unlock(&aw8697->lock);
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	return count;
+}
+#ifdef ENABLE_PIN_CONTROL
+static int select_pin_ctl(struct aw8697 *aw8697, const char *name)
+{
+	size_t i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(aw8697->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+
+		if (!strncmp(n, name, strlen(n))) {
+			rc = pinctrl_select_state(aw8697->aw8697_pinctrl,
+						  aw8697->pinctrl_state[i]);
+			if (rc)
+				printk("cannot select '%s'\n", name);
+			else
+				printk("Selected '%s'\n", name);
+			goto exit;
+		}
+	}
+
+	rc = -EINVAL;
+	printk("%s:'%s' not found\n", __func__, name);
+
+exit:
+	return rc;
+}
+static int aw8697_set_interrupt(struct aw8697 *aw8697)
+{
+	int rc = select_pin_ctl(aw8697, "aw8697_interrupt_active");
+	return rc;
+}
+#endif
+
+static int aw8697_hw_reset(struct aw8697 *aw8697)
+{
+#ifdef ENABLE_PIN_CONTROL
+	int rc = select_pin_ctl(aw8697, "aw8697_reset_active");
+	msleep(5);
+	rc = select_pin_ctl(aw8697, "aw8697_reset_reset");
+	msleep(5);
+	rc = select_pin_ctl(aw8697, "aw8697_reset_active");
+	msleep(3);
+#endif
+	if (!aw8697->enable_pin_control) {
+		if (aw8697 && gpio_is_valid(aw8697->reset_gpio)) {
+			gpio_set_value_cansleep(aw8697->reset_gpio, 0);
+			printk("%s pull down1\n", __func__);
+			msleep(5);
+			gpio_set_value_cansleep(aw8697->reset_gpio, 1);
+			printk("%s pull up1\n", __func__);
+			msleep(5);
+		} else {
+			dev_err(aw8697->dev, "%s:  failed\n", __func__);
+		}
+	}
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * check chip id
+ *
+ *****************************************************/
+static int aw8697_read_chipid(struct aw8697 *aw8697)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+	unsigned char reg = 0;
+
+	while (cnt < AW_READ_CHIPID_RETRIES) {
+		/* hardware reset */
+		aw8697_hw_reset(aw8697);
+
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_ID, &reg);
+		if (ret < 0) {
+			dev_err(aw8697->dev,
+				"%s: failed to read register AW8697_REG_ID: %d\n",
+				__func__, ret);
+		}
+		switch (reg) {
+		case AW8695_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw8695 detected\n",
+				    __func__);
+			aw8697->chipid = AW8695_CHIPID;
+			aw8697->chip_version = AW8697_CHIP_9X;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW8697_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw8697 detected\n",
+				    __func__);
+			aw8697->chipid = AW8697_CHIPID;
+			aw8697->chip_version = AW8697_CHIP_9X;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86905_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86905 detected\n",
+				    __func__);
+			aw8697->chipid = AW86905_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L1;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86907_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86907 detected\n",
+				    __func__);
+			aw8697->chipid = AW86907_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L2;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86915_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86915 detected\n",
+				    __func__);
+			aw8697->chipid = AW86915_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L1;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86917_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86917 detected\n",
+				    __func__);
+			aw8697->chipid = AW86917_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L2;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		default:
+			pr_info("%s unsupported device revision (0x%x)\n",
+				__func__, reg);
+			break;
+		}
+		cnt++;
+
+		msleep(AW_READ_CHIPID_RETRY_DELAY);
+	}
+
+	return -EINVAL;
+}
+
+/******************************************************
+ *
+ * sys group attribute: reg
+ *
+ ******************************************************/
+static ssize_t aw8697_i2c_reg_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		aw8697_i2c_write(aw8697, (unsigned char)databuf[0],
+				 (unsigned char)databuf[1]);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_i2c_reg_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		for (i = 0; i < AW8697_REG_MAX; i++) {
+			if (!(aw8697_reg_access[i] & REG_RD_ACCESS))
+				continue;
+			aw8697_i2c_read(aw8697, i, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02x=0x%02x\n", i, reg_val);
+		}
+	} else {
+		for (i = 0; i < AW869XX_REG_MAX; i++) {
+			if (!(aw869xx_reg_access[i] & REG_RD_ACCESS))
+				continue;
+			aw8697_i2c_read(aw8697, i, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02x=0x%02x\n", i, reg_val);
+		}
+	}
+	return len;
+}
+
+static ssize_t aw8697_i2c_ram_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	unsigned int databuf[1] = { 0 };
+
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		if (1 == databuf[0]) {
+			aw8697_ram_update(aw8697);
+		}
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_i2c_ram_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_haptic_stop(aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRH,
+				 (unsigned char)(aw8697->ram.base_addr >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRL,
+				 (unsigned char)(aw8697->ram.base_addr &
+						 0x00ff));
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"aw8697_haptic_ram:\n");
+		for (i = 0; i < aw8697->ram.len; i++) {
+			aw8697_i2c_read(aw8697, AW8697_REG_RAMDATA, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x,",
+					reg_val);
+		}
+	} else {
+		aw8697_i2c_write_bits(
+			aw8697, AW869XX_REG_RAMADDRH, AW869XX_BIT_RAMADDRH_MASK,
+			(unsigned char)(aw8697->ram.base_addr >> 8));
+		aw8697_i2c_write(aw8697, AW869XX_REG_RAMADDRH,
+				 (unsigned char)(aw8697->ram.base_addr &
+						 0x00ff));
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"aw8697_haptic_ram:\n");
+		for (i = 0; i < aw8697->ram.len; i++) {
+			aw8697_i2c_read(aw8697, AW869XX_REG_RAMDATA, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x,",
+					reg_val);
+		}
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+
+	return len;
+}
+
+static ssize_t aw8697_duration_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ktime_t time_rem;
+	s64 time_ms = 0;
+
+	if (hrtimer_active(&aw8697->timer)) {
+		time_rem = hrtimer_get_remaining(&aw8697->timer);
+		time_ms = ktime_to_ms(time_rem);
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%lld\n", time_ms);
+}
+
+static ssize_t aw8697_duration_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	/* setting 0 on duration is NOP for now */
+	if (val <= 0)
+		return count;
+
+	aw8697->duration = val;
+
+	return count;
+}
+
+static ssize_t aw8697_activate_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->state);
+}
+
+static ssize_t aw8697_activate_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+	;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val != 0 && val != 1)
+		return count;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	hrtimer_cancel(&aw8697->timer);
+
+	aw8697->state = val;
+
+	mutex_unlock(&aw8697->lock);
+	//schedule_work(&aw8697->vibrator_work);
+	queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+
+	return count;
+}
+
+static ssize_t aw8697_activate_mode_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "activate_mode=%d\n",
+			aw8697->activate_mode);
+}
+
+static ssize_t aw8697_activate_mode_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697->activate_mode = val;
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_index_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned char reg_val = 0;
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1, &reg_val);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1, &reg_val);
+	}
+	aw8697->index = reg_val;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->index);
+}
+
+static ssize_t aw8697_index_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->index = val;
+	aw8697_haptic_set_repeat_wav_seq(aw8697, aw8697->index);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_vmax_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw8697->vmax);
+}
+
+static ssize_t aw8697_vmax_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->vmax = val;
+	aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_gain_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw8697->gain);
+}
+
+static ssize_t aw8697_gain_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->gain = val;
+	aw8697_haptic_set_gain(aw8697, aw8697->gain);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_seq_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char AW_REG_CURRENT = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		AW_REG_CURRENT = AW8697_REG_WAVSEQ1;
+	} else {
+		AW_REG_CURRENT = AW869XX_REG_WAVCFG1;
+	}
+
+	for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+		aw8697_i2c_read(aw8697, AW_REG_CURRENT + i, &reg_val);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d: 0x%02x\n", i + 1, reg_val);
+		aw8697->seq[i] |= reg_val;
+	}
+	return count;
+}
+
+static ssize_t aw8697_seq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		pr_debug("%s: seq%d=0x%x\n", __FUNCTION__, databuf[0],
+			 databuf[1]);
+		mutex_lock(&aw8697->lock);
+		aw8697->seq[databuf[0]] = (unsigned char)databuf[1];
+		aw8697_haptic_set_wav_seq(aw8697, (unsigned char)databuf[0],
+					  aw8697->seq[databuf[0]]);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_loop_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char AW_REG_CURRENT = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		AW_REG_CURRENT = AW8697_REG_WAVLOOP1;
+	} else {
+		AW_REG_CURRENT = AW869XX_REG_WAVCFG9;
+	}
+	for (i = 0; i < AW8697_SEQUENCER_LOOP_SIZE; i++) {
+		aw8697_i2c_read(aw8697, AW_REG_CURRENT + i, &reg_val);
+		aw8697->loop[i * 2 + 0] = (reg_val >> 4) & 0x0F;
+		aw8697->loop[i * 2 + 1] = (reg_val >> 0) & 0x0F;
+
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 1,
+				  aw8697->loop[i * 2 + 0]);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 2,
+				  aw8697->loop[i * 2 + 1]);
+	}
+	return count;
+}
+
+static ssize_t aw8697_loop_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		pr_debug("%s: seq%d loop=0x%x\n", __FUNCTION__, databuf[0],
+			 databuf[1]);
+		mutex_lock(&aw8697->lock);
+		aw8697->loop[databuf[0]] = (unsigned char)databuf[1];
+		aw8697_haptic_set_wav_loop(aw8697, (unsigned char)databuf[0],
+					   aw8697->loop[databuf[0]]);
+		mutex_unlock(&aw8697->lock);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_rtp_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "rtp play: %d\n",
+			aw8697->rtp_cnt);
+
+	return len;
+}
+
+static ssize_t aw8697_rtp_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_set_rtp_aei(aw8697, false);
+	aw8697_interrupt_clear(aw8697);
+	if (val < (sizeof(aw8697_rtp_name) / AW8697_RTP_NAME_MAX)) {
+		aw8697->rtp_file_num = val;
+		if (val) {
+			//schedule_work(&aw8697->rtp_work);
+			queue_work(aw8697->work_queue, &aw8697->rtp_work);
+		}
+	} else {
+		pr_err("%s: rtp_file_num 0x%02x over max value \n", __func__,
+		       aw8697->rtp_file_num);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_ram_update_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	//struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "sram update mode\n");
+	return len;
+}
+
+static ssize_t aw8697_ram_update_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val) {
+		aw8697_ram_update(aw8697);
+	}
+	return count;
+}
+
+static ssize_t aw8697_f0_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+#ifdef RETRY_F0_CHECK
+	unsigned int f0_cnt_time = 0;
+#endif
+
+	mutex_lock(&aw8697->lock);
+	aw8697->f0_cali_flag = AW8697_HAPTIC_LRA_F0;
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_f0(aw8697);
+#ifdef RETRY_F0_CHECK
+		f0_cnt_time = 1;
+		if ((f0_cnt_time == 1) && (aw8697->f0 == 0)) {
+			aw8697_haptic_get_f0(aw8697);
+			f0_cnt_time = 0;
+		}
+#endif
+	} else {
+		aw869xx_haptic_cont_get_f0(aw8697);
+#ifdef RETRY_F0_CHECK
+		f0_cnt_time = 1;
+		if ((f0_cnt_time == 1) && (aw8697->f0 == 0)) {
+			aw8697_haptic_get_f0(aw8697);
+			f0_cnt_time = 0;
+		}
+#endif
+	}
+	mutex_unlock(&aw8697->lock);
+	len +=
+		//snprintf(buf + len, PAGE_SIZE - len, "aw8697 lra f0 = %d\n",
+		snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw8697->f0);
+	return len;
+}
+
+static ssize_t aw8697_f0_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	return count;
+}
+
+static ssize_t aw8697_cali_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	mutex_lock(&aw8697->lock);
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+	aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_f0(aw8697);
+	} else {
+		aw869xx_haptic_cont_get_f0(aw8697);
+	}
+
+	mutex_unlock(&aw8697->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw8697 cali f0 = %d\n",
+			aw8697->f0);
+	return len;
+}
+
+static ssize_t aw8697_cali_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val) {
+		mutex_lock(&aw8697->lock);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_f0_calibration(aw8697);
+		} else {
+			aw869xx_haptic_f0_calibration(aw8697);
+		}
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_read_cont_f0(aw8697);
+	} else {
+		aw869xx_haptic_read_cont_f0(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw8697 cont f0 = %d\n",
+			aw8697->cont_f0);
+	return len;
+}
+
+static ssize_t aw8697_cont_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697_haptic_stop(aw8697);
+	if (val) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_cont(aw8697);
+		} else {
+			aw869xx_haptic_cont(aw8697);
+		}
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_td_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont delay time = 0x%04x\n",
+			aw8697->info.cont_td);
+	return len;
+}
+
+static ssize_t aw8697_cont_td_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		aw8697->info.cont_td = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_TD_H,
+				 (unsigned char)(databuf[0] >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_TD_L,
+				 (unsigned char)(databuf[0] >> 0));
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_drv_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont drv level = %d\n",
+			aw8697->info.cont_drv_lvl);
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont drv level overdrive= %d\n",
+			aw8697->info.cont_drv_lvl_ov);
+	return len;
+}
+
+static ssize_t aw8697_cont_drv_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	if (2 == sscanf(buf, "%d %d", &databuf[0], &databuf[1])) {
+		aw8697->info.cont_drv_lvl = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL,
+				 aw8697->info.cont_drv_lvl);
+		aw8697->info.cont_drv_lvl_ov = databuf[1];
+		aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+				 aw8697->info.cont_drv_lvl_ov);
+	}
+	return count;
+}
+
+//return buffer size and availbe size
+static ssize_t aw8697_custom_wave_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "period_size=%d;",
+			aw8697->ram.base_addr >> 2);
+	len += snprintf(buf + len, PAGE_SIZE - len, "max_size=%d;free_size=%d;",
+			get_rb_max_size(), get_rb_free_size());
+	len += snprintf(buf + len, PAGE_SIZE - len, "custom_wave_id=%d;",
+			CUSTOME_WAVE_ID);
+	return len;
+}
+
+static ssize_t aw8697_custom_wave_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned long buf_len, period_size, offset;
+	int ret;
+	period_size = (aw8697->ram.base_addr >> 2);
+	offset = 0;
+	pr_debug(" write szie %d, period size %d", count, period_size);
+	if (count % period_size || count < period_size)
+		rb_end();
+	atomic_set(&aw8697->is_in_write_loop, 1);
+
+	while (count > 0) {
+		buf_len = min(count, period_size);
+		ret = write_rb(buf + offset, buf_len);
+		if (ret < 0)
+			goto exit;
+		count -= buf_len;
+		offset += buf_len;
+	}
+	ret = offset;
+exit:
+	atomic_set(&aw8697->is_in_write_loop, 0);
+	wake_up_interruptible(&aw8697->stop_wait_q);
+	pr_debug(" return size %d", ret);
+	return ret;
+}
+
+static ssize_t aw8697_cont_num_brk_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont break num = %d\n",
+			aw8697->info.cont_num_brk);
+	return len;
+}
+
+static ssize_t aw8697_cont_num_brk_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%d", &databuf[0])) {
+		aw8697->info.cont_num_brk = databuf[0];
+		if (aw8697->info.cont_num_brk > 7) {
+			aw8697->info.cont_num_brk = 7;
+		}
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_BEMF_NUM,
+				      AW8697_BIT_BEMF_NUM_BRK_MASK,
+				      aw8697->info.cont_num_brk);
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_zc_thr_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont zero cross thr = 0x%04x\n",
+			aw8697->info.cont_zc_thr);
+	return len;
+}
+
+static ssize_t aw8697_cont_zc_thr_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		aw8697->info.cont_zc_thr = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_H,
+				 (unsigned char)(databuf[0] >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_L,
+				 (unsigned char)(databuf[0] >> 0));
+	}
+	return count;
+}
+
+static ssize_t aw8697_vbat_monitor_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	mutex_lock(&aw8697->lock);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_stop(aw8697);
+		aw8697_haptic_get_vbat(aw8697);
+	} else {
+		aw869xx_haptic_get_vbat(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "vbat=%dmV\n",
+			aw8697->vbat);
+	mutex_unlock(&aw8697->lock);
+
+	return len;
+}
+
+static ssize_t aw8697_vbat_monitor_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw8697_lra_resistance_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_lra_resistance(aw8697);
+	} else {
+		aw869xx_haptic_get_lra_resistance(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw8697->lra);
+
+	return len;
+}
+
+static ssize_t aw8697_lra_resistance_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw8697_auto_boost_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "auto_boost=%d\n",
+			aw8697->auto_boost);
+
+	return len;
+}
+
+static ssize_t aw8697_auto_boost_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_auto_boost_config(aw8697, val);
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_prctmode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "prctmode=%d\n",
+				reg_val & 0x20);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG1, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "prctmode = %d\n",
+				reg_val & 0x08);
+	}
+	return len;
+}
+
+static ssize_t aw8697_prctmode_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	unsigned int addr = 0;
+	unsigned int val = 0;
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		addr = databuf[0];
+		val = databuf[1];
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_swicth_motorprotect_config(aw8697, addr, val);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_trig_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char i = 0;
+	for (i = 0; i < AW8697_TRIG_NUM; i++) {
+		len += snprintf(
+			buf + len, PAGE_SIZE - len,
+			"trig%d: enable=%d, default_level=%d, dual_edge=%d, frist_seq=%d, second_seq=%d\n",
+			i + 1, aw8697->trig[i].enable,
+			aw8697->trig[i].default_level,
+			aw8697->trig[i].dual_edge, aw8697->trig[i].frist_seq,
+			aw8697->trig[i].second_seq);
+	}
+
+	return len;
+}
+
+static ssize_t aw8697_trig_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[6] = { 0 };
+	if (sscanf(buf, "%d %d %d %d %d %d", &databuf[0], &databuf[1],
+		   &databuf[2], &databuf[3], &databuf[4], &databuf[5])) {
+		pr_debug("%s: %d, %d, %d, %d, %d, %d\n", __func__, databuf[0],
+			 databuf[1], databuf[2], databuf[3], databuf[4],
+			 databuf[5]);
+		if (databuf[0] > 3) {
+			databuf[0] = 3;
+		}
+		if (databuf[0] > 0) {
+			databuf[0] -= 1;
+		}
+		aw8697->trig[databuf[0]].enable = databuf[1];
+		aw8697->trig[databuf[0]].default_level = databuf[2];
+		aw8697->trig[databuf[0]].dual_edge = databuf[3];
+		aw8697->trig[databuf[0]].frist_seq = databuf[4];
+		aw8697->trig[databuf[0]].second_seq = databuf[5];
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_trig_param_config(aw8697);
+		aw8697_haptic_trig_enable_config(aw8697);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_ram_vbat_comp_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_vbat_comp=%d\n",
+			aw8697->ram_vbat_comp);
+
+	return len;
+}
+
+static ssize_t aw8697_ram_vbat_comp_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	if (val) {
+		aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	} else {
+		aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	}
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_osc_cali_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw8697->lra_calib_data);
+
+	return len;
+}
+
+static ssize_t aw8697_osc_cali_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	/*osc calibration flag start,Other behaviors are forbidden*/
+	aw8697->osc_cali_run = 1;
+	if (val == 3) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_rtp_osc_calibration(aw8697);
+			aw8697_rtp_trim_lra_calibration(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_D2SCFG1,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+			aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+			aw869xx_rtp_osc_calibration(aw8697);
+			aw869xx_rtp_trim_lra_calibration(aw8697);
+		}
+	}
+	if (val == 1) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_rtp_osc_calibration(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_D2SCFG1,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+			aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+			aw869xx_rtp_osc_calibration(aw8697);
+		}
+	}
+
+	aw8697->osc_cali_run = 0;
+	/*osc calibration flag end,Other behaviors are permitted*/
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_osc_save_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	pr_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw8697->lra_calib_data = val;
+	pr_info("%s load osa cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw8697_f0_save_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw8697->f0_calib_data);
+
+	return len;
+}
+
+static ssize_t aw8697_f0_save_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	pr_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw8697->f0_calib_data = val;
+	pr_info("%s load f0 cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw8697_f0_value_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->f0);
+}
+
+static ssize_t aw8697_f0_check_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->f0_cali_status == true)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 1);
+	if (aw8697->f0_cali_status == false)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 0);
+
+	return len;
+}
+
+#ifdef SUPPORT_RELOAD_FW
+static ssize_t aw8697_vov_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x\n",
+			aw8697->info.bst_vol_ram);
+
+	return len;
+}
+
+static ssize_t aw8697_vov_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val == 1) {
+		aw8697->vov = 1;
+		aw8697->info.bst_vol_ram = 0x10;
+		pr_info("set ux value: 0x%02x, update ram\n",
+			aw8697->info.bst_vol_ram);
+		aw8697->ram_name = aw8697_ram_name_a;
+		queue_delayed_work(aw8697->work_queue, &aw8697->ram_work,
+				   msecs_to_jiffies(5000));
+	}
+
+	return count;
+}
+#endif
+
+static ssize_t aw869xx_cont_wait_num_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_wait_num = 0x%02X\n",
+			aw8697->info.cont_wait_num);
+	return len;
+}
+
+static ssize_t aw869xx_cont_wait_num_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+
+	if (sscanf(buf, "%x", &databuf[0]) == 1) {
+		aw8697->info.cont_wait_num = databuf[0];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG4,
+				 aw8697->info.cont_wait_num);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_drv_lvl_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_lvl = 0x%02X, cont_drv2_lvl = 0x%02X\n",
+			aw8697->info.cont_drv1_lvl, aw8697->info.cont_drv2_lvl);
+	return len;
+}
+
+static ssize_t aw869xx_cont_drv_lvl_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw8697->info.cont_drv1_lvl = databuf[0];
+		aw8697->info.cont_drv2_lvl = databuf[1];
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+				      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+				      aw8697->info.cont_drv1_lvl);
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+				 aw8697->info.cont_drv2_lvl);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_drv_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_time = 0x%02X, cont_drv2_time = 0x%02X\n",
+			aw8697->info.cont_drv1_time,
+			aw8697->info.cont_drv2_time);
+	return len;
+}
+
+static ssize_t aw869xx_cont_drv_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw8697->info.cont_drv1_time = databuf[0];
+		aw8697->info.cont_drv2_time = databuf[1];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8,
+				 aw8697->info.cont_drv1_time);
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9,
+				 aw8697->info.cont_drv2_time);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_brk_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_brk_time = 0x%02X\n",
+			aw8697->info.cont_brk_time);
+	return len;
+}
+
+static ssize_t aw869xx_cont_brk_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+
+	if (sscanf(buf, "%x", &databuf[0]) == 1) {
+		aw8697->info.cont_brk_time = databuf[0];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG10,
+				 aw8697->info.cont_brk_time);
+	}
+	return count;
+}
+
+/* common */
+static DEVICE_ATTR(effect_id, S_IWUSR | S_IRUGO, aw8697_effect_id_show,
+		   aw8697_effect_id_store);
+static DEVICE_ATTR(bst_vol, S_IWUSR | S_IRUGO, aw8697_bst_vol_show,
+		   aw8697_bst_vol_store);
+static DEVICE_ATTR(activate_test, S_IWUSR | S_IRUGO, aw8697_activate_test_show,
+		   aw8697_activate_test_store);
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO, aw8697_i2c_reg_show,
+		   aw8697_i2c_reg_store);
+static DEVICE_ATTR(ram, S_IWUSR | S_IRUGO, aw8697_i2c_ram_show,
+		   aw8697_i2c_ram_store);
+static DEVICE_ATTR(duration, S_IWUSR | S_IRUGO, aw8697_duration_show,
+		   aw8697_duration_store);
+static DEVICE_ATTR(activate, S_IWUSR | S_IRUGO, aw8697_activate_show,
+		   aw8697_activate_store);
+static DEVICE_ATTR(activate_mode, S_IWUSR | S_IRUGO, aw8697_activate_mode_show,
+		   aw8697_activate_mode_store);
+static DEVICE_ATTR(index, S_IWUSR | S_IRUGO, aw8697_index_show,
+		   aw8697_index_store);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO, aw8697_vmax_show,
+		   aw8697_vmax_store);
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO, aw8697_gain_show,
+		   aw8697_gain_store);
+static DEVICE_ATTR(seq, S_IWUSR | S_IRUGO, aw8697_seq_show, aw8697_seq_store);
+static DEVICE_ATTR(loop, S_IWUSR | S_IRUGO, aw8697_loop_show,
+		   aw8697_loop_store);
+static DEVICE_ATTR(rtp, S_IWUSR | S_IRUGO, aw8697_rtp_show, aw8697_rtp_store);
+static DEVICE_ATTR(ram_update, S_IWUSR | S_IRUGO, aw8697_ram_update_show,
+		   aw8697_ram_update_store);
+static DEVICE_ATTR(f0, S_IWUSR | S_IRUGO, aw8697_f0_show, aw8697_f0_store);
+static DEVICE_ATTR(cali, S_IWUSR | S_IRUGO, aw8697_cali_show,
+		   aw8697_cali_store);
+static DEVICE_ATTR(cont, S_IWUSR | S_IRUGO, aw8697_cont_show,
+		   aw8697_cont_store);
+static DEVICE_ATTR(vbat_monitor, S_IWUSR | S_IRUGO, aw8697_vbat_monitor_show,
+		   aw8697_vbat_monitor_store);
+static DEVICE_ATTR(lra_resistance, S_IWUSR | S_IRUGO,
+		   aw8697_lra_resistance_show, aw8697_lra_resistance_store);
+static DEVICE_ATTR(auto_boost, S_IWUSR | S_IRUGO, aw8697_auto_boost_show,
+		   aw8697_auto_boost_store);
+static DEVICE_ATTR(prctmode, S_IWUSR | S_IRUGO, aw8697_prctmode_show,
+		   aw8697_prctmode_store);
+static DEVICE_ATTR(trig, S_IWUSR | S_IRUGO, aw8697_trig_show,
+		   aw8697_trig_store);
+static DEVICE_ATTR(ram_vbat_comp, S_IWUSR | S_IRUGO, aw8697_ram_vbat_comp_show,
+		   aw8697_ram_vbat_comp_store);
+static DEVICE_ATTR(osc_cali, S_IWUSR | S_IRUGO, aw8697_osc_cali_show,
+		   aw8697_osc_cali_store);
+static DEVICE_ATTR(f0_check, S_IWUSR | S_IRUGO, aw8697_f0_check_show, NULL);
+static DEVICE_ATTR(f0_save, S_IWUSR | S_IRUGO, aw8697_f0_save_show,
+		   aw8697_f0_save_store);
+static DEVICE_ATTR(osc_save, S_IWUSR | S_IRUGO, aw8697_osc_cali_show,
+		   aw8697_osc_save_store);
+static DEVICE_ATTR(f0_value, S_IRUGO, aw8697_f0_value_show, NULL);
+static DEVICE_ATTR(custom_wave, S_IWUSR | S_IRUGO, aw8697_custom_wave_show,
+		   aw8697_custom_wave_store);
+#ifdef SUPPORT_RELOAD_FW
+static DEVICE_ATTR(vov, S_IWUSR | S_IRUGO, aw8697_vov_show, aw8697_vov_store);
+#endif
+
+/* aw869x */
+static DEVICE_ATTR(cont_td, S_IWUSR | S_IRUGO, aw8697_cont_td_show,
+		   aw8697_cont_td_store);
+static DEVICE_ATTR(cont_drv, S_IWUSR | S_IRUGO, aw8697_cont_drv_show,
+		   aw8697_cont_drv_store);
+static DEVICE_ATTR(cont_num_brk, S_IWUSR | S_IRUGO, aw8697_cont_num_brk_show,
+		   aw8697_cont_num_brk_store);
+static DEVICE_ATTR(cont_zc_thr, S_IWUSR | S_IRUGO, aw8697_cont_zc_thr_show,
+		   aw8697_cont_zc_thr_store);
+
+/* aw869xx */
+static DEVICE_ATTR(cont_wait_num, S_IWUSR | S_IRUGO, aw869xx_cont_wait_num_show,
+		   aw869xx_cont_wait_num_store);
+static DEVICE_ATTR(cont_drv_lvl, S_IWUSR | S_IRUGO, aw869xx_cont_drv_lvl_show,
+		   aw869xx_cont_drv_lvl_store);
+static DEVICE_ATTR(cont_drv_time, S_IWUSR | S_IRUGO, aw869xx_cont_drv_time_show,
+		   aw869xx_cont_drv_time_store);
+static DEVICE_ATTR(cont_brk_time, S_IWUSR | S_IRUGO, aw869xx_cont_brk_time_show,
+		   aw869xx_cont_brk_time_store);
+
+static struct attribute *aw8697_vibrator_attributes[] = {
+	&dev_attr_reg.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_activate_test.attr,
+	&dev_attr_effect_id.attr,
+	&dev_attr_bst_vol.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_td.attr,
+	&dev_attr_cont_drv.attr,
+	&dev_attr_cont_num_brk.attr,
+	&dev_attr_cont_zc_thr.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_trig.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_f0_check.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_custom_wave.attr,
+#ifdef SUPPORT_RELOAD_FW
+	&dev_attr_vov.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group aw8697_vibrator_attribute_group = {
+	.attrs = aw8697_vibrator_attributes
+};
+
+static struct attribute *aw869xx_vibrator_attributes[] = {
+	&dev_attr_activate_test.attr,
+	&dev_attr_effect_id.attr,
+	&dev_attr_bst_vol.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_wait_num.attr,
+	&dev_attr_cont_drv_lvl.attr,
+	&dev_attr_cont_drv_time.attr,
+	&dev_attr_cont_brk_time.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_f0_value.attr,
+	NULL
+};
+
+static struct attribute_group aw869xx_vibrator_attribute_group = {
+	.attrs = aw869xx_vibrator_attributes
+};
+
+/******************************************************
+ *
+ * i2c driver
+ *
+ ******************************************************/
+static int aw8697_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct aw8697 *aw8697;
+	struct input_dev *input_dev;
+	int rc = 0, effect_count_max;
+	struct ff_device *ff;
+	struct device_node *np = i2c->dev.of_node;
+	int irq_flags = 0;
+	int ret = -1;
+	unsigned char reg = 0;
+#ifdef ENABLE_PIN_CONTROL
+	int i;
+#endif
+
+	pr_info("%s enter\n", __func__);
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C)) {
+		dev_err(&i2c->dev, "check_functionality failed\n");
+		return -EIO;
+	}
+
+	aw8697 = devm_kzalloc(&i2c->dev, sizeof(struct aw8697), GFP_KERNEL);
+	if (aw8697 == NULL)
+		return -ENOMEM;
+
+	input_dev = devm_input_allocate_device(&i2c->dev);
+	if (!input_dev)
+		return -ENOMEM;
+
+	aw8697->dev = &i2c->dev;
+	aw8697->i2c = i2c;
+	device_init_wakeup(aw8697->dev, true);
+	i2c_set_clientdata(i2c, aw8697);
+
+	/* aw8697 rst & int */
+	if (np) {
+		ret = aw8697_parse_dt_common(&i2c->dev, aw8697, np);
+		printk("%s ---%d \n", __func__, __LINE__);
+		if (ret) {
+			dev_err(&i2c->dev,
+				"%s: failed to parse common device tree node\n",
+				__func__);
+			goto err_parse_dt_common;
+		}
+	} else {
+		aw8697->reset_gpio = -1;
+		aw8697->irq_gpio = -1;
+	}
+	aw8697->enable_pin_control = 0;
+#ifdef ENABLE_PIN_CONTROL
+	aw8697->aw8697_pinctrl = devm_pinctrl_get(&i2c->dev);
+	if (IS_ERR(aw8697->aw8697_pinctrl)) {
+		if (PTR_ERR(aw8697->aw8697_pinctrl) == -EPROBE_DEFER) {
+			printk("pinctrl not ready\n");
+			rc = -EPROBE_DEFER;
+			return rc;
+		}
+		printk("Target does not use pinctrl\n");
+		aw8697->aw8697_pinctrl = NULL;
+		rc = -EINVAL;
+		return rc;
+	}
+	for (i = 0; i < ARRAY_SIZE(aw8697->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+		struct pinctrl_state *state =
+			pinctrl_lookup_state(aw8697->aw8697_pinctrl, n);
+		if (IS_ERR(state)) {
+			printk("cannot find '%s'\n", n);
+			rc = -EINVAL;
+			//goto exit;
+		}
+		printk("found pin control %s\n", n);
+		aw8697->pinctrl_state[i] = state;
+		aw8697->enable_pin_control = 1;
+		aw8697_set_interrupt(aw8697);
+	}
+#endif
+	printk("%s ---%d \n", __func__, __LINE__);
+	if (!aw8697->enable_pin_control) {
+		if (gpio_is_valid(aw8697->reset_gpio)) {
+			ret = devm_gpio_request_one(&i2c->dev,
+						    aw8697->reset_gpio,
+						    GPIOF_OUT_INIT_LOW,
+						    "aw8697_rst");
+			if (ret) {
+				dev_err(&i2c->dev, "%s: rst request failed\n",
+					__func__);
+				goto err_reset_gpio_request;
+			}
+		}
+	}
+
+	if (gpio_is_valid(aw8697->irq_gpio)) {
+		ret = devm_gpio_request_one(&i2c->dev, aw8697->irq_gpio,
+					    GPIOF_DIR_IN, "aw8697_int");
+		if (ret) {
+			dev_err(&i2c->dev, "%s: int request failed\n",
+				__func__);
+			goto err_irq_gpio_request;
+		}
+	}
+
+	ret = aw8697_read_chipid(aw8697);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "%s: aw8697_read_chipid failed ret=%d\n",
+			__func__, ret);
+		goto err_id;
+	}
+	/* aw869xx chip qualify */
+	if (aw8697->chip_version == AW8697_CHIP_9XX) {
+		ret = aw8697_i2c_read(aw8697, 0x64, &reg);
+		if (ret < 0) {
+			aw_dev_err(&i2c->dev,
+				   "%s: failed to read register 0x64: %d\n",
+				   __func__, ret);
+		}
+		if (!(reg & 0x80)) {
+			aw_dev_err(&i2c->dev, "%s: error! unqualified chip!\n",
+				   __func__);
+			goto err_qualify;
+		}
+	}
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = aw8697_parse_dt_attr(&i2c->dev, aw8697, np);
+	} else {
+		ret = aw869xx_parse_dt_attr(&i2c->dev, aw8697, np);
+	}
+	aw_dev_info(aw8697->dev, "%s %d\n", __func__, __LINE__);
+	if (ret) {
+		aw_dev_err(&i2c->dev, "%s: failed to parse device tree node\n",
+			   __func__);
+		goto err_parse_dt_attr;
+	}
+
+	if (gpio_is_valid(aw8697->irq_gpio) &&
+	    !(aw8697->flags & AW8697_FLAG_SKIP_INTERRUPTS)) {
+		/* register irq handler */
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_interrupt_setup(aw8697);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev, gpio_to_irq(aw8697->irq_gpio), NULL,
+				aw8697_irq, irq_flags, "aw8697", aw8697);
+			if (ret != 0) {
+				aw_dev_err(&i2c->dev,
+					   "%s: failed to request IRQ %d: %d\n",
+					   __func__,
+					   gpio_to_irq(aw8697->irq_gpio), ret);
+				goto err_irq;
+			}
+		} else {
+			aw869xx_interrupt_setup(aw8697);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev, gpio_to_irq(aw8697->irq_gpio), NULL,
+				aw869xx_irq, irq_flags, "aw8697", aw8697);
+			if (ret != 0) {
+				aw_dev_err(&i2c->dev,
+					   "%s: failed to request IRQ %d: %d\n",
+					   __func__,
+					   gpio_to_irq(aw8697->irq_gpio), ret);
+				goto err_irq;
+			}
+		}
+	} else {
+		dev_info(&i2c->dev, "%s skipping IRQ registration\n", __func__);
+		/* disable feature support if gpio was invalid */
+		aw8697->flags |= AW8697_FLAG_SKIP_INTERRUPTS;
+	}
+
+	hrtimer_init(&aw8697->stop_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw8697->stop_timer.function = qti_hap_stop_timer;
+	hrtimer_init(&aw8697->hap_disable_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw8697->hap_disable_timer.function = qti_hap_disable_timer;
+
+	input_dev->name = AW8697_HAPTIC_NAME;
+	input_set_drvdata(input_dev, aw8697);
+	aw8697->input_dev = input_dev;
+	input_set_capability(input_dev, EV_FF, FF_CONSTANT);
+	input_set_capability(input_dev, EV_FF, FF_GAIN);
+	if (aw8697->effects_count != 0) {
+		input_set_capability(input_dev, EV_FF, FF_PERIODIC);
+		input_set_capability(input_dev, EV_FF, FF_CUSTOM);
+	}
+
+	if (aw8697->effects_count + 1 > FF_EFFECT_COUNT_MAX)
+		effect_count_max = aw8697->effects_count + 1;
+	else
+		effect_count_max = FF_EFFECT_COUNT_MAX;
+	rc = input_ff_create(input_dev, effect_count_max);
+	if (rc < 0) {
+		dev_err(aw8697->dev, "create FF input device failed, rc=%d\n",
+			rc);
+		return rc;
+	}
+	aw8697->work_queue =
+		create_singlethread_workqueue("aw8976_vibrator_work_queue");
+	if (!aw8697->work_queue) {
+		dev_err(&i2c->dev,
+			"%s: Error creating aw8976_vibrator_work_queue\n",
+			__func__);
+		goto err_sysfs;
+	}
+	INIT_WORK(&aw8697->set_gain_work, set_gain);
+	aw8697_vibrator_init(aw8697);
+	aw8697_haptic_init(aw8697);
+	aw8697_ram_init(aw8697);
+
+	ff = input_dev->ff;
+	ff->upload = aw8697_haptics_upload_effect;
+	ff->playback = aw8697_haptics_playback;
+	ff->erase = aw8697_haptics_erase;
+	ff->set_gain = aw8697_haptics_set_gain;
+	rc = input_register_device(input_dev);
+	if (rc < 0) {
+		dev_err(aw8697->dev, "register input device failed, rc=%d\n",
+			rc);
+		goto destroy_ff;
+	}
+
+	dev_set_drvdata(&i2c->dev, aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = sysfs_create_group(&i2c->dev.kobj,
+					 &aw8697_vibrator_attribute_group);
+	} else {
+		ret = sysfs_create_group(&i2c->dev.kobj,
+					 &aw869xx_vibrator_attribute_group);
+	}
+	if (ret < 0) {
+		dev_info(&i2c->dev, "%s error creating sysfs attr files\n",
+			 __func__);
+		goto err_sysfs;
+	}
+
+	g_aw8697 = aw8697;
+
+	ret = create_rb();
+	if (ret < 0) {
+		dev_info(&i2c->dev, "%s error creating ringbuffer\n", __func__);
+		goto err_rb;
+	}
+
+	CUSTOME_WAVE_ID = aw8697->info.effect_max;
+
+	pr_info("%s probe completed successfully!\n", __func__);
+
+	return 0;
+
+err_rb:
+	sysfs_remove_group(&i2c->dev.kobj, &aw8697_vibrator_attribute_group);
+err_sysfs:
+	devm_free_irq(&i2c->dev, gpio_to_irq(aw8697->irq_gpio), aw8697);
+destroy_ff:
+	input_ff_destroy(aw8697->input_dev);
+err_irq:
+err_parse_dt_attr:
+err_qualify:
+err_id:
+	if (gpio_is_valid(aw8697->irq_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->irq_gpio);
+err_irq_gpio_request:
+	if (gpio_is_valid(aw8697->reset_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->reset_gpio);
+err_reset_gpio_request:
+err_parse_dt_common:
+	device_init_wakeup(aw8697->dev, false);
+	devm_kfree(&i2c->dev, aw8697);
+	aw8697 = NULL;
+	return ret;
+}
+
+static int aw8697_i2c_remove(struct i2c_client *i2c)
+{
+	struct aw8697 *aw8697 = i2c_get_clientdata(i2c);
+
+	pr_info("%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw8697_vibrator_attribute_group);
+	} else {
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw869xx_vibrator_attribute_group);
+	}
+	devm_free_irq(&i2c->dev, gpio_to_irq(aw8697->irq_gpio), aw8697);
+
+	if (gpio_is_valid(aw8697->irq_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->irq_gpio);
+	if (gpio_is_valid(aw8697->reset_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->reset_gpio);
+	if (aw8697 != NULL) {
+		flush_workqueue(aw8697->work_queue);
+		destroy_workqueue(aw8697->work_queue);
+	}
+	device_init_wakeup(aw8697->dev, false);
+	release_rb();
+	devm_kfree(&i2c->dev, aw8697);
+	aw8697 = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id aw8697_i2c_id[] = {
+	{ AW8697_I2C_NAME, 0 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, aw8697_i2c_id);
+
+const static struct of_device_id aw8697_dt_match[] = {
+	{ .compatible = "awinic,aw8697_haptic" },
+	{},
+};
+
+static struct i2c_driver aw8697_i2c_driver = {
+	.driver = {
+		   .name = AW8697_I2C_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(aw8697_dt_match),
+		   },
+	.probe = aw8697_i2c_probe,
+	.remove = aw8697_i2c_remove,
+	.id_table = aw8697_i2c_id,
+};
+
+static int __init aw8697_i2c_init(void)
+{
+	int ret = 0;
+
+	pr_info("aw8697 driver version %s\n", AW8697_VERSION);
+
+	ret = i2c_add_driver(&aw8697_i2c_driver);
+	if (ret) {
+		pr_err("fail to add aw8697 device into i2c\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+module_init(aw8697_i2c_init);
+
+static void __exit aw8697_i2c_exit(void)
+{
+	i2c_del_driver(&aw8697_i2c_driver);
+}
+
+module_exit(aw8697_i2c_exit);
+
+MODULE_DESCRIPTION("AW8697 Haptic Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/misc/aw8697_haptic/aw8697.h b/drivers/input/misc/aw8697_haptic/aw8697.h
new file mode 100644
index 000000000000..192023c3cb93
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw8697.h
@@ -0,0 +1,528 @@
+#ifndef _AW8697_H_
+#define _AW8697_H_
+
+/*********************************************************
+ *
+ * kernel version
+ *
+ ********************************************************/
+#define INPUT_DEV
+//#define TEST_RTP
+#define TEST_CONT_TO_RAM
+/*********************************************************
+ *
+ * aw8697.h
+ *
+ ********************************************************/
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/leds.h>
+#include <linux/atomic.h>
+
+/*********************************************************
+ *
+ * marco
+ *
+ ********************************************************/
+
+#define AW8695_CHIPID 0x95
+#define AW8697_CHIPID 0x97
+#define AW86905_CHIPID 0x05
+#define AW86907_CHIPID 0x04
+#define AW86915_CHIPID 0x07
+#define AW86917_CHIPID 0x06
+
+#define MAX_I2C_BUFFER_SIZE 65536
+
+#define AW8697_SEQUENCER_SIZE 8
+#define AW8697_SEQUENCER_LOOP_SIZE 4
+
+#define AW8697_RTP_I2C_SINGLE_MAX_NUM 512
+
+#define HAPTIC_MAX_TIMEOUT 10000
+
+#define AW8697_VBAT_REFER 4200
+#define AW8697_VBAT_MIN 3000
+#define AW8697_VBAT_MAX 4500
+#define ENABLE_PIN_CONTROL
+
+#define AE_THRESHOLD 1024
+#define AF_THRESHOLD 1536
+
+#ifdef INPUT_DEV
+/* common definitions */
+#define HAP_BRAKE_PATTERN_MAX 4
+#define HAP_WAVEFORM_BUFFER_MAX 8 /*used */
+#define HAP_VMAX_MV_DEFAULT 1800
+#define HAP_VMAX_MV_MAX 3596
+#define HAP_PLAY_RATE_US_DEFAULT 5715 /*used */
+#define HAP_PLAY_RATE_US_MAX 20475
+#define HAP_PLAY_RATE_US_LSB 5
+#define VMAX_MIN_PLAY_TIME_US 20000
+#define HAP_SC_DET_MAX_COUNT 5
+#define HAP_SC_DET_TIME_US 1000000
+#define FF_EFFECT_COUNT_MAX 32
+#define HAP_DISABLE_DELAY_USEC 1000
+#endif
+
+/********************************************
+ * print information control
+ *******************************************/
+#define aw_dev_err(dev, format, ...)                                           \
+	pr_err("[%s]" format, dev_name(dev), ##__VA_ARGS__)
+
+#define aw_dev_info(dev, format, ...)                                          \
+	pr_info("[%s]" format, dev_name(dev), ##__VA_ARGS__)
+
+#define aw_dev_dbg(dev, format, ...)                                           \
+	pr_debug("[%s]" format, dev_name(dev), ##__VA_ARGS__)
+/*
+ * trig default high level
+ * ___________         _________________
+ *           |         |
+ *           |         |
+ *           |___________|
+ *        first edge
+ *                   second edge
+ *
+ *
+ * trig default low level
+ *            ___________
+ *        |           |
+ *        |           |
+ * __________|        |_________________
+ *        first edge
+ *                   second edge
+ */
+/* trig config */
+/*dts config
+* default_level -> 1: high level; 0: low level
+* dual_edge     -> 1: dual edge; 0: first edge
+*vib_trig_config = <
+*       1   1              1          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*       1   1              2          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*       1   1              3          1           2
+*  enable   default_level  dual_edge  first_seq   second_seq
+*/
+#define AW8697_TRIG_NUM 3
+
+enum aw8697_chip_version {
+	AW8697_CHIP_9X = 0,
+	AW8697_CHIP_9XX = 1,
+};
+
+enum aw869xx_haptic_bst_pc {
+	AW869XX_HAPTIC_BST_PC_L1 = 0,
+	AW869XX_HAPTIC_BST_PC_L2 = 1,
+};
+
+enum aw869xx_haptic_bst_mode {
+	AW869XX_HAPTIC_BST_MODE_BYPASS = 0,
+	AW869XX_HAPTIC_BST_MODE_BOOST = 1,
+};
+
+enum aw869xx_haptic_cali_lra {
+	WRITE_ZERO = 0,
+	F0_CALI = 1,
+	OSC_CALI = 2,
+};
+enum aw8697_flags {
+	AW8697_FLAG_NONR = 0,
+	AW8697_FLAG_SKIP_INTERRUPTS = 1,
+};
+
+enum aw8697_haptic_read_write {
+	AW8697_HAPTIC_CMD_READ_REG = 0,
+	AW8697_HAPTIC_CMD_WRITE_REG = 1,
+};
+
+enum aw8697_haptic_work_mode {
+	AW8697_HAPTIC_STANDBY_MODE = 0,
+	AW8697_HAPTIC_RAM_MODE = 1,
+	AW8697_HAPTIC_RTP_MODE = 2,
+	AW8697_HAPTIC_TRIG_MODE = 3,
+	AW8697_HAPTIC_CONT_MODE = 4,
+	AW8697_HAPTIC_RAM_LOOP_MODE = 5,
+};
+
+enum aw8697_haptic_bst_mode {
+	AW8697_HAPTIC_BYPASS_MODE = 0,
+	AW8697_HAPTIC_BOOST_MODE = 1,
+};
+
+enum aw8697_haptic_activate_mode {
+	AW8697_HAPTIC_ACTIVATE_RAM_MODE = 0,
+	AW8697_HAPTIC_ACTIVATE_CONT_MODE = 1,
+	AW8697_HAPTIC_ACTIVATE_RTP_MODE = 2,
+	AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE = 3,
+};
+
+enum aw8697_haptic_cont_vbat_comp_mode {
+	AW8697_HAPTIC_CONT_VBAT_SW_COMP_MODE = 0,
+	AW8697_HAPTIC_CONT_VBAT_HW_COMP_MODE = 1,
+};
+
+enum aw8697_haptic_ram_vbat_comp_mode {
+	AW8697_HAPTIC_RAM_VBAT_COMP_DISABLE = 0,
+	AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE = 1,
+};
+
+enum aw8697_haptic_f0_flag {
+	AW8697_HAPTIC_LRA_F0 = 0,
+	AW8697_HAPTIC_CALI_F0 = 1,
+};
+
+enum aw8697_haptic_pwm_mode {
+	AW8697_PWM_48K = 0,
+	AW8697_PWM_24K = 1,
+	AW8697_PWM_12K = 2,
+};
+
+enum aw8697_haptic_play {
+	AW8697_HAPTIC_PLAY_NULL = 0,
+	AW8697_HAPTIC_PLAY_ENABLE = 1,
+	AW8697_HAPTIC_PLAY_STOP = 2,
+	AW8697_HAPTIC_PLAY_GAIN = 8,
+};
+
+enum aw8697_haptic_cmd {
+	AW8697_HAPTIC_CMD_NULL = 0,
+	AW8697_HAPTIC_CMD_ENABLE = 1,
+	AW8697_HAPTIC_CMD_STOP = 255,
+};
+
+enum haptics_custom_effect_param {
+	CUSTOM_DATA_EFFECT_IDX,
+	CUSTOM_DATA_TIMEOUT_SEC_IDX,
+	CUSTOM_DATA_TIMEOUT_MSEC_IDX,
+	CUSTOM_DATA_LEN,
+};
+enum aw8697_haptic_strength {
+	AW8697_LIGHT_MAGNITUDE = 0x3fff,
+	AW8697_MEDIUM_MAGNITUDE = 0x5fff,
+	AW8697_STRONG_MAGNITUDE = 0x7fff,
+};
+/*********************************************************
+ *
+ * struct
+ *
+ ********************************************************/
+struct fileops {
+	unsigned char cmd;
+	unsigned char reg;
+	unsigned char ram_addrh;
+	unsigned char ram_addrl;
+};
+
+struct ram {
+	unsigned int len;
+	unsigned int check_sum;
+	unsigned int base_addr;
+	unsigned char version;
+	unsigned char ram_shift;
+	unsigned char baseaddr_shift;
+};
+
+struct haptic_ctr {
+	unsigned char cnt;
+	unsigned char cmd;
+	unsigned char play;
+	unsigned char wavseq;
+	unsigned char loop;
+	unsigned char gain;
+	struct list_head list;
+};
+
+struct haptic_audio {
+	struct mutex lock;
+	struct hrtimer timer;
+	struct work_struct work;
+	int delay_val;
+	int timer_val;
+	unsigned char cnt;
+	struct haptic_ctr data[256];
+	struct haptic_ctr ctr;
+	unsigned char ori_gain;
+};
+
+struct trig {
+	unsigned char enable;
+	unsigned char default_level;
+	unsigned char dual_edge;
+	unsigned char frist_seq;
+	unsigned char second_seq;
+};
+
+struct aw8697_dts_info {
+	unsigned int mode;
+	unsigned int f0_pre;
+	unsigned int f0_cali_percen;
+	unsigned int cont_drv_lvl;
+	unsigned int cont_drv_lvl_ov;
+	unsigned int cont_td;
+	unsigned int cont_zc_thr;
+	unsigned int cont_num_brk;
+	unsigned int f0_coeff;
+	unsigned int f0_trace_parameter[4];
+	unsigned int bemf_config[4];
+	unsigned int sw_brake;
+	unsigned int tset;
+	unsigned int r_spare;
+	unsigned int bstdbg[6];
+	unsigned int parameter1;
+	unsigned int effect_id_boundary;
+	unsigned int effect_max;
+	unsigned int rtp_time[175];
+	unsigned int trig_config[3][5];
+	unsigned int bst_vol_default;
+	unsigned int bst_vol_ram;
+	unsigned int bst_vol_rtp;
+
+	/* aw869xx */
+	unsigned int cont_drv1_lvl;
+	unsigned int cont_drv2_lvl;
+	unsigned int cont_drv1_time;
+	unsigned int cont_drv2_time;
+	unsigned int cont_wait_num;
+	unsigned int cont_brk_time;
+	unsigned int cont_track_margin;
+	unsigned int cont_tset;
+	unsigned int cont_drv_width;
+	unsigned int cont_bemf_set;
+	unsigned int cont_brk_gain;
+	unsigned int cont_bst_brk_gain;
+	unsigned int d2s_gain;
+	unsigned int bstcfg[5];
+	unsigned int prctmode[3];
+	unsigned int sine_array[4];
+	unsigned int trig_config_9xx[24];
+	bool is_enabled_auto_bst;
+	bool is_enabled_powerup_f0_cali;
+};
+
+#ifdef INPUT_DEV
+enum actutor_type {
+	ACT_LRA,
+	ACT_ERM,
+};
+
+enum lra_res_sig_shape {
+	RES_SIG_SINE,
+	RES_SIG_SQUARE,
+};
+
+enum lra_auto_res_mode {
+	AUTO_RES_MODE_ZXD,
+	AUTO_RES_MODE_QWD,
+};
+
+enum wf_src {
+	INT_WF_VMAX,
+	INT_WF_BUFFER,
+	EXT_WF_AUDIO,
+	EXT_WF_PWM,
+};
+
+struct qti_hap_effect {
+	int id;
+	u8 *pattern;
+	int pattern_length;
+	u16 play_rate_us;
+	u16 vmax_mv;
+	u8 wf_repeat_n;
+	u8 wf_s_repeat_n;
+	u8 brake[HAP_BRAKE_PATTERN_MAX];
+	int brake_pattern_length;
+	bool brake_en;
+	bool lra_auto_res_disable;
+};
+
+struct qti_hap_play_info {
+	struct qti_hap_effect *effect;
+	u16 vmax_mv;
+	int length_us;
+	int playing_pos;
+	bool playing_pattern;
+};
+
+struct qti_hap_config {
+	enum actutor_type act_type;
+	enum lra_res_sig_shape lra_shape;
+	enum lra_auto_res_mode lra_auto_res_mode;
+	enum wf_src ext_src;
+	u16 vmax_mv;
+	u16 play_rate_us;
+	bool lra_allow_variable_play_rate;
+	bool use_ext_wf_src;
+};
+#endif
+
+#ifdef ENABLE_PIN_CONTROL
+const char *const pctl_names[] = {
+	"aw8697_reset_reset",
+	"aw8697_reset_active",
+	"aw8697_interrupt_active",
+};
+#endif
+struct aw8697 {
+	struct i2c_client *i2c;
+	struct mutex lock;
+#ifdef ENABLE_PIN_CONTROL
+	struct pinctrl *aw8697_pinctrl;
+	struct pinctrl_state *pinctrl_state[ARRAY_SIZE(pctl_names)];
+#endif
+	int enable_pin_control;
+	struct work_struct vibrator_work;
+	struct work_struct rtp_work;
+	struct work_struct set_gain_work;
+	struct delayed_work ram_work;
+
+	struct fileops fileops;
+	struct ram ram;
+
+	struct timeval start, end;
+	unsigned int timeval_flags;
+	unsigned int osc_cali_flag;
+	unsigned long int microsecond;
+	unsigned int sys_frequency;
+	unsigned int rtp_len;
+	unsigned int lra_calib_data;
+	unsigned int f0_calib_data;
+	char *ram_name;
+
+	int reset_gpio;
+	int irq_gpio;
+
+	unsigned char hwen_flag;
+	unsigned char flags;
+	unsigned char chipid;
+
+	unsigned char play_mode;
+
+	unsigned char activate_mode;
+
+	unsigned char auto_boost;
+	unsigned char wk_lock_flag;
+
+	int state;
+	int duration;
+	int amplitude;
+	int index;
+	int vmax;
+	int gain;
+	u16 new_gain;
+	unsigned char level;
+
+	unsigned char seq[AW8697_SEQUENCER_SIZE];
+	unsigned char loop[AW8697_SEQUENCER_SIZE];
+
+	unsigned int rtp_cnt;
+	unsigned int rtp_file_num;
+
+	unsigned char rtp_init;
+	unsigned char ram_init;
+#ifdef SUPPORT_RELOAD_FW
+	unsigned char vov;
+#endif
+
+	unsigned int f0;
+	unsigned int cont_f0;
+	unsigned char max_pos_beme;
+	unsigned char max_neg_beme;
+	unsigned char f0_cali_flag;
+	bool f0_cali_status;
+	unsigned int osc_cali_run;
+
+	unsigned char ram_vbat_comp;
+	unsigned int vbat;
+	unsigned int lra;
+
+	unsigned char bst_pc;
+	unsigned char chip_version;
+	unsigned int ram_update_flag;
+	unsigned int rtp_update_flag;
+	struct trig trig[AW8697_TRIG_NUM];
+
+	struct haptic_audio haptic_audio;
+	struct aw8697_dts_info info;
+	atomic_t is_in_rtp_loop;
+	atomic_t exit_in_rtp_loop;
+	atomic_t is_in_write_loop;
+	wait_queue_head_t wait_q; //wait queue for exit irq mode
+	wait_queue_head_t stop_wait_q; //wait queue for stop rtp mode
+	struct workqueue_struct *work_queue;
+
+#ifdef INPUT_DEV
+	struct platform_device *pdev;
+	struct device *dev;
+	struct regmap *regmap;
+	struct input_dev *input_dev;
+	struct pwm_device *pwm_dev;
+	struct qti_hap_config config;
+	struct qti_hap_play_info play;
+	struct qti_hap_effect *predefined;
+	struct qti_hap_effect constant;
+	struct regulator *vdd_supply;
+	struct hrtimer stop_timer;
+	struct hrtimer hap_disable_timer;
+	struct hrtimer timer; /*test used  ,del */
+	struct dentry *hap_debugfs;
+	struct mutex rtp_lock;
+	spinlock_t bus_lock;
+	ktime_t last_sc_time;
+	int play_irq;
+	int sc_irq;
+	int effects_count;
+	int sc_det_count;
+	u16 reg_base;
+	bool perm_disable;
+	bool play_irq_en;
+	bool vdd_enabled;
+	int effect_type;
+	int effect_id;
+	int test_val;
+	int is_custom_wave;
+#endif
+};
+
+struct aw8697_container {
+	int len;
+	unsigned char data[];
+};
+
+/*********************************************************
+ *
+ * ioctl
+ *
+ ********************************************************/
+struct aw8697_seq_loop {
+	unsigned char loop[AW8697_SEQUENCER_SIZE];
+};
+
+struct aw8697_que_seq {
+	unsigned char index[AW8697_SEQUENCER_SIZE];
+};
+
+#define AW8697_HAPTIC_IOCTL_MAGIC 'h'
+
+#define AW8697_HAPTIC_SET_QUE_SEQ                                              \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 1, struct aw8697_que_seq *)
+#define AW8697_HAPTIC_SET_SEQ_LOOP                                             \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 2, struct aw8697_seq_loop *)
+#define AW8697_HAPTIC_PLAY_QUE_SEQ                                             \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 3, unsigned int)
+#define AW8697_HAPTIC_SET_BST_VOL                                              \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 4, unsigned int)
+#define AW8697_HAPTIC_SET_BST_PEAK_CUR                                         \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 5, unsigned int)
+#define AW8697_HAPTIC_SET_GAIN _IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 6, unsigned int)
+#define AW8697_HAPTIC_PLAY_REPEAT_SEQ                                          \
+	_IOWR(AW8697_HAPTIC_IOCTL_MAGIC, 7, unsigned int)
+
+#endif
diff --git a/drivers/input/misc/aw8697_haptic/aw8697_config.h b/drivers/input/misc/aw8697_haptic/aw8697_config.h
new file mode 100644
index 000000000000..ca3119c0d868
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw8697_config.h
@@ -0,0 +1,117 @@
+#ifndef __AW8697_CONFIG_H__
+#define __AW8697_CONFIG_H__
+
+#define AW8697_BSTCFG_PEAKCUR_LIMIT 0x07
+#define AW8697_DEFAULT_PEAKCUR AW8697_BIT_BSTCFG_PEAKCUR_3P5A
+
+#define AW8697_CONT_PLAYBACK_MODE AW8697_BIT_CONT_CTRL_CLOSE_PLAYBACK
+
+/*#define CONFIG_DEBUG_FS*/
+
+/*#ifdef INPUT_DEV*/
+#if 1
+/* haptics module register definitions */
+#define REG_HAP_STATUS1 0x0A
+#define HAP_SC_DET_BIT BIT(3)
+#define HAP_BUSY_BIT BIT(1)
+
+#define REG_HAP_EN_CTL1 0x46
+#define HAP_EN_BIT BIT(7)
+
+#define REG_HAP_EN_CTL2 0x48
+#define HAP_AUTO_STANDBY_EN_BIT BIT(1)
+#define HAP_BRAKE_EN_BIT BIT(0)
+
+#define REG_HAP_EN_CTL3 0x4A
+#define HAP_HBRIDGE_EN_BIT BIT(7)
+#define HAP_PWM_SIGNAL_EN_BIT BIT(6)
+#define HAP_ILIM_EN_BIT BIT(5)
+#define HAP_ILIM_CC_EN_BIT BIT(4)
+#define HAP_AUTO_RES_RBIAS_EN_BIT BIT(3)
+#define HAP_DAC_EN_BIT BIT(2)
+#define HAP_ZX_HYST_EN_BIT BIT(1)
+#define HAP_PWM_CTL_EN_BIT BIT(0)
+
+#define REG_HAP_AUTO_RES_CTRL 0x4B
+#define HAP_AUTO_RES_EN_BIT BIT(7)
+#define HAP_SEL_AUTO_RES_PERIOD BIT(6)
+#define HAP_AUTO_RES_CNT_ERR_DELTA_MASK GENMASK(5, 4)
+#define HAP_AUTO_RES_CNT_ERR_DELTA_SHIFT 4
+#define HAP_AUTO_RES_ERR_RECOVERY_BIT BIT(3)
+#define HAP_AUTO_RES_EN_DLY_MASK GENMASK(2, 0)
+#define AUTO_RES_CNT_ERR_DELTA(x) (x << HAP_AUTO_RES_CNT_ERR_DELTA_SHIFT)
+#define AUTO_RES_EN_DLY(x) x
+
+#define REG_HAP_CFG1 0x4C
+#define REG_HAP_CFG2 0x4D
+#define HAP_LRA_RES_TYPE_BIT BIT(0)
+
+#define REG_HAP_SEL 0x4E
+#define HAP_WF_SOURCE_MASK GENMASK(5, 4)
+#define HAP_WF_SOURCE_SHIFT 4
+#define HAP_WF_TRIGGER_BIT BIT(0)
+#define HAP_WF_SOURCE_VMAX (0 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_BUFFER (1 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_AUDIO (2 << HAP_WF_SOURCE_SHIFT)
+#define HAP_WF_SOURCE_PWM (3 << HAP_WF_SOURCE_SHIFT)
+
+#define REG_HAP_AUTO_RES_CFG 0x4F
+#define HAP_AUTO_RES_MODE_BIT BIT(7)
+#define HAP_AUTO_RES_MODE_SHIFT 7
+#define HAP_AUTO_RES_CAL_DURATON_MASK GENMASK(6, 5)
+#define HAP_CAL_EOP_EN_BIT BIT(3)
+#define HAP_CAL_PERIOD_MASK GENMASK(2, 0)
+#define HAP_CAL_OPT3_EVERY_8_PERIOD 2
+
+#define REG_HAP_SLEW_CFG 0x50
+#define REG_HAP_VMAX_CFG 0x51
+#define HAP_VMAX_SIGN_BIT BIT(7)
+#define HAP_VMAX_OVD_BIT BIT(6)
+#define HAP_VMAX_MV_MASK GENMASK(5, 1)
+#define HAP_VMAX_MV_SHIFT 1
+#define HAP_VMAX_MV_LSB 116
+
+#define REG_HAP_ILIM_CFG 0x52
+#define HAP_ILIM_SEL_1000MA BIT(1)
+#define HAP_ILIM_DEFAULT_SEL HAP_ILIM_SEL_1000MA
+#define REG_HAP_SC_DEB_CFG 0x53
+#define REG_HAP_RATE_CFG1 0x54
+#define REG_HAP_RATE_CFG2 0x55
+#define REG_HAP_INTERNAL_PWM 0x56
+#define REG_HAP_EXTERNAL_PWM 0x57
+#define REG_HAP_PWM 0x58
+
+#define REG_HAP_SC_CLR 0x59
+#define HAP_SC_CLR_BIT BIT(0)
+
+#define REG_HAP_ZX_CFG 0x5A
+#define HAP_ZX_DET_DEB_MASK GENMASK(2, 0)
+#define ZX_DET_DEB_10US 0
+#define ZX_DET_DEB_20US 1
+#define ZX_DET_DEB_40US 2
+#define ZX_DET_DEB_80US 3
+
+#define REG_HAP_BRAKE 0x5C
+#define HAP_BRAKE_PATTERN_MASK 0x3
+#define HAP_BRAKE_PATTERN_SHIFT 2
+
+#define REG_HAP_WF_REPEAT 0x5E
+#define HAP_WF_REPEAT_MASK GENMASK(6, 4)
+#define HAP_WF_REPEAT_SHIFT 4
+#define HAP_WF_S_REPEAT_MASK GENMASK(1, 0)
+
+#define REG_HAP_WF_S1 0x60
+#define HAP_WF_SIGN_BIT BIT(7)
+#define HAP_WF_OVD_BIT BIT(6)
+#define HAP_WF_AMP_BIT GENMASK(5, 1)
+#define HAP_WF_AMP_SHIFT 1
+
+#define REG_HAP_PLAY 0x70
+#define HAP_PLAY_BIT BIT(7)
+
+#define REG_HAP_SEC_ACCESS 0xD0
+
+static int wf_repeat[8] = { 1, 2, 4, 8, 16, 32, 64, 128 };
+static int wf_s_repeat[4] = { 1, 2, 4, 8 };
+#endif
+#endif
diff --git a/drivers/input/misc/aw8697_haptic/aw8697_dagu.c b/drivers/input/misc/aw8697_haptic/aw8697_dagu.c
new file mode 100644
index 000000000000..9188650fbdd2
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw8697_dagu.c
@@ -0,0 +1,7048 @@
+/*
+ * aw8697.c   aw8697 haptic module
+ *
+ * Version: v1.1.3
+ *
+ * Copyright (c) 2019 AWINIC Technology CO., LTD
+ *
+ *  Author: Nick Li <zhangzetao@awinic.com.cn>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#define DEBUG
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/power_supply.h>
+#include <linux/vmalloc.h>
+#include <linux/pm_qos.h>
+#include <linux/string.h>
+#include "aw8697_config.h"
+#include "aw8697_reg.h"
+#include "aw869xx_reg.h"
+#include "aw8697.h"
+#include "ringbuffer.h"
+
+/******************************************************
+ *
+ * Marco
+ *
+ ******************************************************/
+#define AW8697_I2C_NAME "aw8697_haptic"
+#define AW8697_HAPTIC_NAME "aw8697_haptic"
+
+#define AW8697_VERSION "v1.1.3"
+
+#define AWINIC_RAM_UPDATE_DELAY
+
+#define AW_I2C_RETRIES 2
+#define AW_I2C_RETRY_DELAY 2
+#define AW_READ_CHIPID_RETRIES 5
+#define AW_READ_CHIPID_RETRY_DELAY 2
+
+#define AW8697_MAX_DSP_START_TRY_COUNT 10
+
+#define AW8697_MAX_FIRMWARE_LOAD_CNT 20
+
+#define AW8697_MAX_BST_VO 0x1f
+
+#define OSC_CALIBRATION_T_LENGTH 5100000
+#define PM_QOS_VALUE_VB 400
+struct pm_qos_request pm_qos_req_vb;
+/******************************************************
+ *
+ * variable
+ *
+ ******************************************************/
+#define AW8697_RTP_NAME_MAX 64
+static char *aw8697_ram_name = "aw8697_haptic.bin";
+#ifdef SUPPORT_RELOAD_FW
+static char *aw8697_ram_name_a = "aw8697_haptic_a.bin";
+static char aw8697_rtp_name_a[AW8697_RTP_NAME_MAX];
+#endif
+#ifdef TEST_RTP
+static char aw8697_rtp_name[][AW8697_RTP_NAME_MAX] = {
+	{ "aw8697_rtp_1.bin" },
+};
+#else
+static char aw8697_rtp_name[][AW8697_RTP_NAME_MAX] = {
+	{ "aw8697_rtp_1.bin" }, //10
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	//{"aw8697_rtp_1.bin"},
+	//{"aw8697_rtp_1.bin"},
+	{ "AcousticGuitar_RTP.bin" }, //21
+	{ "Blues_RTP.bin" },
+	{ "Candy_RTP.bin" },
+	{ "Carousel_RTP.bin" },
+	{ "Celesta_RTP.bin" },
+	{ "Childhood_RTP.bin" },
+	{ "Country_RTP.bin" },
+	{ "Cowboy_RTP.bin" },
+	{ "Echo_RTP.bin" },
+	{ "Fairyland_RTP.bin" },
+	{ "Fantasy_RTP.bin" },
+	{ "Field_Trip_RTP.bin" },
+	{ "Glee_RTP.bin" },
+	{ "Glockenspiel_RTP.bin" },
+	{ "Ice_Latte_RTP.bin" },
+	{ "Kung_Fu_RTP.bin" },
+	{ "Leisure_RTP.bin" },
+	{ "Lollipop_RTP.bin" },
+	{ "MiMix2_RTP.bin" },
+	{ "Mi_RTP.bin" },
+	{ "MiHouse_RTP.bin" },
+	{ "MiJazz_RTP.bin" },
+	{ "MiRemix_RTP.bin" },
+	{ "Mountain_Spring_RTP.bin" },
+	{ "Orange_RTP.bin" },
+	{ "WindChime_RTP.bin" },
+	{ "Space_Age_RTP.bin" },
+	{ "ToyRobot_RTP.bin" },
+	{ "Vigor_RTP.bin" },
+	{ "Bottle_RTP.bin" },
+	{ "Bubble_RTP.bin" },
+	{ "Bullfrog_RTP.bin" },
+	{ "Burst_RTP.bin" },
+	{ "Chirp_RTP.bin" },
+	{ "Clank_RTP.bin" },
+	{ "Crystal_RTP.bin" },
+	{ "FadeIn_RTP.bin" },
+	{ "FadeOut_RTP.bin" },
+	{ "Flute_RTP.bin" },
+	{ "Fresh_RTP.bin" },
+	{ "Frog_RTP.bin" },
+	{ "Guitar_RTP.bin" },
+	{ "Harp_RTP.bin" },
+	{ "IncomingMessage_RTP.bin" },
+	{ "MessageSent_RTP.bin" },
+	{ "Moment_RTP.bin" },
+	{ "NotificationXylophone_RTP.bin" },
+	{ "Potion_RTP.bin" },
+	{ "Radar_RTP.bin" },
+	{ "Spring_RTP.bin" },
+	{ "Swoosh_RTP.bin" }, //71
+	{ "Gesture_UpSlide_RTP.bin" },
+	{ "FOD_Motion_Planet_RTP.bin" },
+	{ "Charge_Wire_RTP.bin" },
+	{ "Charge_Wireless_RTP.bin" },
+	{ "Unlock_Failed_RTP.bin" },
+	{ "FOD_Motion1_RTP.bin" },
+	{ "FOD_Motion2_RTP.bin" },
+	{ "FOD_Motion3_RTP.bin" },
+	{ "FOD_Motion4_RTP.bin" },
+	{ "FOD_Motion_Aurora_RTP.bin" },
+	{ "FaceID_Wrong2_RTP.bin" }, //82
+	{ "uninstall_animation_rtp.bin" },
+	{ "uninstall_dialog_rtp.bin" },
+	{ "screenshot_rtp.bin" },
+	{ "lockscreen_camera_entry_rtp.bin" },
+	{ "launcher_edit_rtp.bin" },
+	{ "launcher_icon_selection_rtp.bin" },
+	{ "taskcard_remove_rtp.bin" },
+	{ "task_cleanall_rtp.bin" },
+	{ "new_iconfolder_rtp.bin" },
+	{ "notification_remove_rtp.bin" },
+	{ "notification_cleanall_rtp.bin" },
+	{ "notification_setting_rtp.bin" },
+	{ "game_turbo_rtp.bin" },
+	{ "NFC_card_rtp.bin" },
+	{ "wakeup_voice_assistant_rtp.bin" },
+	{ "NFC_card_slow_rtp.bin" },
+	{ "aw8697_rtp_1.bin" }, //99
+	{ "aw8697_rtp_1.bin" }, //100
+	{ "offline_countdown_RTP.bin" },
+	{ "scene_bomb_injury_RTP.bin" },
+	{ "scene_bomb_RTP.bin" }, //103
+	{ "door_open_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_step_RTP.bin" }, //106
+	{ "crawl_RTP.bin" },
+	{ "scope_on_RTP.bin" },
+	{ "scope_off_RTP.bin" },
+	{ "magazine_quick_RTP.bin" },
+	{ "grenade_RTP.bin" },
+	{ "scene_getshot_RTP.bin" }, //112
+	{ "grenade_explosion_RTP.bin" },
+	{ "punch_RTP.bin" },
+	{ "pan_RTP.bin" },
+	{ "bandage_RTP.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "scene_jump_RTP.bin" },
+	{ "vehicle_plane_RTP.bin" }, //119
+	{ "scene_openparachute_RTP.bin" }, //120
+	{ "scene_closeparachute_RTP.bin" }, //121
+	{ "vehicle_collision_RTP.bin" },
+	{ "vehicle_buggy_RTP.bin" }, //123
+	{ "vehicle_dacia_RTP.bin" }, //124
+	{ "vehicle_moto_RTP.bin" }, //125
+	{ "firearms_akm_RTP.bin" }, //126
+	{ "firearms_m16a4_RTP.bin" }, //127
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_awm_RTP.bin" }, //129
+	{ "firearms_mini14_RTP.bin" }, //130
+	{ "firearms_vss_RTP.bin" }, //131
+	{ "firearms_qbz_RTP.bin" }, //132
+	{ "firearms_ump9_RTP.bin" }, //133
+	{ "firearms_dp28_RTP.bin" }, //134
+	{ "firearms_s1897_RTP.bin" }, //135
+	{ "aw8697_rtp_1.bin" },
+	{ "firearms_p18c_RTP.bin" }, //137
+	{ "aw8697_rtp_1.bin" },
+	{ "aw8697_rtp_1.bin" },
+	{ "CFM_KillOne_RTP.bin" },
+	{ "CFM_Headshot_RTP.bin" }, //141
+	{ "CFM_MultiKill_RTP.bin" },
+	{ "CFM_KillOne_Strong_RTP.bin" },
+	{ "CFM_Headshot_Strong_RTP.bin" },
+	{ "CFM_MultiKill_Strong_RTP.bin" },
+	{ "CFM_Weapon_Grenade_Explode_RTP.bin" },
+	{ "CFM_Weapon_Grenade_KillOne_RTP.bin" },
+	{ "CFM_ImpactFlesh_Normal_RTP.bin" },
+	{ "CFM_Weapon_C4_Installed_RTP.bin" },
+	{ "CFM_Hero_Appear_RTP.bin" },
+	{ "CFM_UI_Reward_OpenBox_RTP.bin" },
+	{ "CFM_UI_Reward_Task_RTP.bin" },
+	{ "CFM_Weapon_BLT_Shoot_RTP.bin" }, //153
+	{ "Atlantis_RTP.bin" },
+	{ "DigitalUniverse_RTP.bin" },
+	{ "Reveries_RTP.bin" },
+	{ "FOD_Motion_Triang_RTP.bin" },
+	{ "FOD_Motion_Flare_RTP.bin" },
+	{ "FOD_Motion_Ripple_RTP.bin" },
+	{ "FOD_Motion_Spiral_RTP.bin" },
+	{ "gamebox_launch_rtp.bin" }, // 161
+	{ "Gesture_Back_Pull_RTP.bin" }, // 162
+	{ "Gesture_Back_Release_RTP.bin" }, // 163
+	{ "alert_rtp.bin" }, // 164
+	{ "feedback_negative_light_rtp.bin" }, // 165
+	{ "feedback_neutral_rtp.bin" }, // 166
+	{ "feedback_positive_rtp.bin" }, // 167
+	{ "fingerprint_record_rtp.bin" }, // 168
+	{ "lockdown_rtp.bin" }, // 169
+	{ "sliding_damping_rtp.bin" }, // 170
+	{ "todo_alldone_rtp.bin" }, // 171
+	{ "uninstall_animation_icon_rtp.bin" }, // 172
+	{ "signal_button_highlight_rtp.bin" }, //173
+	{ "signal_button_negative_rtp.bin" },
+	{ "signal_button_rtp.bin" },
+	{ "signal_clock_high_rtp.bin" }, //176
+	{ "signal_clock_rtp.bin" },
+	{ "signal_clock_unit_rtp.bin" },
+	{ "signal_inputbox_rtp.bin" },
+	{ "signal_key_high_rtp.bin" },
+	{ "signal_key_unit_rtp.bin" }, //181
+	{ "signal_list_highlight_rtp.bin" },
+	{ "signal_list_rtp.bin" },
+	{ "signal_picker_rtp.bin" },
+	{ "signal_popup_rtp.bin" },
+	{ "signal_seekbar_rtp.bin" }, //186
+	{ "signal_switch_rtp.bin" },
+	{ "signal_tab_rtp.bin" },
+	{ "signal_text_rtp.bin" },
+	{ "signal_transition_light_rtp.bin" },
+	{ "signal_transition_rtp.bin" }, //191
+	{ "haptics_video_rtp.bin" }, //192
+};
+#endif
+static int CUSTOME_WAVE_ID;
+struct aw8697_container *aw8697_rtp;
+struct aw8697 *g_aw8697;
+
+/******************************************************
+ *
+ * functions
+ *
+ ******************************************************/
+static void aw8697_interrupt_clear(struct aw8697 *aw8697);
+static int aw8697_haptic_trig_enable_config(struct aw8697 *aw8697);
+static int aw8697_haptic_stop(struct aw8697 *aw8697);
+static unsigned char aw8697_haptic_osc_read_int(struct aw8697 *aw8697);
+/******************************************************
+ *
+ * aw8697 i2c write/read
+ *
+ ******************************************************/
+static int aw8697_i2c_write(struct aw8697 *aw8697, unsigned char reg_addr,
+			    unsigned char reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw8697->i2c, reg_addr,
+						reg_data);
+		if (ret < 0) {
+			pr_err("%s: i2c_write cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw8697_i2c_read(struct aw8697 *aw8697, unsigned char reg_addr,
+			   unsigned char *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw8697->i2c, reg_addr);
+		if (ret < 0) {
+			pr_err("%s: i2c_read cnt=%d error=%d\n", __func__, cnt,
+			       ret);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+static int aw8697_i2c_write_bits(struct aw8697 *aw8697, unsigned char reg_addr,
+				 unsigned int mask, unsigned char reg_data)
+{
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, reg_addr, &reg_val);
+	reg_val &= mask;
+	reg_val |= reg_data;
+	aw8697_i2c_write(aw8697, reg_addr, reg_val);
+
+	return 0;
+}
+
+static int aw8697_i2c_writes(struct aw8697 *aw8697, unsigned char reg_addr,
+			     unsigned char *buf, unsigned int len)
+{
+	int ret = -1;
+	unsigned char *data;
+
+	data = kmalloc(len + 1, GFP_KERNEL);
+	if (data == NULL) {
+		pr_err("%s: can not allocate memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	data[0] = reg_addr;
+	memcpy(&data[1], buf, len);
+
+	ret = i2c_master_send(aw8697->i2c, data, len + 1);
+	if (ret < 0) {
+		pr_err("%s: i2c master send error\n", __func__);
+	}
+
+	kfree(data);
+
+	return ret;
+}
+
+static void aw8697_haptic_raminit(struct aw8697 *aw8697, bool flag)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		if (flag) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_RAMINIT_MASK,
+					      AW8697_BIT_SYSCTRL_RAMINIT_EN);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_RAMINIT_MASK,
+					      AW8697_BIT_SYSCTRL_RAMINIT_OFF);
+		}
+	} else {
+		if (flag) {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL1,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_MASK,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_ON);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL1,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_MASK,
+					      AW869XX_BIT_SYSCTRL1_RAMINIT_OFF);
+		}
+	}
+}
+
+static int aw8697_haptic_get_lra_resistance(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+			      AW8697_BIT_ANACTRL_HD_PD_MASK,
+			      AW8697_BIT_ANACTRL_HD_HZ_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_D2SCFG,
+			      AW8697_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW8697_BIT_D2SCFG_CLK_ASC_1P5MHZ);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_RL_OS_MASK,
+			      AW8697_BIT_DETCTRL_RL_DETECT);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_DIAG_GO_MASK,
+			      AW8697_BIT_DETCTRL_DIAG_GO_ENABLE);
+	msleep(3);
+	aw8697_i2c_read(aw8697, AW8697_REG_RLDET, &reg_val);
+	aw8697->lra = 298 * reg_val;
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+			      AW8697_BIT_ANACTRL_HD_PD_MASK,
+			      AW8697_BIT_ANACTRL_HD_PD_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_D2SCFG,
+			      AW8697_BIT_D2SCFG_CLK_ADC_MASK,
+			      AW8697_BIT_D2SCFG_CLK_ASC_6MHZ);
+
+	aw8697_haptic_raminit(aw8697, false);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static int aw869xx_haptic_get_lra_resistance(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned char d2s_gain_temp = 0;
+	unsigned int lra_code = 0;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSCTRL7, &reg_val);
+	d2s_gain_temp = 0x07 & reg_val;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      aw8697->info.d2s_gain);
+	aw8697_haptic_raminit(aw8697, true);
+	/* enter standby mode */
+	aw8697_haptic_stop(aw8697);
+	usleep_range(2000, 2500);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL2,
+			      AW869XX_BIT_SYSCTRL2_STANDBY_MASK,
+			      AW869XX_BIT_SYSCTRL2_STANDBY_OFF);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG1,
+			      AW869XX_BIT_DETCFG1_RL_OS_MASK,
+			      AW869XX_BIT_DETCFG1_RL);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+			      AW869XX_BIT_DETCFG2_DIAG_GO_MASK,
+			      AW869XX_BIT_DETCFG2_DIAG_GO_ON);
+	usleep_range(30000, 35000);
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_RL, &reg_val);
+	lra_code = (lra_code | reg_val) << 2;
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_LO, &reg_val);
+	lra_code = lra_code | (reg_val & 0x03);
+	/* 2num */
+	aw8697->lra = (lra_code * 678 * 1000) / (1024 * 10);
+	aw8697_haptic_raminit(aw8697, false);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      d2s_gain_temp);
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static void aw869xx_haptic_misc_para_init(struct aw8697 *aw8697)
+{
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG1, aw8697->info.bstcfg[0]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG2, aw8697->info.bstcfg[1]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG3, aw8697->info.bstcfg[2]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG4, aw8697->info.bstcfg[3]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_BSTCFG5, aw8697->info.bstcfg[4]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL3,
+			 aw8697->info.sine_array[0]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL4,
+			 aw8697->info.sine_array[1]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL5,
+			 aw8697->info.sine_array[2]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_SYSCTRL6,
+			 aw8697->info.sine_array[3]);
+
+	/* enable auto break */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK,
+			      AW869XX_BIT_PLAYCFG3_BRK_ENABLE);
+	/* d2s_gain */
+
+	if (!aw8697->info.d2s_gain)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.d2s_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK,
+			      aw8697->info.d2s_gain);
+
+	/* cont_tset */
+	if (!aw8697->info.cont_tset)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_tset = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG13,
+			      AW869XX_BIT_CONTCFG13_TSET_MASK,
+			      aw8697->info.cont_tset << 4);
+
+	/* cont_bemf_set */
+	if (!aw8697->info.cont_bemf_set)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_bemf_set = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG13,
+			      AW869XX_BIT_CONTCFG13_BEME_SET_MASK,
+			      aw8697->info.cont_bemf_set);
+
+	/* cont_brk_time */
+	if (!aw8697->info.cont_brk_time)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_brk_time = 0!\n",
+			   __func__);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG10,
+			 aw8697->info.cont_brk_time);
+
+	/* cont_bst_brk_gain */
+	if (!aw8697->info.cont_bst_brk_gain)
+		aw_dev_err(aw8697->dev,
+			   "%s aw8697->info.cont_bst_brk_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG5,
+			      AW869XX_BIT_CONTCFG5_BST_BRK_GAIN_MASK,
+			      aw8697->info.cont_bst_brk_gain);
+
+	/* cont_brk_gain */
+	if (!aw8697->info.cont_brk_gain)
+		aw_dev_err(aw8697->dev, "%s aw8697->info.cont_brk_gain = 0!\n",
+			   __func__);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG5,
+			      AW869XX_BIT_CONTCFG5_BRK_GAIN_MASK,
+			      aw8697->info.cont_brk_gain);
+}
+
+/*****************************************************
+ *
+ * ram update
+ *
+ *****************************************************/
+static void aw8697_rtp_loaded(const struct firmware *cont, void *context)
+{
+	struct aw8697 *aw8697 = context;
+	pr_info("%s enter\n", __func__);
+
+	if (!cont) {
+		pr_err("%s: failed to read %s\n", __func__,
+		       aw8697_rtp_name[aw8697->rtp_file_num]);
+		release_firmware(cont);
+		return;
+	}
+
+	pr_info("%s: loaded %s - size: %zu\n", __func__,
+		aw8697_rtp_name[aw8697->rtp_file_num], cont ? cont->size : 0);
+
+	/* aw8697 rtp update */
+	aw8697_rtp = vmalloc(cont->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(cont);
+		pr_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw8697_rtp->len = cont->size;
+	pr_info("%s: rtp size = %d\n", __func__, aw8697_rtp->len);
+	memcpy(aw8697_rtp->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	aw8697->rtp_init = 1;
+	pr_info("%s: rtp update complete\n", __func__);
+}
+
+static int aw8697_rtp_update(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       aw8697_rtp_name[aw8697->rtp_file_num],
+				       aw8697->dev, GFP_KERNEL, aw8697,
+				       aw8697_rtp_loaded);
+}
+
+static void aw8697_container_update(struct aw8697 *aw8697,
+				    struct aw8697_container *aw8697_cont)
+{
+	int i = 0;
+	unsigned int shift = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	mutex_lock(&aw8697->lock);
+
+	aw8697->ram.baseaddr_shift = 2;
+	aw8697->ram.ram_shift = 4;
+
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+
+	/* base addr */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697->ram.base_addr =
+		(unsigned int)((aw8697_cont->data[0 + shift] << 8) |
+			       (aw8697_cont->data[1 + shift]));
+	pr_info("%s: base_addr=0x%4x\n", __func__, aw8697->ram.base_addr);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_BASE_ADDRH,
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW8697_REG_BASE_ADDRL,
+			 aw8697_cont->data[1 + shift]);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AEH,
+			 (unsigned char)((aw8697->ram.base_addr >> 2) >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AEL,
+			 (unsigned char)((aw8697->ram.base_addr >> 2) &
+					 0x00FF));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AFH,
+			 (unsigned char)((aw8697->ram.base_addr -
+					  (aw8697->ram.base_addr >> 2)) >>
+					 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_FIFO_AFL,
+			 (unsigned char)((aw8697->ram.base_addr -
+					  (aw8697->ram.base_addr >> 2)) &
+					 0x00FF));
+
+	/* ram */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRH,
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRL,
+			 aw8697_cont->data[1 + shift]);
+	shift = aw8697->ram.ram_shift;
+	for (i = shift; i < aw8697_cont->len; i++) {
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMDATA,
+				 aw8697_cont->data[i]);
+	}
+
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+
+	mutex_unlock(&aw8697->lock);
+
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+}
+
+static void aw869xx_container_update(struct aw8697 *aw8697,
+				     struct aw8697_container *aw8697_cont)
+{
+	int i = 0;
+	unsigned int shift = 0;
+	unsigned char reg_val = 0;
+	unsigned int temp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	mutex_lock(&aw8697->lock);
+	aw8697->ram.baseaddr_shift = 2;
+	aw8697->ram.ram_shift = 4;
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+	/* Enter standby mode */
+	aw8697_haptic_stop(aw8697);
+	/* base addr */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697->ram.base_addr =
+		(unsigned int)((aw8697_cont->data[0 + shift] << 8) |
+			       (aw8697_cont->data[1 + shift]));
+	aw_dev_info(aw8697->dev, "%s: base_addr = %d\n", __func__,
+		    aw8697->ram.base_addr);
+
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG1, /*ADDRH*/
+			 aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG2, /*ADDRL*/
+			 aw8697_cont->data[1 + shift]);
+	/* FIFO_AEH */
+	aw8697_i2c_write_bits(
+		aw8697, AW869XX_REG_RTPCFG3, AW869XX_BIT_RTPCFG3_FIFO_AEH_MASK,
+		(unsigned char)(((aw8697->ram.base_addr >> 1) >> 4) & 0xF0));
+	/* FIFO AEL */
+	aw8697_i2c_write(
+		aw8697, AW869XX_REG_RTPCFG4,
+		(unsigned char)(((aw8697->ram.base_addr >> 1) & 0x00FF)));
+	/* FIFO_AFH */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_RTPCFG3,
+			      AW869XX_BIT_RTPCFG3_FIFO_AFH_MASK,
+			      (unsigned char)(((aw8697->ram.base_addr -
+						(aw8697->ram.base_addr >> 2)) >>
+					       8) &
+					      0x0F));
+	/* FIFO_AFL */
+	aw8697_i2c_write(aw8697, AW869XX_REG_RTPCFG5,
+			 (unsigned char)(((aw8697->ram.base_addr -
+					   (aw8697->ram.base_addr >> 2)) &
+					  0x00FF)));
+	/*
+*	unsigned int temp
+*	HIGH<byte4 byte3 byte2 byte1>LOW
+*	|_ _ _ _AF-12BIT_ _ _ _AE-12BIT|
+*/
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG3, &reg_val);
+	temp = ((reg_val & 0x0f) << 24) | ((reg_val & 0xf0) << 4);
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG4, &reg_val);
+	temp = temp | reg_val;
+	aw_dev_info(aw8697->dev, "%s: almost_empty_threshold = %d\n", __func__,
+		    (unsigned short)temp);
+	aw8697_i2c_read(aw8697, AW869XX_REG_RTPCFG5, &reg_val);
+	temp = temp | (reg_val << 16);
+	aw_dev_info(aw8697->dev, "%s: almost_full_threshold = %d\n", __func__,
+		    temp >> 16);
+	/* ram */
+	shift = aw8697->ram.baseaddr_shift;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_RAMADDRH,
+			      AW869XX_BIT_RAMADDRH_MASK,
+			      aw8697_cont->data[0 + shift]);
+	aw8697_i2c_write(aw8697, AW869XX_REG_RAMADDRL,
+			 aw8697_cont->data[1 + shift]);
+	shift = aw8697->ram.ram_shift;
+	for (i = shift; i < aw8697_cont->len; i++) {
+		aw8697_i2c_write(aw8697, AW869XX_REG_RAMDATA,
+				 aw8697_cont->data[i]);
+	}
+
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+	mutex_unlock(&aw8697->lock);
+
+	pr_info("%s exit\n", __func__);
+}
+
+static void aw8697_ram_loaded(const struct firmware *cont, void *context)
+{
+	struct aw8697 *aw8697 = context;
+	struct aw8697_container *aw8697_fw;
+	int i = 0;
+	unsigned short check_sum = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	if (!cont) {
+		pr_err("%s: failed to read %s\n", __func__, aw8697->ram_name);
+		release_firmware(cont);
+		return;
+	}
+
+	pr_info("%s: loaded %s - size: %zu\n", __func__, aw8697->ram_name,
+		cont ? cont->size : 0);
+	/*
+	for(i=0; i<cont->size; i++) {
+		pr_info("%s: addr:0x%04x, data:0x%02x\n", __func__, i, *(cont->data+i));
+	}
+	*/
+	pr_info("%s: loaded %s - size: %zu bytes\n", __func__, aw8697->ram_name,
+		cont ? cont->size : 0);
+	/* check sum */
+	for (i = 2; i < cont->size; i++) {
+		check_sum += cont->data[i];
+	}
+	if (check_sum !=
+	    (unsigned short)((cont->data[0] << 8) | (cont->data[1]))) {
+		pr_err("%s: check sum err: check_sum=0x%04x\n", __func__,
+		       check_sum);
+		return;
+	} else {
+		pr_info("%s: check sum pass : 0x%04x\n", __func__, check_sum);
+		aw8697->ram.check_sum = check_sum;
+	}
+
+	/* aw8697 ram update */
+	aw8697_fw = kzalloc(cont->size + sizeof(int), GFP_KERNEL);
+	if (!aw8697_fw) {
+		release_firmware(cont);
+		pr_err("%s: Error allocating memory\n", __func__);
+		return;
+	}
+	aw8697_fw->len = cont->size;
+	memcpy(aw8697_fw->data, cont->data, cont->size);
+	release_firmware(cont);
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_container_update(aw8697, aw8697_fw);
+	} else {
+		aw869xx_container_update(aw8697, aw8697_fw);
+	}
+
+	aw8697->ram.len = aw8697_fw->len;
+
+	kfree(aw8697_fw);
+
+	aw8697->ram_init = 1;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_trig_enable_config(aw8697);
+		aw8697_rtp_update(aw8697);
+	}
+	pr_info("%s: fw update complete\n", __func__);
+}
+
+static int aw8697_ram_update(struct aw8697 *aw8697)
+{
+	aw8697->ram_init = 0;
+	aw8697->rtp_init = 0;
+	return request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+				       aw8697->ram_name, aw8697->dev,
+				       GFP_KERNEL, aw8697, aw8697_ram_loaded);
+}
+
+#ifdef AWINIC_RAM_UPDATE_DELAY
+static void aw8697_ram_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, ram_work.work);
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697_ram_update(aw8697);
+}
+#endif
+
+static int aw8697_ram_init(struct aw8697 *aw8697)
+{
+#ifdef AWINIC_RAM_UPDATE_DELAY
+	int ram_timer_val = 5000;
+	aw8697->ram_name = aw8697_ram_name;
+	INIT_DELAYED_WORK(&aw8697->ram_work, aw8697_ram_work_routine);
+	//schedule_delayed_work(&aw8697->ram_work,
+	//msecs_to_jiffies(ram_timer_val));
+	queue_delayed_work(aw8697->work_queue, &aw8697->ram_work,
+			   msecs_to_jiffies(ram_timer_val));
+#else
+	aw8697->ram_name = aw8697_ram_name;
+	aw8697_ram_update(aw8697);
+#endif
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic control
+ *
+ *****************************************************/
+static int aw8697_haptic_softreset(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_i2c_write(aw8697, AW8697_REG_ID, 0xAA);
+	usleep_range(3000, 3500);
+	return 0;
+}
+
+static int aw8697_haptic_active(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_WORK_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_ACTIVE);
+	aw8697_interrupt_clear(aw8697);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_UVLO_MASK,
+			      AW8697_BIT_SYSINTM_UVLO_EN);
+	return 0;
+}
+
+static int aw8697_haptic_play_mode(struct aw8697 *aw8697,
+				   unsigned char play_mode)
+{
+	pr_debug("%s enter\n", __func__);
+
+	switch (play_mode) {
+	case AW8697_HAPTIC_STANDBY_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter standby mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_STANDBY_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_UVLO_MASK,
+					      AW8697_BIT_SYSINTM_UVLO_OFF);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_WORK_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_STANDBY);
+		} else {
+			aw8697_haptic_stop(aw8697);
+		}
+		break;
+	case AW8697_HAPTIC_RAM_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter ram mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RAM_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+			/* bst mode */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BOOST);
+		}
+
+		break;
+	case AW8697_HAPTIC_RAM_LOOP_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter ram loop mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RAM_LOOP_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		}
+
+		break;
+	case AW8697_HAPTIC_RTP_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter rtp mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_RTP_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RTP);
+			aw8697_haptic_active(aw8697);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RTP);
+			/* bst mode config */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BOOST);
+		}
+		break;
+	case AW8697_HAPTIC_TRIG_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter trig mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_TRIG_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+					      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+			aw8697_haptic_active(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM);
+		}
+
+		break;
+	case AW8697_HAPTIC_CONT_MODE:
+		aw_dev_info(aw8697->dev, "%s: enter cont mode\n", __func__);
+		aw8697->play_mode = AW8697_HAPTIC_CONT_MODE;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+				AW8697_BIT_SYSCTRL_PLAY_MODE_CONT);
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_SYSCTRL,
+				AW8697_BIT_SYSCTRL_BST_MODE_MASK,
+				AW8697_BIT_SYSCTRL_BST_MODE_BYPASS);
+			aw8697_haptic_active(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK,
+				AW869XX_BIT_PLAYCFG3_PLAY_MODE_CONT);
+			/* bst mode */
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG1,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+				AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+		}
+
+		break;
+	default:
+		dev_err(aw8697->dev, "%s: play mode %d err", __func__,
+			play_mode);
+		break;
+	}
+	return 0;
+}
+
+static int aw8697_haptic_play_go(struct aw8697 *aw8697, bool flag)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		if (flag == true) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_GO,
+					      AW8697_BIT_GO_MASK,
+					      AW8697_BIT_GO_ENABLE);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_GO,
+					      AW8697_BIT_GO_MASK,
+					      AW8697_BIT_GO_DISABLE);
+		}
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG4,
+				 AW869XX_BIT_PLAYCFG4_GO_ON);
+	}
+	return 0;
+}
+
+static int aw8697_haptic_stop_delay(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int cnt = 100;
+
+	while (cnt--) {
+		aw8697_i2c_read(aw8697, AW8697_REG_GLB_STATE, &reg_val);
+		if ((reg_val & 0x0f) == 0x00) {
+			return 0;
+		}
+		msleep(2);
+		pr_debug("%s wait for standby, reg glb_state=0x%02x\n",
+			 __func__, reg_val);
+	}
+	pr_err("%s do not enter standby automatically\n", __func__);
+
+	return 0;
+}
+
+static int aw8697_haptic_stop(struct aw8697 *aw8697)
+{
+	unsigned char cnt = 40;
+	unsigned char reg_val = 0;
+	bool force_flag = true;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_play_go(aw8697, false);
+		aw8697_haptic_stop_delay(aw8697);
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	} else {
+		aw8697->play_mode = AW8697_HAPTIC_STANDBY_MODE;
+		aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == AW869XX_BIT_GLBRD5_STATE_STANDBY ||
+		    (reg_val & 0x0f) == AW869XX_BIT_GLBRD5_STATE_I2S_GO) {
+			force_flag = false;
+			aw_dev_info(
+				aw8697->dev,
+				"%s already in standby mode! glb_state=0x%02X\n",
+				__func__, reg_val);
+		} else {
+			aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG4,
+					 AW869XX_BIT_PLAYCFG4_STOP_ON);
+			while (cnt) {
+				aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+						&reg_val);
+				if ((reg_val & 0x0f) ==
+					    AW869XX_BIT_GLBRD5_STATE_STANDBY ||
+				    (reg_val & 0x0f) ==
+					    AW869XX_BIT_GLBRD5_STATE_I2S_GO) {
+					cnt = 0;
+					force_flag = false;
+					aw_dev_info(
+						aw8697->dev,
+						"%s entered standby! glb_state=0x%02X\n",
+						__func__, reg_val);
+				} else {
+					cnt--;
+					aw_dev_info(
+						aw8697->dev,
+						"%s wait for standby, glb_state=0x%02X\n",
+						__func__, reg_val);
+				}
+				usleep_range(2000, 2500);
+			}
+		}
+		if (force_flag) {
+			aw_dev_err(aw8697->dev,
+				   "%s force to enter standby mode!\n",
+				   __func__);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL2,
+					      AW869XX_BIT_SYSCTRL2_STANDBY_MASK,
+					      AW869XX_BIT_SYSCTRL2_STANDBY_ON);
+		}
+	}
+	return 0;
+}
+
+static int aw8697_haptic_start(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+
+	aw8697_haptic_play_go(aw8697, true);
+
+	return 0;
+}
+
+static int aw8697_haptic_set_wav_seq(struct aw8697 *aw8697, unsigned char wav,
+				     unsigned char seq)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_WAVSEQ1 + wav, seq);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_WAVCFG1 + wav, seq);
+	}
+	return 0;
+}
+
+static int aw8697_haptic_set_wav_loop(struct aw8697 *aw8697, unsigned char wav,
+				      unsigned char loop)
+{
+	unsigned char tmp = 0;
+
+	if (wav % 2) {
+		tmp = loop << 0;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697,
+					      AW8697_REG_WAVLOOP1 + (wav / 2),
+					      AW8697_BIT_WAVLOOP_SEQNP1_MASK,
+					      tmp);
+		} else {
+			aw8697_i2c_write_bits(aw8697,
+					      AW869XX_REG_WAVCFG9 + (wav / 2),
+					      AW869XX_BIT_WAVLOOP_SEQ_EVEN_MASK,
+					      tmp);
+		}
+	} else {
+		tmp = loop << 4;
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697,
+					      AW8697_REG_WAVLOOP1 + (wav / 2),
+					      AW8697_BIT_WAVLOOP_SEQN_MASK,
+					      tmp);
+		} else {
+			aw8697_i2c_write_bits(aw8697,
+					      AW869XX_REG_WAVCFG9 + (wav / 2),
+					      AW869XX_BIT_WAVLOOP_SEQ_ODD_MASK,
+					      tmp);
+		}
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_set_repeat_wav_seq(struct aw8697 *aw8697,
+					    unsigned char seq)
+{
+	aw8697_haptic_set_wav_seq(aw8697, 0x00, seq);
+	aw8697_haptic_set_wav_loop(aw8697, 0x00,
+				   AW8697_BIT_WAVLOOP_INIFINITELY);
+
+	return 0;
+}
+
+static int aw8697_haptic_set_bst_vol(struct aw8697 *aw8697,
+				     unsigned char bst_vol)
+{
+	if (bst_vol & 0xe0) {
+		bst_vol = 0x1f;
+	}
+	//printk("%s %d --\n", __func__, __LINE__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_BSTDBG4,
+				      AW8697_BIT_BSTDBG4_BSTVOL_MASK,
+				      (bst_vol << 1));
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG1,
+				      AW869XX_BIT_PLAYCFG1_BST_VOUT_RDA_MASK,
+				      (bst_vol << 1));
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_set_bst_peak_cur(struct aw8697 *aw8697,
+					  unsigned char peak_cur)
+{
+	peak_cur &= AW8697_BSTCFG_PEAKCUR_LIMIT;
+	pr_info("%s  %d enter\n", __func__, __LINE__);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_BSTCFG,
+			      AW8697_BIT_BSTCFG_PEAKCUR_MASK, peak_cur);
+	return 0;
+}
+
+static int aw869xx_haptic_set_bst_peak_cur(struct aw8697 *aw8697)
+{
+	switch (aw8697->bst_pc) {
+	case AW869XX_HAPTIC_BST_PC_L1:
+		aw_dev_info(aw8697->dev, "%s bst pc = L1\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (0 << 1));
+		return 0;
+	case AW869XX_HAPTIC_BST_PC_L2:
+		aw_dev_info(aw8697->dev, "%s bst pc = L2\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (5 << 1));
+		return 0;
+	default:
+		aw_dev_info(aw8697->dev, "%s bst pc = L1\n", __func__);
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG1,
+				      AW869XX_BIT_BSTCFG1_BST_PC_MASK,
+				      (0 << 1));
+		break;
+	}
+	return 0;
+}
+static int aw8697_haptic_set_gain(struct aw8697 *aw8697, unsigned char gain)
+{
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_DATDBG, gain);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_PLAYCFG2, gain);
+	}
+	return 0;
+}
+static int aw8697_haptic_set_pwm(struct aw8697 *aw8697, unsigned char mode)
+{
+	switch (mode) {
+	case AW8697_PWM_48K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_48K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_48K);
+		}
+
+		break;
+	case AW8697_PWM_24K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_24K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_24K);
+		}
+
+		break;
+	case AW8697_PWM_12K:
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMDBG,
+					      AW8697_BIT_PWMDBG_PWM_MODE_MASK,
+					      AW8697_BIT_PWMDBG_PWM_12K);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL2,
+				AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL2_RATE_12K);
+		}
+
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int aw8697_haptic_play_repeat_seq(struct aw8697 *aw8697,
+					 unsigned char flag)
+{
+	pr_debug("%s enter\n", __func__);
+
+	if (flag) {
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_LOOP_MODE);
+		aw8697_haptic_start(aw8697);
+	}
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * motor protect
+ *
+ *****************************************************/
+static int aw8697_haptic_swicth_motorprotect_config(struct aw8697 *aw8697,
+						    unsigned char addr,
+						    unsigned char val)
+{
+	pr_info("%s enter\n", __func__);
+
+	if (addr == 1) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_DETCTRL,
+				AW8697_BIT_DETCTRL_PROTECT_MASK,
+				AW8697_BIT_DETCTRL_PROTECT_SHUTDOWN);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRC_MASK,
+					      AW8697_BIT_PWMPRC_PRC_ENABLE);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PR_MASK,
+					      AW8697_BIT_PRLVL_PR_ENABLE);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_DETCFG1,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_MASK,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_VALID);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRC_EN_MASK,
+					      AW869XX_BIT_PWMCFG1_PRC_ENABLE);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PR_EN_MASK,
+					      AW869XX_BIT_PWMCFG3_PR_ENABLE);
+		}
+
+	} else if (addr == 0) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_DETCTRL,
+				AW8697_BIT_DETCTRL_PROTECT_MASK,
+				AW8697_BIT_DETCTRL_PROTECT_NO_ACTION);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRC_MASK,
+					      AW8697_BIT_PWMPRC_PRC_DISABLE);
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PR_MASK,
+					      AW8697_BIT_PRLVL_PR_DISABLE);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_DETCFG1,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_MASK,
+				AW869XX_BIT_DETCFG1_PRCT_MODE_INVALID);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRC_EN_MASK,
+					      AW869XX_BIT_PWMCFG1_PRC_DISABLE);
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PR_EN_MASK,
+					      AW869XX_BIT_PWMCFG3_PR_DISABLE);
+		}
+
+	} else if (addr == 0x2d) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PWMPRC,
+					      AW8697_BIT_PWMPRC_PRCTIME_MASK,
+					      val);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG1,
+					      AW869XX_BIT_PWMCFG1_PRCTIME_MASK,
+					      val);
+		}
+
+	} else if (addr == 0x3e) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRLVL,
+					      AW8697_BIT_PRLVL_PRLVL_MASK, val);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_PWMCFG3,
+					      AW869XX_BIT_PWMCFG3_PRLVL_MASK,
+					      val);
+		}
+
+	} else if (addr == 0x3f) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_PRTIME,
+					      AW8697_BIT_PRTIME_PRTIME_MASK,
+					      val);
+		} else {
+			aw8697_i2c_write(aw8697, AW869XX_REG_PWMCFG4, val);
+		}
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * offset calibration
+ *
+ *****************************************************/
+static int aw8697_haptic_offset_calibration(struct aw8697 *aw8697)
+{
+	unsigned int cont = 2000;
+	unsigned char reg_val = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697_haptic_raminit(aw8697, true);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+				      AW8697_BIT_DETCTRL_DIAG_GO_MASK,
+				      AW8697_BIT_DETCTRL_DIAG_GO_ENABLE);
+		while (1) {
+			aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+			if ((reg_val & 0x01) == 0 || cont == 0)
+				break;
+			cont--;
+		}
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+				      AW869XX_BIT_DETCFG2_DIAG_GO_MASK,
+				      AW869XX_BIT_DETCFG2_DIAG_GO_ON);
+		while (1) {
+			aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG2, &reg_val);
+			if ((reg_val & AW869XX_BIT_DETCFG2_DIAG_GO_ON) == 0 ||
+			    cont == 0)
+				break;
+			cont--;
+		}
+	}
+	if (cont == 0)
+		aw_dev_err(aw8697->dev, "%s calibration offset failed!\n",
+			   __func__);
+	aw8697_haptic_raminit(aw8697, false);
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * trig config
+ *
+ *****************************************************/
+
+static int aw8697_haptic_trig_param_init(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	aw8697->trig[0].enable = aw8697->info.trig_config[0][0];
+	aw8697->trig[0].default_level = aw8697->info.trig_config[0][1];
+	aw8697->trig[0].dual_edge = aw8697->info.trig_config[0][2];
+	aw8697->trig[0].frist_seq = aw8697->info.trig_config[0][3];
+	aw8697->trig[0].second_seq = aw8697->info.trig_config[0][4];
+
+	aw8697->trig[1].enable = aw8697->info.trig_config[1][0];
+	;
+	aw8697->trig[1].default_level = aw8697->info.trig_config[1][1];
+	aw8697->trig[1].dual_edge = aw8697->info.trig_config[1][2];
+	aw8697->trig[1].frist_seq = aw8697->info.trig_config[1][3];
+	aw8697->trig[1].second_seq = aw8697->info.trig_config[1][4];
+
+	aw8697->trig[2].enable = aw8697->info.trig_config[2][0];
+	;
+	aw8697->trig[2].default_level = aw8697->info.trig_config[2][1];
+	aw8697->trig[2].dual_edge = aw8697->info.trig_config[2][2];
+	aw8697->trig[2].frist_seq = aw8697->info.trig_config[2][3];
+	aw8697->trig[2].second_seq = aw8697->info.trig_config[2][4];
+
+	return 0;
+}
+
+static int aw8697_haptic_trig_param_config(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	if (aw8697->trig[0].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_POLAR_POS);
+	}
+	if (aw8697->trig[1].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_POLAR_POS);
+	}
+	if (aw8697->trig[2].default_level) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_POLAR_POS);
+	}
+
+	if (aw8697->trig[0].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG1_EDGE_POS);
+	}
+	if (aw8697->trig[1].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG2_EDGE_POS);
+	}
+	if (aw8697->trig[2].dual_edge) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_POS_NEG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG1,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_MASK,
+				      AW8697_BIT_TRGCFG1_TRG3_EDGE_POS);
+	}
+
+	if (aw8697->trig[0].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG1_WAV_P,
+				 aw8697->trig[0].frist_seq);
+	}
+	if (aw8697->trig[0].second_seq && aw8697->trig[0].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG1_WAV_N,
+				 aw8697->trig[0].second_seq);
+	}
+	if (aw8697->trig[1].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG2_WAV_P,
+				 aw8697->trig[1].frist_seq);
+	}
+	if (aw8697->trig[1].second_seq && aw8697->trig[1].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG2_WAV_N,
+				 aw8697->trig[1].second_seq);
+	}
+	if (aw8697->trig[2].frist_seq) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG3_WAV_P,
+				 aw8697->trig[1].frist_seq);
+	}
+	if (aw8697->trig[2].second_seq && aw8697->trig[2].dual_edge) {
+		aw8697_i2c_write(aw8697, AW8697_REG_TRG3_WAV_N,
+				 aw8697->trig[1].second_seq);
+	}
+
+	return 0;
+}
+
+static int aw8697_haptic_trig_enable_config(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG1_ENABLE_MASK,
+			      aw8697->trig[0].enable);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG2_ENABLE_MASK,
+			      aw8697->trig[1].enable);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_TRG_CFG2,
+			      AW8697_BIT_TRGCFG2_TRG3_ENABLE_MASK,
+			      aw8697->trig[2].enable);
+
+	return 0;
+}
+
+static int aw8697_haptic_auto_boost_config(struct aw8697 *aw8697,
+					   unsigned char flag)
+{
+	aw8697->auto_boost = flag;
+	if (flag) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_BST_AUTO,
+				AW8697_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				AW8697_BIT_BST_AUTO_BST_AUTOMATIC_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_MASK,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_ENABLE);
+		}
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(
+				aw8697, AW8697_REG_BST_AUTO,
+				AW8697_BIT_BST_AUTO_BST_AUTOSW_MASK,
+				AW8697_BIT_BST_AUTO_BST_MANUAL_BOOST);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_PLAYCFG3,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_MASK,
+				AW869XX_BIT_PLAYCFG3_AUTO_BST_DISABLE);
+		}
+	}
+	return 0;
+}
+/*****************************************************
+ *
+ * vbat mode
+ *
+ *****************************************************/
+static int aw8697_haptic_cont_vbat_mode(struct aw8697 *aw8697,
+					unsigned char flag)
+{
+	if (flag == AW8697_HAPTIC_CONT_VBAT_HW_COMP_MODE) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_ADCTEST,
+					      AW8697_BIT_ADCTEST_VBAT_MODE_MASK,
+					      AW8697_BIT_ADCTEST_VBAT_HW_COMP);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL1,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_HW);
+		}
+
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_ADCTEST,
+					      AW8697_BIT_ADCTEST_VBAT_MODE_MASK,
+					      AW8697_BIT_ADCTEST_VBAT_SW_COMP);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_SYSCTRL1,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_MASK,
+				AW869XX_BIT_SYSCTRL1_VBAT_MODE_SW);
+		}
+	}
+	return 0;
+}
+
+static int aw869xx_haptic_get_vbat(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int vbat_code = 0;
+	unsigned int cont = 2000;
+
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_DETCFG2,
+			      AW869XX_BIT_DETCFG2_VBAT_GO_MASK,
+			      AW869XX_BIT_DETCFG2_VABT_GO_ON);
+
+	while (1) {
+		aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG2, &reg_val);
+		if ((reg_val & 0x02) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_VBAT, &reg_val);
+	vbat_code = (vbat_code | reg_val) << 2;
+	aw8697_i2c_read(aw8697, AW869XX_REG_DET_LO, &reg_val);
+	vbat_code = vbat_code | ((reg_val & 0x30) >> 4);
+	aw8697->vbat = 6100 * vbat_code / 1024;
+	if (aw8697->vbat > AW8697_VBAT_MAX) {
+		aw8697->vbat = AW8697_VBAT_MAX;
+		aw_dev_info(aw8697->dev, "%s vbat max limit = %dmV\n", __func__,
+			    aw8697->vbat);
+	}
+	if (aw8697->vbat < AW8697_VBAT_MIN) {
+		aw8697->vbat = AW8697_VBAT_MIN;
+		aw_dev_info(aw8697->dev, "%s vbat min limit = %dmV\n", __func__,
+			    aw8697->vbat);
+	}
+	aw_dev_info(aw8697->dev, "%s aw8697->vbat=%dmV, vbat_code=0x%02X\n",
+		    __func__, aw8697->vbat, vbat_code);
+	aw8697_haptic_raminit(aw8697, false);
+	return 0;
+}
+
+static int aw8697_haptic_get_vbat(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int cont = 2000;
+
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DETCTRL,
+			      AW8697_BIT_DETCTRL_VBAT_GO_MASK,
+			      AW8697_BIT_DETCTRL_VABT_GO_ENABLE);
+
+	while (1) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+		if ((reg_val & 0x02) == 0 || cont == 0)
+			break;
+		cont--;
+	}
+
+	aw8697_i2c_read(aw8697, AW8697_REG_VBATDET, &reg_val);
+	aw8697->vbat = 6100 * reg_val / 256;
+	if (aw8697->vbat > AW8697_VBAT_MAX) {
+		aw8697->vbat = AW8697_VBAT_MAX;
+		pr_debug("%s vbat max limit = %dmV\n", __func__, aw8697->vbat);
+	}
+	if (aw8697->vbat < AW8697_VBAT_MIN) {
+		aw8697->vbat = AW8697_VBAT_MIN;
+		pr_debug("%s vbat min limit = %dmV\n", __func__, aw8697->vbat);
+	}
+
+	aw8697_haptic_raminit(aw8697, false);
+
+	return 0;
+}
+
+static int aw8697_haptic_ram_vbat_comp(struct aw8697 *aw8697, bool flag)
+{
+	int temp_gain = 0;
+	//pr_info("%s  %d enter\n", __func__, __LINE__);
+	if (flag) {
+		if (aw8697->ram_vbat_comp ==
+		    AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE) {
+			if (aw8697->chip_version == AW8697_CHIP_9X) {
+				aw8697_haptic_get_vbat(aw8697);
+			} else {
+				aw869xx_haptic_get_vbat(aw8697);
+			}
+			temp_gain =
+				aw8697->gain * AW8697_VBAT_REFER / aw8697->vbat;
+			if (temp_gain >
+			    (128 * AW8697_VBAT_REFER / AW8697_VBAT_MIN)) {
+				temp_gain = 128 * AW8697_VBAT_REFER /
+					    AW8697_VBAT_MIN;
+				pr_debug("%s gain limit=%d\n", __func__,
+					 temp_gain);
+			}
+			aw8697_haptic_set_gain(aw8697, temp_gain);
+		} else {
+			aw8697_haptic_set_gain(aw8697, aw8697->gain);
+		}
+	} else {
+		aw8697_haptic_set_gain(aw8697, aw8697->gain);
+	}
+	return 0;
+}
+
+/*****************************************************
+ *
+ * f0
+ *
+ *****************************************************/
+static int aw8697_haptic_set_f0_preset(struct aw8697 *aw8697)
+{
+	unsigned int f0_reg = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	f0_reg = 1000000000 / (aw8697->info.f0_pre * aw8697->info.f0_coeff);
+	aw8697_i2c_write(aw8697, AW8697_REG_F_PRE_H,
+			 (unsigned char)((f0_reg >> 8) & 0xff));
+	aw8697_i2c_write(aw8697, AW8697_REG_F_PRE_L,
+			 (unsigned char)((f0_reg >> 0) & 0xff));
+
+	return 0;
+}
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_F0_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_F0_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+#ifdef RETRY_F0_CHECK
+		aw8697->f0 = 0;
+#endif
+		aw8697->f0_cali_status = false;
+		return 0;
+	}
+	aw8697->f0_cali_status = true;
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->f0 = (unsigned int)f0_tmp;
+	pr_info("%s f0=%d\n", __func__, aw8697->f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_debug("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->cont_f0 = (unsigned int)f0_tmp;
+	pr_info("%s f0=%d\n", __func__, aw8697->cont_f0);
+
+	return 0;
+}
+#else
+static int aw8697_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	pr_debug("%s enter\n", __func__);
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_H, &reg_val);
+	f0_reg = (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_F_LRA_CONT_L, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		pr_info("%s: not get f0_reg value is 0!\n", __func__);
+		return 0;
+	}
+	f0_tmp = 1000000000 / (f0_reg * aw8697->info.f0_coeff);
+	aw8697->cont_f0 = (unsigned int)f0_tmp;
+	aw8697->cont_f0 -= 12;
+	aw8697->f0 = aw8697->cont_f0;
+	pr_info("%s f0=%d\n", __func__, aw8697->cont_f0);
+
+	return 0;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_haptic_read_beme(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	pr_info("%s  %d enter\n", __func__, __LINE__);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_WAIT_VOL_MP, &reg_val);
+	aw8697->max_pos_beme = (reg_val << 0);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_WAIT_VOL_MN, &reg_val);
+	aw8697->max_neg_beme = (reg_val << 0);
+
+	pr_info("%s max_pos_beme=%d\n", __func__, aw8697->max_pos_beme);
+	pr_info("%s max_neg_beme=%d\n", __func__, aw8697->max_neg_beme);
+
+	return 0;
+}
+#else
+static int aw8697_haptic_read_cont_bemf(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int bemf = 0;
+
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_BEMF_VOL_H, &reg_val);
+	bemf |= (reg_val << 8);
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_BEMF_VOL_L, &reg_val);
+	bemf |= (reg_val << 0);
+
+	pr_info("%s bemf=%d\n", __func__, bemf);
+
+	return 0;
+}
+#endif
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static void aw8697_haptic_set_rtp_aei(struct aw8697 *aw8697, bool flag)
+{
+	if (flag) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_FF_AE_MASK,
+					      AW8697_BIT_SYSINTM_FF_AE_EN);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+					      AW869XX_BIT_SYSINTM_FF_AEM_MASK,
+					      AW869XX_BIT_SYSINTM_FF_AEM_ON);
+		}
+	} else {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+					      AW8697_BIT_SYSINTM_FF_AE_MASK,
+					      AW8697_BIT_SYSINTM_FF_AE_OFF);
+		} else {
+			aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+					      AW869XX_BIT_SYSINTM_FF_AEM_MASK,
+					      AW869XX_BIT_SYSINTM_FF_AEM_OFF);
+		}
+	}
+}
+static unsigned char aw8697_haptic_rtp_get_fifo_afi(struct aw8697 *aw8697)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->osc_cali_flag == 1) {
+		aw8697_i2c_read(aw8697, AW8697_REG_SYSST, &reg_val);
+		reg_val &= AW8697_BIT_SYSST_FF_AFS;
+		ret = reg_val >> 3;
+	} else {
+		aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+		reg_val &= AW8697_BIT_SYSINT_FF_AFI;
+		ret = reg_val >> 3;
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * rtp
+ *
+ *****************************************************/
+static int aw8697_haptic_rtp_init(struct aw8697 *aw8697)
+{
+	unsigned int buf_len = 0;
+	unsigned int period_size = aw8697->ram.base_addr >> 2;
+	bool rtp_start = true;
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	mutex_lock(&aw8697->rtp_lock);
+	aw8697->rtp_cnt = 0;
+	while ((!aw8697_haptic_rtp_get_fifo_afi(aw8697)) &&
+	       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		if (aw8697->is_custom_wave == 0) {
+			if (rtp_start) {
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    aw8697->ram.base_addr)
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				else
+					buf_len = (aw8697->ram.base_addr);
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				rtp_start = false;
+			} else {
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    (aw8697->ram.base_addr >> 2)) {
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				} else {
+					buf_len = (aw8697->ram.base_addr >> 2);
+				}
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+			}
+			aw8697->rtp_cnt += buf_len;
+			pr_info("%s update rtp_cnt = %d \n", __func__,
+				aw8697->rtp_cnt);
+			if (aw8697->rtp_cnt == aw8697_rtp->len) {
+				aw8697->rtp_cnt = 0;
+				aw8697_haptic_set_rtp_aei(aw8697, false);
+				mutex_unlock(&aw8697->rtp_lock);
+				pm_qos_remove_request(&pm_qos_req_vb);
+				return 0;
+			}
+		} else {
+			buf_len = read_rb(aw8697_rtp->data, period_size);
+			aw8697_i2c_writes(aw8697, AW8697_REG_RTP_DATA,
+					  aw8697_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				pr_info("%s: custom rtp update complete\n",
+					__func__);
+				aw8697->rtp_cnt = 0;
+				aw8697_haptic_set_rtp_aei(aw8697, false);
+				mutex_unlock(&aw8697->rtp_lock);
+				pm_qos_remove_request(&pm_qos_req_vb);
+				return 0;
+			}
+		}
+	}
+	if (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE &&
+	    !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw8697_haptic_set_rtp_aei(aw8697, true);
+	}
+	pr_info("%s: exit\n", __func__);
+	mutex_unlock(&aw8697->rtp_lock);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+static unsigned char aw869xx_haptic_rtp_get_fifo_afs(struct aw8697 *aw8697)
+{
+	unsigned char ret = 0;
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSST, &reg_val);
+	reg_val &= AW869XX_BIT_SYSST_FF_AFS;
+	ret = reg_val >> 3;
+	return ret;
+}
+
+static int aw869xx_haptic_rtp_init(struct aw8697 *aw8697)
+{
+	unsigned int buf_len = 0;
+	unsigned char glb_state_val = 0;
+	unsigned int period_size = aw8697->ram.base_addr >> 2;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	aw8697->rtp_cnt = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	while ((!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) &&
+	       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw_dev_info(aw8697->dev, "%s rtp cnt = %d\n", __func__,
+			    aw8697->rtp_cnt);
+		if (aw8697->is_custom_wave == 0) {
+			if (!aw8697_rtp) {
+				aw_dev_info(aw8697->dev,
+					    "%s:aw8697_rtp is null, break!\n",
+					    __func__);
+				break;
+			}
+			if (aw8697->rtp_cnt < (aw8697->ram.base_addr)) {
+				if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				    (aw8697->ram.base_addr)) {
+					buf_len = aw8697_rtp->len -
+						  aw8697->rtp_cnt;
+				} else {
+					buf_len = aw8697->ram.base_addr;
+				}
+			} else if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+				   (aw8697->ram.base_addr >> 2)) {
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			} else {
+				buf_len = aw8697->ram.base_addr >> 2;
+			}
+			aw_dev_info(aw8697->dev, "%s buf_len = %d\n", __func__,
+				    buf_len);
+			aw8697_i2c_writes(aw8697, AW869XX_REG_RTPDATA,
+					  &aw8697_rtp->data[aw8697->rtp_cnt],
+					  buf_len);
+			aw8697->rtp_cnt += buf_len;
+			aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+					&glb_state_val);
+			if ((aw8697->rtp_cnt == aw8697_rtp->len) ||
+			    ((glb_state_val & 0x0f) == 0x00)) {
+				aw_dev_info(aw8697->dev,
+					    "%s: rtp update complete!\n",
+					    __func__);
+				aw8697->rtp_cnt = 0;
+				//pm_qos_remove_request(&pm_qos_req_vb);
+				//mutex_unlock(&aw8697->rtp_lock);
+				//return 0;
+				break;
+			}
+		} else {
+			buf_len = read_rb(aw8697_rtp->data, period_size);
+			aw8697_i2c_writes(aw8697, AW869XX_REG_RTPDATA,
+					  aw8697_rtp->data, buf_len);
+			if (buf_len < period_size) {
+				pr_info("%s: custom rtp update complete\n",
+					__func__);
+				aw8697->rtp_cnt = 0;
+				aw8697_haptic_set_rtp_aei(aw8697, false);
+				mutex_unlock(&aw8697->rtp_lock);
+				pm_qos_remove_request(&pm_qos_req_vb);
+				return 0;
+			}
+		}
+	}
+	mutex_unlock(&aw8697->rtp_lock);
+
+	if ((aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+	    !atomic_read(&aw8697->exit_in_rtp_loop))
+		aw8697_haptic_set_rtp_aei(aw8697, true);
+
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+	pm_qos_remove_request(&pm_qos_req_vb);
+	return 0;
+}
+static int16_t aw8697_haptic_effect_strength(struct aw8697 *aw8697)
+{
+	pr_debug("%s enter\n", __func__);
+	pr_debug("%s: aw8697->play.vmax_mv =0x%x\n", __func__,
+		 aw8697->play.vmax_mv);
+#if 0
+	switch (aw8697->play.vmax_mv) {
+	case AW8697_LIGHT_MAGNITUDE:
+		aw8697->level = 0x80;
+		break;
+	case AW8697_MEDIUM_MAGNITUDE:
+		aw8697->level = 0x50;
+		break;
+	case AW8697_STRONG_MAGNITUDE:
+		aw8697->level = 0x30;
+		break;
+	default:
+		break;
+	}
+#else
+	if (aw8697->play.vmax_mv >= 0x7FFF)
+		aw8697->level = 0x80; /*128*/
+	else if (aw8697->play.vmax_mv <= 0x3FFF)
+		aw8697->level = 0x1E; /*30*/
+	else
+		aw8697->level = (aw8697->play.vmax_mv - 16383) / 128;
+	if (aw8697->level < 0x1E)
+		aw8697->level = 0x1E; /*30*/
+#endif
+
+	pr_info("%s: aw8697->level =0x%x\n", __func__, aw8697->level);
+	return 0;
+}
+
+static int aw8697_haptic_play_effect_seq(struct aw8697 *aw8697,
+					 unsigned char flag)
+{
+	if (aw8697->effect_id > aw8697->info.effect_id_boundary)
+		return 0;
+	//printk("%s:aw8697->effect_id =%d\n", __func__, aw8697->effect_id);
+	//printk("%s:aw8697->activate_mode =%d\n", __func__, aw8697->activate_mode);
+
+	if (flag) {
+		if (aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw8697_haptic_set_wav_seq(aw8697, 0x00,
+						  (char)aw8697->effect_id + 1);
+			aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+			aw8697_haptic_set_wav_loop(aw8697, 0x00, 0x00);
+			aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+			if (aw8697->info.bst_vol_ram <= AW8697_MAX_BST_VO)
+				aw8697_haptic_set_bst_vol(
+					aw8697, aw8697->info.bst_vol_ram);
+			else
+				aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+			aw8697_haptic_effect_strength(aw8697);
+			aw8697_haptic_set_gain(aw8697, aw8697->level);
+			aw8697_haptic_start(aw8697);
+		}
+		if (aw8697->activate_mode ==
+		    AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw8697_haptic_set_repeat_wav_seq(
+				aw8697, (aw8697->info.effect_id_boundary + 1));
+			aw8697_haptic_play_repeat_seq(aw8697, true);
+		}
+	}
+
+	return 0;
+}
+
+static void aw8697_haptic_upload_lra(struct aw8697 *aw8697, unsigned char flag)
+{
+	switch (flag) {
+	case WRITE_ZERO:
+		pr_info("%s write zero to trim_lra!\n", __func__);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK, 0x00);
+		}
+
+		break;
+	case F0_CALI:
+		pr_info("%s write f0_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw8697->f0_calib_data);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+					 (char)aw8697->f0_calib_data);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				(char)aw8697->f0_calib_data);
+		}
+		break;
+	case OSC_CALI:
+		pr_info("%s write lra_calib_data to trim_lra = 0x%02X\n",
+			__func__, aw8697->lra_calib_data);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+					 (char)aw8697->lra_calib_data);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_TRIMCFG3,
+				AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK,
+				(char)aw8697->lra_calib_data);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int aw8697_clock_OSC_trim_calibration(unsigned long int theory_time,
+					     unsigned long int real_time)
+{
+	unsigned int real_code = 0;
+	unsigned int LRA_TRIM_CODE = 0;
+	unsigned int DFT_LRA_TRIM_CODE = 0;
+	unsigned int Not_need_cali_threshold =
+		10; /*0.1 percent not need calibrate*/
+
+	if (theory_time == real_time) {
+		pr_info("aw_osctheory_time == real_time:%ld  theory_time = %ld not need to cali\n",
+			real_time, theory_time);
+		return 0;
+	} else if (theory_time < real_time) {
+		if ((real_time - theory_time) > (theory_time / 50)) {
+			pr_info("aw_osc(real_time - theory_time) > (theory_time/50) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		if ((real_time - theory_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			pr_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+
+		real_code = ((real_time - theory_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 + real_code;
+	} else if (theory_time > real_time) {
+		if ((theory_time - real_time) > (theory_time / 50)) {
+			pr_info("aw_osc((theory_time - real_time) > (theory_time / 50)) not to cali\n");
+			return DFT_LRA_TRIM_CODE;
+		}
+		if ((theory_time - real_time) <
+		    (Not_need_cali_threshold * theory_time / 10000)) {
+			pr_info("aw_oscmicrosecond:%ld  theory_time = %ld not need to cali\n",
+				real_time, theory_time);
+			return DFT_LRA_TRIM_CODE;
+		}
+		real_code = ((theory_time - real_time) * 4000) / theory_time;
+		real_code = ((real_code % 10 < 5) ? 0 : 1) + real_code / 10;
+		real_code = 32 - real_code;
+	}
+	if (real_code > 31)
+		LRA_TRIM_CODE = real_code - 32;
+	else
+		LRA_TRIM_CODE = real_code + 32;
+	pr_info("aw_oscmicrosecond:%ld  theory_time = %ld real_code =0X%02X LRA_TRIM_CODE 0X%02X\n",
+		real_time, theory_time, real_code, LRA_TRIM_CODE);
+
+	return LRA_TRIM_CODE;
+}
+
+static int aw869xx_rtp_trim_lra_calibration(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_trim_code = 0;
+
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSCTRL2, &reg_val);
+	fre_val = (reg_val & 0x03) >> 0;
+
+	if (fre_val == 2 || fre_val == 3)
+		theory_time = (aw8697->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 0)
+		theory_time = (aw8697->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1)
+		theory_time = (aw8697->rtp_len / 48000) * 1000000; /*48K */
+
+	aw_dev_info(aw8697->dev, "%s microsecond:%ld, theory_time = %d\n",
+		    __func__, aw8697->microsecond, theory_time);
+
+	lra_trim_code = aw8697_clock_OSC_trim_calibration(theory_time,
+							  aw8697->microsecond);
+	if (lra_trim_code >= 0) {
+		aw8697->lra_calib_data = lra_trim_code;
+		aw8697_haptic_upload_lra(aw8697, OSC_CALI);
+	}
+	return 0;
+}
+
+static int aw869xx_rtp_osc_calibration(struct aw8697 *aw8697)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+
+	aw8697->rtp_cnt = 0;
+	aw8697->timeval_flags = 1;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file, aw8697_rtp_name[0], aw8697->dev);
+	if (ret < 0) {
+		aw_dev_err(aw8697->dev, "%s: failed to read %s\n", __func__,
+			   aw8697_rtp_name[0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate */
+	aw8697_haptic_stop(aw8697);
+	aw8697->rtp_init = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	vfree(aw8697_rtp);
+	aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw8697->rtp_lock);
+		aw_dev_err(aw8697->dev, "%s: error allocating memory\n",
+			   __func__);
+		return -ENOMEM;
+	}
+	aw8697_rtp->len = rtp_file->size;
+	aw8697->rtp_len = rtp_file->size;
+	aw_dev_info(aw8697->dev, "%s: rtp file:[%s], size: %dbytes\n", __func__,
+		    aw8697_rtp_name[0], aw8697_rtp->len);
+
+	memcpy(aw8697_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw8697->rtp_lock);
+	/* gain */
+	aw8697_haptic_ram_vbat_comp(aw8697, false);
+	/* rtp mode config */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+	/* bst mode */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG1,
+			      AW869XX_BIT_PLAYCFG1_BST_MODE_MASK,
+			      AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS);
+	disable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	/* haptic go */
+	aw8697_haptic_play_go(aw8697, true);
+	/* require latency of CPU & DMA not more then PM_QOS_VALUE_VB us */
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) {
+			aw_dev_info(aw8697->dev,
+				    "%s not full, aw8697->rtp_cnt= %d\n",
+				    __func__, aw8697->rtp_cnt);
+			mutex_lock(&aw8697->rtp_lock);
+			if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			    (aw8697->ram.base_addr >> 2))
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			else
+				buf_len = (aw8697->ram.base_addr >> 2);
+
+			if (aw8697->rtp_cnt != aw8697_rtp->len) {
+				if (aw8697->timeval_flags == 1) {
+					do_gettimeofday(&aw8697->start);
+					aw8697->timeval_flags = 0;
+				}
+				aw8697_i2c_writes(
+					aw8697, AW869XX_REG_RTPDATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				aw8697->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw8697->rtp_lock);
+		}
+		osc_int_state = aw8697_haptic_osc_read_int(aw8697);
+		if (osc_int_state & AW869XX_BIT_SYSST2_FF_EMPTY) {
+			do_gettimeofday(&aw8697->end);
+			aw_dev_info(
+				aw8697->dev,
+				"%s osc trim playback done aw8697->rtp_cnt= %d\n",
+				__func__, aw8697->rtp_cnt);
+			break;
+		}
+		do_gettimeofday(&aw8697->end);
+		aw8697->microsecond =
+			(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+			(aw8697->end.tv_usec - aw8697->start.tv_usec);
+		if (aw8697->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			aw_dev_info(
+				aw8697->dev,
+				"%s osc trim time out! aw8697->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw8697->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	aw8697->microsecond =
+		(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+		(aw8697->end.tv_usec - aw8697->start.tv_usec);
+	/*calibration osc */
+	aw_dev_info(aw8697->dev, "%s awinic_microsecond: %ld\n", __func__,
+		    aw8697->microsecond);
+	return 0;
+}
+
+static int aw8697_rtp_trim_lra_calibration(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	unsigned int fre_val = 0;
+	unsigned int theory_time = 0;
+	unsigned int lra_rtim_code = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_PWMDBG, &reg_val);
+	fre_val = (reg_val & 0x006f) >> 5;
+
+	if (fre_val == 3)
+		theory_time = (aw8697->rtp_len / 12000) * 1000000; /*12K */
+	if (fre_val == 2)
+		theory_time = (aw8697->rtp_len / 24000) * 1000000; /*24K */
+	if (fre_val == 1 || fre_val == 0)
+		theory_time = (aw8697->rtp_len / 48000) * 1000000; /*48K */
+
+	printk("microsecond:%ld  theory_time = %d\n", aw8697->microsecond,
+	       theory_time);
+
+	lra_rtim_code = aw8697_clock_OSC_trim_calibration(theory_time,
+							  aw8697->microsecond);
+	if (lra_rtim_code > 0) {
+		aw8697->lra_calib_data = lra_rtim_code;
+		aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+				 (char)lra_rtim_code);
+	}
+	return 0;
+}
+static unsigned char aw8697_haptic_osc_read_int(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DBGSTAT, &reg_val);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_SYSST2, &reg_val);
+	}
+	return reg_val;
+}
+static int aw8697_rtp_osc_calibration(struct aw8697 *aw8697)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	unsigned int buf_len = 0;
+	unsigned char osc_int_state = 0;
+	aw8697->rtp_cnt = 0;
+	aw8697->timeval_flags = 1;
+	aw8697->osc_cali_flag = 1;
+
+	pr_info("%s enter\n", __func__);
+	/* fw loaded */
+	ret = request_firmware(&rtp_file,
+			       aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0],
+			       aw8697->dev);
+	if (ret < 0) {
+		pr_err("%s: failed to read %s\n", __func__,
+		       aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0]);
+		return ret;
+	}
+	/*awinic add stop,for irq interrupt during calibrate*/
+	aw8697_haptic_stop(aw8697);
+	aw8697->rtp_init = 0;
+	mutex_lock(&aw8697->rtp_lock);
+	vfree(aw8697_rtp);
+	aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+	if (!aw8697_rtp) {
+		release_firmware(rtp_file);
+		mutex_unlock(&aw8697->rtp_lock);
+		pr_err("%s: error allocating memory\n", __func__);
+		return -ENOMEM;
+	}
+	aw8697_rtp->len = rtp_file->size;
+	aw8697->rtp_len = rtp_file->size;
+	pr_info("%s: rtp file [%s] size = %d\n", __func__,
+		aw8697_rtp_name[/*aw8697->rtp_file_num*/ 0], aw8697_rtp->len);
+	memcpy(aw8697_rtp->data, rtp_file->data, rtp_file->size);
+	release_firmware(rtp_file);
+	mutex_unlock(&aw8697->rtp_lock);
+
+	/* gain */
+	aw8697_haptic_ram_vbat_comp(aw8697, false);
+
+	/* rtp mode config */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DBGCTRL,
+			      AW8697_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW8697_BIT_DBGCTRL_INT_MODE_EDGE);
+	disable_irq(gpio_to_irq(aw8697->irq_gpio));
+	/* haptic start */
+	aw8697_haptic_start(aw8697);
+	pm_qos_add_request(&pm_qos_req_vb, PM_QOS_CPU_DMA_LATENCY,
+			   PM_QOS_VALUE_VB);
+	while (1) {
+		if (!aw8697_haptic_rtp_get_fifo_afi(aw8697)) {
+			mutex_lock(&aw8697->rtp_lock);
+			if ((aw8697_rtp->len - aw8697->rtp_cnt) <
+			    (aw8697->ram.base_addr >> 2))
+				buf_len = aw8697_rtp->len - aw8697->rtp_cnt;
+			else
+				buf_len = (aw8697->ram.base_addr >> 2);
+			if (aw8697->rtp_cnt != aw8697_rtp->len) {
+				if (aw8697->timeval_flags == 1) {
+					do_gettimeofday(&aw8697->start);
+					aw8697->timeval_flags = 0;
+				}
+				aw8697_i2c_writes(
+					aw8697, AW8697_REG_RTP_DATA,
+					&aw8697_rtp->data[aw8697->rtp_cnt],
+					buf_len);
+				aw8697->rtp_cnt += buf_len;
+			}
+			mutex_unlock(&aw8697->rtp_lock);
+		}
+		osc_int_state = aw8697_haptic_osc_read_int(aw8697);
+		if (osc_int_state & AW8697_BIT_SYSINT_DONEI) {
+			do_gettimeofday(&aw8697->end);
+			pr_info("%s vincent playback done aw8697->rtp_cnt= %d \n",
+				__func__, aw8697->rtp_cnt);
+			break;
+		}
+
+		do_gettimeofday(&aw8697->end);
+		aw8697->microsecond =
+			(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+			(aw8697->end.tv_usec - aw8697->start.tv_usec);
+		if (aw8697->microsecond > OSC_CALIBRATION_T_LENGTH) {
+			pr_info("%s vincent time out aw8697->rtp_cnt %d osc_int_state %02x\n",
+				__func__, aw8697->rtp_cnt, osc_int_state);
+			break;
+		}
+	}
+	pm_qos_remove_request(&pm_qos_req_vb);
+	enable_irq(gpio_to_irq(aw8697->irq_gpio));
+
+	aw8697->osc_cali_flag = 0;
+	aw8697->microsecond =
+		(aw8697->end.tv_sec - aw8697->start.tv_sec) * 1000000 +
+		(aw8697->end.tv_usec - aw8697->start.tv_usec);
+	/*calibration osc*/
+	pr_info("%s 2018_microsecond:%ld \n", __func__, aw8697->microsecond);
+	pr_info("%s exit\n", __func__);
+	return 0;
+}
+
+static void aw8697_rtp_work_routine(struct work_struct *work)
+{
+	const struct firmware *rtp_file;
+	int ret = -1;
+	struct aw8697 *aw8697 = container_of(work, struct aw8697, rtp_work);
+	unsigned int cnt = 200;
+	unsigned char reg_val = 0;
+	bool rtp_work_flag = false;
+
+	if ((aw8697->effect_id < aw8697->info.effect_id_boundary) &&
+	    (aw8697->effect_id > aw8697->info.effect_max))
+		return;
+
+	pr_info("%s: effect_id = %d state=%d activate_mode = %d\n", __func__,
+		aw8697->effect_id, aw8697->state, aw8697->activate_mode);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_upload_lra(aw8697, OSC_CALI);
+	aw8697_haptic_set_rtp_aei(aw8697, false);
+	aw8697_interrupt_clear(aw8697);
+	//wait for irq to exit
+
+	atomic_set(&aw8697->exit_in_rtp_loop, 1);
+	while (atomic_read(&aw8697->is_in_rtp_loop)) {
+		pr_info("%s  goint to waiting irq exit\n", __func__);
+		mutex_unlock(&aw8697->lock);
+		ret = wait_event_interruptible(
+			aw8697->wait_q,
+			atomic_read(&aw8697->is_in_rtp_loop) == 0);
+		pr_info("%s  wakeup \n", __func__);
+		mutex_lock(&aw8697->lock);
+		if (ret == -ERESTARTSYS) {
+			atomic_set(&aw8697->exit_in_rtp_loop, 0);
+			wake_up_interruptible(&aw8697->stop_wait_q);
+			mutex_unlock(&aw8697->lock);
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return;
+		}
+	}
+
+	atomic_set(&aw8697->exit_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->stop_wait_q);
+
+	//how to force exit this call
+	if (aw8697->is_custom_wave == 1 && aw8697->state) {
+		pr_err("%s buffer size %d, availbe size %d \n", __func__,
+		       aw8697->ram.base_addr >> 2, get_rb_avalible_size());
+		while (get_rb_avalible_size() < aw8697->ram.base_addr &&
+		       !rb_shoule_exit()) {
+			mutex_unlock(&aw8697->lock);
+			ret = wait_event_interruptible(
+				aw8697->stop_wait_q, (get_rb_avalible_size() >=
+						      aw8697->ram.base_addr) ||
+							     rb_shoule_exit());
+			pr_info("%s  wakeup  \n", __func__);
+			pr_err("%s after wakeup sbuffer size %d, availbe size %d \n",
+			       __func__, aw8697->ram.base_addr >> 2,
+			       get_rb_avalible_size());
+			if (ret == -ERESTARTSYS) {
+				pr_err("%s wake up by signal return erro\n",
+				       __func__);
+				return;
+			}
+			mutex_lock(&aw8697->lock);
+		}
+	}
+
+	aw8697_haptic_stop(aw8697);
+
+	if (aw8697->state) {
+		pm_stay_awake(aw8697->dev);
+		if (aw8697->info.bst_vol_rtp <= AW8697_MAX_BST_VO)
+			aw8697_haptic_set_bst_vol(aw8697,
+						  aw8697->info.bst_vol_rtp);
+		else
+			aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+		aw8697_haptic_effect_strength(aw8697);
+		aw8697_haptic_set_gain(aw8697, aw8697->level);
+		aw8697->rtp_init = 0;
+		if (aw8697->is_custom_wave == 0) {
+			aw8697->rtp_file_num = aw8697->effect_id -
+					       aw8697->info.effect_id_boundary;
+			printk("%s: aw8697->rtp_file_num =%d\n", __func__,
+			       aw8697->rtp_file_num);
+			if (aw8697->rtp_file_num < 0)
+				aw8697->rtp_file_num = 0;
+			if (aw8697->rtp_file_num >
+			    ((sizeof(aw8697_rtp_name) / AW8697_RTP_NAME_MAX) -
+			     1))
+				aw8697->rtp_file_num =
+					(sizeof(aw8697_rtp_name) /
+					 AW8697_RTP_NAME_MAX) -
+					1;
+
+#ifdef SUPPORT_RELOAD_FW
+			if (aw8697->vov == 1) {
+				/* fw loaded */
+				memset(aw8697_rtp_name_a, 0,
+				       AW8697_RTP_NAME_MAX);
+				strncpy(aw8697_rtp_name_a,
+					aw8697_rtp_name[aw8697->rtp_file_num],
+					strlen(aw8697_rtp_name
+						       [aw8697->rtp_file_num]) -
+						4);
+				strcat(aw8697_rtp_name_a, "_a.bin");
+				ret = request_firmware(&rtp_file,
+						       aw8697_rtp_name_a,
+						       aw8697->dev);
+				if (ret < 0) {
+					pr_err("%s: failed to read %s\n",
+					       __func__, aw8697_rtp_name_a);
+				} else {
+					goto RTP_REQUEST_DONE;
+				}
+			}
+#endif
+			/* fw loaded */
+			ret = request_firmware(
+				&rtp_file,
+				aw8697_rtp_name[aw8697->rtp_file_num],
+				aw8697->dev);
+			if (ret < 0) {
+				pr_err("%s: failed to read %s\n", __func__,
+				       aw8697_rtp_name[aw8697->rtp_file_num]);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+#ifdef SUPPORT_RELOAD_FW
+		RTP_REQUEST_DONE:
+#endif
+			vfree(aw8697_rtp);
+			aw8697_rtp = vmalloc(rtp_file->size + sizeof(int));
+			if (!aw8697_rtp) {
+				release_firmware(rtp_file);
+				pr_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+			aw8697_rtp->len = rtp_file->size;
+			pr_info("%s: rtp file [%s] size = %d\n", __func__,
+				aw8697_rtp_name[aw8697->rtp_file_num],
+				aw8697_rtp->len);
+			memcpy(aw8697_rtp->data, rtp_file->data,
+			       rtp_file->size);
+			release_firmware(rtp_file);
+		} else {
+			vfree(aw8697_rtp);
+			aw8697_rtp = vmalloc(aw8697->ram.base_addr >> 2);
+			if (!aw8697_rtp) {
+				pr_err("%s: error allocating memory\n",
+				       __func__);
+				pm_relax(aw8697->dev);
+				mutex_unlock(&aw8697->lock);
+				return;
+			}
+		}
+		aw8697->rtp_init = 1;
+
+		/* ram_vbat_compensate( */
+#ifndef RTP_SET_GAIN
+		aw8697_haptic_ram_vbat_comp(aw8697, false);
+#endif
+
+		/* rtp mode config */
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RTP_MODE);
+
+		/* haptic start */
+		aw8697_haptic_start(aw8697);
+		usleep_range(2000, 2500);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_rtp_init(aw8697);
+		} else {
+			while (cnt) {
+				aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5,
+						&reg_val);
+				if ((reg_val & 0x0f) == 0x08) {
+					cnt = 0;
+					rtp_work_flag = true;
+					aw_dev_info(
+						aw8697->dev,
+						"%s RTP_GO! glb_state=0x08\n",
+						__func__);
+				} else {
+					cnt--;
+					aw_dev_dbg(
+						aw8697->dev,
+						"%s wait for RTP_GO, glb_state=0x%02X\n",
+						__func__, reg_val);
+				}
+				usleep_range(2000, 2500);
+			}
+			if (rtp_work_flag) {
+				aw869xx_haptic_rtp_init(aw8697);
+			} else {
+				/* enter standby mode */
+				aw8697_haptic_stop(aw8697);
+				aw_dev_err(
+					aw8697->dev,
+					"%s failed to enter RTP_GO status!\n",
+					__func__);
+			}
+		}
+
+	} else {
+		aw8697->rtp_cnt = 0;
+		aw8697->rtp_init = 0;
+		pm_relax(aw8697->dev);
+	}
+	mutex_unlock(&aw8697->lock);
+}
+
+static enum hrtimer_restart
+aw8697_haptic_audio_timer_func(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 =
+		container_of(timer, struct aw8697, haptic_audio.timer);
+
+	pr_debug("%s enter\n", __func__);
+	//schedule_work(&aw8697->haptic_audio.work);
+	queue_work(aw8697->work_queue, &aw8697->haptic_audio.work);
+
+	hrtimer_start(
+		&aw8697->haptic_audio.timer,
+		ktime_set(aw8697->haptic_audio.timer_val / 1000000,
+			  (aw8697->haptic_audio.timer_val % 1000000) * 1000),
+		HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+static void aw8697_haptic_audio_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, haptic_audio.work);
+
+	pr_info("%s enter\n", __func__);
+
+	mutex_lock(&aw8697->haptic_audio.lock);
+	memcpy(&aw8697->haptic_audio.ctr,
+	       &aw8697->haptic_audio.data[aw8697->haptic_audio.cnt],
+	       sizeof(struct haptic_ctr));
+	pr_debug("%s: cnt=%d, cmd=%d, play=%d, wavseq=%d, loop=%d, gain=%d\n",
+		 __func__, aw8697->haptic_audio.cnt,
+		 aw8697->haptic_audio.ctr.cmd, aw8697->haptic_audio.ctr.play,
+		 aw8697->haptic_audio.ctr.wavseq, aw8697->haptic_audio.ctr.loop,
+		 aw8697->haptic_audio.ctr.gain);
+	mutex_unlock(&aw8697->haptic_audio.lock);
+	if (AW8697_HAPTIC_CMD_ENABLE == aw8697->haptic_audio.ctr.cmd) {
+		if (AW8697_HAPTIC_PLAY_ENABLE ==
+		    aw8697->haptic_audio.ctr.play) {
+			pr_info("%s: haptic_audio_play_start\n", __func__);
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_stop(aw8697);
+			aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+
+			aw8697_haptic_set_wav_seq(
+				aw8697, 0x00, aw8697->haptic_audio.ctr.wavseq);
+			aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+
+			aw8697_haptic_set_wav_loop(
+				aw8697, 0x00, aw8697->haptic_audio.ctr.loop);
+
+			aw8697_haptic_set_gain(aw8697,
+					       aw8697->haptic_audio.ctr.gain);
+
+			aw8697_haptic_start(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else if (AW8697_HAPTIC_PLAY_STOP ==
+			   aw8697->haptic_audio.ctr.play) {
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_stop(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else if (AW8697_HAPTIC_PLAY_GAIN ==
+			   aw8697->haptic_audio.ctr.play) {
+			mutex_lock(&aw8697->lock);
+			aw8697_haptic_set_gain(aw8697,
+					       aw8697->haptic_audio.ctr.gain);
+			mutex_unlock(&aw8697->lock);
+		}
+		mutex_lock(&aw8697->haptic_audio.lock);
+		memset(&aw8697->haptic_audio.data[aw8697->haptic_audio.cnt], 0,
+		       sizeof(struct haptic_ctr));
+		mutex_unlock(&aw8697->haptic_audio.lock);
+	}
+
+	mutex_lock(&aw8697->haptic_audio.lock);
+	aw8697->haptic_audio.cnt++;
+	if (aw8697->haptic_audio.data[aw8697->haptic_audio.cnt].cmd == 0) {
+		aw8697->haptic_audio.cnt = 0;
+		pr_debug("%s: haptic play buffer restart\n", __func__);
+	}
+	mutex_unlock(&aw8697->haptic_audio.lock);
+}
+
+static int aw869xx_haptic_cont(struct aw8697 *aw8697)
+{
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+
+	/* work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+	/* cont config */
+	/* aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+	 **                     AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+	 **                     AW869XX_BIT_CONTCFG1_F0_DET_ENABLE);
+	 */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_TRACK_EN_MASK,
+			      AW869XX_BIT_CONTCFG6_TRACK_ENABLE);
+	/* f0 driver level */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+			      aw8697->info.cont_drv1_lvl);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+			 aw8697->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	/* aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8, 0xFF); */
+	/* DRV2_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9, 0xFF);
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+	return 0;
+}
+
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw869xx_haptic_read_lra_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	/* F_LRA_F0_H */
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD14, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	/* F_LRA_F0_L */
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD15, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_dev_err(aw8697->dev,
+			   "%s didn't get lra f0 because f0_reg value is 0!\n",
+			   __func__);
+#ifdef RETRY_F0_CHECK
+		aw8697->f0 = 0;
+#else
+		aw8697->f0 = aw8697->info.f0_pre;
+#endif
+		return ret;
+	} else {
+		f0_tmp = 384000 * 10 / f0_reg;
+		aw8697->f0 = (unsigned int)f0_tmp;
+		aw_dev_info(aw8697->dev, "%s lra_f0=%d\n", __func__,
+			    aw8697->f0);
+	}
+
+	return ret;
+}
+
+static int aw869xx_haptic_read_cont_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_reg = 0;
+	unsigned long f0_tmp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD16, &reg_val);
+	f0_reg = (f0_reg | reg_val) << 8;
+	ret = aw8697_i2c_read(aw8697, AW869XX_REG_CONTRD17, &reg_val);
+	f0_reg |= (reg_val << 0);
+	if (!f0_reg) {
+		aw_dev_err(aw8697->dev,
+			   "%s didn't get cont f0 because f0_reg value is 0!\n",
+			   __func__);
+		aw8697->cont_f0 = aw8697->info.f0_pre;
+		return ret;
+	} else {
+		f0_tmp = 384000 * 10 / f0_reg;
+		aw8697->cont_f0 = (unsigned int)f0_tmp;
+		aw_dev_info(aw8697->dev, "%s cont_f0=%d\n", __func__,
+			    aw8697->cont_f0);
+	}
+	return ret;
+}
+
+static int aw869xx_haptic_cont_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int cnt = 200;
+	bool get_f0_flag = false;
+	unsigned char brk_en_temp = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697->f0 = aw8697->info.f0_pre;
+	/* enter standby mode */
+	aw8697_haptic_stop(aw8697);
+#ifdef RETRY_F0_CHECK
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+			      AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK, 0x00);
+#endif
+	/* f0 calibrate work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+	/* enable f0 detect */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+			      AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+			      AW869XX_BIT_CONTCFG1_F0_DET_ENABLE);
+	/* cont config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_TRACK_EN_MASK,
+			      AW869XX_BIT_CONTCFG6_TRACK_ENABLE);
+	/* enable auto break */
+	aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG3, &reg_val);
+	brk_en_temp = 0x04 & reg_val;
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK,
+			      AW869XX_BIT_PLAYCFG3_BRK_ENABLE);
+	/* LRA OSC Source */
+#ifndef RETRY_F0_CHECK
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_TRIMCFG3,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK,
+				      AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_EFUSE);
+	}
+#endif
+
+	/* f0 driver level */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+			      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+			      aw8697->info.cont_drv1_lvl);
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+			 aw8697->info.cont_drv2_lvl);
+	/* DRV1_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8,
+			 aw8697->info.cont_drv1_time);
+	/* DRV2_TIME */
+	aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9,
+			 aw8697->info.cont_drv2_time);
+	/* TRACK_MARGIN */
+	if (!aw8697->info.cont_track_margin) {
+		aw_dev_err(aw8697->dev,
+			   "%s aw8697->info.cont_track_margin = 0!\n",
+			   __func__);
+	} else {
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG11,
+				 (unsigned char)aw8697->info.cont_track_margin);
+	}
+	/* DRV_WIDTH */
+	/*
+	 * aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG3,
+	 *                aw8697->info.cont_drv_width);
+	 */
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+	/* 300ms */
+	while (cnt) {
+		aw8697_i2c_read(aw8697, AW869XX_REG_GLBRD5, &reg_val);
+		if ((reg_val & 0x0f) == 0x00) {
+			cnt = 0;
+			get_f0_flag = true;
+			aw_dev_info(
+				aw8697->dev,
+				"%s entered standby mode! glb_state=0x%02X\n",
+				__func__, reg_val);
+#ifdef RETRY_F0_CHECK
+			break;
+#endif
+		} else {
+			cnt--;
+			aw_dev_dbg(
+				aw8697->dev,
+				"%s waitting for standby, glb_state=0x%02X\n",
+				__func__, reg_val);
+		}
+		usleep_range(10000, 10500);
+	}
+	if (get_f0_flag) {
+		aw869xx_haptic_read_lra_f0(aw8697);
+		aw869xx_haptic_read_cont_f0(aw8697);
+	} else {
+		aw_dev_err(aw8697->dev,
+			   "%s enter standby mode failed, stop reading f0!\n",
+			   __func__);
+	}
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG1,
+			      AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK,
+			      AW869XX_BIT_CONTCFG1_F0_DET_DISABLE);
+	/* recover auto break config */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_PLAYCFG3,
+			      AW869XX_BIT_PLAYCFG3_BRK_EN_MASK, brk_en_temp);
+	return ret;
+}
+
+static int aw869xx_haptic_f0_calibration(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+	unsigned int f0_cali_min =
+		aw8697->info.f0_pre * (100 - aw8697->info.f0_cali_percen) / 100;
+	unsigned int f0_cali_max =
+		aw8697->info.f0_pre * (100 + aw8697->info.f0_cali_percen) / 100;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+
+	aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+	if (aw869xx_haptic_cont_get_f0(aw8697)) {
+		aw_dev_err(aw8697->dev, "%s get f0 error, user defafult f0\n",
+			   __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw8697->f0;
+		aw_dev_info(aw8697->dev,
+			    "%s f0_pre = %d, f0_cali_min = %d,"
+			    " f0_cali_max = %d, f0 = %d\n",
+			    __func__, aw8697->info.f0_pre, f0_cali_min,
+			    f0_cali_max, aw8697->f0);
+
+		if ((aw8697->f0 < f0_cali_min) || aw8697->f0 > f0_cali_max) {
+			aw_dev_err(aw8697->dev,
+				   "%s f0 calibration out of range = %d!\n",
+				   __func__, aw8697->f0);
+			f0_limit = aw8697->info.f0_pre;
+			return -ERANGE;
+		}
+		aw_dev_info(aw8697->dev, "%s f0_limit = %d\n", __func__,
+			    (int)f0_limit);
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw8697->info.f0_pre) /
+			       ((int)f0_limit * 24);
+		aw_dev_info(aw8697->dev, "%s f0_cali_step = %d\n", __func__,
+			    f0_cali_step);
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5)
+				f0_cali_step = 32 + (f0_cali_step / 10 + 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		} else { /* f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5)
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			else
+				f0_cali_step = 32 + f0_cali_step / 10;
+		}
+		if (f0_cali_step > 31)
+			f0_cali_lra = (char)f0_cali_step - 32;
+		else
+			f0_cali_lra = (char)f0_cali_step + 32;
+		/* update cali step */
+		aw8697_i2c_read(aw8697, AW869XX_REG_TRIMCFG3, &reg_val);
+		aw8697->f0_calib_data =
+			((int)f0_cali_lra + (int)(reg_val & 0x3f)) & 0x3f;
+
+		aw_dev_info(aw8697->dev,
+			    "%s origin trim_lra = 0x%02X, f0_cali_lra = 0x%02X,"
+			    " final f0_calib_data = 0x%02X\n",
+			    __func__, (reg_val & 0x3f), f0_cali_lra,
+			    aw8697->f0_calib_data);
+		aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	}
+	/* restore standby work mode */
+	aw8697_haptic_stop(aw8697);
+	return ret;
+}
+
+/*****************************************************
+ *
+ * haptic cont
+ *
+ *****************************************************/
+static int aw8697_haptic_cont(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	/* work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* lpf */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_FC_MASK,
+			      AW8697_BIT_DATCTRL_FC_1000HZ);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* cont config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_ZC_DETEC_MASK,
+			      AW8697_BIT_CONT_CTRL_ZC_DETEC_ENABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_WAIT_PERIOD_MASK,
+			      AW8697_BIT_CONT_CTRL_WAIT_1PERIOD);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_MODE_MASK,
+			      AW8697_BIT_CONT_CTRL_BY_GO_SIGNAL);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_O2C_MASK,
+			      AW8697_BIT_CONT_CTRL_O2C_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_ENABLE);
+
+	/* TD time */
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_H,
+			 (unsigned char)(aw8697->info.cont_td >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_L,
+			 (unsigned char)(aw8697->info.cont_td >> 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+
+	/* zero cross */
+	aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_H,
+			 (unsigned char)(aw8697->info.cont_zc_thr >> 8));
+	aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_L,
+			 (unsigned char)(aw8697->info.cont_zc_thr >> 0));
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_BEMF_NUM,
+			      AW8697_BIT_BEMF_NUM_BRK_MASK,
+			      aw8697->info.cont_num_brk);
+	aw8697_i2c_write(aw8697, AW8697_REG_TIME_NZC, 0x23); // 35*171us=5.985ms
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+			 aw8697->info.cont_drv_lvl_ov);
+
+	/* cont play go */
+	aw8697_haptic_play_go(aw8697, true);
+
+	return 0;
+}
+
+#ifndef USE_CONT_F0_CALI
+static int aw8697_get_glb_state(struct aw8697 *aw8697)
+{
+	unsigned char glb_state_val = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_GLB_STATE, &glb_state_val);
+	return glb_state_val;
+}
+#endif
+
+#ifndef USE_CONT_F0_CALI
+/*****************************************************
+ *
+ * haptic f0 cali
+ *
+ *****************************************************/
+static int aw8697_haptic_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char f0_pre_num = 0;
+	unsigned char f0_wait_num = 0;
+	unsigned char f0_repeat_num = 0;
+	unsigned char f0_trace_num = 0;
+	unsigned int t_f0_ms = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0 = aw8697->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw8697_haptic_stop(aw8697);
+#ifdef RETRY_F0_CHECK
+	aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+#endif
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_ENABLE);
+
+	/* LPF */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_FC_MASK,
+			      AW8697_BIT_DATCTRL_FC_1000HZ);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE_MASK,
+			      AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* LRA OSC Source */
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_EFUSE);
+	}
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+
+	/* f0 trace parameter */
+	f0_pre_num = aw8697->info.f0_trace_parameter[0];
+	f0_wait_num = aw8697->info.f0_trace_parameter[1];
+	f0_repeat_num = aw8697->info.f0_trace_parameter[2];
+	f0_trace_num = aw8697->info.f0_trace_parameter[3];
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_1,
+			 (f0_pre_num << 4) | (f0_wait_num << 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_2, (f0_repeat_num << 0));
+	aw8697_i2c_write(aw8697, AW8697_REG_NUM_F0_3, (f0_trace_num << 0));
+
+	/* clear aw8697 interrupt */
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw8697_haptic_play_go(aw8697, true);
+
+	/* f0 trace time */
+	t_f0_ms = 1000 * 10 / aw8697->info.f0_pre;
+	t_f0_trace_ms =
+		t_f0_ms * (f0_pre_num + f0_wait_num +
+			   (f0_trace_num + f0_wait_num) * (f0_repeat_num - 1)) +
+		50;
+	usleep_range(t_f0_trace_ms * 1000, t_f0_trace_ms * 1000 + 500);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		reg_val = aw8697_get_glb_state(aw8697);
+		/* f0 calibrate done */
+		if ((reg_val & 0x0f) == 0x00) {
+			aw8697_haptic_read_f0(aw8697);
+			aw8697_haptic_read_beme(aw8697);
+			break;
+		}
+		usleep_range(10000, 10500);
+		pr_info("%s: f0 cali sleep 10ms\n", __func__);
+	}
+
+#ifdef RETRY_F0_CHECK
+	if ((i == f0_cali_cnt) || (aw8697->f0 == 0)) { //Daniel 20210903 modify
+#else
+	if (i == f0_cali_cnt) {
+#endif
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+#ifndef RETRY_F0_CHECK
+	aw8697_haptic_read_f0(aw8697);
+	aw8697_haptic_read_beme(aw8697);
+#endif
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#else
+/*****************************************************
+ *
+ * haptic cont mode f0 cali
+ *
+ *****************************************************/
+static int aw8697_haptic_get_f0(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned int t_f0_trace_ms = 0;
+	unsigned int f0_cali_cnt = 50;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0 = aw8697->info.f0_pre;
+
+	/* f0 calibrate work mode */
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_CONT_MODE);
+
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_MODE_MASK,
+			      AW8697_BIT_CONT_CTRL_BY_DRV_TIME);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_OPEN_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_BIT_CONT_CTRL_CLOSE_PLAYBACK);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_MASK,
+			      AW8697_BIT_CONT_CTRL_AUTO_BRK_DISABLE);
+
+	/* LPF */
+	//aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+	//        AW8697_BIT_DATCTRL_FC_MASK, AW8697_BIT_DATCTRL_FC_1000HZ);
+	//aw8697_i2c_write_bits(aw8697, AW8697_REG_DATCTRL,
+	//        AW8697_BIT_DATCTRL_LPF_ENABLE_MASK, AW8697_BIT_DATCTRL_LPF_ENABLE);
+
+	/* LRA OSC Source */
+	if (aw8697->f0_cali_flag == AW8697_HAPTIC_CALI_F0) {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_REG);
+	} else {
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANACTRL,
+				      AW8697_BIT_ANACTRL_LRA_SRC_MASK,
+				      AW8697_BIT_ANACTRL_LRA_SRC_EFUSE);
+	}
+
+	/* f0 driver level */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL, aw8697->info.cont_drv_lvl);
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+			 aw8697->info.cont_drv_lvl_ov);
+
+	/* TD time */
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_H, aw8697->info.cont_td >> 8);
+	aw8697_i2c_write(aw8697, AW8697_REG_TD_L, aw8697->info.cont_td);
+	aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+
+	/* drive time  */
+	aw8697_i2c_write(aw8697, AW8697_REG_DRV_TIME, 0x75);
+
+	/* preset f0 */
+	aw8697_haptic_set_f0_preset(aw8697);
+
+	/* clear aw8697 interrupt */
+	ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* play go and start f0 calibration */
+	aw8697_haptic_play_go(aw8697, true);
+
+	/* f0 trace time */
+	t_f0_trace_ms = 0xfe * 684 / 1000;
+	msleep(t_f0_trace_ms);
+
+	for (i = 0; i < f0_cali_cnt; i++) {
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+		/* f0 calibrate done */
+		if (reg_val & 0x01) {
+			aw8697_haptic_read_cont_f0(aw8697);
+			aw8697_haptic_read_cont_bemf(aw8697);
+			break;
+		}
+		msleep(10);
+		pr_info("%s f0 cali sleep 10ms\n", __func__);
+	}
+
+	if (i == f0_cali_cnt) {
+		ret = -1;
+	} else {
+		ret = 0;
+	}
+
+	/* restore default config */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK,
+			      AW8697_CONT_PLAYBACK_MODE);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_CONT_CTRL,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_MASK,
+			      AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE);
+
+	return ret;
+}
+#endif
+
+static int aw8697_haptic_f0_calibration(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char reg_val = 0;
+	unsigned int f0_limit = 0;
+	char f0_cali_lra = 0;
+	int f0_cali_step = 0;
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+
+	aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA, 0x00);
+	if (aw8697_haptic_get_f0(aw8697)) {
+		pr_err("%s get f0 error, user defafult f0\n", __func__);
+	} else {
+		/* max and min limit */
+		f0_limit = aw8697->f0;
+		if (aw8697->f0 * 100 <
+		    aw8697->info.f0_pre * (100 - aw8697->info.f0_cali_percen)) {
+			f0_limit = aw8697->info.f0_pre;
+		}
+		if (aw8697->f0 * 100 >
+		    aw8697->info.f0_pre * (100 + aw8697->info.f0_cali_percen)) {
+			f0_limit = aw8697->info.f0_pre;
+		}
+
+		/* calculate cali step */
+		f0_cali_step = 100000 *
+			       ((int)f0_limit - (int)aw8697->info.f0_pre) /
+			       ((int)f0_limit * 25);
+		pr_info("%s  line=%d f0_cali_step=%d\n", __func__, __LINE__,
+			f0_cali_step);
+		pr_info("%s line=%d  f0_limit=%d\n", __func__, __LINE__,
+			(int)f0_limit);
+		pr_info("%s line=%d  aw8697->info.f0_pre=%d\n", __func__,
+			__LINE__, (int)aw8697->info.f0_pre);
+
+		if (f0_cali_step >= 0) { /*f0_cali_step >= 0 */
+			if (f0_cali_step % 10 >= 5) {
+				f0_cali_step = f0_cali_step / 10 + 1 + 32;
+			} else {
+				f0_cali_step = f0_cali_step / 10 + 32;
+			}
+		} else { /*f0_cali_step < 0 */
+			if (f0_cali_step % 10 <= -5) {
+				f0_cali_step = 32 + (f0_cali_step / 10 - 1);
+			} else {
+				f0_cali_step = 32 + f0_cali_step / 10;
+			}
+		}
+
+		if (f0_cali_step > 31) {
+			f0_cali_lra = (char)f0_cali_step - 32;
+		} else {
+			f0_cali_lra = (char)f0_cali_step + 32;
+		}
+		aw8697->f0_calib_data = (int)f0_cali_lra;
+		printk("%s f0_cali_lra=%d\n", __func__, (int)f0_cali_lra);
+
+		/* update cali step */
+		aw8697_i2c_write(aw8697, AW8697_REG_TRIM_LRA,
+				 (char)f0_cali_lra);
+		aw8697_i2c_read(aw8697, AW8697_REG_TRIM_LRA, &reg_val);
+		pr_info("%s final trim_lra=0x%02x\n", __func__, reg_val);
+	}
+
+	/* restore default work mode */
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	aw8697->play_mode = AW8697_HAPTIC_RAM_MODE;
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSCTRL,
+			      AW8697_BIT_SYSCTRL_PLAY_MODE_MASK,
+			      AW8697_BIT_SYSCTRL_PLAY_MODE_RAM);
+	aw8697_haptic_stop(aw8697);
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * haptic fops
+ *
+ *****************************************************/
+static int aw8697_file_open(struct inode *inode, struct file *file)
+{
+	if (!try_module_get(THIS_MODULE))
+		return -ENODEV;
+	pr_info("%s enter\n", __func__);
+	file->private_data = (void *)g_aw8697;
+
+	return 0;
+}
+
+static int aw8697_file_release(struct inode *inode, struct file *file)
+{
+	file->private_data = (void *)NULL;
+	pr_info("%s enter\n", __func__);
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+static long aw8697_file_unlocked_ioctl(struct file *file, unsigned int cmd,
+				       unsigned long arg)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)file->private_data;
+
+	int ret = 0;
+	pr_info("%s enter\n", __func__);
+	dev_info(aw8697->dev, "%s: cmd=0x%x, arg=0x%lx\n", __func__, cmd, arg);
+
+	mutex_lock(&aw8697->lock);
+
+	if (_IOC_TYPE(cmd) != AW8697_HAPTIC_IOCTL_MAGIC) {
+		dev_err(aw8697->dev, "%s: cmd magic err\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd\n", __func__);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	return ret;
+}
+
+static ssize_t aw8697_file_read(struct file *filp, char *buff, size_t len,
+				loff_t *offset)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)filp->private_data;
+	int ret = 0;
+	int i = 0;
+	unsigned char reg_val = 0;
+	unsigned char *pbuff = NULL;
+	pr_info("%s enter\n", __func__);
+	mutex_lock(&aw8697->lock);
+
+	dev_info(aw8697->dev, "%s: len=%zu\n", __func__, len);
+
+	switch (aw8697->fileops.cmd) {
+	case AW8697_HAPTIC_CMD_READ_REG:
+		pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+		if (pbuff != NULL) {
+			for (i = 0; i < len; i++) {
+				aw8697_i2c_read(aw8697, aw8697->fileops.reg + i,
+						&reg_val);
+				pbuff[i] = reg_val;
+			}
+			for (i = 0; i < len; i++) {
+				dev_info(aw8697->dev, "%s: pbuff[%d]=0x%02x\n",
+					 __func__, i, pbuff[i]);
+			}
+			ret = copy_to_user(buff, pbuff, len);
+			if (ret) {
+				dev_err(aw8697->dev, "%s: copy to user fail\n",
+					__func__);
+			}
+			kfree(pbuff);
+		} else {
+			dev_err(aw8697->dev, "%s: alloc memory fail\n",
+				__func__);
+		}
+		break;
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd %d \n", __func__,
+			aw8697->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	return len;
+}
+
+static ssize_t aw8697_file_write(struct file *filp, const char *buff,
+				 size_t len, loff_t *off)
+{
+	struct aw8697 *aw8697 = (struct aw8697 *)filp->private_data;
+	int i = 0;
+	int ret = 0;
+	unsigned char *pbuff = NULL;
+	pr_info("%s enter\n", __func__);
+	pbuff = (unsigned char *)kzalloc(len, GFP_KERNEL);
+	if (pbuff == NULL) {
+		dev_err(aw8697->dev, "%s: alloc memory fail\n", __func__);
+		return len;
+	}
+	ret = copy_from_user(pbuff, buff, len);
+	if (ret) {
+		dev_err(aw8697->dev, "%s: copy from user fail\n", __func__);
+		kfree(pbuff);
+		return len;
+	}
+
+	for (i = 0; i < len; i++) {
+		dev_info(aw8697->dev, "%s: pbuff[%d]=0x%02x\n", __func__, i,
+			 pbuff[i]);
+	}
+
+	mutex_lock(&aw8697->lock);
+
+	aw8697->fileops.cmd = pbuff[0];
+
+	switch (aw8697->fileops.cmd) {
+	case AW8697_HAPTIC_CMD_READ_REG:
+		if (len == 2) {
+			aw8697->fileops.reg = pbuff[1];
+		} else {
+			dev_err(aw8697->dev, "%s: read cmd len %zu err\n",
+				__func__, len);
+		}
+		break;
+	case AW8697_HAPTIC_CMD_WRITE_REG:
+		if (len > 2) {
+			for (i = 0; i < len - 2; i++) {
+				dev_info(aw8697->dev,
+					 "%s: write reg0x%02x=0x%02x\n",
+					 __func__, pbuff[1] + i, pbuff[i + 2]);
+				aw8697_i2c_write(aw8697, pbuff[1] + i,
+						 pbuff[2 + i]);
+			}
+		} else {
+			dev_err(aw8697->dev, "%s: write cmd len %zu err\n",
+				__func__, len);
+		}
+		break;
+	default:
+		dev_err(aw8697->dev, "%s, unknown cmd %d \n", __func__,
+			aw8697->fileops.cmd);
+		break;
+	}
+
+	mutex_unlock(&aw8697->lock);
+
+	if (pbuff != NULL) {
+		kfree(pbuff);
+	}
+	return len;
+}
+
+static struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.read = aw8697_file_read,
+	.write = aw8697_file_write,
+	.unlocked_ioctl = aw8697_file_unlocked_ioctl,
+	.open = aw8697_file_open,
+	.release = aw8697_file_release,
+};
+
+static struct miscdevice aw8697_haptic_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = AW8697_HAPTIC_NAME,
+	.fops = &fops,
+};
+
+static int aw8697_haptic_init(struct aw8697 *aw8697)
+{
+	int ret = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char bemf_config = 0;
+
+	pr_info("%s enter\n", __func__);
+	ret = misc_register(&aw8697_haptic_misc);
+	if (ret) {
+		dev_err(aw8697->dev, "%s: misc fail: %d\n", __func__, ret);
+		return ret;
+	}
+
+	/* haptic audio */
+	aw8697->haptic_audio.delay_val = 1;
+	aw8697->haptic_audio.timer_val = 21318;
+	aw8697->f0_cali_status = true;
+
+	hrtimer_init(&aw8697->haptic_audio.timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw8697->haptic_audio.timer.function = aw8697_haptic_audio_timer_func;
+	INIT_WORK(&aw8697->haptic_audio.work, aw8697_haptic_audio_work_routine);
+
+	mutex_init(&aw8697->haptic_audio.lock);
+
+	/* haptic init */
+	mutex_lock(&aw8697->lock);
+
+	aw8697->activate_mode = aw8697->info.mode;
+	aw8697->osc_cali_run = 0;
+	aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_STANDBY_MODE);
+	aw8697_haptic_set_pwm(aw8697, AW8697_PWM_24K);
+	aw8697_haptic_swicth_motorprotect_config(aw8697, 0x00, 0x00);
+	/* vbat compensation */
+	aw8697_haptic_cont_vbat_mode(aw8697,
+				     AW8697_HAPTIC_CONT_VBAT_HW_COMP_MODE);
+	aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	aw8697_haptic_offset_calibration(aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1, &reg_val);
+		aw8697->index = reg_val & 0x7F;
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_DATDBG, &reg_val);
+		aw8697->gain = reg_val & 0xFF;
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_BSTDBG4, &reg_val);
+		aw8697->vmax = (reg_val >> 1) & 0x1F;
+		for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+			ret = aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1 + i,
+					      &reg_val);
+			aw8697->seq[i] = reg_val;
+		}
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG1,
+				 aw8697->info.bstdbg[0]);
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG2,
+				 aw8697->info.bstdbg[1]);
+		aw8697_i2c_write(aw8697, AW8697_REG_BSTDBG3,
+				 aw8697->info.bstdbg[2]);
+		aw8697_i2c_write(aw8697, AW8697_REG_TSET, aw8697->info.tset);
+		aw8697_i2c_write(aw8697, AW8697_REG_R_SPARE,
+				 aw8697->info.r_spare);
+
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_ANADBG,
+				      AW8697_BIT_ANADBG_IOC_MASK,
+				      AW8697_BIT_ANADBG_IOC_4P65A);
+		aw8697_haptic_set_bst_peak_cur(aw8697, AW8697_DEFAULT_PEAKCUR);
+		aw8697_haptic_auto_boost_config(aw8697, false);
+
+		if ((aw8697->info.trig_config[0][0] == 1) ||
+		    (aw8697->info.trig_config[1][0] == 1) ||
+		    (aw8697->info.trig_config[2][0] == 1)) {
+			aw8697_haptic_trig_param_init(aw8697);
+			aw8697_haptic_trig_param_config(aw8697);
+		}
+		mutex_unlock(&aw8697->lock);
+
+		/* f0 calibration */
+		mutex_lock(&aw8697->lock);
+#ifndef USE_CONT_F0_CALI
+		aw8697_haptic_f0_calibration(aw8697);
+#endif
+		mutex_unlock(&aw8697->lock);
+		/* beme config */
+		bemf_config = aw8697->info.bemf_config[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHH_H, bemf_config);
+		bemf_config = aw8697->info.bemf_config[1];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHH_L, bemf_config);
+		bemf_config = aw8697->info.bemf_config[2];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHL_H, bemf_config);
+		bemf_config = aw8697->info.bemf_config[3];
+		aw8697_i2c_write(aw8697, AW8697_REG_BEMF_VTHL_L, bemf_config);
+
+	} else {
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1, &reg_val);
+		aw8697->index = reg_val & 0x7F;
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG2, &reg_val);
+		aw8697->gain = reg_val & 0xFF;
+		aw_dev_info(aw8697->dev, "%s aw8697->gain =0x%02X\n", __func__,
+			    aw8697->gain);
+		ret = aw8697_i2c_read(aw8697, AW869XX_REG_PLAYCFG1, &reg_val);
+		aw8697->vmax = (reg_val >> 1) & 0x1F;
+		for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+			ret = aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1 + i,
+					      &reg_val);
+			aw8697->seq[i] = reg_val;
+		}
+
+		/* misc value init */
+		aw869xx_haptic_misc_para_init(aw8697);
+		/* set BST_ADJ */
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_BSTCFG5,
+				      AW869XX_BIT_BSTCFG5_BST_ADJ_MASK,
+				      AW869XX_BIT_BSTCFG5_BST_ADJ_LOW);
+		aw869xx_haptic_set_bst_peak_cur(aw8697);
+		aw8697_haptic_auto_boost_config(
+			aw8697, aw8697->info.is_enabled_auto_bst);
+		//aw869xx_haptic_trig_param_init(aw8697);
+		//aw869xx_haptic_trig_param_config(aw8697);
+
+		mutex_unlock(&aw8697->lock);
+
+		/* f0 calibration */
+		if (aw8697->info.is_enabled_powerup_f0_cali) {
+			mutex_lock(&aw8697->lock);
+			aw869xx_haptic_f0_calibration(aw8697);
+			mutex_unlock(&aw8697->lock);
+		} else {
+			aw_dev_info(aw8697->dev,
+				    "%s powerup f0 calibration is disabled\n",
+				    __func__);
+		}
+	}
+
+	return ret;
+}
+
+/*****************************************************
+ *
+ * vibrator
+ *
+ *****************************************************/
+static enum hrtimer_restart qti_hap_stop_timer(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 = container_of(timer, struct aw8697, stop_timer);
+	int rc;
+
+	pr_info("%s enter\n", __func__);
+	aw8697->play.length_us = 0;
+	rc = aw8697_haptic_play_go(aw8697,
+				   false); // qti_haptics_play(aw8697, false);
+	if (rc < 0)
+		dev_err(aw8697->dev, "Stop playing failed, rc=%d\n", rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart qti_hap_disable_timer(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 =
+		container_of(timer, struct aw8697, hap_disable_timer);
+	int rc;
+
+	pr_info("%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		rc = aw8697_haptic_play_go(
+			aw8697, false); //qti_haptics_module_en(aw8697, false);
+	} else {
+		rc = aw8697_haptic_stop(aw8697);
+	}
+	if (rc < 0)
+		dev_err(aw8697->dev, "Disable haptics module failed, rc=%d\n",
+			rc);
+
+	return HRTIMER_NORESTART;
+}
+
+static enum hrtimer_restart aw8697_vibrator_timer_func(struct hrtimer *timer)
+{
+	struct aw8697 *aw8697 = container_of(timer, struct aw8697, timer);
+
+	pr_info("%s enter\n", __func__);
+
+	aw8697->state = 0;
+	//schedule_work(&aw8697->vibrator_work);
+	queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void aw8697_vibrator_work_routine(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, vibrator_work);
+
+	pr_debug("%s enter\n", __func__);
+	pr_info("%s: effect_id = %d state=%d activate_mode = %d duration = %d\n",
+		__func__, aw8697->effect_id, aw8697->state,
+		aw8697->activate_mode, aw8697->duration);
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	aw8697_haptic_stop(aw8697);
+	if (aw8697->state) {
+		if (aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+			aw8697_haptic_ram_vbat_comp(aw8697, false);
+			aw8697_haptic_play_effect_seq(aw8697, true);
+		} else if (aw8697->activate_mode ==
+			   AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+			aw8697_haptic_ram_vbat_comp(aw8697, true);
+			aw8697_haptic_play_effect_seq(aw8697, true);
+			hrtimer_start(
+				&aw8697->timer,
+				ktime_set(aw8697->duration / 1000,
+					  (aw8697->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+			pm_stay_awake(aw8697->dev);
+			aw8697->wk_lock_flag = 1;
+		} else if (aw8697->activate_mode ==
+			   AW8697_HAPTIC_ACTIVATE_CONT_MODE) {
+			if (aw8697->chip_version == AW8697_CHIP_9X) {
+				aw8697_haptic_cont(aw8697);
+			} else {
+				aw869xx_haptic_cont(aw8697);
+			}
+			hrtimer_start(
+				&aw8697->timer,
+				ktime_set(aw8697->duration / 1000,
+					  (aw8697->duration % 1000) * 1000000),
+				HRTIMER_MODE_REL);
+		} else {
+			/*other mode */
+		}
+	} else {
+		if (aw8697->wk_lock_flag == 1) {
+			pm_relax(aw8697->dev);
+			aw8697->wk_lock_flag = 0;
+		}
+	}
+	mutex_unlock(&aw8697->lock);
+}
+
+static int aw8697_vibrator_init(struct aw8697 *aw8697)
+{
+	pr_info("%s enter\n", __func__);
+
+	hrtimer_init(&aw8697->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw8697->timer.function = aw8697_vibrator_timer_func;
+	INIT_WORK(&aw8697->vibrator_work, aw8697_vibrator_work_routine);
+	INIT_WORK(&aw8697->rtp_work, aw8697_rtp_work_routine);
+
+	mutex_init(&aw8697->lock);
+	mutex_init(&aw8697->rtp_lock);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	atomic_set(&aw8697->exit_in_rtp_loop, 0);
+	atomic_set(&aw8697->is_in_write_loop, 0);
+	init_waitqueue_head(&aw8697->wait_q);
+	init_waitqueue_head(&aw8697->stop_wait_q);
+
+	return 0;
+}
+
+/******************************************************
+ *
+ * irq
+ *
+ ******************************************************/
+static void aw8697_interrupt_clear(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+}
+
+static void aw8697_interrupt_setup(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+
+	/* edge int mode */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_DBGCTRL,
+			      AW8697_BIT_DBGCTRL_INT_MODE_MASK,
+			      AW8697_BIT_DBGCTRL_INT_MODE_EDGE);
+
+	/* int enable */
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_BSTERR_MASK,
+			      AW8697_BIT_SYSINTM_BSTERR_OFF);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OV_MASK,
+			      AW8697_BIT_SYSINTM_OV_OFF);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_UVLO_MASK,
+			      AW8697_BIT_SYSINTM_UVLO_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OCD_MASK,
+			      AW8697_BIT_SYSINTM_OCD_EN);
+	aw8697_i2c_write_bits(aw8697, AW8697_REG_SYSINTM,
+			      AW8697_BIT_SYSINTM_OT_MASK,
+			      AW8697_BIT_SYSINTM_OT_EN);
+}
+
+static void aw869xx_interrupt_setup(struct aw8697 *aw8697)
+{
+	unsigned char reg_val = 0;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSINT, &reg_val);
+	aw_dev_info(aw8697->dev, "%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	/* posedge interrupt mode */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_INT_MODE_MASK,
+			      AW869XX_BIT_SYSCTRL7_INT_MODE_EDGE);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSCTRL7,
+			      AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_MASK,
+			      AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_POS);
+	/* interrupts enable */
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_BST_SCPM_MASK,
+			      AW869XX_BIT_SYSINTM_BST_SCPM_OFF);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_BST_OVPM_MASK,
+			      AW869XX_BIT_SYSINTM_BST_OVPM_OFF);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_UVLM_MASK,
+			      AW869XX_BIT_SYSINTM_UVLM_ON);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_OCDM_MASK,
+			      AW869XX_BIT_SYSINTM_OCDM_ON);
+	aw8697_i2c_write_bits(aw8697, AW869XX_REG_SYSINTM,
+			      AW869XX_BIT_SYSINTM_OTM_MASK,
+			      AW869XX_BIT_SYSINTM_OTM_ON);
+}
+
+static irqreturn_t aw869xx_irq(int irq, void *data)
+{
+	struct aw8697 *aw8697 = data;
+	unsigned char reg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned char glb_state_val = 0;
+	unsigned period_size = aw8697->ram.base_addr >> 2;
+
+	aw_dev_info(aw8697->dev, "%s enter\n", __func__);
+	atomic_set(&aw8697->is_in_rtp_loop, 1);
+	aw8697_i2c_read(aw8697, AW869XX_REG_SYSINT, &reg_val);
+	aw_dev_info(aw8697->dev, "%s: reg SYSINT=0x%02X\n", __func__, reg_val);
+	if (reg_val & AW869XX_BIT_SYSINT_BST_OVPI) {
+		aw_dev_err(aw8697->dev, "%s chip ov int error\n", __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_UVLI) {
+		aw_dev_err(aw8697->dev, "%s chip uvlo int error\n", __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_OCDI) {
+		aw_dev_err(aw8697->dev, "%s chip over current int error\n",
+			   __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_OTI) {
+		aw_dev_err(aw8697->dev, "%s chip over temperature int error\n",
+			   __func__);
+	}
+	if (reg_val & AW869XX_BIT_SYSINT_DONEI) {
+		aw_dev_info(aw8697->dev, "%s chip playback done\n", __func__);
+	}
+
+	if (reg_val & AW869XX_BIT_SYSINT_FF_AEI) {
+		aw_dev_info(aw8697->dev, "%s: aw869xx rtp fifo almost empty\n",
+			    __func__);
+		if (aw8697->rtp_init) {
+			while ((!aw869xx_haptic_rtp_get_fifo_afs(aw8697)) &&
+			       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+			       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+				mutex_lock(&aw8697->rtp_lock);
+				aw_dev_info(
+					aw8697->dev,
+					"%s: aw869xx rtp mode fifo update, cnt=%d\n",
+					__func__, aw8697->rtp_cnt);
+				if (!aw8697_rtp) {
+					pr_info("%s:aw8697_rtp is null, break!\n",
+						__func__);
+					mutex_unlock(&aw8697->rtp_lock);
+					break;
+				}
+				if (aw8697->is_custom_wave == 1) {
+					buf_len = read_rb(aw8697_rtp->data,
+							  period_size);
+					aw8697_i2c_writes(aw8697,
+							  AW869XX_REG_RTPDATA,
+							  aw8697_rtp->data,
+							  buf_len);
+					if (buf_len < period_size) {
+						pr_info("%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				} else {
+					if ((aw8697_rtp->len -
+					     aw8697->rtp_cnt) <
+					    (aw8697->ram.base_addr >> 2)) {
+						buf_len = aw8697_rtp->len -
+							  aw8697->rtp_cnt;
+					} else {
+						buf_len =
+							(aw8697->ram.base_addr >>
+							 2);
+					}
+					aw8697_i2c_writes(
+						aw8697, AW869XX_REG_RTPDATA,
+						&aw8697_rtp
+							 ->data[aw8697->rtp_cnt],
+						buf_len);
+					aw8697->rtp_cnt += buf_len;
+					aw8697_i2c_read(aw8697,
+							AW869XX_REG_GLBRD5,
+							&glb_state_val);
+					if ((aw8697->rtp_cnt ==
+					     aw8697_rtp->len) ||
+					    ((glb_state_val & 0x0f) == 0)) {
+						aw_dev_info(
+							aw8697->dev,
+							"%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				}
+				mutex_unlock(&aw8697->rtp_lock);
+			}
+		} else {
+			aw_dev_info(aw8697->dev,
+				    "%s: aw869xx rtp init = %d, init error\n",
+				    __func__, aw8697->rtp_init);
+		}
+	}
+
+	if (reg_val & AW869XX_BIT_SYSINT_FF_AFI)
+		aw_dev_info(aw8697->dev,
+			    "%s: aw869xx rtp mode fifo almost full!\n",
+			    __func__);
+
+	if (aw8697->play_mode != AW8697_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw8697->exit_in_rtp_loop))
+		aw8697_haptic_set_rtp_aei(aw8697, false);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->wait_q);
+	aw_dev_info(aw8697->dev, "%s exit\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t aw8697_irq(int irq, void *data)
+{
+	struct aw8697 *aw8697 = data;
+	unsigned char reg_val = 0;
+	unsigned char dbg_val = 0;
+	unsigned int buf_len = 0;
+	unsigned period_size = aw8697->ram.base_addr >> 2;
+
+	atomic_set(&aw8697->is_in_rtp_loop, 1);
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSINT, &reg_val);
+	pr_info("%s: reg SYSINT=0x%x\n", __func__, reg_val);
+	aw8697_i2c_read(aw8697, AW8697_REG_DBGSTAT, &dbg_val);
+	pr_info("%s: reg DBGSTAT=0x%x\n", __func__, dbg_val);
+
+	if (reg_val & AW8697_BIT_SYSINT_OVI) {
+		pr_err("%s chip ov int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_UVLI) {
+		pr_err("%s chip uvlo int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_OCDI) {
+		pr_err("%s chip over current int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_OTI) {
+		pr_err("%s chip over temperature int error\n", __func__);
+	}
+	if (reg_val & AW8697_BIT_SYSINT_DONEI) {
+		pr_info("%s chip playback done\n", __func__);
+	}
+
+	if (reg_val & AW8697_BIT_SYSINT_FF_AEI) {
+		pr_debug("%s: aw8697 rtp fifo almost empty int\n", __func__);
+		if (aw8697->rtp_init) {
+			while ((!aw8697_haptic_rtp_get_fifo_afi(aw8697)) &&
+			       (aw8697->play_mode == AW8697_HAPTIC_RTP_MODE) &&
+			       !atomic_read(&aw8697->exit_in_rtp_loop)) {
+				mutex_lock(&aw8697->rtp_lock);
+				if (!aw8697_rtp) {
+					pr_info("%s:aw8697_rtp is null break\n",
+						__func__);
+					mutex_unlock(&aw8697->rtp_lock);
+					break;
+				}
+
+				if (aw8697->is_custom_wave == 1) {
+					buf_len = read_rb(aw8697_rtp->data,
+							  period_size);
+					aw8697_i2c_writes(aw8697,
+							  AW8697_REG_RTP_DATA,
+							  aw8697_rtp->data,
+							  buf_len);
+					if (buf_len < period_size) {
+						pr_info("%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				} else {
+					if ((aw8697_rtp->len -
+					     aw8697->rtp_cnt) < period_size) {
+						buf_len = aw8697_rtp->len -
+							  aw8697->rtp_cnt;
+					} else {
+						buf_len = period_size;
+					}
+					aw8697_i2c_writes(
+						aw8697, AW8697_REG_RTP_DATA,
+						&aw8697_rtp
+							 ->data[aw8697->rtp_cnt],
+						buf_len);
+					aw8697->rtp_cnt += buf_len;
+					if (aw8697->rtp_cnt ==
+					    aw8697_rtp->len) {
+						pr_info("%s: rtp update complete\n",
+							__func__);
+						aw8697_haptic_set_rtp_aei(
+							aw8697, false);
+						aw8697->rtp_cnt = 0;
+						aw8697->rtp_init = 0;
+						mutex_unlock(&aw8697->rtp_lock);
+						break;
+					}
+				}
+				mutex_unlock(&aw8697->rtp_lock);
+			}
+		} else {
+			pr_err("%s: aw8697 rtp init = %d, init error\n",
+			       __func__, aw8697->rtp_init);
+		}
+	}
+
+	if (reg_val & AW8697_BIT_SYSINT_FF_AFI) {
+		pr_debug("%s: aw8697 rtp mode fifo full empty\n", __func__);
+	}
+
+	if (aw8697->play_mode != AW8697_HAPTIC_RTP_MODE ||
+	    atomic_read(&aw8697->exit_in_rtp_loop)) {
+		aw8697_haptic_set_rtp_aei(aw8697, false);
+	}
+
+	aw8697_i2c_read(aw8697, AW8697_REG_SYSST, &reg_val);
+	pr_debug("%s: reg SYSST=0x%x\n", __func__, reg_val);
+	atomic_set(&aw8697->is_in_rtp_loop, 0);
+	wake_up_interruptible(&aw8697->wait_q);
+	pr_debug("%s exit\n", __func__);
+	return IRQ_HANDLED;
+}
+
+/*****************************************************
+ *
+ * device tree
+ *
+ *****************************************************/
+
+static int aw8697_parse_dt_common(struct device *dev, struct aw8697 *aw8697,
+				  struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int rtp_time[175];
+	struct qti_hap_config *config = &aw8697->config;
+	struct device_node *child_node;
+	struct qti_hap_effect *effect;
+	int rc = 0, tmp, i = 0, j, m;
+
+	printk("%s  %d enter\n", __func__, __LINE__);
+	aw8697->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);
+	if (aw8697->reset_gpio < 0) {
+		dev_err(dev,
+			"%s: no reset gpio provided, will not HW reset device\n",
+			__func__);
+		return -EINVAL;
+	} else {
+		dev_info(dev, "%s: reset gpio provided ok\n", __func__);
+	}
+	aw8697->irq_gpio = of_get_named_gpio(np, "irq-gpio", 0);
+	if (aw8697->irq_gpio < 0) {
+		dev_err(dev, "%s: no irq gpio provided.\n", __func__);
+	} else {
+		dev_info(dev, "%s: irq gpio provided ok.\n", __func__);
+	}
+
+	val = of_property_read_u32(np, "vib_mode", &aw8697->info.mode);
+	if (val != 0)
+		printk("vib_mode not found\n");
+	val = of_property_read_u32(np, "vib_f0_pre", &aw8697->info.f0_pre);
+	if (val != 0)
+		printk("vib_f0_pre not found\n");
+	val = of_property_read_u32(np, "vib_f0_cali_percen",
+				   &aw8697->info.f0_cali_percen);
+	if (val != 0)
+		printk("vib_f0_cali_percen not found\n");
+
+	val = of_property_read_u32_array(np, "vib_rtp_time", rtp_time,
+					 ARRAY_SIZE(rtp_time));
+	if (val != 0)
+		printk("%s vib_rtp_time not found\n", __func__);
+	memcpy(aw8697->info.rtp_time, rtp_time, sizeof(rtp_time));
+
+	val = of_property_read_u32(np, "vib_effect_id_boundary",
+				   &aw8697->info.effect_id_boundary);
+	if (val != 0)
+		printk("%s vib_effect_id_boundary not found\n", __func__);
+	val = of_property_read_u32(np, "vib_effect_max",
+				   &aw8697->info.effect_max);
+	if (val != 0)
+		printk("%s vib_effect_max not found\n", __func__);
+
+	config->play_rate_us = HAP_PLAY_RATE_US_DEFAULT;
+	rc = of_property_read_u32(np, "qcom,play-rate-us", &tmp);
+	if (!rc)
+		config->play_rate_us = (tmp >= HAP_PLAY_RATE_US_MAX) ?
+					       HAP_PLAY_RATE_US_MAX :
+					       tmp;
+
+	aw8697->constant.pattern = devm_kcalloc(
+		aw8697->dev, HAP_WAVEFORM_BUFFER_MAX, sizeof(u8), GFP_KERNEL);
+	if (!aw8697->constant.pattern)
+		return -ENOMEM;
+
+	tmp = of_get_available_child_count(np);
+	aw8697->predefined = devm_kcalloc(
+		aw8697->dev, tmp, sizeof(*aw8697->predefined), GFP_KERNEL);
+	if (!aw8697->predefined)
+		return -ENOMEM;
+
+	aw8697->effects_count = tmp;
+	printk("%s ---%d aw8697->effects_count=%d\n", __func__, __LINE__,
+	       aw8697->effects_count);
+	for_each_available_child_of_node (np, child_node) {
+		printk("%s  %d  i=%d\n", __func__, __LINE__, i);
+		effect = &aw8697->predefined[i++];
+		printk("%s  %d  i=%d\n", __func__, __LINE__, i);
+		rc = of_property_read_u32(child_node, "qcom,effect-id",
+					  &effect->id);
+		if (rc != 0) {
+			printk("%s Read qcom,effect-id failed\n", __func__);
+		}
+		printk(" 20190420_dt effect_id: %d\n", effect->id);
+
+		printk("%s ---%d \n", __func__, __LINE__);
+		effect->vmax_mv = config->vmax_mv;
+		rc = of_property_read_u32(child_node, "qcom,wf-vmax-mv", &tmp);
+		if (rc != 0)
+			printk("%s  Read qcom,wf-vmax-mv failed !\n", __func__);
+		else
+			effect->vmax_mv = tmp;
+
+		printk("%s ---%d effect->vmax_mv =%d \n", __func__, __LINE__,
+		       effect->vmax_mv);
+		rc = of_property_count_elems_of_size(
+			child_node, "qcom,wf-pattern", sizeof(u8));
+		if (rc < 0) {
+			printk("%s Count qcom,wf-pattern property failed !\n",
+			       __func__);
+		} else if (rc == 0) {
+			printk("%s qcom,wf-pattern has no data\n", __func__);
+		}
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		effect->pattern_length = rc;
+		effect->pattern =
+			devm_kcalloc(aw8697->dev, effect->pattern_length,
+				     sizeof(u8), GFP_KERNEL);
+
+		rc = of_property_read_u8_array(child_node, "qcom,wf-pattern",
+					       effect->pattern,
+					       effect->pattern_length);
+		if (rc < 0) {
+			printk("%s Read qcom,wf-pattern property failed !\n",
+			       __func__);
+		}
+		printk("%s %d  effect->pattern_length=%d  effect->pattern=%d \n",
+		       __func__, __LINE__, effect->pattern_length,
+		       (int)effect->pattern);
+
+		effect->play_rate_us = config->play_rate_us;
+		rc = of_property_read_u32(child_node, "qcom,wf-play-rate-us",
+					  &tmp);
+		if (rc < 0)
+			printk("%s Read qcom,wf-play-rate-us failed !\n",
+			       __func__);
+		else
+			effect->play_rate_us = tmp;
+		printk("%s ---%d effect->play_rate_us=%d \n", __func__,
+		       __LINE__, effect->play_rate_us);
+
+		rc = of_property_read_u32(child_node, "qcom,wf-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			printk("%s Read  qcom,wf-repeat-count failed !\n",
+			       __func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_repeat); j++)
+				if (tmp <= wf_repeat[j])
+					break;
+
+			effect->wf_repeat_n = j;
+		}
+
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		rc = of_property_read_u32(child_node, "qcom,wf-s-repeat-count",
+					  &tmp);
+		if (rc < 0) {
+			printk("%s Read  qcom,wf-s-repeat-count failed !\n",
+			       __func__);
+		} else {
+			for (j = 0; j < ARRAY_SIZE(wf_s_repeat); j++)
+				if (tmp <= wf_s_repeat[j])
+					break;
+
+			effect->wf_s_repeat_n = j;
+		}
+
+		printk("%s ---%d \n", __func__, __LINE__);
+
+		effect->lra_auto_res_disable = of_property_read_bool(
+			child_node, "qcom,lra-auto-resonance-disable");
+
+		tmp = of_property_count_elems_of_size(
+			child_node, "qcom,wf-brake-pattern", sizeof(u8));
+		if (tmp <= 0)
+			continue;
+
+		if (tmp > HAP_BRAKE_PATTERN_MAX) {
+			printk("%s wf-brake-pattern shouldn't be more than %d bytes\n",
+			       __func__, HAP_BRAKE_PATTERN_MAX);
+		}
+
+		rc = of_property_read_u8_array(child_node,
+					       "qcom,wf-brake-pattern",
+					       effect->brake, tmp);
+		if (rc < 0) {
+			printk("%s Failed to get wf-brake-pattern !\n",
+			       __func__);
+		}
+
+		effect->brake_pattern_length = tmp;
+	}
+
+	for (j = 0; j < 175; j++)
+		aw_dev_info(aw8697->dev,
+			    " 20190420_dt aw8697->info.rtp_time[%d]: %d\n", j,
+			    aw8697->info.rtp_time[j]);
+
+	for (j = 0; j < i; j++) {
+		printk(" 20190420_dt       effect_id: %d\n",
+		       aw8697->predefined[j].id);
+		printk(" 20190420_dt       vmax: %d mv\n",
+		       aw8697->predefined[j].vmax_mv);
+		printk("20190420_dt        play_rate: %d us\n",
+		       aw8697->predefined[j].play_rate_us);
+		for (m = 0; m < aw8697->predefined[j].pattern_length; m++)
+			printk("20190420_dt     pattern[%d]: 0x%x\n", m,
+			       aw8697->predefined[j].pattern[m]);
+		for (m = 0; m < aw8697->predefined[j].brake_pattern_length; m++)
+			printk("20190420_dt     brake_pattern[%d]: 0x%x\n", m,
+			       aw8697->predefined[j].brake[m]);
+		printk("20190420_dt         brake_en: %d\n",
+		       aw8697->predefined[j].brake_en);
+		printk("20190420_dt        wf_repeat_n: %d\n",
+		       aw8697->predefined[j].wf_repeat_n);
+		printk("20190420_dt         wf_s_repeat_n: %d\n",
+		       aw8697->predefined[j].wf_s_repeat_n);
+		printk("20190420_dt         lra_auto_res_disable: %d\n",
+		       aw8697->predefined[j].lra_auto_res_disable);
+	}
+	printk(" 20190420_dt       aw8697->effects_count: %d\n",
+	       aw8697->effects_count);
+	printk(" 20190420_dt       aw8697->effect_id_boundary: %d\n",
+	       aw8697->info.effect_id_boundary);
+
+	printk(" 20190420_dt aw8697->effect_max: %d\n",
+	       aw8697->info.effect_max);
+
+	return 0;
+}
+
+static int aw8697_parse_dt_attr(struct device *dev, struct aw8697 *aw8697,
+				struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int bstdbg[6];
+	unsigned int f0_trace_parameter[4];
+	unsigned int bemf_config[4];
+	unsigned int trig_config[15];
+	int i = 0, j;
+
+	aw_dev_info(aw8697->dev, "%s  %d enter\n", __func__, __LINE__);
+
+	val = of_property_read_u32(np, "vib_cont_drv_lev",
+				   &aw8697->info.cont_drv_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_drv_lev not found\n");
+	val = of_property_read_u32(np, "vib_cont_drv_lvl_ov",
+				   &aw8697->info.cont_drv_lvl_ov);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_drv_lvl_ov not found\n");
+	val = of_property_read_u32(np, "vib_cont_td", &aw8697->info.cont_td);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_td not found\n");
+	val = of_property_read_u32(np, "vib_cont_zc_thr",
+				   &aw8697->info.cont_zc_thr);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_zc_thr not found\n");
+	val = of_property_read_u32(np, "vib_cont_num_brk",
+				   &aw8697->info.cont_num_brk);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_cont_num_brk not found\n");
+	val = of_property_read_u32(np, "vib_f0_coeff", &aw8697->info.f0_coeff);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "vib_f0_coeff not found\n");
+
+	val = of_property_read_u32(np, "vib_tset", &aw8697->info.tset);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_tset not found\n", __func__);
+	val = of_property_read_u32(np, "vib_r_spare", &aw8697->info.r_spare);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_r_spare not found\n",
+			    __func__);
+	val = of_property_read_u32_array(np, "vib_bstdbg", bstdbg,
+					 ARRAY_SIZE(bstdbg));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bstdbg not found\n", __func__);
+	memcpy(aw8697->info.bstdbg, bstdbg, sizeof(bstdbg));
+
+	val = of_property_read_u32_array(np, "vib_f0_trace_parameter",
+					 f0_trace_parameter,
+					 ARRAY_SIZE(f0_trace_parameter));
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_f0_trace_parameter not found\n", __func__);
+	memcpy(aw8697->info.f0_trace_parameter, f0_trace_parameter,
+	       sizeof(f0_trace_parameter));
+	val = of_property_read_u32_array(np, "vib_bemf_config", bemf_config,
+					 ARRAY_SIZE(bemf_config));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bemf_config not found\n",
+			    __func__);
+	memcpy(aw8697->info.bemf_config, bemf_config, sizeof(bemf_config));
+
+	val = of_property_read_u32_array(np, "vib_trig_config", trig_config,
+					 ARRAY_SIZE(trig_config));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_trig_config not found\n",
+			    __func__);
+	memcpy(aw8697->info.trig_config, trig_config, sizeof(trig_config));
+
+	val = of_property_read_u32(np, "vib_bst_vol_default_9x",
+				   &aw8697->info.bst_vol_default);
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_bst_vol_default_9x not found\n", __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_ram",
+				   &aw8697->info.bst_vol_ram);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_ram not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_rtp",
+				   &aw8697->info.bst_vol_rtp);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_rtp not found\n",
+			    __func__);
+
+	aw_dev_info(aw8697->dev, " 20190420_dt aw8697->info.cont_drv_lvl: %d\n",
+		    aw8697->info.cont_drv_lvl);
+	aw_dev_info(aw8697->dev,
+		    " 20190420_dt aw8697->info.cont_drv_lvl_ov: %d\n",
+		    aw8697->info.cont_drv_lvl_ov);
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 5; j++)
+			printk(" 20190420_dt aw8697->info.trig_config_9x[%d][%d]: %d\n",
+			       i, j, aw8697->info.trig_config[i][j]);
+
+	printk(" 20190420_dt aw8697->info.bst_vol_default_9x: 0x%x\n",
+	       aw8697->info.bst_vol_default);
+	printk(" 20190420_dt aw8697->info.bst_vol_ram_9x: 0x%x\n",
+	       aw8697->info.bst_vol_ram);
+	printk(" 20190420_dt aw8697->info.bst_vol_rtp_9x: 0x%x\n",
+	       aw8697->info.bst_vol_rtp);
+	return 0;
+}
+
+static int aw869xx_parse_dt_attr(struct device *dev, struct aw8697 *aw8697,
+				 struct device_node *np)
+{
+	unsigned int val = 0;
+	unsigned int bstcfg_temp[5] = { 0x2a, 0x24, 0x9a, 0x40, 0x91 };
+	unsigned int prctmode_temp[3];
+	unsigned int sine_array_temp[4] = { 0x05, 0xB2, 0xFF, 0xEF };
+	unsigned int trig_config_temp[24] = { 1, 0, 1, 1, 1, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0,
+					      1, 0, 0, 1, 0, 2, 0, 0 };
+
+	val = of_property_read_u32(np, "vib_cont_drv1_lvl",
+				   &aw8697->info.cont_drv1_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv1_lvl not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv2_lvl",
+				   &aw8697->info.cont_drv2_lvl);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv2_lvl not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv1_time",
+				   &aw8697->info.cont_drv1_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv1_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv2_time",
+				   &aw8697->info.cont_drv2_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv2_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_drv_width",
+				   &aw8697->info.cont_drv_width);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_drv_width not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_wait_num",
+				   &aw8697->info.cont_wait_num);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_wait_num not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_bst_brk_gain",
+				   &aw8697->info.cont_bst_brk_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_bst_brk_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_brk_gain",
+				   &aw8697->info.cont_brk_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_brk_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_tset",
+				   &aw8697->info.cont_tset);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_tset not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_bemf_set",
+				   &aw8697->info.cont_bemf_set);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_bemf_set not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_d2s_gain", &aw8697->info.d2s_gain);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_d2s_gain not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_brk_time",
+				   &aw8697->info.cont_brk_time);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_brk_time not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_cont_track_margin",
+				   &aw8697->info.cont_track_margin);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_cont_track_margin not found\n",
+			    __func__);
+	aw8697->info.is_enabled_auto_bst =
+		of_property_read_bool(np, "vib_is_enabled_auto_bst");
+	aw_dev_info(aw8697->dev, "%s aw8697->info.is_enabled_auto_bst = %d\n",
+		    __func__, aw8697->info.is_enabled_auto_bst);
+	aw8697->info.is_enabled_powerup_f0_cali =
+		of_property_read_bool(np, "vib_powerup_f0_cali");
+	aw_dev_info(aw8697->dev,
+		    "%s aw8697->info.is_enabled_powerup_f0_cali = %d\n",
+		    __func__, aw8697->info.is_enabled_powerup_f0_cali);
+	val = of_property_read_u32_array(np, "vib_bstcfg", bstcfg_temp,
+					 ARRAY_SIZE(bstcfg_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bstcfg not found\n", __func__);
+	memcpy(aw8697->info.bstcfg, bstcfg_temp, sizeof(bstcfg_temp));
+
+	val = of_property_read_u32_array(np, "vib_prctmode", prctmode_temp,
+					 ARRAY_SIZE(prctmode_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_prctmode not found\n",
+			    __func__);
+	memcpy(aw8697->info.prctmode, prctmode_temp, sizeof(prctmode_temp));
+	val = of_property_read_u32_array(np, "vib_sine_array", sine_array_temp,
+					 ARRAY_SIZE(sine_array_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_sine_array not found\n",
+			    __func__);
+	memcpy(aw8697->info.sine_array, sine_array_temp,
+	       sizeof(sine_array_temp));
+	val = of_property_read_u32_array(np, "vib_trig_config_9xx",
+					 trig_config_temp,
+					 ARRAY_SIZE(trig_config_temp));
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_trig_config_9xx not found\n",
+			    __func__);
+	memcpy(aw8697->info.trig_config_9xx, trig_config_temp,
+	       sizeof(trig_config_temp));
+
+	val = of_property_read_u32(np, "vib_bst_vol_default_9xx",
+				   &aw8697->info.bst_vol_default);
+	if (val != 0)
+		aw_dev_info(aw8697->dev,
+			    "%s vib_bst_vol_default_9xx not found\n", __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_ram_9xx",
+				   &aw8697->info.bst_vol_ram);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_ram_9xx not found\n",
+			    __func__);
+	val = of_property_read_u32(np, "vib_bst_vol_rtp_9xx",
+				   &aw8697->info.bst_vol_rtp);
+	if (val != 0)
+		aw_dev_info(aw8697->dev, "%s vib_bst_vol_rtp_9xx not found\n",
+			    __func__);
+
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_default_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_default);
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_ram_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_ram);
+	aw_dev_info(aw8697->dev, "%s aw8697->info.bst_vol_rtp_9xx: 0x%x\n",
+		    __func__, aw8697->info.bst_vol_rtp);
+
+	return 0;
+}
+
+static inline void get_play_length(struct qti_hap_play_info *play,
+				   int *length_us)
+{
+	struct qti_hap_effect *effect = play->effect;
+	int tmp;
+	//printk("%s  %d enter\n", __func__, __LINE__);
+
+	tmp = effect->pattern_length * effect->play_rate_us;
+	tmp *= wf_s_repeat[effect->wf_s_repeat_n];
+	tmp *= wf_repeat[effect->wf_repeat_n];
+	if (effect->brake_en)
+		tmp += effect->play_rate_us * effect->brake_pattern_length;
+
+	*length_us = tmp;
+}
+
+static int aw8697_haptics_upload_effect(struct input_dev *dev,
+					struct ff_effect *effect,
+					struct ff_effect *old)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	struct qti_hap_play_info *play = &aw8697->play;
+	s16 data[CUSTOM_DATA_LEN];
+	ktime_t rem;
+	s64 time_us;
+	int ret;
+
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	if (hrtimer_active(&aw8697->timer)) {
+		rem = hrtimer_get_remaining(&aw8697->timer);
+		time_us = ktime_to_us(rem);
+		printk("waiting for playing clear sequence: %lld us\n",
+		       time_us);
+		usleep_range(time_us, time_us + 100);
+	}
+	pr_debug("%s: effect->type=0x%x,FF_CONSTANT=0x%x,FF_PERIODIC=0x%x\n",
+		 __func__, effect->type, FF_CONSTANT, FF_PERIODIC);
+	aw8697->effect_type = effect->type;
+	mutex_lock(&aw8697->lock);
+	while (atomic_read(&aw8697->exit_in_rtp_loop)) {
+		pr_info("%s  goint to waiting rtp  exit\n", __func__);
+		mutex_unlock(&aw8697->lock);
+		ret = wait_event_interruptible(
+			aw8697->stop_wait_q,
+			atomic_read(&aw8697->exit_in_rtp_loop) == 0);
+		pr_info("%s  wakeup \n", __func__);
+		if (ret == -ERESTARTSYS) {
+			mutex_unlock(&aw8697->lock);
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+		mutex_lock(&aw8697->lock);
+	}
+
+	if (aw8697->effect_type == FF_CONSTANT) {
+		pr_debug("%s: effect_type is  FF_CONSTANT! \n", __func__);
+		/*cont mode set duration */
+		aw8697->duration = effect->replay.length;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE;
+		aw8697->effect_id = aw8697->info.effect_id_boundary;
+
+	} else if (aw8697->effect_type == FF_PERIODIC) {
+		if (aw8697->effects_count == 0) {
+			mutex_unlock(&aw8697->lock);
+			return -EINVAL;
+		}
+
+		pr_debug("%s: effect_type is  FF_PERIODIC! \n", __func__);
+		if (copy_from_user(data, effect->u.periodic.custom_data,
+				   sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw8697->lock);
+			return -EFAULT;
+		}
+
+		aw8697->effect_id = data[0];
+		pr_debug("%s: aw8697->effect_id =%d \n", __func__,
+			 aw8697->effect_id);
+		play->vmax_mv = effect->u.periodic.magnitude; /*vmax level*/
+
+		if (aw8697->effect_id < 0 ||
+		    aw8697->effect_id > aw8697->info.effect_max) {
+			mutex_unlock(&aw8697->lock);
+			return 0;
+		}
+		aw8697->is_custom_wave = 0;
+
+		if (aw8697->effect_id < aw8697->info.effect_id_boundary) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->predefined[aw8697->effect_id]
+					  .play_rate_us /
+				  1000000; /*second data*/
+			data[2] = aw8697->predefined[aw8697->effect_id]
+					  .play_rate_us /
+				  1000; /*millisecond data*/
+		}
+		if (aw8697->effect_id >= aw8697->info.effect_id_boundary) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RTP_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->info.rtp_time[aw8697->effect_id] /
+				  1000; /*second data*/
+			data[2] =
+				aw8697->info.rtp_time
+					[aw8697->effect_id]; /*millisecond data*/
+		}
+		if (aw8697->effect_id == CUSTOME_WAVE_ID) {
+			aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RTP_MODE;
+			pr_debug(
+				"%s: aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+				__func__, aw8697->effect_id,
+				aw8697->activate_mode);
+			data[1] = aw8697->info.rtp_time[aw8697->effect_id] /
+				  1000; /*second data*/
+			data[2] =
+				aw8697->info.rtp_time
+					[aw8697->effect_id]; /*millisecond data*/
+			aw8697->is_custom_wave = 1;
+			rb_init();
+		}
+
+		if (copy_to_user(effect->u.periodic.custom_data, data,
+				 sizeof(s16) * CUSTOM_DATA_LEN)) {
+			mutex_unlock(&aw8697->lock);
+			return -EFAULT;
+		}
+
+	} else {
+		pr_err("%s Unsupported effect type: %d\n", __func__,
+		       effect->type);
+	}
+	mutex_unlock(&aw8697->lock);
+	return 0;
+}
+
+static int aw8697_haptics_playback(struct input_dev *dev, int effect_id,
+				   int val)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	int rc = 0;
+
+	//printk("%s effect_id=%d , val = %d\n", __func__, effect_id, val);
+	//printk("%s aw8697->effect_id=%d , aw8697->activate_mode = %d\n",
+	//     __func__, aw8697->effect_id, aw8697->activate_mode);
+
+	pr_debug("%s: effect_id=%d , activate_mode = %d val = %d\n", __func__,
+		 aw8697->effect_id, aw8697->activate_mode, val);
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	if (val > 0)
+		aw8697->state = 1;
+	if (val <= 0)
+		aw8697->state = 0;
+	hrtimer_cancel(&aw8697->timer);
+
+	if (aw8697->effect_type == FF_CONSTANT &&
+	    aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_LOOP_MODE) {
+		pr_debug("%s: enter ram_loop_mode \n", __func__);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	} else if (aw8697->effect_type == FF_PERIODIC &&
+		   aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RAM_MODE) {
+		pr_debug("%s: enter  ram_mode\n", __func__);
+		//schedule_work(&aw8697->vibrator_work)
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+		;
+	} else if ((aw8697->effect_type == FF_PERIODIC) &&
+		   aw8697->activate_mode == AW8697_HAPTIC_ACTIVATE_RTP_MODE) {
+		pr_debug("%s: enter  rtp_mode\n", __func__);
+		//schedule_work(&aw8697->rtp_work);
+		queue_work(aw8697->work_queue, &aw8697->rtp_work);
+		//if we are in the play mode, force to exit
+		if (val == 0) {
+			atomic_set(&aw8697->exit_in_rtp_loop, 1);
+			rb_force_exit();
+			wake_up_interruptible(&aw8697->stop_wait_q);
+		}
+	} else {
+		/*other mode */
+	}
+
+	return rc;
+}
+
+static int aw8697_haptics_erase(struct input_dev *dev, int effect_id)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	int rc = 0;
+
+	/*for osc calibration*/
+	if (aw8697->osc_cali_run != 0)
+		return 0;
+
+	pr_debug("%s: enter\n", __func__);
+	aw8697->effect_type = 0;
+	aw8697->is_custom_wave = 0;
+	aw8697->duration = 0;
+	return rc;
+}
+
+static void set_gain(struct work_struct *work)
+{
+	struct aw8697 *aw8697 =
+		container_of(work, struct aw8697, set_gain_work);
+	pr_debug("%s enter set_gain queue work\n", __func__);
+
+	if (aw8697->new_gain >= 0x7FFF)
+		aw8697->level = 0x80; /*128*/
+	else if (aw8697->new_gain <= 0x3FFF)
+		aw8697->level = 0x1E; /*30*/
+	else
+		aw8697->level = (aw8697->new_gain - 16383) / 128;
+
+	if (aw8697->level < 0x1E)
+		aw8697->level = 0x1E; /*30*/
+
+	aw8697_haptic_set_gain(aw8697, aw8697->level);
+}
+
+static void aw8697_haptics_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct aw8697 *aw8697 = input_get_drvdata(dev);
+	pr_debug("%s enter\n", __func__);
+	aw8697->new_gain = gain;
+	queue_work(aw8697->work_queue, &aw8697->set_gain_work);
+}
+
+static ssize_t aw8697_effect_id_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "effect_id =%d\n", aw8697->effect_id);
+}
+
+static ssize_t aw8697_effect_id_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697->effect_id = val;
+	aw8697->play.vmax_mv = AW8697_MEDIUM_MAGNITUDE;
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_bst_vol_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "bst_vol_ram=%d\nbst_vol_rtp=%d\n",
+			aw8697->info.bst_vol_ram, aw8697->info.bst_vol_rtp);
+}
+
+static ssize_t aw8697_bst_vol_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	if (2 == sscanf(buf, "%d %d", &databuf[0], &databuf[1])) {
+		aw8697->info.bst_vol_ram = databuf[0];
+		aw8697->info.bst_vol_rtp = databuf[1];
+	}
+	return count;
+}
+
+static ssize_t aw8697_activate_test_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->test_val);
+}
+
+static ssize_t aw8697_activate_test_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+	;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697->test_val = val;
+	pr_debug("%s: aw8697->test_val=%d\n", __FUNCTION__, aw8697->test_val);
+
+	if (aw8697->test_val == 1) {
+		printk("%s  %d  \n", __func__, __LINE__);
+		aw8697->duration = 3000;
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+	if (aw8697->test_val == 2) {
+		printk("%s  %d  \n", __func__, __LINE__);
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_set_wav_seq(aw8697, 0x00, 0x01);
+		aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x01);
+
+		/*step 1:  choose  loop */
+		aw8697_haptic_set_wav_loop(aw8697, 0x01, 0x01);
+		mutex_unlock(&aw8697->lock);
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	if (aw8697->test_val == 3) { /*Ram instead of Cont */
+		aw8697->duration = 10000;
+
+		aw8697->state = 1;
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_CONT_MODE;
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	if (aw8697->test_val == 4) {
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_stop(aw8697);
+		aw8697_haptic_play_mode(aw8697, AW8697_HAPTIC_RAM_MODE);
+
+		aw8697_haptic_set_wav_seq(aw8697, 0x00, 0x01);
+		aw8697_haptic_set_wav_seq(aw8697, 0x01, 0x00);
+
+		aw8697_haptic_set_wav_loop(aw8697, 0x01, 0x01);
+
+		if (aw8697->info.bst_vol_ram <= AW8697_MAX_BST_VO)
+			aw8697_haptic_set_bst_vol(aw8697,
+						  aw8697->info.bst_vol_ram);
+		else
+			aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+
+		aw8697->activate_mode = AW8697_HAPTIC_ACTIVATE_RAM_MODE;
+		aw8697->state = 1;
+		mutex_unlock(&aw8697->lock);
+		hrtimer_cancel(&aw8697->timer);
+		//schedule_work(&aw8697->vibrator_work);
+		queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+	}
+
+	return count;
+}
+#ifdef ENABLE_PIN_CONTROL
+static int select_pin_ctl(struct aw8697 *aw8697, const char *name)
+{
+	size_t i;
+	int rc;
+
+	for (i = 0; i < ARRAY_SIZE(aw8697->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+
+		if (!strncmp(n, name, strlen(n))) {
+			rc = pinctrl_select_state(aw8697->aw8697_pinctrl,
+						  aw8697->pinctrl_state[i]);
+			if (rc)
+				printk("cannot select '%s'\n", name);
+			else
+				printk("Selected '%s'\n", name);
+			goto exit;
+		}
+	}
+
+	rc = -EINVAL;
+	printk("%s:'%s' not found\n", __func__, name);
+
+exit:
+	return rc;
+}
+static int aw8697_set_interrupt(struct aw8697 *aw8697)
+{
+	int rc = select_pin_ctl(aw8697, "aw8697_interrupt_active");
+	return rc;
+}
+#endif
+
+static int aw8697_hw_reset(struct aw8697 *aw8697)
+{
+#ifdef ENABLE_PIN_CONTROL
+	int rc = select_pin_ctl(aw8697, "aw8697_reset_active");
+	msleep(5);
+	rc = select_pin_ctl(aw8697, "aw8697_reset_reset");
+	msleep(5);
+	rc = select_pin_ctl(aw8697, "aw8697_reset_active");
+	msleep(3);
+#endif
+	if (!aw8697->enable_pin_control) {
+		if (aw8697 && gpio_is_valid(aw8697->reset_gpio)) {
+			gpio_set_value_cansleep(aw8697->reset_gpio, 0);
+			printk("%s pull down1\n", __func__);
+			msleep(5);
+			gpio_set_value_cansleep(aw8697->reset_gpio, 1);
+			printk("%s pull up1\n", __func__);
+			msleep(5);
+		} else {
+			dev_err(aw8697->dev, "%s:  failed\n", __func__);
+		}
+	}
+
+	return 0;
+}
+
+/*****************************************************
+ *
+ * check chip id
+ *
+ *****************************************************/
+static int aw8697_read_chipid(struct aw8697 *aw8697)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+	unsigned char reg = 0;
+
+	while (cnt < AW_READ_CHIPID_RETRIES) {
+		/* hardware reset */
+		aw8697_hw_reset(aw8697);
+
+		ret = aw8697_i2c_read(aw8697, AW8697_REG_ID, &reg);
+		if (ret < 0) {
+			dev_err(aw8697->dev,
+				"%s: failed to read register AW8697_REG_ID: %d\n",
+				__func__, ret);
+		}
+		switch (reg) {
+		case AW8695_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw8695 detected\n",
+				    __func__);
+			aw8697->chipid = AW8695_CHIPID;
+			aw8697->chip_version = AW8697_CHIP_9X;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW8697_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw8697 detected\n",
+				    __func__);
+			aw8697->chipid = AW8697_CHIPID;
+			aw8697->chip_version = AW8697_CHIP_9X;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86905_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86905 detected\n",
+				    __func__);
+			aw8697->chipid = AW86905_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L1;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86907_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86907 detected\n",
+				    __func__);
+			aw8697->chipid = AW86907_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L2;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86915_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86915 detected\n",
+				    __func__);
+			aw8697->chipid = AW86915_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L1;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		case AW86917_CHIPID:
+			aw_dev_info(aw8697->dev, "%s aw86917 detected\n",
+				    __func__);
+			aw8697->chipid = AW86917_CHIPID;
+			aw8697->bst_pc = AW869XX_HAPTIC_BST_PC_L2;
+			aw8697->chip_version = AW8697_CHIP_9XX;
+			aw8697_haptic_softreset(aw8697);
+			return 0;
+		default:
+			pr_info("%s unsupported device revision (0x%x)\n",
+				__func__, reg);
+			break;
+		}
+		cnt++;
+
+		msleep(AW_READ_CHIPID_RETRY_DELAY);
+	}
+
+	return -EINVAL;
+}
+
+/******************************************************
+ *
+ * sys group attribute: reg
+ *
+ ******************************************************/
+static ssize_t aw8697_i2c_reg_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		aw8697_i2c_write(aw8697, (unsigned char)databuf[0],
+				 (unsigned char)databuf[1]);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_i2c_reg_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		for (i = 0; i < AW8697_REG_MAX; i++) {
+			if (!(aw8697_reg_access[i] & REG_RD_ACCESS))
+				continue;
+			aw8697_i2c_read(aw8697, i, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02x=0x%02x\n", i, reg_val);
+		}
+	} else {
+		for (i = 0; i < AW869XX_REG_MAX; i++) {
+			if (!(aw869xx_reg_access[i] & REG_RD_ACCESS))
+				continue;
+			aw8697_i2c_read(aw8697, i, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02x=0x%02x\n", i, reg_val);
+		}
+	}
+	return len;
+}
+
+static ssize_t aw8697_i2c_ram_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	unsigned int databuf[1] = { 0 };
+
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		if (1 == databuf[0]) {
+			aw8697_ram_update(aw8697);
+		}
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_i2c_ram_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+
+	/* RAMINIT Enable */
+	aw8697_haptic_raminit(aw8697, true);
+	aw8697_haptic_stop(aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRH,
+				 (unsigned char)(aw8697->ram.base_addr >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_RAMADDRL,
+				 (unsigned char)(aw8697->ram.base_addr &
+						 0x00ff));
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"aw8697_haptic_ram:\n");
+		for (i = 0; i < aw8697->ram.len; i++) {
+			aw8697_i2c_read(aw8697, AW8697_REG_RAMDATA, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x,",
+					reg_val);
+		}
+	} else {
+		aw8697_i2c_write_bits(
+			aw8697, AW869XX_REG_RAMADDRH, AW869XX_BIT_RAMADDRH_MASK,
+			(unsigned char)(aw8697->ram.base_addr >> 8));
+		aw8697_i2c_write(aw8697, AW869XX_REG_RAMADDRH,
+				 (unsigned char)(aw8697->ram.base_addr &
+						 0x00ff));
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"aw8697_haptic_ram:\n");
+		for (i = 0; i < aw8697->ram.len; i++) {
+			aw8697_i2c_read(aw8697, AW869XX_REG_RAMDATA, &reg_val);
+			len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x,",
+					reg_val);
+		}
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	/* RAMINIT Disable */
+	aw8697_haptic_raminit(aw8697, false);
+
+	return len;
+}
+
+static ssize_t aw8697_duration_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ktime_t time_rem;
+	s64 time_ms = 0;
+
+	if (hrtimer_active(&aw8697->timer)) {
+		time_rem = hrtimer_get_remaining(&aw8697->timer);
+		time_ms = ktime_to_ms(time_rem);
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%lld\n", time_ms);
+}
+
+static ssize_t aw8697_duration_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	/* setting 0 on duration is NOP for now */
+	if (val <= 0)
+		return count;
+
+	aw8697->duration = val;
+
+	return count;
+}
+
+static ssize_t aw8697_activate_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	/* For now nothing to show */
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->state);
+}
+
+static ssize_t aw8697_activate_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+	;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val != 0 && val != 1)
+		return count;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	hrtimer_cancel(&aw8697->timer);
+
+	aw8697->state = val;
+
+	mutex_unlock(&aw8697->lock);
+	//schedule_work(&aw8697->vibrator_work);
+	queue_work(aw8697->work_queue, &aw8697->vibrator_work);
+
+	return count;
+}
+
+static ssize_t aw8697_activate_mode_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "activate_mode=%d\n",
+			aw8697->activate_mode);
+}
+
+static ssize_t aw8697_activate_mode_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697->activate_mode = val;
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_index_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned char reg_val = 0;
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_WAVSEQ1, &reg_val);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_WAVCFG1, &reg_val);
+	}
+	aw8697->index = reg_val;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->index);
+}
+
+static ssize_t aw8697_index_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->index = val;
+	aw8697_haptic_set_repeat_wav_seq(aw8697, aw8697->index);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_vmax_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw8697->vmax);
+}
+
+static ssize_t aw8697_vmax_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->vmax = val;
+	aw8697_haptic_set_bst_vol(aw8697, aw8697->vmax);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_gain_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	return snprintf(buf, PAGE_SIZE, "0x%02x\n", aw8697->gain);
+}
+
+static ssize_t aw8697_gain_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	pr_debug("%s: value=%d\n", __FUNCTION__, val);
+
+	mutex_lock(&aw8697->lock);
+	aw8697->gain = val;
+	aw8697_haptic_set_gain(aw8697, aw8697->gain);
+	mutex_unlock(&aw8697->lock);
+	return count;
+}
+
+static ssize_t aw8697_seq_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char AW_REG_CURRENT = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		AW_REG_CURRENT = AW8697_REG_WAVSEQ1;
+	} else {
+		AW_REG_CURRENT = AW869XX_REG_WAVCFG1;
+	}
+
+	for (i = 0; i < AW8697_SEQUENCER_SIZE; i++) {
+		aw8697_i2c_read(aw8697, AW_REG_CURRENT + i, &reg_val);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d: 0x%02x\n", i + 1, reg_val);
+		aw8697->seq[i] |= reg_val;
+	}
+	return count;
+}
+
+static ssize_t aw8697_seq_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		pr_debug("%s: seq%d=0x%x\n", __FUNCTION__, databuf[0],
+			 databuf[1]);
+		mutex_lock(&aw8697->lock);
+		aw8697->seq[databuf[0]] = (unsigned char)databuf[1];
+		aw8697_haptic_set_wav_seq(aw8697, (unsigned char)databuf[0],
+					  aw8697->seq[databuf[0]]);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_loop_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	size_t count = 0;
+	unsigned char i = 0;
+	unsigned char reg_val = 0;
+	unsigned char AW_REG_CURRENT = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		AW_REG_CURRENT = AW8697_REG_WAVLOOP1;
+	} else {
+		AW_REG_CURRENT = AW869XX_REG_WAVCFG9;
+	}
+	for (i = 0; i < AW8697_SEQUENCER_LOOP_SIZE; i++) {
+		aw8697_i2c_read(aw8697, AW_REG_CURRENT + i, &reg_val);
+		aw8697->loop[i * 2 + 0] = (reg_val >> 4) & 0x0F;
+		aw8697->loop[i * 2 + 1] = (reg_val >> 0) & 0x0F;
+
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 1,
+				  aw8697->loop[i * 2 + 0]);
+		count += snprintf(buf + count, PAGE_SIZE - count,
+				  "seq%d loop: 0x%02x\n", i * 2 + 2,
+				  aw8697->loop[i * 2 + 1]);
+	}
+	return count;
+}
+
+static ssize_t aw8697_loop_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		pr_debug("%s: seq%d loop=0x%x\n", __FUNCTION__, databuf[0],
+			 databuf[1]);
+		mutex_lock(&aw8697->lock);
+		aw8697->loop[databuf[0]] = (unsigned char)databuf[1];
+		aw8697_haptic_set_wav_loop(aw8697, (unsigned char)databuf[0],
+					   aw8697->loop[databuf[0]]);
+		mutex_unlock(&aw8697->lock);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_rtp_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "rtp play: %d\n",
+			aw8697->rtp_cnt);
+
+	return len;
+}
+
+static ssize_t aw8697_rtp_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_set_rtp_aei(aw8697, false);
+	aw8697_interrupt_clear(aw8697);
+	if (val < (sizeof(aw8697_rtp_name) / AW8697_RTP_NAME_MAX)) {
+		aw8697->rtp_file_num = val;
+		if (val) {
+			//schedule_work(&aw8697->rtp_work);
+			queue_work(aw8697->work_queue, &aw8697->rtp_work);
+		}
+	} else {
+		pr_err("%s: rtp_file_num 0x%02x over max value \n", __func__,
+		       aw8697->rtp_file_num);
+	}
+
+	return count;
+}
+
+static ssize_t aw8697_ram_update_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	//struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "sram update mode\n");
+	return len;
+}
+
+static ssize_t aw8697_ram_update_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val) {
+		aw8697_ram_update(aw8697);
+	}
+	return count;
+}
+
+static ssize_t aw8697_f0_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+#ifdef RETRY_F0_CHECK
+	unsigned int f0_cnt_time = 0;
+#endif
+
+	mutex_lock(&aw8697->lock);
+	aw8697->f0_cali_flag = AW8697_HAPTIC_LRA_F0;
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_f0(aw8697);
+#ifdef RETRY_F0_CHECK
+		f0_cnt_time = 1;
+		if ((f0_cnt_time == 1) && (aw8697->f0 == 0)) {
+			aw8697_haptic_get_f0(aw8697);
+			f0_cnt_time = 0;
+		}
+#endif
+	} else {
+		aw869xx_haptic_cont_get_f0(aw8697);
+#ifdef RETRY_F0_CHECK
+		f0_cnt_time = 1;
+		if ((f0_cnt_time == 1) && (aw8697->f0 == 0)) {
+			aw8697_haptic_get_f0(aw8697);
+			f0_cnt_time = 0;
+		}
+#endif
+	}
+	mutex_unlock(&aw8697->lock);
+	len +=
+		//snprintf(buf + len, PAGE_SIZE - len, "aw8697 lra f0 = %d\n",
+		snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw8697->f0);
+	return len;
+}
+
+static ssize_t aw8697_f0_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	return count;
+}
+
+static ssize_t aw8697_cali_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	mutex_lock(&aw8697->lock);
+	aw8697->f0_cali_flag = AW8697_HAPTIC_CALI_F0;
+	aw8697_haptic_upload_lra(aw8697, F0_CALI);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_f0(aw8697);
+	} else {
+		aw869xx_haptic_cont_get_f0(aw8697);
+	}
+
+	mutex_unlock(&aw8697->lock);
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw8697 cali f0 = %d\n",
+			aw8697->f0);
+	return len;
+}
+
+static ssize_t aw8697_cali_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	if (val) {
+		mutex_lock(&aw8697->lock);
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_f0_calibration(aw8697);
+		} else {
+			aw869xx_haptic_f0_calibration(aw8697);
+		}
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_read_cont_f0(aw8697);
+	} else {
+		aw869xx_haptic_read_cont_f0(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "aw8697 cont f0 = %d\n",
+			aw8697->cont_f0);
+	return len;
+}
+
+static ssize_t aw8697_cont_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	aw8697_haptic_stop(aw8697);
+	if (val) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_haptic_cont(aw8697);
+		} else {
+			aw869xx_haptic_cont(aw8697);
+		}
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_td_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont delay time = 0x%04x\n",
+			aw8697->info.cont_td);
+	return len;
+}
+
+static ssize_t aw8697_cont_td_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		aw8697->info.cont_td = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_TD_H,
+				 (unsigned char)(databuf[0] >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_TD_L,
+				 (unsigned char)(databuf[0] >> 0));
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_drv_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont drv level = %d\n",
+			aw8697->info.cont_drv_lvl);
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont drv level overdrive= %d\n",
+			aw8697->info.cont_drv_lvl_ov);
+	return len;
+}
+
+static ssize_t aw8697_cont_drv_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	if (2 == sscanf(buf, "%d %d", &databuf[0], &databuf[1])) {
+		aw8697->info.cont_drv_lvl = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL,
+				 aw8697->info.cont_drv_lvl);
+		aw8697->info.cont_drv_lvl_ov = databuf[1];
+		aw8697_i2c_write(aw8697, AW8697_REG_DRV_LVL_OV,
+				 aw8697->info.cont_drv_lvl_ov);
+	}
+	return count;
+}
+
+//return buffer size and availbe size
+static ssize_t aw8697_custom_wave_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len, "period_size=%d;",
+			aw8697->ram.base_addr >> 2);
+	len += snprintf(buf + len, PAGE_SIZE - len, "max_size=%d;free_size=%d;",
+			get_rb_max_size(), get_rb_free_size());
+	len += snprintf(buf + len, PAGE_SIZE - len, "custom_wave_id=%d;",
+			CUSTOME_WAVE_ID);
+	return len;
+}
+
+static ssize_t aw8697_custom_wave_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned long buf_len, period_size, offset;
+	int ret;
+	period_size = (aw8697->ram.base_addr >> 2);
+	offset = 0;
+	pr_debug(" write szie %d, period size %d", count, period_size);
+	if (count % period_size || count < period_size)
+		rb_end();
+	atomic_set(&aw8697->is_in_write_loop, 1);
+
+	while (count > 0) {
+		buf_len = min(count, period_size);
+		ret = write_rb(buf + offset, buf_len);
+		if (ret < 0)
+			goto exit;
+		count -= buf_len;
+		offset += buf_len;
+	}
+	ret = offset;
+exit:
+	atomic_set(&aw8697->is_in_write_loop, 0);
+	wake_up_interruptible(&aw8697->stop_wait_q);
+	pr_debug(" return size %d", ret);
+	return ret;
+}
+
+static ssize_t aw8697_cont_num_brk_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont break num = %d\n",
+			aw8697->info.cont_num_brk);
+	return len;
+}
+
+static ssize_t aw8697_cont_num_brk_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%d", &databuf[0])) {
+		aw8697->info.cont_num_brk = databuf[0];
+		if (aw8697->info.cont_num_brk > 7) {
+			aw8697->info.cont_num_brk = 7;
+		}
+		aw8697_i2c_write_bits(aw8697, AW8697_REG_BEMF_NUM,
+				      AW8697_BIT_BEMF_NUM_BRK_MASK,
+				      aw8697->info.cont_num_brk);
+	}
+	return count;
+}
+
+static ssize_t aw8697_cont_zc_thr_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw8697 cont zero cross thr = 0x%04x\n",
+			aw8697->info.cont_zc_thr);
+	return len;
+}
+
+static ssize_t aw8697_cont_zc_thr_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+	if (1 == sscanf(buf, "%x", &databuf[0])) {
+		aw8697->info.cont_zc_thr = databuf[0];
+		aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_H,
+				 (unsigned char)(databuf[0] >> 8));
+		aw8697_i2c_write(aw8697, AW8697_REG_ZC_THRSH_L,
+				 (unsigned char)(databuf[0] >> 0));
+	}
+	return count;
+}
+
+static ssize_t aw8697_vbat_monitor_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	mutex_lock(&aw8697->lock);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_stop(aw8697);
+		aw8697_haptic_get_vbat(aw8697);
+	} else {
+		aw869xx_haptic_get_vbat(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "vbat=%dmV\n",
+			aw8697->vbat);
+	mutex_unlock(&aw8697->lock);
+
+	return len;
+}
+
+static ssize_t aw8697_vbat_monitor_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw8697_lra_resistance_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_haptic_get_lra_resistance(aw8697);
+	} else {
+		aw869xx_haptic_get_lra_resistance(aw8697);
+	}
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", aw8697->lra);
+
+	return len;
+}
+
+static ssize_t aw8697_lra_resistance_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	return count;
+}
+
+static ssize_t aw8697_auto_boost_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "auto_boost=%d\n",
+			aw8697->auto_boost);
+
+	return len;
+}
+
+static ssize_t aw8697_auto_boost_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	aw8697_haptic_stop(aw8697);
+	aw8697_haptic_auto_boost_config(aw8697, val);
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_prctmode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char reg_val = 0;
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		aw8697_i2c_read(aw8697, AW8697_REG_DETCTRL, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "prctmode=%d\n",
+				reg_val & 0x20);
+	} else {
+		aw8697_i2c_read(aw8697, AW869XX_REG_DETCFG1, &reg_val);
+		len += snprintf(buf + len, PAGE_SIZE - len, "prctmode = %d\n",
+				reg_val & 0x08);
+	}
+	return len;
+}
+
+static ssize_t aw8697_prctmode_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+	unsigned int addr = 0;
+	unsigned int val = 0;
+	if (2 == sscanf(buf, "%x %x", &databuf[0], &databuf[1])) {
+		addr = databuf[0];
+		val = databuf[1];
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_swicth_motorprotect_config(aw8697, addr, val);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_trig_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+	unsigned char i = 0;
+	for (i = 0; i < AW8697_TRIG_NUM; i++) {
+		len += snprintf(
+			buf + len, PAGE_SIZE - len,
+			"trig%d: enable=%d, default_level=%d, dual_edge=%d, frist_seq=%d, second_seq=%d\n",
+			i + 1, aw8697->trig[i].enable,
+			aw8697->trig[i].default_level,
+			aw8697->trig[i].dual_edge, aw8697->trig[i].frist_seq,
+			aw8697->trig[i].second_seq);
+	}
+
+	return len;
+}
+
+static ssize_t aw8697_trig_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[6] = { 0 };
+	if (sscanf(buf, "%d %d %d %d %d %d", &databuf[0], &databuf[1],
+		   &databuf[2], &databuf[3], &databuf[4], &databuf[5])) {
+		pr_debug("%s: %d, %d, %d, %d, %d, %d\n", __func__, databuf[0],
+			 databuf[1], databuf[2], databuf[3], databuf[4],
+			 databuf[5]);
+		if (databuf[0] > 3) {
+			databuf[0] = 3;
+		}
+		if (databuf[0] > 0) {
+			databuf[0] -= 1;
+		}
+		aw8697->trig[databuf[0]].enable = databuf[1];
+		aw8697->trig[databuf[0]].default_level = databuf[2];
+		aw8697->trig[databuf[0]].dual_edge = databuf[3];
+		aw8697->trig[databuf[0]].frist_seq = databuf[4];
+		aw8697->trig[databuf[0]].second_seq = databuf[5];
+		mutex_lock(&aw8697->lock);
+		aw8697_haptic_trig_param_config(aw8697);
+		aw8697_haptic_trig_enable_config(aw8697);
+		mutex_unlock(&aw8697->lock);
+	}
+	return count;
+}
+
+static ssize_t aw8697_ram_vbat_comp_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "ram_vbat_comp=%d\n",
+			aw8697->ram_vbat_comp);
+
+	return len;
+}
+
+static ssize_t aw8697_ram_vbat_comp_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	if (val) {
+		aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_ENABLE;
+	} else {
+		aw8697->ram_vbat_comp = AW8697_HAPTIC_RAM_VBAT_COMP_DISABLE;
+	}
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_osc_cali_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw8697->lra_calib_data);
+
+	return len;
+}
+
+static ssize_t aw8697_osc_cali_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&aw8697->lock);
+	/*osc calibration flag start,Other behaviors are forbidden*/
+	aw8697->osc_cali_run = 1;
+	if (val == 3) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_rtp_osc_calibration(aw8697);
+			aw8697_rtp_trim_lra_calibration(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_D2SCFG1,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+			aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+			aw869xx_rtp_osc_calibration(aw8697);
+			aw869xx_rtp_trim_lra_calibration(aw8697);
+		}
+	}
+	if (val == 1) {
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_rtp_osc_calibration(aw8697);
+		} else {
+			aw8697_i2c_write_bits(
+				aw8697, AW869XX_REG_D2SCFG1,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_MASK,
+				AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_24K);
+			aw8697_haptic_upload_lra(aw8697, WRITE_ZERO);
+			aw869xx_rtp_osc_calibration(aw8697);
+		}
+	}
+
+	aw8697->osc_cali_run = 0;
+	/*osc calibration flag end,Other behaviors are permitted*/
+	mutex_unlock(&aw8697->lock);
+
+	return count;
+}
+
+static ssize_t aw8697_osc_save_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	pr_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw8697->lra_calib_data = val;
+	pr_info("%s load osa cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw8697_f0_save_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "%d\n",
+			aw8697->f0_calib_data);
+
+	return len;
+}
+
+static ssize_t aw8697_f0_save_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	pr_info("%s enter\n", __func__);
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	aw8697->f0_calib_data = val;
+	pr_info("%s load f0 cal: %d\n", __func__, val);
+
+	return count;
+}
+
+static ssize_t aw8697_f0_value_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", aw8697->f0);
+}
+
+static ssize_t aw8697_f0_check_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	if (aw8697->f0_cali_status == true)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 1);
+	if (aw8697->f0_cali_status == false)
+		len += snprintf(buf + len, PAGE_SIZE - len, "%d\n", 0);
+
+	return len;
+}
+
+#ifdef SUPPORT_RELOAD_FW
+static ssize_t aw8697_vov_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "0x%02x\n",
+			aw8697->info.bst_vol_ram);
+
+	return len;
+}
+
+static ssize_t aw8697_vov_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int val = 0;
+	int rc = 0;
+
+	rc = kstrtouint(buf, 0, &val);
+	if (rc < 0)
+		return rc;
+	if (val == 1) {
+		aw8697->vov = 1;
+		aw8697->info.bst_vol_ram = 0x10;
+		pr_info("set ux value: 0x%02x, update ram\n",
+			aw8697->info.bst_vol_ram);
+		aw8697->ram_name = aw8697_ram_name_a;
+		queue_delayed_work(aw8697->work_queue, &aw8697->ram_work,
+				   msecs_to_jiffies(5000));
+	}
+
+	return count;
+}
+#endif
+
+static ssize_t aw869xx_cont_wait_num_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_wait_num = 0x%02X\n",
+			aw8697->info.cont_wait_num);
+	return len;
+}
+
+static ssize_t aw869xx_cont_wait_num_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+
+	if (sscanf(buf, "%x", &databuf[0]) == 1) {
+		aw8697->info.cont_wait_num = databuf[0];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG4,
+				 aw8697->info.cont_wait_num);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_drv_lvl_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_lvl = 0x%02X, cont_drv2_lvl = 0x%02X\n",
+			aw8697->info.cont_drv1_lvl, aw8697->info.cont_drv2_lvl);
+	return len;
+}
+
+static ssize_t aw869xx_cont_drv_lvl_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw8697->info.cont_drv1_lvl = databuf[0];
+		aw8697->info.cont_drv2_lvl = databuf[1];
+		aw8697_i2c_write_bits(aw8697, AW869XX_REG_CONTCFG6,
+				      AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK,
+				      aw8697->info.cont_drv1_lvl);
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG7,
+				 aw8697->info.cont_drv2_lvl);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_drv_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"cont_drv1_time = 0x%02X, cont_drv2_time = 0x%02X\n",
+			aw8697->info.cont_drv1_time,
+			aw8697->info.cont_drv2_time);
+	return len;
+}
+
+static ssize_t aw869xx_cont_drv_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[2] = { 0, 0 };
+
+	if (sscanf(buf, "%x %x", &databuf[0], &databuf[1]) == 2) {
+		aw8697->info.cont_drv1_time = databuf[0];
+		aw8697->info.cont_drv2_time = databuf[1];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG8,
+				 aw8697->info.cont_drv1_time);
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG9,
+				 aw8697->info.cont_drv2_time);
+	}
+	return count;
+}
+
+static ssize_t aw869xx_cont_brk_time_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "cont_brk_time = 0x%02X\n",
+			aw8697->info.cont_brk_time);
+	return len;
+}
+
+static ssize_t aw869xx_cont_brk_time_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct aw8697 *aw8697 = dev_get_drvdata(dev);
+	unsigned int databuf[1] = { 0 };
+
+	if (sscanf(buf, "%x", &databuf[0]) == 1) {
+		aw8697->info.cont_brk_time = databuf[0];
+		aw8697_i2c_write(aw8697, AW869XX_REG_CONTCFG10,
+				 aw8697->info.cont_brk_time);
+	}
+	return count;
+}
+
+/* common */
+static DEVICE_ATTR(effect_id, S_IWUSR | S_IRUGO, aw8697_effect_id_show,
+		   aw8697_effect_id_store);
+static DEVICE_ATTR(bst_vol, S_IWUSR | S_IRUGO, aw8697_bst_vol_show,
+		   aw8697_bst_vol_store);
+static DEVICE_ATTR(activate_test, S_IWUSR | S_IRUGO, aw8697_activate_test_show,
+		   aw8697_activate_test_store);
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO, aw8697_i2c_reg_show,
+		   aw8697_i2c_reg_store);
+static DEVICE_ATTR(ram, S_IWUSR | S_IRUGO, aw8697_i2c_ram_show,
+		   aw8697_i2c_ram_store);
+static DEVICE_ATTR(duration, S_IWUSR | S_IRUGO, aw8697_duration_show,
+		   aw8697_duration_store);
+static DEVICE_ATTR(activate, S_IWUSR | S_IRUGO, aw8697_activate_show,
+		   aw8697_activate_store);
+static DEVICE_ATTR(activate_mode, S_IWUSR | S_IRUGO, aw8697_activate_mode_show,
+		   aw8697_activate_mode_store);
+static DEVICE_ATTR(index, S_IWUSR | S_IRUGO, aw8697_index_show,
+		   aw8697_index_store);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO, aw8697_vmax_show,
+		   aw8697_vmax_store);
+static DEVICE_ATTR(gain, S_IWUSR | S_IRUGO, aw8697_gain_show,
+		   aw8697_gain_store);
+static DEVICE_ATTR(seq, S_IWUSR | S_IRUGO, aw8697_seq_show, aw8697_seq_store);
+static DEVICE_ATTR(loop, S_IWUSR | S_IRUGO, aw8697_loop_show,
+		   aw8697_loop_store);
+static DEVICE_ATTR(rtp, S_IWUSR | S_IRUGO, aw8697_rtp_show, aw8697_rtp_store);
+static DEVICE_ATTR(ram_update, S_IWUSR | S_IRUGO, aw8697_ram_update_show,
+		   aw8697_ram_update_store);
+static DEVICE_ATTR(f0, S_IWUSR | S_IRUGO, aw8697_f0_show, aw8697_f0_store);
+static DEVICE_ATTR(cali, S_IWUSR | S_IRUGO, aw8697_cali_show,
+		   aw8697_cali_store);
+static DEVICE_ATTR(cont, S_IWUSR | S_IRUGO, aw8697_cont_show,
+		   aw8697_cont_store);
+static DEVICE_ATTR(vbat_monitor, S_IWUSR | S_IRUGO, aw8697_vbat_monitor_show,
+		   aw8697_vbat_monitor_store);
+static DEVICE_ATTR(lra_resistance, S_IWUSR | S_IRUGO,
+		   aw8697_lra_resistance_show, aw8697_lra_resistance_store);
+static DEVICE_ATTR(auto_boost, S_IWUSR | S_IRUGO, aw8697_auto_boost_show,
+		   aw8697_auto_boost_store);
+static DEVICE_ATTR(prctmode, S_IWUSR | S_IRUGO, aw8697_prctmode_show,
+		   aw8697_prctmode_store);
+static DEVICE_ATTR(trig, S_IWUSR | S_IRUGO, aw8697_trig_show,
+		   aw8697_trig_store);
+static DEVICE_ATTR(ram_vbat_comp, S_IWUSR | S_IRUGO, aw8697_ram_vbat_comp_show,
+		   aw8697_ram_vbat_comp_store);
+static DEVICE_ATTR(osc_cali, S_IWUSR | S_IRUGO, aw8697_osc_cali_show,
+		   aw8697_osc_cali_store);
+static DEVICE_ATTR(f0_check, S_IWUSR | S_IRUGO, aw8697_f0_check_show, NULL);
+static DEVICE_ATTR(f0_save, S_IWUSR | S_IRUGO, aw8697_f0_save_show,
+		   aw8697_f0_save_store);
+static DEVICE_ATTR(osc_save, S_IWUSR | S_IRUGO, aw8697_osc_cali_show,
+		   aw8697_osc_save_store);
+static DEVICE_ATTR(f0_value, S_IRUGO, aw8697_f0_value_show, NULL);
+static DEVICE_ATTR(custom_wave, S_IWUSR | S_IRUGO, aw8697_custom_wave_show,
+		   aw8697_custom_wave_store);
+#ifdef SUPPORT_RELOAD_FW
+static DEVICE_ATTR(vov, S_IWUSR | S_IRUGO, aw8697_vov_show, aw8697_vov_store);
+#endif
+
+/* aw869x */
+static DEVICE_ATTR(cont_td, S_IWUSR | S_IRUGO, aw8697_cont_td_show,
+		   aw8697_cont_td_store);
+static DEVICE_ATTR(cont_drv, S_IWUSR | S_IRUGO, aw8697_cont_drv_show,
+		   aw8697_cont_drv_store);
+static DEVICE_ATTR(cont_num_brk, S_IWUSR | S_IRUGO, aw8697_cont_num_brk_show,
+		   aw8697_cont_num_brk_store);
+static DEVICE_ATTR(cont_zc_thr, S_IWUSR | S_IRUGO, aw8697_cont_zc_thr_show,
+		   aw8697_cont_zc_thr_store);
+
+/* aw869xx */
+static DEVICE_ATTR(cont_wait_num, S_IWUSR | S_IRUGO, aw869xx_cont_wait_num_show,
+		   aw869xx_cont_wait_num_store);
+static DEVICE_ATTR(cont_drv_lvl, S_IWUSR | S_IRUGO, aw869xx_cont_drv_lvl_show,
+		   aw869xx_cont_drv_lvl_store);
+static DEVICE_ATTR(cont_drv_time, S_IWUSR | S_IRUGO, aw869xx_cont_drv_time_show,
+		   aw869xx_cont_drv_time_store);
+static DEVICE_ATTR(cont_brk_time, S_IWUSR | S_IRUGO, aw869xx_cont_brk_time_show,
+		   aw869xx_cont_brk_time_store);
+
+static struct attribute *aw8697_vibrator_attributes[] = {
+	&dev_attr_reg.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_activate_test.attr,
+	&dev_attr_effect_id.attr,
+	&dev_attr_bst_vol.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_td.attr,
+	&dev_attr_cont_drv.attr,
+	&dev_attr_cont_num_brk.attr,
+	&dev_attr_cont_zc_thr.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_trig.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_f0_check.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_custom_wave.attr,
+#ifdef SUPPORT_RELOAD_FW
+	&dev_attr_vov.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group aw8697_vibrator_attribute_group = {
+	.attrs = aw8697_vibrator_attributes
+};
+
+static struct attribute *aw869xx_vibrator_attributes[] = {
+	&dev_attr_activate_test.attr,
+	&dev_attr_effect_id.attr,
+	&dev_attr_bst_vol.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_activate.attr,
+	&dev_attr_activate_mode.attr,
+	&dev_attr_index.attr,
+	&dev_attr_vmax.attr,
+	&dev_attr_gain.attr,
+	&dev_attr_seq.attr,
+	&dev_attr_loop.attr,
+	&dev_attr_reg.attr,
+	&dev_attr_rtp.attr,
+	&dev_attr_ram.attr,
+	&dev_attr_ram_update.attr,
+	&dev_attr_f0.attr,
+	&dev_attr_f0_save.attr,
+	&dev_attr_osc_save.attr,
+	&dev_attr_osc_cali.attr,
+	&dev_attr_cali.attr,
+	&dev_attr_cont.attr,
+	&dev_attr_cont_wait_num.attr,
+	&dev_attr_cont_drv_lvl.attr,
+	&dev_attr_cont_drv_time.attr,
+	&dev_attr_cont_brk_time.attr,
+	&dev_attr_vbat_monitor.attr,
+	&dev_attr_lra_resistance.attr,
+	&dev_attr_auto_boost.attr,
+	&dev_attr_prctmode.attr,
+	&dev_attr_ram_vbat_comp.attr,
+	&dev_attr_f0_value.attr,
+	&dev_attr_custom_wave.attr,
+	NULL
+};
+
+static struct attribute_group aw869xx_vibrator_attribute_group = {
+	.attrs = aw869xx_vibrator_attributes
+};
+
+/******************************************************
+ *
+ * i2c driver
+ *
+ ******************************************************/
+static int aw8697_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct aw8697 *aw8697;
+	struct input_dev *input_dev;
+	int rc = 0, effect_count_max;
+	struct ff_device *ff;
+	struct device_node *np = i2c->dev.of_node;
+	int irq_flags = 0;
+	int ret = -1;
+	unsigned char reg = 0;
+#ifdef ENABLE_PIN_CONTROL
+	int i;
+#endif
+
+	pr_info("%s enter\n", __func__);
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C)) {
+		dev_err(&i2c->dev, "check_functionality failed\n");
+		return -EIO;
+	}
+
+	aw8697 = devm_kzalloc(&i2c->dev, sizeof(struct aw8697), GFP_KERNEL);
+	if (aw8697 == NULL)
+		return -ENOMEM;
+
+	input_dev = devm_input_allocate_device(&i2c->dev);
+	if (!input_dev)
+		return -ENOMEM;
+
+	aw8697->dev = &i2c->dev;
+	aw8697->i2c = i2c;
+	device_init_wakeup(aw8697->dev, true);
+	i2c_set_clientdata(i2c, aw8697);
+
+	/* aw8697 rst & int */
+	if (np) {
+		ret = aw8697_parse_dt_common(&i2c->dev, aw8697, np);
+		printk("%s ---%d \n", __func__, __LINE__);
+		if (ret) {
+			dev_err(&i2c->dev,
+				"%s: failed to parse common device tree node\n",
+				__func__);
+			goto err_parse_dt_common;
+		}
+	} else {
+		aw8697->reset_gpio = -1;
+		aw8697->irq_gpio = -1;
+	}
+	aw8697->enable_pin_control = 0;
+#ifdef ENABLE_PIN_CONTROL
+	aw8697->aw8697_pinctrl = devm_pinctrl_get(&i2c->dev);
+	if (IS_ERR(aw8697->aw8697_pinctrl)) {
+		if (PTR_ERR(aw8697->aw8697_pinctrl) == -EPROBE_DEFER) {
+			printk("pinctrl not ready\n");
+			rc = -EPROBE_DEFER;
+			return rc;
+		}
+		printk("Target does not use pinctrl\n");
+		aw8697->aw8697_pinctrl = NULL;
+		rc = -EINVAL;
+		return rc;
+	}
+	for (i = 0; i < ARRAY_SIZE(aw8697->pinctrl_state); i++) {
+		const char *n = pctl_names[i];
+		struct pinctrl_state *state =
+			pinctrl_lookup_state(aw8697->aw8697_pinctrl, n);
+		if (IS_ERR(state)) {
+			printk("cannot find '%s'\n", n);
+			rc = -EINVAL;
+			//goto exit;
+		}
+		printk("found pin control %s\n", n);
+		aw8697->pinctrl_state[i] = state;
+		aw8697->enable_pin_control = 1;
+		aw8697_set_interrupt(aw8697);
+	}
+#endif
+	printk("%s ---%d \n", __func__, __LINE__);
+	if (!aw8697->enable_pin_control) {
+		if (gpio_is_valid(aw8697->reset_gpio)) {
+			ret = devm_gpio_request_one(&i2c->dev,
+						    aw8697->reset_gpio,
+						    GPIOF_OUT_INIT_LOW,
+						    "aw8697_rst");
+			if (ret) {
+				dev_err(&i2c->dev, "%s: rst request failed\n",
+					__func__);
+				goto err_reset_gpio_request;
+			}
+		}
+	}
+
+	if (gpio_is_valid(aw8697->irq_gpio)) {
+		ret = devm_gpio_request_one(&i2c->dev, aw8697->irq_gpio,
+					    GPIOF_DIR_IN, "aw8697_int");
+		if (ret) {
+			dev_err(&i2c->dev, "%s: int request failed\n",
+				__func__);
+			goto err_irq_gpio_request;
+		}
+	}
+
+	ret = aw8697_read_chipid(aw8697);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "%s: aw8697_read_chipid failed ret=%d\n",
+			__func__, ret);
+		goto err_id;
+	}
+	/* aw869xx chip qualify */
+	if (aw8697->chip_version == AW8697_CHIP_9XX) {
+		ret = aw8697_i2c_read(aw8697, 0x64, &reg);
+		if (ret < 0) {
+			aw_dev_err(&i2c->dev,
+				   "%s: failed to read register 0x64: %d\n",
+				   __func__, ret);
+		}
+		if (!(reg & 0x80)) {
+			aw_dev_err(&i2c->dev, "%s: error! unqualified chip!\n",
+				   __func__);
+			goto err_qualify;
+		}
+	}
+
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = aw8697_parse_dt_attr(&i2c->dev, aw8697, np);
+	} else {
+		ret = aw869xx_parse_dt_attr(&i2c->dev, aw8697, np);
+	}
+	aw_dev_info(aw8697->dev, "%s %d\n", __func__, __LINE__);
+	if (ret) {
+		aw_dev_err(&i2c->dev, "%s: failed to parse device tree node\n",
+			   __func__);
+		goto err_parse_dt_attr;
+	}
+
+	if (gpio_is_valid(aw8697->irq_gpio) &&
+	    !(aw8697->flags & AW8697_FLAG_SKIP_INTERRUPTS)) {
+		/* register irq handler */
+		if (aw8697->chip_version == AW8697_CHIP_9X) {
+			aw8697_interrupt_setup(aw8697);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev, gpio_to_irq(aw8697->irq_gpio), NULL,
+				aw8697_irq, irq_flags, "aw8697", aw8697);
+			if (ret != 0) {
+				aw_dev_err(&i2c->dev,
+					   "%s: failed to request IRQ %d: %d\n",
+					   __func__,
+					   gpio_to_irq(aw8697->irq_gpio), ret);
+				goto err_irq;
+			}
+		} else {
+			aw869xx_interrupt_setup(aw8697);
+			irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+			ret = devm_request_threaded_irq(
+				&i2c->dev, gpio_to_irq(aw8697->irq_gpio), NULL,
+				aw869xx_irq, irq_flags, "aw8697", aw8697);
+			if (ret != 0) {
+				aw_dev_err(&i2c->dev,
+					   "%s: failed to request IRQ %d: %d\n",
+					   __func__,
+					   gpio_to_irq(aw8697->irq_gpio), ret);
+				goto err_irq;
+			}
+		}
+	} else {
+		dev_info(&i2c->dev, "%s skipping IRQ registration\n", __func__);
+		/* disable feature support if gpio was invalid */
+		aw8697->flags |= AW8697_FLAG_SKIP_INTERRUPTS;
+	}
+
+	hrtimer_init(&aw8697->stop_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	aw8697->stop_timer.function = qti_hap_stop_timer;
+	hrtimer_init(&aw8697->hap_disable_timer, CLOCK_MONOTONIC,
+		     HRTIMER_MODE_REL);
+	aw8697->hap_disable_timer.function = qti_hap_disable_timer;
+
+	input_dev->name = AW8697_HAPTIC_NAME;
+	input_set_drvdata(input_dev, aw8697);
+	aw8697->input_dev = input_dev;
+	input_set_capability(input_dev, EV_FF, FF_CONSTANT);
+	input_set_capability(input_dev, EV_FF, FF_GAIN);
+	if (aw8697->effects_count != 0) {
+		input_set_capability(input_dev, EV_FF, FF_PERIODIC);
+		input_set_capability(input_dev, EV_FF, FF_CUSTOM);
+	}
+
+	if (aw8697->effects_count + 1 > FF_EFFECT_COUNT_MAX)
+		effect_count_max = aw8697->effects_count + 1;
+	else
+		effect_count_max = FF_EFFECT_COUNT_MAX;
+	rc = input_ff_create(input_dev, effect_count_max);
+	if (rc < 0) {
+		dev_err(aw8697->dev, "create FF input device failed, rc=%d\n",
+			rc);
+		return rc;
+	}
+	aw8697->work_queue =
+		create_singlethread_workqueue("aw8976_vibrator_work_queue");
+	if (!aw8697->work_queue) {
+		dev_err(&i2c->dev,
+			"%s: Error creating aw8976_vibrator_work_queue\n",
+			__func__);
+		goto err_sysfs;
+	}
+	INIT_WORK(&aw8697->set_gain_work, set_gain);
+	aw8697_vibrator_init(aw8697);
+	aw8697_haptic_init(aw8697);
+	aw8697_ram_init(aw8697);
+
+	ff = input_dev->ff;
+	ff->upload = aw8697_haptics_upload_effect;
+	ff->playback = aw8697_haptics_playback;
+	ff->erase = aw8697_haptics_erase;
+	ff->set_gain = aw8697_haptics_set_gain;
+	rc = input_register_device(input_dev);
+	if (rc < 0) {
+		dev_err(aw8697->dev, "register input device failed, rc=%d\n",
+			rc);
+		goto destroy_ff;
+	}
+
+	dev_set_drvdata(&i2c->dev, aw8697);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		ret = sysfs_create_group(&i2c->dev.kobj,
+					 &aw8697_vibrator_attribute_group);
+	} else {
+		ret = sysfs_create_group(&i2c->dev.kobj,
+					 &aw869xx_vibrator_attribute_group);
+	}
+	if (ret < 0) {
+		dev_info(&i2c->dev, "%s error creating sysfs attr files\n",
+			 __func__);
+		goto err_sysfs;
+	}
+
+	g_aw8697 = aw8697;
+
+	ret = create_rb();
+	if (ret < 0) {
+		dev_info(&i2c->dev, "%s error creating ringbuffer\n", __func__);
+		goto err_rb;
+	}
+
+	CUSTOME_WAVE_ID = aw8697->info.effect_max;
+
+	pr_info("%s probe completed successfully!\n", __func__);
+
+	return 0;
+
+err_rb:
+	sysfs_remove_group(&i2c->dev.kobj, &aw8697_vibrator_attribute_group);
+err_sysfs:
+	devm_free_irq(&i2c->dev, gpio_to_irq(aw8697->irq_gpio), aw8697);
+destroy_ff:
+	input_ff_destroy(aw8697->input_dev);
+err_irq:
+err_parse_dt_attr:
+err_qualify:
+err_id:
+	if (gpio_is_valid(aw8697->irq_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->irq_gpio);
+err_irq_gpio_request:
+	if (gpio_is_valid(aw8697->reset_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->reset_gpio);
+err_reset_gpio_request:
+err_parse_dt_common:
+	device_init_wakeup(aw8697->dev, false);
+	devm_kfree(&i2c->dev, aw8697);
+	aw8697 = NULL;
+	return ret;
+}
+
+static int aw8697_i2c_remove(struct i2c_client *i2c)
+{
+	struct aw8697 *aw8697 = i2c_get_clientdata(i2c);
+
+	pr_info("%s enter\n", __func__);
+	if (aw8697->chip_version == AW8697_CHIP_9X) {
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw8697_vibrator_attribute_group);
+	} else {
+		sysfs_remove_group(&i2c->dev.kobj,
+				   &aw869xx_vibrator_attribute_group);
+	}
+	devm_free_irq(&i2c->dev, gpio_to_irq(aw8697->irq_gpio), aw8697);
+
+	if (gpio_is_valid(aw8697->irq_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->irq_gpio);
+	if (gpio_is_valid(aw8697->reset_gpio))
+		devm_gpio_free(&i2c->dev, aw8697->reset_gpio);
+	if (aw8697 != NULL) {
+		flush_workqueue(aw8697->work_queue);
+		destroy_workqueue(aw8697->work_queue);
+	}
+	device_init_wakeup(aw8697->dev, false);
+	release_rb();
+	devm_kfree(&i2c->dev, aw8697);
+	aw8697 = NULL;
+
+	return 0;
+}
+
+static const struct i2c_device_id aw8697_i2c_id[] = {
+	{ AW8697_I2C_NAME, 0 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, aw8697_i2c_id);
+
+const static struct of_device_id aw8697_dt_match[] = {
+	{ .compatible = "awinic,aw8697_haptic" },
+	{},
+};
+
+static struct i2c_driver aw8697_i2c_driver = {
+	.driver = {
+		   .name = AW8697_I2C_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(aw8697_dt_match),
+		   },
+	.probe = aw8697_i2c_probe,
+	.remove = aw8697_i2c_remove,
+	.id_table = aw8697_i2c_id,
+};
+
+static int __init aw8697_i2c_init(void)
+{
+	int ret = 0;
+
+	pr_info("aw8697 driver version %s\n", AW8697_VERSION);
+
+	ret = i2c_add_driver(&aw8697_i2c_driver);
+	if (ret) {
+		pr_err("fail to add aw8697 device into i2c\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+module_init(aw8697_i2c_init);
+
+static void __exit aw8697_i2c_exit(void)
+{
+	i2c_del_driver(&aw8697_i2c_driver);
+}
+
+module_exit(aw8697_i2c_exit);
+
+MODULE_DESCRIPTION("AW8697 Haptic Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/misc/aw8697_haptic/aw8697_reg.h b/drivers/input/misc/aw8697_haptic/aw8697_reg.h
new file mode 100644
index 000000000000..09e5424eda6f
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw8697_reg.h
@@ -0,0 +1,539 @@
+#ifndef _AW8697_REG_H_
+#define _AW8697_REG_H_
+
+/********************************************
+ * Register List
+ *******************************************/
+#define AW8697_REG_ID 0x00
+#define AW8697_REG_SYSST 0x01
+#define AW8697_REG_SYSINT 0x02
+#define AW8697_REG_SYSINTM 0x03
+#define AW8697_REG_SYSCTRL 0x04
+#define AW8697_REG_GO 0x05
+#define AW8697_REG_RTP_DATA 0x06
+#define AW8697_REG_WAVSEQ1 0x07
+#define AW8697_REG_WAVSEQ2 0x08
+#define AW8697_REG_WAVSEQ3 0x09
+#define AW8697_REG_WAVSEQ4 0x0a
+#define AW8697_REG_WAVSEQ5 0x0b
+#define AW8697_REG_WAVSEQ6 0x0c
+#define AW8697_REG_WAVSEQ7 0x0d
+#define AW8697_REG_WAVSEQ8 0x0e
+#define AW8697_REG_WAVLOOP1 0x0f
+#define AW8697_REG_WAVLOOP2 0x10
+#define AW8697_REG_WAVLOOP3 0x11
+#define AW8697_REG_WAVLOOP4 0x12
+#define AW8697_REG_MAIN_LOOP 0x13
+#define AW8697_REG_TRG1_WAV_P 0x14
+#define AW8697_REG_TRG2_WAV_P 0x15
+#define AW8697_REG_TRG3_WAV_P 0x16
+#define AW8697_REG_TRG1_WAV_N 0x17
+#define AW8697_REG_TRG2_WAV_N 0x18
+#define AW8697_REG_TRG3_WAV_N 0x19
+#define AW8697_REG_TRG_PRIO 0x1a
+#define AW8697_REG_TRG_CFG1 0x1b
+#define AW8697_REG_TRG_CFG2 0x1c
+#define AW8697_REG_DBGCTRL 0x20
+#define AW8697_REG_BASE_ADDRH 0x21
+#define AW8697_REG_BASE_ADDRL 0x22
+#define AW8697_REG_FIFO_AEH 0x23
+#define AW8697_REG_FIFO_AEL 0x24
+#define AW8697_REG_FIFO_AFH 0x25
+#define AW8697_REG_FIFO_AFL 0x26
+#define AW8697_REG_WAKE_DLY 0x27
+#define AW8697_REG_START_DLY 0x28
+#define AW8697_REG_END_DLY_H 0x29
+#define AW8697_REG_END_DLY_L 0x2a
+#define AW8697_REG_DATCTRL 0x2b
+#define AW8697_REG_PWMDEL 0x2c
+#define AW8697_REG_PWMPRC 0x2d
+#define AW8697_REG_PWMDBG 0x2e
+#define AW8697_REG_LDOCTRL 0x2f
+#define AW8697_REG_DBGSTAT 0x30
+#define AW8697_REG_BSTDBG1 0x31
+#define AW8697_REG_BSTDBG2 0x32
+#define AW8697_REG_BSTDBG3 0x33
+#define AW8697_REG_BSTCFG 0x34
+#define AW8697_REG_ANADBG 0x35
+#define AW8697_REG_ANACTRL 0x36
+#define AW8697_REG_CPDBG 0x37
+#define AW8697_REG_GLBDBG 0x38
+#define AW8697_REG_DATDBG 0x39
+#define AW8697_REG_BSTDBG4 0x3a
+#define AW8697_REG_BSTDBG5 0x3b
+#define AW8697_REG_BSTDBG6 0x3c
+#define AW8697_REG_HDRVDBG 0x3d
+#define AW8697_REG_PRLVL 0x3e
+#define AW8697_REG_PRTIME 0x3f
+#define AW8697_REG_RAMADDRH 0x40
+#define AW8697_REG_RAMADDRL 0x41
+#define AW8697_REG_RAMDATA 0x42
+#define AW8697_REG_GLB_STATE 0x46
+#define AW8697_REG_BST_AUTO 0x47
+#define AW8697_REG_CONT_CTRL 0x48
+#define AW8697_REG_F_PRE_H 0x49
+#define AW8697_REG_F_PRE_L 0x4a
+#define AW8697_REG_TD_H 0x4b
+#define AW8697_REG_TD_L 0x4c
+#define AW8697_REG_TSET 0x4d
+#define AW8697_REG_TRIM_LRA 0x5b
+#define AW8697_REG_R_SPARE 0x5d
+#define AW8697_REG_D2SCFG 0x5e
+#define AW8697_REG_DETCTRL 0x5f
+#define AW8697_REG_RLDET 0x60
+#define AW8697_REG_OSDET 0x61
+#define AW8697_REG_VBATDET 0x62
+#define AW8697_REG_TESTDET 0x63
+#define AW8697_REG_DETLO 0x64
+#define AW8697_REG_BEMFDBG 0x65
+#define AW8697_REG_ADCTEST 0x66
+#define AW8697_REG_BEMFTEST 0x67
+#define AW8697_REG_F_LRA_F0_H 0x68
+#define AW8697_REG_F_LRA_F0_L 0x69
+#define AW8697_REG_F_LRA_CONT_H 0x6a
+#define AW8697_REG_F_LRA_CONT_L 0x6b
+#define AW8697_REG_WAIT_VOL_MP 0x6d
+#define AW8697_REG_WAIT_VOL_MN 0x6f
+#define AW8697_REG_BEMF_VOL_H 0x70
+#define AW8697_REG_BEMF_VOL_L 0x71
+#define AW8697_REG_ZC_THRSH_H 0x72
+#define AW8697_REG_ZC_THRSH_L 0x73
+#define AW8697_REG_BEMF_VTHH_H 0x74
+#define AW8697_REG_BEMF_VTHH_L 0x75
+#define AW8697_REG_BEMF_VTHL_H 0x76
+#define AW8697_REG_BEMF_VTHL_L 0x77
+#define AW8697_REG_BEMF_NUM 0x78
+#define AW8697_REG_DRV_TIME 0x79
+#define AW8697_REG_TIME_NZC 0x7a
+#define AW8697_REG_DRV_LVL 0x7b
+#define AW8697_REG_DRV_LVL_OV 0x7c
+#define AW8697_REG_NUM_F0_1 0x7d
+#define AW8697_REG_NUM_F0_2 0x7e
+#define AW8697_REG_NUM_F0_3 0x7f
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define REG_NONE_ACCESS 0
+#define REG_RD_ACCESS (1 << 0)
+#define REG_WR_ACCESS (1 << 1)
+#define AW8697_REG_MAX 0xff
+
+const unsigned char aw8697_reg_access[AW8697_REG_MAX] = {
+	[AW8697_REG_ID] = REG_RD_ACCESS,
+	[AW8697_REG_SYSST] = REG_RD_ACCESS,
+	[AW8697_REG_SYSINT] = REG_RD_ACCESS,
+	[AW8697_REG_SYSINTM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_SYSCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_GO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_RTP_DATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVSEQ8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVLOOP1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVLOOP2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVLOOP3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAVLOOP4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_MAIN_LOOP] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG1_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG2_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG3_WAV_P] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG1_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG2_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG3_WAV_N] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG_PRIO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG_CFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRG_CFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DBGCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BASE_ADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BASE_ADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_FIFO_AEH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_FIFO_AEL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_FIFO_AFH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_FIFO_AFL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAKE_DLY] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_START_DLY] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_END_DLY_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_END_DLY_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DATCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_PWMDEL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_PWMPRC] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_PWMDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_LDOCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DBGSTAT] = REG_RD_ACCESS,
+	[AW8697_REG_BSTDBG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTDBG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTDBG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTCFG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_ANADBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_ANACTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_CPDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_GLBDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DATDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTDBG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTDBG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BSTDBG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_HDRVDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_PRLVL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_PRTIME] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_RAMADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_RAMADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_RAMDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_GLB_STATE] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BST_AUTO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_CONT_CTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_PRE_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_PRE_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TD_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TD_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TSET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TRIM_LRA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_R_SPARE] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_D2SCFG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DETCTRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_RLDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_OSDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_VBATDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TESTDET] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DETLO] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMFDBG] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_ADCTEST] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMFTEST] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_LRA_F0_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_LRA_F0_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_LRA_CONT_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_F_LRA_CONT_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAIT_VOL_MP] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_WAIT_VOL_MN] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VOL_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VOL_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_ZC_THRSH_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_ZC_THRSH_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VTHH_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VTHH_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VTHL_H] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_VTHL_L] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_BEMF_NUM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DRV_TIME] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_TIME_NZC] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DRV_LVL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_DRV_LVL_OV] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_NUM_F0_1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_NUM_F0_2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW8697_REG_NUM_F0_3] = REG_RD_ACCESS | REG_WR_ACCESS,
+};
+
+/******************************************************
+ * Register Detail
+ *****************************************************/
+/* SYSST: reg0x01 */
+#define AW8697_BIT_SYSST_BSTERRS (1 << 7)
+#define AW8697_BIT_SYSST_OVS (1 << 6)
+#define AW8697_BIT_SYSST_UVLS (1 << 5)
+#define AW8697_BIT_SYSST_FF_AES (1 << 4)
+#define AW8697_BIT_SYSST_FF_AFS (1 << 3)
+#define AW8697_BIT_SYSST_OCDS (1 << 2)
+#define AW8697_BIT_SYSST_OTS (1 << 1)
+#define AW8697_BIT_SYSST_DONES (1 << 0)
+
+/* SYSINT: reg0x02 */
+#define AW8697_BIT_SYSINT_BSTERRI (1 << 7)
+#define AW8697_BIT_SYSINT_OVI (1 << 6)
+#define AW8697_BIT_SYSINT_UVLI (1 << 5)
+#define AW8697_BIT_SYSINT_FF_AEI (1 << 4)
+#define AW8697_BIT_SYSINT_FF_AFI (1 << 3)
+#define AW8697_BIT_SYSINT_OCDI (1 << 2)
+#define AW8697_BIT_SYSINT_OTI (1 << 1)
+#define AW8697_BIT_SYSINT_DONEI (1 << 0)
+
+/* SYSINTM: reg0x03 */
+#define AW8697_BIT_SYSINTM_BSTERR_MASK (~(1 << 7))
+#define AW8697_BIT_SYSINTM_BSTERR_OFF (1 << 7)
+#define AW8697_BIT_SYSINTM_BSTERR_EN (0 << 7)
+#define AW8697_BIT_SYSINTM_OV_MASK (~(1 << 6))
+#define AW8697_BIT_SYSINTM_OV_OFF (1 << 6)
+#define AW8697_BIT_SYSINTM_OV_EN (0 << 6)
+#define AW8697_BIT_SYSINTM_UVLO_MASK (~(1 << 5))
+#define AW8697_BIT_SYSINTM_UVLO_OFF (1 << 5)
+#define AW8697_BIT_SYSINTM_UVLO_EN (0 << 5)
+#define AW8697_BIT_SYSINTM_FF_AE_MASK (~(1 << 4))
+#define AW8697_BIT_SYSINTM_FF_AE_OFF (1 << 4)
+#define AW8697_BIT_SYSINTM_FF_AE_EN (0 << 4)
+#define AW8697_BIT_SYSINTM_FF_AF_MASK (~(1 << 3))
+#define AW8697_BIT_SYSINTM_FF_AF_OFF (1 << 3)
+#define AW8697_BIT_SYSINTM_FF_AF_EN (0 << 3)
+#define AW8697_BIT_SYSINTM_OCD_MASK (~(1 << 2))
+#define AW8697_BIT_SYSINTM_OCD_OFF (1 << 2)
+#define AW8697_BIT_SYSINTM_OCD_EN (0 << 2)
+#define AW8697_BIT_SYSINTM_OT_MASK (~(1 << 1))
+#define AW8697_BIT_SYSINTM_OT_OFF (1 << 1)
+#define AW8697_BIT_SYSINTM_OT_EN (0 << 1)
+#define AW8697_BIT_SYSINTM_DONE_MASK (~(1 << 0))
+#define AW8697_BIT_SYSINTM_DONE_OFF (1 << 0)
+#define AW8697_BIT_SYSINTM_DONE_EN (0 << 0)
+
+/* SYSCTRL: reg0x04 */
+#define AW8697_BIT_SYSCTRL_WAVDAT_MODE_MASK (~(3 << 6))
+#define AW8697_BIT_SYSCTRL_WAVDAT_MODE_4X (3 << 6)
+#define AW8697_BIT_SYSCTRL_WAVDAT_MODE_2X (0 << 6)
+#define AW8697_BIT_SYSCTRL_WAVDAT_MODE_1X (1 << 6)
+#define AW8697_BIT_SYSCTRL_RAMINIT_MASK (~(1 << 5))
+#define AW8697_BIT_SYSCTRL_RAMINIT_EN (1 << 5)
+#define AW8697_BIT_SYSCTRL_RAMINIT_OFF (0 << 5)
+#define AW8697_BIT_SYSCTRL_PLAY_MODE_MASK (~(3 << 2))
+#define AW8697_BIT_SYSCTRL_PLAY_MODE_CONT (2 << 2)
+#define AW8697_BIT_SYSCTRL_PLAY_MODE_RTP (1 << 2)
+#define AW8697_BIT_SYSCTRL_PLAY_MODE_RAM (0 << 2)
+#define AW8697_BIT_SYSCTRL_BST_MODE_MASK (~(1 << 1))
+#define AW8697_BIT_SYSCTRL_BST_MODE_BOOST (1 << 1)
+#define AW8697_BIT_SYSCTRL_BST_MODE_BYPASS (0 << 1)
+#define AW8697_BIT_SYSCTRL_WORK_MODE_MASK (~(1 << 0))
+#define AW8697_BIT_SYSCTRL_STANDBY (1 << 0)
+#define AW8697_BIT_SYSCTRL_ACTIVE (0 << 0)
+
+/* GO: reg0x05 */
+#define AW8697_BIT_GO_MASK (~(1 << 0))
+#define AW8697_BIT_GO_ENABLE (1 << 0)
+#define AW8697_BIT_GO_DISABLE (0 << 0)
+
+/* WAVSEQ1: reg0x07 */
+#define AW8697_BIT_WAVSEQ1_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ1_WAV_FRM_SEQ1_MASK (~(127 << 0))
+
+/* WAVSEQ2: reg0x08 */
+#define AW8697_BIT_WAVSEQ2_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ2_WAV_FRM_SEQ2_MASK (~(127 << 0))
+
+/* WAVSEQ3: reg0x09 */
+#define AW8697_BIT_WAVSEQ3_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ3_WAV_FRM_SEQ3_MASK (~(127 << 0))
+
+/* WAVSEQ4: reg0x0a */
+#define AW8697_BIT_WAVSEQ4_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ4_WAV_FRM_SEQ4_MASK (~(127 << 0))
+
+/* WAVSEQ5: reg0x0b */
+#define AW8697_BIT_WAVSEQ5_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ5_WAV_FRM_SEQ5_MASK (~(127 << 0))
+
+/* WAVSEQ6: reg0x0c */
+#define AW8697_BIT_WAVSEQ6_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ6_WAV_FRM_SEQ6_MASK (~(127 << 0))
+
+/* WAVSEQ7: reg0x0d */
+#define AW8697_BIT_WAVSEQ7_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ7_WAV_FRM_SEQ7_MASK (~(127 << 0))
+
+/* WAVSEQ8: reg0x0e */
+#define AW8697_BIT_WAVSEQ8_WAIT (1 << 7)
+#define AW8697_BIT_WAVSEQ8_WAV_FRM_SEQ8_MASK (~(127 << 0))
+
+/* WAVLOOP: */
+#define AW8697_BIT_WAVLOOP_SEQN_MASK (~(15 << 4))
+#define AW8697_BIT_WAVLOOP_SEQNP1_MASK (~(15 << 0))
+#define AW8697_BIT_WAVLOOP_INIFINITELY (15 << 0)
+
+/* WAVLOOP1: reg0x0f */
+#define AW8697_BIT_WAVLOOP1_SEQ1_MASK (~(15 << 4))
+#define AW8697_BIT_WAVLOOP1_SEQ2_MASK (~(15 << 0))
+
+/* WAVLOOP2: reg0x10 */
+#define AW8697_BIT_WAVLOOP2_SEQ3_MASK (~(15 << 4))
+#define AW8697_BIT_WAVLOOP2_SEQ4_MASK (~(15 << 0))
+
+/* WAVLOOP3: reg0x11 */
+#define AW8697_BIT_WAVLOOP3_SEQ5_MASK (~(15 << 4))
+#define AW8697_BIT_WAVLOOP3_SEQ6_MASK (~(15 << 0))
+
+/* WAVLOOP4: reg0x12 */
+#define AW8697_BIT_WAVLOOP4_SEQ7_MASK (~(15 << 4))
+#define AW8697_BIT_WAVLOOP4_SEQ8_MASK (~(15 << 0))
+
+/* PLAYPRIO: reg0x1a */
+#define AW8697_BIT_PLAYPRIO_GO_MASK (~(3 << 6))
+#define AW8697_BIT_PLAYPRIO_TRIG3_MASK (~(3 << 4))
+#define AW8697_BIT_PLAYPRIO_TRIG2_MASK (~(3 << 2))
+#define AW8697_BIT_PLAYPRIO_TRIG1_MASK (~(3 << 0))
+
+/* TRGCFG1: reg0x1b */
+#define AW8697_BIT_TRGCFG1_TRG3_POLAR_MASK (~(1 << 5))
+#define AW8697_BIT_TRGCFG1_TRG3_POLAR_NEG (1 << 5)
+#define AW8697_BIT_TRGCFG1_TRG3_POLAR_POS (0 << 5)
+#define AW8697_BIT_TRGCFG1_TRG3_EDGE_MASK (~(1 << 4))
+#define AW8697_BIT_TRGCFG1_TRG3_EDGE_POS (1 << 4)
+#define AW8697_BIT_TRGCFG1_TRG3_EDGE_POS_NEG (0 << 4)
+#define AW8697_BIT_TRGCFG1_TRG2_POLAR_MASK (~(1 << 3))
+#define AW8697_BIT_TRGCFG1_TRG2_POLAR_NEG (1 << 3)
+#define AW8697_BIT_TRGCFG1_TRG2_POLAR_POS (0 << 3)
+#define AW8697_BIT_TRGCFG1_TRG2_EDGE_MASK (~(1 << 2))
+#define AW8697_BIT_TRGCFG1_TRG2_EDGE_POS (1 << 2)
+#define AW8697_BIT_TRGCFG1_TRG2_EDGE_POS_NEG (0 << 2)
+#define AW8697_BIT_TRGCFG1_TRG1_POLAR_MASK (~(1 << 1))
+#define AW8697_BIT_TRGCFG1_TRG1_POLAR_NEG (1 << 1)
+#define AW8697_BIT_TRGCFG1_TRG1_POLAR_POS (0 << 1)
+#define AW8697_BIT_TRGCFG1_TRG1_EDGE_MASK (~(1 << 0))
+#define AW8697_BIT_TRGCFG1_TRG1_EDGE_POS (1 << 0)
+#define AW8697_BIT_TRGCFG1_TRG1_EDGE_POS_NEG (0 << 0)
+
+/* TRGCFG2: reg0x1c */
+#define AW8697_BIT_TRGCFG2_TRG3_ENABLE_MASK (~(1 << 2))
+#define AW8697_BIT_TRGCFG2_TRG3_ENABLE (1 << 2)
+#define AW8697_BIT_TRGCFG2_TRG3_DISABLE (0 << 2)
+#define AW8697_BIT_TRGCFG2_TRG2_ENABLE_MASK (~(1 << 1))
+#define AW8697_BIT_TRGCFG2_TRG2_ENABLE (1 << 1)
+#define AW8697_BIT_TRGCFG2_TRG2_DISABLE (0 << 1)
+#define AW8697_BIT_TRGCFG2_TRG1_ENABLE_MASK (~(1 << 0))
+#define AW8697_BIT_TRGCFG2_TRG1_ENABLE (1 << 0)
+#define AW8697_BIT_TRGCFG2_TRG1_DISABLE (0 << 0)
+
+/* DBGCTRL: reg0x20 */
+#define AW8697_BIT_DBGCTRL_INT_EDGE_MODE_MASK (~(1 << 3))
+#define AW8697_BIT_DBGCTRL_INT_EDGE_MODE_POS (1 << 3)
+#define AW8697_BIT_DBGCTRL_INT_EDGE_MODE_BOTH (0 << 3)
+#define AW8697_BIT_DBGCTRL_INT_MODE_MASK (~(1 << 2))
+#define AW8697_BIT_DBGCTRL_INT_MODE_EDGE (1 << 2)
+#define AW8697_BIT_DBGCTRL_INT_MODE_LEVEL (0 << 2)
+
+/* DATCTRL: reg0x2b */
+#define AW8697_BIT_DATCTRL_FC_MASK (~(1 << 6))
+#define AW8697_BIT_DATCTRL_FC_1000HZ (3 << 6)
+#define AW8697_BIT_DATCTRL_FC_800HZ (3 << 6)
+#define AW8697_BIT_DATCTRL_FC_600HZ (1 << 6)
+#define AW8697_BIT_DATCTRL_FC_400HZ (0 << 6)
+#define AW8697_BIT_DATCTRL_LPF_ENABLE_MASK (~(1 << 5))
+#define AW8697_BIT_DATCTRL_LPF_ENABLE (1 << 5)
+#define AW8697_BIT_DATCTRL_LPF_DISABLE (0 << 5)
+#define AW8697_BIT_DATCTRL_WAKEMODE_ENABLE_MASK (~(1 << 0))
+#define AW8697_BIT_DATCTRL_WAKEMODE_ENABLE (1 << 0)
+#define AW8697_BIT_DATCTRL_WAKEMODE_DISABLE (0 << 0)
+
+/* PWMPRC: reg0x2d */
+#define AW8697_BIT_PWMPRC_PRC_MASK (~(1 << 7))
+#define AW8697_BIT_PWMPRC_PRC_ENABLE (1 << 7)
+#define AW8697_BIT_PWMPRC_PRC_DISABLE (0 << 7)
+#define AW8697_BIT_PWMPRC_PRCTIME_MASK (~(0x7f << 0))
+
+/* PWMDBG: reg0x2e */
+#define AW8697_BIT_PWMDBG_PWM_MODE_MASK (~(3 << 5))
+#define AW8697_BIT_PWMDBG_PWM_12K (3 << 5)
+#define AW8697_BIT_PWMDBG_PWM_24K (2 << 5)
+#define AW8697_BIT_PWMDBG_PWM_48K (0 << 5)
+
+/* DBGST: reg0x30 */
+#define AW8697_BIT_DBGSTAT_FF_EMPTY (1 << 0)
+/* BSTCFG: reg0x34 */
+#define AW8697_BIT_BSTCFG_PEAKCUR_MASK (~(7 << 0))
+#define AW8697_BIT_BSTCFG_PEAKCUR_4A (7 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_3P75A (6 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_3P5A (5 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_3P25A (4 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_3A (3 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_2P5A (2 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_2A (1 << 0)
+#define AW8697_BIT_BSTCFG_PEAKCUR_1P5A (0 << 0)
+
+/* ANADBG: reg0x35 */
+#define AW8697_BIT_ANADBG_IOC_MASK (~(3 << 2))
+#define AW8697_BIT_ANADBG_IOC_4P65A (3 << 2)
+#define AW8697_BIT_ANADBG_IOC_4P15A (2 << 2)
+#define AW8697_BIT_ANADBG_IOC_3P65A (1 << 2)
+#define AW8697_BIT_ANADBG_IOC_3P15A (0 << 2)
+
+/* ANACTRL: reg0x36 */
+#define AW8697_BIT_ANACTRL_LRA_SRC_MASK (~(1 << 5))
+#define AW8697_BIT_ANACTRL_LRA_SRC_REG (1 << 5)
+#define AW8697_BIT_ANACTRL_LRA_SRC_EFUSE (0 << 5)
+#define AW8697_BIT_ANACTRL_HD_PD_MASK (~(1 << 3))
+#define AW8697_BIT_ANACTRL_HD_PD_EN (1 << 3)
+#define AW8697_BIT_ANACTRL_HD_HZ_EN (0 << 3)
+
+/* BSTDBG4: reg0x3a */
+#define AW8697_BIT_BSTDBG4_BSTVOL_MASK (~(31 << 1))
+
+/* PRLVL: reg0x3e */
+#define AW8697_BIT_PRLVL_PR_MASK (~(1 << 7))
+#define AW8697_BIT_PRLVL_PR_ENABLE (1 << 7)
+#define AW8697_BIT_PRLVL_PR_DISABLE (0 << 7)
+#define AW8697_BIT_PRLVL_PRLVL_MASK (~(0x7f << 0))
+
+/*PRTIME: reg0x3f */
+#define AW8697_BIT_PRTIME_PRTIME_MASK (~(0xff << 0))
+
+/* BST_AUTO: reg0x47 */
+#define AW8697_BIT_BST_AUTO_BST_AUTOSW_MASK (~(1 << 2))
+#define AW8697_BIT_BST_AUTO_BST_AUTOMATIC_BOOST (1 << 2)
+#define AW8697_BIT_BST_AUTO_BST_MANUAL_BOOST (0 << 2)
+#define AW8697_BIT_BST_AUTO_BST_RTP_MASK (~(1 << 1))
+#define AW8697_BIT_BST_AUTO_BST_RTP_ENABLE (1 << 1)
+#define AW8697_BIT_BST_AUTO_BST_RTP_DISABLE (0 << 1)
+#define AW8697_BIT_BST_AUTO_BST_RAM_MASK (~(1 << 0))
+#define AW8697_BIT_BST_AUTO_BST_RAM_ENABLE (1 << 0)
+#define AW8697_BIT_BST_AUTO_BST_RAM_DISABLE (0 << 0)
+
+/* CONT_CTRL: reg0x48 */
+#define AW8697_BIT_CONT_CTRL_ZC_DETEC_MASK (~(1 << 7))
+#define AW8697_BIT_CONT_CTRL_ZC_DETEC_ENABLE (1 << 7)
+#define AW8697_BIT_CONT_CTRL_ZC_DETEC_DISABLE (0 << 7)
+#define AW8697_BIT_CONT_CTRL_WAIT_PERIOD_MASK (~(3 << 5))
+#define AW8697_BIT_CONT_CTRL_WAIT_8PERIOD (3 << 5)
+#define AW8697_BIT_CONT_CTRL_WAIT_4PERIOD (2 << 5)
+#define AW8697_BIT_CONT_CTRL_WAIT_2PERIOD (1 << 5)
+#define AW8697_BIT_CONT_CTRL_WAIT_1PERIOD (0 << 5)
+#define AW8697_BIT_CONT_CTRL_MODE_MASK (~(1 << 4))
+#define AW8697_BIT_CONT_CTRL_BY_DRV_TIME (1 << 4)
+#define AW8697_BIT_CONT_CTRL_BY_GO_SIGNAL (0 << 4)
+#define AW8697_BIT_CONT_CTRL_EN_CLOSE_MASK (~(1 << 3))
+#define AW8697_BIT_CONT_CTRL_CLOSE_PLAYBACK (1 << 3)
+#define AW8697_BIT_CONT_CTRL_OPEN_PLAYBACK (0 << 3)
+#define AW8697_BIT_CONT_CTRL_F0_DETECT_MASK (~(1 << 2))
+#define AW8697_BIT_CONT_CTRL_F0_DETECT_ENABLE (1 << 2)
+#define AW8697_BIT_CONT_CTRL_F0_DETECT_DISABLE (0 << 2)
+#define AW8697_BIT_CONT_CTRL_O2C_MASK (~(1 << 1))
+#define AW8697_BIT_CONT_CTRL_O2C_ENABLE (1 << 1)
+#define AW8697_BIT_CONT_CTRL_O2C_DISABLE (0 << 1)
+#define AW8697_BIT_CONT_CTRL_AUTO_BRK_MASK (~(1 << 0))
+#define AW8697_BIT_CONT_CTRL_AUTO_BRK_ENABLE (1 << 0)
+#define AW8697_BIT_CONT_CTRL_AUTO_BRK_DISABLE (0 << 0)
+
+/* D2SCFG: reg0x5e */
+#define AW8697_BIT_D2SCFG_CLK_ADC_MASK (~(7 << 5))
+#define AW8697_BIT_D2SCFG_CLK_ASC_0P09375MHZ (7 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_0P1875MHZ (6 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_0P375MHZ (5 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_0P75MHZ (4 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_1P5MHZ (3 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_3MHZ (2 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_6MHZ (1 << 5)
+#define AW8697_BIT_D2SCFG_CLK_ASC_12MHZ (0 << 5)
+
+/* DETCTRL: reg0x5f */
+#define AW8697_BIT_DETCTRL_RL_OS_MASK (~(1 << 6))
+#define AW8697_BIT_DETCTRL_RL_DETECT (1 << 6)
+#define AW8697_BIT_DETCTRL_OS_DETECT (0 << 6)
+#define AW8697_BIT_DETCTRL_PROTECT_MASK (~(1 << 5))
+#define AW8697_BIT_DETCTRL_PROTECT_NO_ACTION (1 << 5)
+#define AW8697_BIT_DETCTRL_PROTECT_SHUTDOWN (0 << 5)
+#define AW8697_BIT_DETCTRL_ADO_SLOT_MODE_MASK (~(1 << 4))
+#define AW8697_BIT_DETCTRL_ADO_SLOT_MODE_ENABLE (1 << 4)
+#define AW8697_BIT_DETCTRL_ADO_SLOT_MODE_DISABLE (0 << 4)
+#define AW8697_BIT_DETCTRL_VBAT_GO_MASK (~(1 << 1))
+#define AW8697_BIT_DETCTRL_VABT_GO_ENABLE (1 << 1)
+#define AW8697_BIT_DETCTRL_VBAT_GO_DISBALE (0 << 1)
+#define AW8697_BIT_DETCTRL_DIAG_GO_MASK (~(1 << 0))
+#define AW8697_BIT_DETCTRL_DIAG_GO_ENABLE (1 << 0)
+#define AW8697_BIT_DETCTRL_DIAG_GO_DISABLE (0 << 0)
+
+/* ADCTEST: reg0x66 */
+#define AW8697_BIT_ADCTEST_VBAT_MODE_MASK (~(1 << 6))
+#define AW8697_BIT_ADCTEST_VBAT_HW_COMP (1 << 6)
+#define AW8697_BIT_ADCTEST_VBAT_SW_COMP (0 << 6)
+
+/* BEMF_NUM: reg0x78 */
+#define AW8697_BIT_BEMF_NUM_BRK_MASK (~(15 << 0))
+
+#endif
diff --git a/drivers/input/misc/aw8697_haptic/aw869xx_reg.h b/drivers/input/misc/aw8697_haptic/aw869xx_reg.h
new file mode 100644
index 000000000000..dd13a1373bae
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/aw869xx_reg.h
@@ -0,0 +1,907 @@
+#ifndef _AW869XX_REG_H_
+#define _AW869XX_REG_H_
+
+/********************************************
+ * Register List
+ *******************************************/
+
+#define AW869XX_REG_ID 0x00
+#define AW869XX_REG_SYSST 0x01
+#define AW869XX_REG_SYSINT 0x02
+#define AW869XX_REG_SYSINTM 0x03
+#define AW869XX_REG_SYSST2 0x04
+#define AW869XX_REG_SYSER 0x05
+#define AW869XX_REG_PLAYCFG1 0x06
+#define AW869XX_REG_PLAYCFG2 0x07
+#define AW869XX_REG_PLAYCFG3 0x08
+#define AW869XX_REG_PLAYCFG4 0x09
+#define AW869XX_REG_WAVCFG1 0x0A
+#define AW869XX_REG_WAVCFG2 0x0B
+#define AW869XX_REG_WAVCFG3 0x0C
+#define AW869XX_REG_WAVCFG4 0x0D
+#define AW869XX_REG_WAVCFG5 0x0E
+#define AW869XX_REG_WAVCFG6 0x0F
+#define AW869XX_REG_WAVCFG7 0x10
+#define AW869XX_REG_WAVCFG8 0x11
+#define AW869XX_REG_WAVCFG9 0x12
+#define AW869XX_REG_WAVCFG10 0x13
+#define AW869XX_REG_WAVCFG11 0x14
+#define AW869XX_REG_WAVCFG12 0x15
+#define AW869XX_REG_WAVCFG13 0x16
+#define AW869XX_REG_WAVCFG14 0x17
+#define AW869XX_REG_CONTCFG1 0x18
+#define AW869XX_REG_CONTCFG2 0x19
+#define AW869XX_REG_CONTCFG3 0x1A
+#define AW869XX_REG_CONTCFG4 0x1B
+#define AW869XX_REG_CONTCFG5 0x1C
+#define AW869XX_REG_CONTCFG6 0x1D
+#define AW869XX_REG_CONTCFG7 0x1E
+#define AW869XX_REG_CONTCFG8 0x1F
+#define AW869XX_REG_CONTCFG9 0x20
+#define AW869XX_REG_CONTCFG10 0x21
+#define AW869XX_REG_CONTCFG11 0x22
+#define AW869XX_REG_CONTCFG12 0x23
+#define AW869XX_REG_CONTCFG13 0x24
+#define AW869XX_REG_CONTRD14 0x25
+#define AW869XX_REG_CONTRD15 0x26
+#define AW869XX_REG_CONTRD16 0x27
+#define AW869XX_REG_CONTRD17 0x28
+#define AW869XX_REG_CONTRD18 0x29
+#define AW869XX_REG_CONTRD19 0x2A
+#define AW869XX_REG_CONTRD20 0x2B
+#define AW869XX_REG_CONTRD21 0x2C
+#define AW869XX_REG_RTPCFG1 0x2D
+#define AW869XX_REG_RTPCFG2 0x2E
+#define AW869XX_REG_RTPCFG3 0x2F
+#define AW869XX_REG_RTPCFG4 0x30
+#define AW869XX_REG_RTPCFG5 0x31
+#define AW869XX_REG_RTPDATA 0x32
+#define AW869XX_REG_TRGCFG1 0x33
+#define AW869XX_REG_TRGCFG2 0x34
+#define AW869XX_REG_TRGCFG3 0x35
+#define AW869XX_REG_TRGCFG4 0x36
+#define AW869XX_REG_TRGCFG5 0x37
+#define AW869XX_REG_TRGCFG6 0x38
+#define AW869XX_REG_TRGCFG7 0x39
+#define AW869XX_REG_TRGCFG8 0x3A
+#define AW869XX_REG_GLBCFG1 0x3B
+#define AW869XX_REG_GLBCFG2 0x3C
+#define AW869XX_REG_GLBCFG3 0x3D
+#define AW869XX_REG_GLBCFG4 0x3E
+#define AW869XX_REG_GLBRD5 0x3F
+#define AW869XX_REG_RAMADDRH 0x40
+#define AW869XX_REG_RAMADDRL 0x41
+#define AW869XX_REG_RAMDATA 0x42
+#define AW869XX_REG_SYSCTRL1 0x43
+#define AW869XX_REG_SYSCTRL2 0x44
+#define AW869XX_REG_SYSCTRL3 0x45
+#define AW869XX_REG_SYSCTRL4 0x46
+#define AW869XX_REG_SYSCTRL5 0x47
+#define AW869XX_REG_SYSCTRL6 0x48
+#define AW869XX_REG_SYSCTRL7 0x49
+#define AW869XX_REG_I2SCFG1 0x4A
+#define AW869XX_REG_I2SCFG2 0x4B
+#define AW869XX_REG_PWMCFG1 0x4C
+#define AW869XX_REG_PWMCFG2 0x4D
+#define AW869XX_REG_PWMCFG3 0x4E
+#define AW869XX_REG_PWMCFG4 0x4F
+#define AW869XX_REG_TMCFG 0x50
+#define AW869XX_REG_DETCFG1 0x51
+#define AW869XX_REG_DETCFG2 0x52
+#define AW869XX_REG_DET_RL 0x53
+#define AW869XX_REG_DET_OS 0x54
+#define AW869XX_REG_DET_VBAT 0x55
+#define AW869XX_REG_DET_TEST 0x56
+#define AW869XX_REG_DET_LO 0x57
+#define AW869XX_REG_TRIMCFG1 0x58
+#define AW869XX_REG_TRIMCFG2 0x59
+#define AW869XX_REG_TRIMCFG3 0x5A
+#define AW869XX_REG_TRIMCFG4 0x5B
+#define AW869XX_REG_PLLCFG1 0x68
+#define AW869XX_REG_PLLCFG2 0x69
+#define AW869XX_REG_HDRVCFG1 0x6A
+#define AW869XX_REG_IOCFG1 0x6B
+#define AW869XX_REG_BEMFCFG1 0x6C
+#define AW869XX_REG_BSTCFG1 0x6D
+#define AW869XX_REG_BSTCFG2 0x6E
+#define AW869XX_REG_BSTCFG3 0x6F
+#define AW869XX_REG_BSTCFG4 0x70
+#define AW869XX_REG_BSTCFG5 0x71
+#define AW869XX_REG_CPCFG1 0x72
+#define AW869XX_REG_LDOCFG1 0x73
+#define AW869XX_REG_OCCFG1 0x74
+#define AW869XX_REG_ADCCFG1 0x75
+#define AW869XX_REG_D2SCFG1 0x76
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define REG_NONE_ACCESS 0
+#define REG_RD_ACCESS (1 << 0)
+#define REG_WR_ACCESS (1 << 1)
+#define AW869XX_REG_MAX 0xff
+
+const unsigned char aw869xx_reg_access[AW869XX_REG_MAX] = {
+	[AW869XX_REG_ID] = REG_RD_ACCESS,
+	[AW869XX_REG_SYSST] = REG_RD_ACCESS,
+	[AW869XX_REG_SYSINT] = REG_RD_ACCESS,
+	[AW869XX_REG_SYSINTM] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSST2] = REG_RD_ACCESS,
+	[AW869XX_REG_SYSER] = REG_RD_ACCESS,
+	[AW869XX_REG_PLAYCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PLAYCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PLAYCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PLAYCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG9] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG10] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG11] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG12] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG13] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_WAVCFG14] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG9] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG10] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG11] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG12] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTCFG13] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CONTRD14] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD15] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD16] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD17] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD18] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD19] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD20] = REG_RD_ACCESS,
+	[AW869XX_REG_CONTRD21] = REG_RD_ACCESS,
+	[AW869XX_REG_RTPCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RTPCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RTPCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RTPCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RTPCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RTPDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRGCFG8] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_GLBCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_GLBCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_GLBCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_GLBCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_GLBRD5] = REG_RD_ACCESS,
+	[AW869XX_REG_RAMADDRH] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RAMADDRL] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_RAMDATA] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL6] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_SYSCTRL7] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_I2SCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_I2SCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PWMCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PWMCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PWMCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PWMCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_DETCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_DETCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_DET_RL] = REG_RD_ACCESS,
+	[AW869XX_REG_DET_OS] = REG_RD_ACCESS,
+	[AW869XX_REG_DET_VBAT] = REG_RD_ACCESS,
+	[AW869XX_REG_DET_TEST] = REG_RD_ACCESS,
+	[AW869XX_REG_DET_LO] = REG_RD_ACCESS,
+	[AW869XX_REG_TRIMCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRIMCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRIMCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_TRIMCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PLLCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_PLLCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_HDRVCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_IOCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BEMFCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BSTCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BSTCFG2] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BSTCFG3] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BSTCFG4] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_BSTCFG5] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_CPCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_LDOCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_OCCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_ADCCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+	[AW869XX_REG_D2SCFG1] = REG_RD_ACCESS | REG_WR_ACCESS,
+
+};
+
+/******************************************************
+ * Register Detail
+ *****************************************************/
+/* SYSST: reg 0x01 RO */
+#define AW869XX_BIT_SYSST_BST_SCPS (1 << 7)
+#define AW869XX_BIT_SYSST_BST_OVPS (1 << 6)
+#define AW869XX_BIT_SYSST_UVLS (1 << 5)
+#define AW869XX_BIT_SYSST_FF_AES (1 << 4)
+#define AW869XX_BIT_SYSST_FF_AFS (1 << 3)
+#define AW869XX_BIT_SYSST_OCDS (1 << 2)
+#define AW869XX_BIT_SYSST_OTS (1 << 1)
+#define AW869XX_BIT_SYSST_DONES (1 << 0)
+
+/* SYSINT: reg 0x02 RC */
+#define AW869XX_BIT_SYSINT_BST_SCPI (1 << 7)
+#define AW869XX_BIT_SYSINT_BST_OVPI (1 << 6)
+#define AW869XX_BIT_SYSINT_UVLI (1 << 5)
+#define AW869XX_BIT_SYSINT_FF_AEI (1 << 4)
+#define AW869XX_BIT_SYSINT_FF_AFI (1 << 3)
+#define AW869XX_BIT_SYSINT_OCDI (1 << 2)
+#define AW869XX_BIT_SYSINT_OTI (1 << 1)
+#define AW869XX_BIT_SYSINT_DONEI (1 << 0)
+
+/* SYSINTM: reg 0x03 RW */
+#define AW869XX_BIT_SYSINTM_BST_SCPM_MASK (~(1 << 7))
+#define AW869XX_BIT_SYSINTM_BST_SCPM_OFF (1 << 7)
+#define AW869XX_BIT_SYSINTM_BST_SCPM_ON (0 << 7)
+#define AW869XX_BIT_SYSINTM_BST_OVPM_MASK (~(1 << 6))
+#define AW869XX_BIT_SYSINTM_BST_OVPM_OFF (1 << 6)
+#define AW869XX_BIT_SYSINTM_BST_OVPM_ON (0 << 6)
+#define AW869XX_BIT_SYSINTM_UVLM_MASK (~(1 << 5))
+#define AW869XX_BIT_SYSINTM_UVLM_OFF (1 << 5)
+#define AW869XX_BIT_SYSINTM_UVLM_ON (0 << 5)
+#define AW869XX_BIT_SYSINTM_FF_AEM_MASK (~(1 << 4))
+#define AW869XX_BIT_SYSINTM_FF_AEM_OFF (1 << 4)
+#define AW869XX_BIT_SYSINTM_FF_AEM_ON (0 << 4)
+#define AW869XX_BIT_SYSINTM_FF_AFM_MASK (~(1 << 3))
+#define AW869XX_BIT_SYSINTM_FF_AFM_OFF (1 << 3)
+#define AW869XX_BIT_SYSINTM_FF_AFM_ON (0 << 3)
+#define AW869XX_BIT_SYSINTM_OCDM_MASK (~(1 << 2))
+#define AW869XX_BIT_SYSINTM_OCDM_OFF (1 << 2)
+#define AW869XX_BIT_SYSINTM_OCDM_ON (0 << 2)
+#define AW869XX_BIT_SYSINTM_OTM_MASK (~(1 << 1))
+#define AW869XX_BIT_SYSINTM_OTM_OFF (1 << 1)
+#define AW869XX_BIT_SYSINTM_OTM_ON (0 << 1)
+#define AW869XX_BIT_SYSINTM_DONEM_MASK (~(1 << 0))
+#define AW869XX_BIT_SYSINTM_DONEM_OFF (1 << 0)
+#define AW869XX_BIT_SYSINTM_DONEM_ON (0 << 0)
+
+/* SYSST2: reg 0x04 RO */
+#define AW869XX_BIT_SYSST2_RAM_ADDR_ER (1 << 7)
+#define AW869XX_BIT_SYSST2_TRG_ADDR_ER (1 << 6)
+#define AW869XX_BIT_SYSST2_PLL_REF_OK (1 << 5)
+#define AW869XX_BIT_SYSST2_BST_OK (1 << 4)
+#define AW869XX_BIT_SYSST2_VBG_OK (1 << 3)
+#define AW869XX_BIT_SYSST2_LDO_OK (1 << 2)
+#define AW869XX_BIT_SYSST2_FF_FULL (1 << 1)
+#define AW869XX_BIT_SYSST2_FF_EMPTY (1 << 0)
+
+/* SYSER: reg 0x05 RC */
+#define AW869XX_BIT_SYSER_I2S_ERR (1 << 7)
+#define AW869XX_BIT_SYSER_TRIG1_EVENT (1 << 6)
+#define AW869XX_BIT_SYSER_TRIG2_EVENT (1 << 5)
+#define AW869XX_BIT_SYSER_TRIG3_EVENT (1 << 4)
+#define AW869XX_BIT_SYSER_OV (1 << 3)
+#define AW869XX_BIT_SYSER_ADDR_ER (1 << 2)
+#define AW869XX_BIT_SYSER_FF_ER (1 << 1)
+#define AW869XX_BIT_SYSER_PLL_REF_ER (1 << 0)
+
+/* PLAYCFG1: reg 0x06 RW */
+#define AW869XX_BIT_PLAYCFG1_BST_MODE_MASK (~(1 << 6))
+#define AW869XX_BIT_PLAYCFG1_BST_MODE_BYPASS (0 << 6)
+#define AW869XX_BIT_PLAYCFG1_BST_MODE_BOOST (1 << 6)
+#define AW869XX_BIT_PLAYCFG1_BST_VOUT_RDA_MASK (~(63 << 0))
+
+/* PLAYCFG2: reg 0x07 RW */
+/* GAIN */
+
+/* PLAYCFG3: reg 0x08 RW */
+#define AW869XX_BIT_PLAYCFG3_AUTO_BST_MASK (~(1 << 6))
+#define AW869XX_BIT_PLAYCFG3_AUTO_BST_ENABLE (1 << 6)
+#define AW869XX_BIT_PLAYCFG3_AUTO_BST_DISABLE (0 << 6)
+#define AW869XX_BIT_PLAYCFG3_STOP_MODE_MASK (~(1 << 5))
+#define AW869XX_BIT_PLAYCFG3_STOP_MODE_NOW (1 << 5)
+#define AW869XX_BIT_PLAYCFG3_STOP_MODE_LATER (0 << 5)
+#define AW869XX_BIT_PLAYCFG3_BRK_EN_MASK (~(1 << 2))
+#define AW869XX_BIT_PLAYCFG3_BRK_ENABLE (1 << 2)
+#define AW869XX_BIT_PLAYCFG3_BRK_DISABLE (0 << 2)
+#define AW869XX_BIT_PLAYCFG3_PLAY_MODE_MASK (~(3 << 0))
+#define AW869XX_BIT_PLAYCFG3_PLAY_MODE_STOP (3 << 0)
+#define AW869XX_BIT_PLAYCFG3_PLAY_MODE_CONT (2 << 0)
+#define AW869XX_BIT_PLAYCFG3_PLAY_MODE_RTP (1 << 0)
+#define AW869XX_BIT_PLAYCFG3_PLAY_MODE_RAM (0 << 0)
+
+/* PLAYCFG4: reg 0x09 RW */
+#define AW869XX_BIT_PLAYCFG4_STOP_MASK (~(1 << 1))
+#define AW869XX_BIT_PLAYCFG4_STOP_ON (1 << 1)
+#define AW869XX_BIT_PLAYCFG4_STOP_OFF (0 << 1)
+#define AW869XX_BIT_PLAYCFG4_GO_MASK (~(1 << 0))
+#define AW869XX_BIT_PLAYCFG4_GO_ON (1 << 0)
+#define AW869XX_BIT_PLAYCFG4_GO_OFF (0 << 0)
+
+/* WAVCFG1-8: reg 0x0A - reg 0x11 RW */
+#define AW869XX_BIT_WAVCFG_SEQWAIT_MASK (~(1 << 7))
+#define AW869XX_BIT_WAVCFG_SEQWAIT_TIME (1 << 7)
+#define AW869XX_BIT_WAVCFG_SEQWAIT_NUMBER (0 << 7)
+
+/* WAVCFG9-12: reg 0x12 - reg 0x15 RW */
+#define AW869XX_BIT_WAVLOOP_SEQ_ODD_MASK (~(0x0F << 4))
+#define AW869XX_BIT_WAVLOOP_SEQ_ODD_INIFINITELY (0x0F << 4)
+#define AW869XX_BIT_WAVLOOP_SEQ_EVEN_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVLOOP_SEQ_EVEN_INIFINITELY (0x0F << 0)
+#define AW869XX_BIT_WAVLOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG9: reg 0x12 RW */
+#define AW869XX_BIT_WAVCFG9_SEQ1LOOP_MASK (~(0x0F << 4))
+#define AW869XX_BIT_WAVCFG9_SEQ1LOOP_INIFINITELY (0x0F << 4)
+#define AW869XX_BIT_WAVCFG9_SEQ2LOOP_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVCFG9_SEQ2LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG10: reg 0x13 RW */
+#define AW869XX_BIT_WAVCFG10_SEQ3LOOP_MASK (~(0x0F << 4))
+#define AW869XX_BIT_WAVCFG10_SEQ3LOOP_INIFINITELY (0x0F << 4)
+#define AW869XX_BIT_WAVCFG10_SEQ4LOOP_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVCFG10_SEQ4LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG11: reg 0x14 RW */
+#define AW869XX_BIT_WAVCFG11_SEQ5LOOP_MASK (~(0x0F << 4))
+#define AW869XX_BIT_WAVCFG11_SEQ5LOOP_INIFINITELY (0x0F << 4)
+#define AW869XX_BIT_WAVCFG11_SEQ6LOOP_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVCFG11_SEQ6LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG12: reg 0x15 RW */
+#define AW869XX_BIT_WAVCFG12_SEQ7LOOP_MASK (~(0x0F << 4))
+#define AW869XX_BIT_WAVCFG12_SEQ7LOOP_INIFINITELY (0x0F << 4)
+#define AW869XX_BIT_WAVCFG12_SEQ8LOOP_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVCFG12_SEQ8LOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG13: reg 0x16 RW */
+#define AW869XX_BIT_WAVCFG13_WAITSLOT_MASK (~(3 << 5))
+#define AW869XX_BIT_WAVCFG13_WAITSLOT_DIV_1 (0 << 5)
+#define AW869XX_BIT_WAVCFG13_WAITSLOT_DIV_8 (1 << 5)
+#define AW869XX_BIT_WAVCFG13_WAITSLOT_DIV_64 (2 << 5)
+#define AW869XX_BIT_WAVCFG13_WAITSLOT_DIV_512 (3 << 5)
+#define AW869XX_BIT_WAVCFG13_AUTO_MD_MASK (~(1 << 4))
+#define AW869XX_BIT_WAVCFG13_AUTO_MD_CONT_MODE (1 << 4)
+#define AW869XX_BIT_WAVCFG13_AUTO_MD_SIN_WAV (0 << 4)
+#define AW869XX_BIT_WAVCFG13_MAINLOOP_MASK (~(0x0F << 0))
+#define AW869XX_BIT_WAVCFG13_MAINLOOP_INIFINITELY (0x0F << 0)
+
+/* WAVCFG14: reg 0x17 RW */
+/* AUTO_WAV */
+
+/***************** CONT *****************/
+/* CONTCFG1: reg 0x18 RW */
+#define AW869XX_BIT_CONTCFG1_EDGE_FRE_MASK (~(0x0F << 4))
+#define AW869XX_BIT_CONTCFG1_EN_F0_DET_MASK (~(1 << 3))
+#define AW869XX_BIT_CONTCFG1_F0_DET_ENABLE (1 << 3)
+#define AW869XX_BIT_CONTCFG1_F0_DET_DISABLE (0 << 3)
+#define AW869XX_BIT_CONTCFG1_MBRK_MASK (~(1 << 2))
+#define AW869XX_BIT_CONTCFG1_MBRK_ENABLE (1 << 2)
+#define AW869XX_BIT_CONTCFG1_MBRK_DISABLE (0 << 2)
+#define AW869XX_BIT_CONTCFG1_BRK_BST_MD_MASK (~(1 << 1))
+#define AW869XX_BIT_CONTCFG1_BRK_BST_MD_ENABLE (1 << 1)
+#define AW869XX_BIT_CONTCFG1_BRK_BST_MD_DISABLE (0 << 1)
+#define AW869XX_BIT_CONTCFG1_SIN_MODE_MASK (~(1 << 0))
+#define AW869XX_BIT_CONTCFG1_SIN_MODE_COS (1 << 0)
+#define AW869XX_BIT_CONTCFG1_SIN_MODE_SINE (0 << 0)
+
+/* CONTCFG2: reg 0x19 RW */
+/* F_PRE */
+
+/* CONTCFG3: reg 0x1A RW */
+/* DRV_WIDTH */
+
+/* CONTCFG4: reg 0x1B RW */
+/* WAIT_NUM */
+
+/* CONTCFG5: reg 0x1C RW */
+#define AW869XX_BIT_CONTCFG5_BST_BRK_GAIN_MASK (~(0x0F << 4))
+#define AW869XX_BIT_CONTCFG5_BRK_GAIN_MASK (~(0x0F << 0))
+
+/* CONTCFG6: reg 0x1D RW */
+#define AW869XX_BIT_CONTCFG6_TRACK_EN_MASK (~(1 << 7))
+#define AW869XX_BIT_CONTCFG6_TRACK_ENABLE (1 << 7)
+#define AW869XX_BIT_CONTCFG6_TRACK_DISABLE (0 << 7)
+#define AW869XX_BIT_CONTCFG6_DRV1_LVL_MASK (~(0x7F << 0))
+
+/* CONTCFG7: reg 0x1E RW */
+#define AW869XX_BIT_CONTCFG7_DRV2_LVL_MASK (~(0x7F << 0))
+
+/* CONTCFG8: reg 0x1F RW */
+/* DRV1_TIME */
+
+/* CONTCFG9: reg 0x20 RW */
+/* DRV2_TIME */
+
+/* CONTCFG10: reg 0x21 RW */
+/* BRK_TIME */
+
+/* CONTCFG11: reg 0x22 RW */
+/* TRACK_MARGIN */
+
+/* CONTCFG12: reg 0x23 RW */
+/* MBRK_TH */
+
+/* CONTCFG13: reg 0x24 RW */
+#define AW869XX_BIT_CONTCFG13_TSET_MASK (~(0x0F << 4))
+#define AW869XX_BIT_CONTCFG13_BEME_SET_MASK (~(0x0F << 0))
+
+/* CONTRD14: reg 0x25 RO */
+/* F_LRA_F0_H */
+
+/* CONTRD15: reg 0x26 RO */
+/* F_LRA_F0_L */
+
+/* CONTRD16: reg 0x27 RO */
+/* CONT_F0_H */
+
+/* CONTRD17: reg 0x28 RO */
+/* CONT_F0_L */
+
+/* CONTRD18: reg 0x29 RO */
+/* ACCELERATION */
+
+/* CONTRD19: reg 0x2A RO */
+/* BEMF_PEAK1 */
+
+/* CONTRD20: reg 0x2B RO */
+/* BEMF_PEAK2 */
+
+/* CONTRD21: reg 0x2C RO */
+/* BEMF_PEAK3 */
+
+/***************** RTP *****************/
+/* RTPCFG1: reg 0x2D RW */
+/* BASE_ADDR_H */
+
+/* RTPCFG2: reg 0x2E RW */
+/* BASE_ADDR_L */
+
+/* RTPCFG3: reg 0x2F RW */
+#define AW869XX_BIT_RTPCFG3_FIFO_AEH_MASK (~(0x0F << 4))
+#define AW869XX_BIT_RTPCFG3_FIFO_AFH_MASK (~(0x0F << 0))
+
+/* RTPCFG4: reg 0x30 RW */
+/* FIFO_AEL */
+
+/* RTPCFG5: reg 0x31 RW */
+/* FIFO_AFL */
+
+/* RTPDATA: reg 0x32 RW */
+/* FIFO_AFL */
+
+/***************** TRIGGER *****************/
+#define AW869XX_BIT_TRG_ENABLE_MASK (~(1 << 7))
+#define AW869XX_BIT_TRG_ENABLE (1 << 7)
+#define AW869XX_BIT_TRG_DISABLE (0 << 7)
+#define AW869XX_BIT_TRG_SEQ_MASK (~(0x7F << 0))
+
+/* TRGCFG1: reg 0x33 RW */
+#define AW869XX_BIT_TRGCFG1_TRG1_POS_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG1_TRG1_POS_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG1_TRG1_POS_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG1_TRG1SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG2: reg 0x34 RW */
+#define AW869XX_BIT_TRGCFG2_TRG2_POS_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG2_TRG2_POS_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG2_TRG2_POS_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG2_TRG2SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG3: reg 0x35 RW */
+#define AW869XX_BIT_TRGCFG3_TRG3_POS_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG3_TRG3_POS_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG3_TRG3_POS_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG3_TRG3SEQ_P_MASK (~(0x7F << 0))
+
+/* TRGCFG4: reg 0x36 RW */
+#define AW869XX_BIT_TRGCFG4_TRG1_NEG_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG4_TRG1_NEG_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG4_TRG1_NEG_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG4_TRG1SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG5: reg 0x37 RW */
+#define AW869XX_BIT_TRGCFG5_TRG2_NEG_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG5_TRG2_NEG_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG5_TRG2_NEG_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG5_TRG2SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG6: reg 0x38 RW */
+#define AW869XX_BIT_TRGCFG6_TRG3_NEG_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG6_TRG3_NEG_ENABLE (1 << 7)
+#define AW869XX_BIT_TRGCFG6_TRG3_NEG_DISABLE (0 << 7)
+#define AW869XX_BIT_TRGCFG6_TRG3SEQ_N_MASK (~(0x7F << 0))
+
+/* TRGCFG7: reg 0x39 RW */
+#define AW869XX_BIT_TRGCFG7_TRG1_POLAR_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG7_TRG1_POLAR_NEG (1 << 7)
+#define AW869XX_BIT_TRGCFG7_TRG1_POLAR_POS (0 << 7)
+#define AW869XX_BIT_TRGCFG7_TRG1_MODE_MASK (~(1 << 6))
+#define AW869XX_BIT_TRGCFG7_TRG1_MODE_LEVEL (1 << 6)
+#define AW869XX_BIT_TRGCFG7_TRG1_MODE_EDGE (0 << 6)
+#define AW869XX_BIT_TRGCFG7_TRG1_AUTO_BRK_MASK (~(1 << 5))
+#define AW869XX_BIT_TRGCFG7_TRG1_AUTO_BRK_ENABLE (1 << 5)
+#define AW869XX_BIT_TRGCFG7_TRG1_AUTO_BRK_DISABLE (0 << 5)
+#define AW869XX_BIT_TRGCFG7_TRG1_BST_MASK (~(1 << 4))
+#define AW869XX_BIT_TRGCFG7_TRG1_BST_ENABLE (1 << 4)
+#define AW869XX_BIT_TRGCFG7_TRG1_BST_DISABLE (0 << 4)
+#define AW869XX_BIT_TRGCFG7_TRG2_POLAR_MASK (~(1 << 3))
+#define AW869XX_BIT_TRGCFG7_TRG2_POLAR_NEG (1 << 3)
+#define AW869XX_BIT_TRGCFG7_TRG2_POLAR_POS (0 << 3)
+#define AW869XX_BIT_TRGCFG7_TRG2_MODE_MASK (~(1 << 2))
+#define AW869XX_BIT_TRGCFG7_TRG2_MODE_LEVEL (1 << 2)
+#define AW869XX_BIT_TRGCFG7_TRG2_MODE_EDGE (0 << 2)
+#define AW869XX_BIT_TRGCFG7_TRG2_AUTO_BRK_MASK (~(1 << 1))
+#define AW869XX_BIT_TRGCFG7_TRG2_AUTO_BRK_ENABLE (1 << 1)
+#define AW869XX_BIT_TRGCFG7_TRG2_AUTO_BRK_DISABLE (0 << 1)
+#define AW869XX_BIT_TRGCFG7_TRG2_BST_MASK (~(1 << 0))
+#define AW869XX_BIT_TRGCFG7_TRG2_BST_ENABLE (1 << 0)
+#define AW869XX_BIT_TRGCFG7_TRG2_BST_DISABLE (0 << 0)
+
+/* TRGCFG8: reg 0x3A RW */
+#define AW869XX_BIT_TRGCFG8_TRG3_POLAR_MASK (~(1 << 7))
+#define AW869XX_BIT_TRGCFG8_TRG3_POLAR_NEG (1 << 7)
+#define AW869XX_BIT_TRGCFG8_TRG3_POLAR_POS (0 << 7)
+#define AW869XX_BIT_TRGCFG8_TRG3_MODE_MASK (~(1 << 6))
+#define AW869XX_BIT_TRGCFG8_TRG3_MODE_LEVEL (1 << 6)
+#define AW869XX_BIT_TRGCFG8_TRG3_MODE_EDGE (0 << 6)
+#define AW869XX_BIT_TRGCFG8_TRG3_AUTO_BRK_MASK (~(1 << 5))
+#define AW869XX_BIT_TRGCFG8_TRG3_AUTO_BRK_ENABLE (1 << 5)
+#define AW869XX_BIT_TRGCFG8_TRG3_AUTO_BRK_DISABLE (0 << 5)
+#define AW869XX_BIT_TRGCFG8_TRG3_BST_MASK (~(1 << 4))
+#define AW869XX_BIT_TRGCFG8_TRG3_BST_ENABLE (1 << 4)
+#define AW869XX_BIT_TRGCFG8_TRG3_BST_DISABLE (0 << 4)
+#define AW869XX_BIT_TRGCFG8_TRG_ONEWIRE_MASK (~(1 << 3))
+#define AW869XX_BIT_TRGCFG8_TRG_ONEWIRE (1 << 3)
+#define AW869XX_BIT_TRGCFG8_TRG1_STOP_MASK (~(1 << 2))
+#define AW869XX_BIT_TRGCFG8_TRG1_STOP (1 << 2)
+#define AW869XX_BIT_TRGCFG8_TRG2_STOP_MASK (~(1 << 1))
+#define AW869XX_BIT_TRGCFG8_TRG2_STOP (1 << 1)
+#define AW869XX_BIT_TRGCFG8_TRG3_STOP_MASK (~(1 << 0))
+#define AW869XX_BIT_TRGCFG8_TRG3_STOP (1 << 0)
+
+/* GLBCFG1: reg 0x3B RW */
+/* WAKE_DLY */
+
+/* GLBCFG2: reg 0x3C RW */
+/* START_DLY */
+
+/* GLBCFG3: reg 0x3D RW */
+/* END_DLY */
+
+/* GLBCFG4: reg 0x3E RW */
+#define AW869XX_BIT_GLBCFG4_GO_PRIO_MASK (~(3 << 6))
+#define AW869XX_BIT_GLBCFG4_TRG3_PRIO_MASK (~(3 << 4))
+#define AW869XX_BIT_GLBCFG4_TRG2_PRIO_MASK (~(3 << 2))
+#define AW869XX_BIT_GLBCFG4_TRG1_PRIO_MASK (~(3 << 0))
+
+/* GLBRD5: reg 0x3F R0 */
+/* GLB_STATE [3:0] */
+#define AW869XX_BIT_GLBRD5_STATE_MASK (~(15 << 0))
+#define AW869XX_BIT_GLBRD5_STATE_STANDBY (0 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_WAKEUP (1 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_STARTUP (2 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_WAIT (3 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_CONT_GO (6 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_RAM_GO (7 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_RTP_GO (8 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_TRIG_GO (9 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_I2S_GO (10 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_BRAKE (11 << 0)
+#define AW869XX_BIT_GLBRD5_STATE_END (12 << 0)
+
+/* RAMADDRH: reg 0x40 RWS */
+#define AW869XX_BIT_RAMADDRH_MASK (~(63 << 0))
+
+/* RAMADDRL: reg 0x41 RWS */
+/* RAMADDRL */
+
+/* RAMDATA: reg 0x42 RWS */
+/* RAMDATA */
+
+/***************** SYSCTRL *****************/
+/* SYSCTRL1: reg 0x43 RW */
+#define AW869XX_BIT_SYSCTRL1_VBAT_MODE_MASK (~(1 << 7))
+#define AW869XX_BIT_SYSCTRL1_VBAT_MODE_HW (1 << 7)
+#define AW869XX_BIT_SYSCTRL1_VBAT_MODE_SW (0 << 7)
+#define AW869XX_BIT_SYSCTRL1_PERP_MASK (~(1 << 6))
+#define AW869XX_BIT_SYSCTRL1_PERP_ON (1 << 6)
+#define AW869XX_BIT_SYSCTRL1_PERP_OFF (0 << 6)
+#define AW869XX_BIT_SYSCTRL1_CLK_SEL_MASK (~(3 << 4))
+#define AW869XX_BIT_SYSCTRL1_CLK_SEL_OSC (1 << 4)
+#define AW869XX_BIT_SYSCTRL1_CLK_SEL_AUTO (0 << 4)
+#define AW869XX_BIT_SYSCTRL1_RAMINIT_MASK (~(1 << 3))
+#define AW869XX_BIT_SYSCTRL1_RAMINIT_ON (1 << 3)
+#define AW869XX_BIT_SYSCTRL1_RAMINIT_OFF (0 << 3)
+#define AW869XX_BIT_SYSCTRL1_EN_FIR_MASK (~(1 << 2))
+#define AW869XX_BIT_SYSCTRL1_FIR_ENABLE (0 << 2)
+#define AW869XX_BIT_SYSCTRL1_WAKE_MODE_MASK (~(1 << 1))
+#define AW869XX_BIT_SYSCTRL1_WAKE_MODE_WAKEUP (1 << 1)
+#define AW869XX_BIT_SYSCTRL1_WAKE_MODE_BST (0 << 1)
+#define AW869XX_BIT_SYSCTRL1_RTP_CLK_MASK (~(1 << 0))
+#define AW869XX_BIT_SYSCTRL1_RTP_PLL (1 << 0)
+#define AW869XX_BIT_SYSCTRL1_RTP_OSC (0 << 0)
+
+/* SYSCTRL2: reg 0x44 RW */
+#define AW869XX_BIT_SYSCTRL2_WAKE_MASK (~(1 << 7))
+#define AW869XX_BIT_SYSCTRL2_WAKE_ON (1 << 7)
+#define AW869XX_BIT_SYSCTRL2_WAKE_OFF (0 << 7)
+#define AW869XX_BIT_SYSCTRL2_STANDBY_MASK (~(1 << 6))
+#define AW869XX_BIT_SYSCTRL2_STANDBY_ON (1 << 6)
+#define AW869XX_BIT_SYSCTRL2_STANDBY_OFF (0 << 6)
+#define AW869XX_BIT_SYSCTRL2_RTP_DLY_MASK (~(3 << 4))
+#define AW869XX_BIT_SYSCTRL2_PLL_PIN_MASK (~(1 << 3))
+#define AW869XX_BIT_SYSCTRL2_PLL_PIN_TEST (1 << 3)
+#define AW869XX_BIT_SYSCTRL2_I2S_PIN_MASK (~(1 << 2))
+#define AW869XX_BIT_SYSCTRL2_I2S_PIN_I2S (1 << 2)
+#define AW869XX_BIT_SYSCTRL2_I2S_PIN_TRIG (0 << 2)
+#define AW869XX_BIT_SYSCTRL2_WAVDAT_MODE_MASK (~(3 << 0))
+#define AW869XX_BIT_SYSCTRL2_RATE_12K (2 << 0)
+#define AW869XX_BIT_SYSCTRL2_RATE_24K (0 << 0)
+#define AW869XX_BIT_SYSCTRL2_RATE_48K (1 << 0)
+
+/* SYSCTRL3: reg 0x45 RW */
+/* SIN_H */
+
+/* SYSCTRL4: reg 0x46 RW */
+/* SIN_L */
+
+/* SYSCTRL5: reg 0x47 RW */
+/* COS_H */
+
+/* SYSCTRL6: reg 0x48 RW */
+/* COS_L */
+
+/* SYSCTRL7: reg 0x49 RW */
+#define AW869XX_BIT_SYSCTRL7_GAIN_BYPASS_MASK (~(1 << 6))
+#define AW869XX_BIT_SYSCTRL7_GAIN_CHANGEABLE (1 << 6)
+#define AW869XX_BIT_SYSCTRL7_GAIN_FIXED (0 << 6)
+#define AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_MASK (~(1 << 5))
+#define AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_POS (0 << 5)
+#define AW869XX_BIT_SYSCTRL7_INT_EDGE_MODE_BOTH (1 << 5)
+#define AW869XX_BIT_SYSCTRL7_INT_MODE_MASK (~(1 << 4))
+#define AW869XX_BIT_SYSCTRL7_INT_MODE_EDGE (1 << 4)
+#define AW869XX_BIT_SYSCTRL7_INT_MODE_LEVEL (0 << 4)
+#define AW869XX_BIT_SYSCTRL7_INTP_MASK (~(1 << 3))
+#define AW869XX_BIT_SYSCTRL7_INTP_HIGH (1 << 3)
+#define AW869XX_BIT_SYSCTRL7_INTP_LOW (0 << 3)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_MASK (~(7 << 0))
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_1 (0 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_2 (1 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_4 (2 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_8 (3 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_10 (4 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_16 (5 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_20 (6 << 0)
+#define AW869XX_BIT_SYSCTRL7_D2S_GAIN_26 (7 << 0)
+
+/***************** I2S *****************/
+/* I2SCFG1: reg 0x4A RW */
+#define AW869XX_BIT_I2SCFG1_I2SMD_MASK (~(3 << 6))
+#define AW869XX_BIT_I2SCFG1_I2SFS_MASK (~(3 << 4))
+#define AW869XX_BIT_I2SCFG1_I2SFS_16BIT (0 << 4)
+#define AW869XX_BIT_I2SCFG1_I2SFS_20BIT (1 << 4)
+#define AW869XX_BIT_I2SCFG1_I2SFS_24BIT (2 << 4)
+#define AW869XX_BIT_I2SCFG1_I2SFS_32BIT (3 << 4)
+#define AW869XX_BIT_I2SCFG1_I2SBCK_MASK (~(3 << 2))
+#define AW869XX_BIT_I2SCFG1_I2SBCK_32FS (0 << 2)
+#define AW869XX_BIT_I2SCFG1_I2SBCK_48FS (1 << 2)
+#define AW869XX_BIT_I2SCFG1_I2SBCK_64FS (2 << 2)
+#define AW869XX_BIT_I2SCFG1_RX_THRS_MASK (~(3 << 0))
+
+/* I2SCFG2: reg 0x4B RW */
+#define AW869XX_BIT_I2SCFG2_WSINV_MASK (~(1 << 4))
+#define AW869XX_BIT_I2SCFG2_WSINV_SWITCH (1 << 4)
+#define AW869XX_BIT_I2SCFG2_WSINV_NO_SWITCH (0 << 4)
+#define AW869XX_BIT_I2SCFG2_BCKINV_MASK (~(1 << 3))
+#define AW869XX_BIT_I2SCFG2_BCKINV_INVERT (1 << 3)
+#define AW869XX_BIT_I2SCFG2_BCKINV_NOTINVT (0 << 3)
+#define AW869XX_BIT_I2SCFG2_CHSEL_MASK (~(1 << 2))
+#define AW869XX_BIT_I2SCFG2_CHSEL_LEFT (1 << 2)
+#define AW869XX_BIT_I2SCFG2_CHSEL_RIGHT (0 << 2)
+#define AW869XX_BIT_I2SCFG2_I2S_INT_MASK (~(1 << 1))
+#define AW869XX_BIT_I2SCFG2_I2S_INT_ON (1 << 1)
+#define AW869XX_BIT_I2SCFG2_I2S_INT_OFF (0 << 1)
+#define AW869XX_BIT_I2SCFG2_I2S_EN_MASK (~(1 << 0))
+#define AW869XX_BIT_I2SCFG2_I2S_ENABLE (1 << 0)
+#define AW869XX_BIT_I2SCFG2_I2S_DISABLE (0 << 0)
+
+/* PWMCFG1: reg 0x4C RW */
+#define AW869XX_BIT_PWMCFG1_PRC_EN_MASK (~(1 << 7))
+#define AW869XX_BIT_PWMCFG1_PRC_ENABLE (1 << 7)
+#define AW869XX_BIT_PWMCFG1_PRC_DISABLE (0 << 7)
+#define AW869XX_BIT_PWMCFG1_PRCTIME_MASK (~(0x7F << 0))
+
+/* PWMCFG2: reg 0x4D RW */
+#define AW869XX_BIT_PWMCFG2_REF_SEL_MASK (~(1 << 5))
+#define AW869XX_BIT_PWMCFG2_REF_SEL_TRIANGLE (1 << 5)
+#define AW869XX_BIT_PWMCFG2_REF_SEL_SAWTOOTH (0 << 5)
+#define AW869XX_BIT_PWMCFG2_PD_HWM_MASK (~(1 << 4))
+#define AW869XX_BIT_PWMCFG2_PD_HWM_ON (1 << 4)
+#define AW869XX_BIT_PWMCFG2_PWMOE_MASK (~(1 << 3))
+#define AW869XX_BIT_PWMCFG2_PWMOE_ON (1 << 3)
+#define AW869XX_BIT_PWMCFG2_PWMFRC_MASK (~(7 << 0))
+
+/* PWMCFG3: reg 0x4E RW */
+#define AW869XX_BIT_PWMCFG3_PR_EN_MASK (~(1 << 7))
+#define AW869XX_BIT_PWMCFG3_PR_ENABLE (1 << 7)
+#define AW869XX_BIT_PWMCFG3_PR_DISABLE (0 << 7)
+#define AW869XX_BIT_PWMCFG3_PRLVL_MASK (~(0x7F << 0))
+
+/* PWMCFG4: reg 0x4F RW */
+/* PRTIME */
+
+/* TMCFG: reg 0x50 RW */
+/* TM */
+
+/* DETCFG1: reg 0x51 RW */
+#define AW869XX_BIT_DETCFG1_FTS_GO_MASK (~(1 << 7))
+#define AW869XX_BIT_DETCFG1_FTS_GO_ENABLE (1 << 7)
+#define AW869XX_BIT_DETCFG1_TEST_GO_MASK (~(1 << 6))
+#define AW869XX_BIT_DETCFG1_TEST_GO_ENABLE (1 << 6)
+#define AW869XX_BIT_DETCFG1_ADO_SLOT_MODE_MASK (~(1 << 5))
+#define AW869XX_BIT_DETCFG1_ADO_SLOT_ADC_32 (1 << 5)
+#define AW869XX_BIT_DETCFG1_ADO_SLOT_ADC_256 (0 << 5)
+#define AW869XX_BIT_DETCFG1_RL_OS_MASK (~(1 << 4))
+#define AW869XX_BIT_DETCFG1_RL (1 << 4)
+#define AW869XX_BIT_DETCFG1_OS (0 << 4)
+#define AW869XX_BIT_DETCFG1_PRCT_MODE_MASK (~(1 << 3))
+#define AW869XX_BIT_DETCFG1_PRCT_MODE_INVALID (1 << 3)
+#define AW869XX_BIT_DETCFG1_PRCT_MODE_VALID (0 << 3)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_MASK (~(7 << 0))
+#define AW869XX_BIT_DETCFG1_CLK_ADC_12M (0 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_6M (1 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_3M (2 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_1M5 (3 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_M75 (4 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_M37 (5 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_M18 (6 << 0)
+#define AW869XX_BIT_DETCFG1_CLK_ADC_M09 (7 << 0)
+
+/* DETCFG2: reg 0x52 RW */
+#define AW869XX_BIT_DETCFG2_VBAT_GO_MASK (~(1 << 1))
+#define AW869XX_BIT_DETCFG2_VABT_GO_ON (1 << 1)
+#define AW869XX_BIT_DETCFG2_DIAG_GO_MASK (~(1 << 0))
+#define AW869XX_BIT_DETCFG2_DIAG_GO_ON (1 << 0)
+
+/* DET_RL: reg 0x53 RW */
+/* RL */
+
+/* DET_OS: reg 0x54 RW */
+/* OS */
+
+/* DET_VBAT: reg 0x55 RW */
+/* VBAT */
+
+/* DET_TEST: reg 0x56 RW */
+/* TEST */
+
+/* DET_LO: reg 0x57 RW */
+#define AW869XX_BIT_DET_LO_TEST_MASK (~(3 << 6))
+#define AW869XX_BIT_DET_LO_VBAT_MASK (~(3 << 4))
+#define AW869XX_BIT_DET_LO_OS_MASK (~(3 << 2))
+#define AW869XX_BIT_DET_LO_RL_MASK (~(3 << 0))
+
+/* TRIMCFG1: reg:0x58 RW */
+#define AW869XX_BIT_TRIMCFG1_RL_TRIM_SRC_MASK (~(1 << 6))
+#define AW869XX_BIT_TRIMCFG1_RL_TRIM_SRC_REG (1 << 6)
+#define AW869XX_BIT_TRIMCFG1_RL_TRIM_SRC_EFUSE (0 << 6)
+#define AW869XX_BIT_TRIMCFG1_TRIM_RL_MASK (~(63 << 0))
+
+/* TRIMCFG2: reg:0x59 RW */
+#define AW869XX_BIT_TRIMCFG2_BST_TRIM_SRC_MASK (~(1 << 6))
+#define AW869XX_BIT_TRIMCFG2_BST_TRIM_SRC_REG (1 << 6)
+#define AW869XX_BIT_TRIMCFG2_BST_TRIM_SRC_EFUSE (0 << 6)
+#define AW869XX_BIT_TRIMCFG2_TRIM_BST_MASK (~(63 << 0))
+
+/* TRIMCFG3: reg:0x5A RW */
+#define AW869XX_BIT_TRIMCFG3_OSC_TRIM_SRC_MASK (~(1 << 7))
+#define AW869XX_BIT_TRIMCFG3_OSC_TRIM_SRC_REG (1 << 7)
+#define AW869XX_BIT_TRIMCFG3_OSC_TRIM_SRC_EFUSE (0 << 7)
+#define AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_MASK (~(1 << 6))
+#define AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_REG (1 << 6)
+#define AW869XX_BIT_TRIMCFG3_LRA_TRIM_SRC_EFUSE (0 << 6)
+#define AW869XX_BIT_TRIMCFG3_TRIM_LRA_MASK (~(63 << 0))
+
+/* TRIMCFG4: reg:0x5B RW */
+/* TRIM_OSC */
+
+/* PLLCFG1: reg:0x68 RW */
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_EN_MASK (~(1 << 6))
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_ENABLE (1 << 6)
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_DIV_MASK (~(3 << 4))
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_DIV_1 (0 << 4)
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_DIV_2 (1 << 4)
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_DIV_4 (2 << 4)
+#define AW869XX_BIT_PLLCFG1_PLL_TEST_DIV_8 (3 << 4)
+#define AW869XX_BIT_PLLCFG1_PLL_BIAS_CP1_IEN_MASK (~(1 << 3))
+#define AW869XX_BIT_PLLCFG1_PLL_BIAS_CP1_IENABLE (1 << 3)
+#define AW869XX_BIT_PLLCFG1_PLL_VTI_CP1_IEN_MASK (~(1 << 2))
+#define AW869XX_BIT_PLLCFG1_PLL_VTI_CP1_IENABLE (1 << 2)
+#define AW869XX_BIT_PLLCFG1_PLL_DELAY_SEL_MASK (~(1 << 1))
+#define AW869XX_BIT_PLLCFG1_PLL_R1_SEL_MASK (~(1 << 0))
+
+/* PLLCFG2: reg:0x69 RW */
+#define AW869XX_BIT_PLLCFG2_PLL_CP1_SEL_MASK (~(0x0F << 4))
+#define AW869XX_BIT_PLLCFG2_PLL_CP1_40UA (4 << 4)
+#define AW869XX_BIT_PLLCFG2_PLL_CP1_50UA (5 << 4)
+#define AW869XX_BIT_PLLCFG2_PLL_CP1_80UA (8 << 4)
+#define AW869XX_BIT_PLLCFG2_PLL_CP1_100UA (10 << 4)
+#define AW869XX_BIT_PLLCFG2_PLL_CP2_SEL_MASK (~(0x0F << 0))
+#define AW869XX_BIT_PLLCFG2_PLL_CP2_40NA (1 << 0)
+#define AW869XX_BIT_PLLCFG2_PLL_CP2_600NA (8 << 0)
+#define AW869XX_BIT_PLLCFG2_PLL_CP2_800NA (10 << 0)
+#define AW869XX_BIT_PLLCFG2_PLL_CP2_1200NA (12 << 0)
+
+/* HDRVCFG1: reg:0x6A RW */
+#define AW869XX_BIT_HDRVCFG1_EN_HD_LOW_MASK (~(1 << 7))
+#define AW869XX_BIT_HDRVCFG1_EN_HD_HZ (0 << 7)
+#define AW869XX_BIT_HDRVCFG1_EN_HD_PD (1 << 7)
+
+/* IOCFG1: reg:0x6B RW */
+#define AW869XX_BIT_IOCFG1_HSEN_MASK (~(1 << 6))
+#define AW869XX_BIT_IOCFG1_HS_ENABLE (1 << 6)
+#define AW869XX_BIT_IOCFG1_HS_DISABLE (0 << 6)
+#define AW869XX_BIT_IOCFG1_IO_FAST_MASK (~(3 << 4))
+#define AW869XX_BIT_IOCFG1_ALL_IO_FAST_ENABLE (3 << 4)
+#define AW869XX_BIT_IOCFG1_IIS_IO_FAST_ENABLE (2 << 4)
+#define AW869XX_BIT_IOCFG1_IIC_IO_FAST_ENABLE (1 << 4)
+#define AW869XX_BIT_IOCFG1_IO_FAST_DISABLE (0 << 4)
+
+/* BSTCFG1: reg:0x6D RW */
+#define AW869XX_BIT_BSTCFG1_BST_PC_MASK (~(7 << 1))
+
+/* BSTCFG5: reg:0x71 RW */
+#define AW869XX_BIT_BSTCFG5_BST_ADJ_MASK (~(1 << 7))
+#define AW869XX_BIT_BSTCFG5_BST_ADJ_HIGH (1 << 7)
+#define AW869XX_BIT_BSTCFG5_BST_ADJ_LOW (0 << 7)
+
+/* OCCFG1: reg:0x74 RW */
+#define AW869XX_BIT_OCCFG1_HS_IOC_MASK (~(3 << 6))
+#define AW869XX_BIT_OCCFG1_HS_IOC_3A15 (0 << 6)
+#define AW869XX_BIT_OCCFG1_HS_IOC_3A65 (1 << 6)
+#define AW869XX_BIT_OCCFG1_HS_IOC_4A15 (2 << 6)
+#define AW869XX_BIT_OCCFG1_HS_IOC_4A65 (3 << 6)
+#define AW869XX_BIT_OCCFG1_LS_IOC_MASK (~(3 << 4))
+#define AW869XX_BIT_OCCFG1_LS_IOC_3A15 (0 << 4)
+#define AW869XX_BIT_OCCFG1_LS_IOC_3A65 (1 << 4)
+#define AW869XX_BIT_OCCFG1_LS_IOC_4A15 (2 << 4)
+#define AW869XX_BIT_OCCFG1_LS_IOC_4A65 (3 << 4)
+#define AW869XX_BIT_OCCFG1_OCDT_MASK (~(3 << 2))
+
+#define AW869XX_BIT_OCCLK_MODE_MASK (~(3 << 0))
+
+/* ADCCFG1: reg:0x75 RW */
+#define AW869XX_BIT_ADCCFG1_BST_SOFT_DLY_ADJ_MASK (~(1 << 7))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_HDP_MASK (~(1 << 6))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_HDN_MASK (~(1 << 5))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_PVDD_MASK (~(1 << 4))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_TEST_MASK (~(1 << 3))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_VBAT_MASK (~(1 << 2))
+#define AW869XX_BIT_ADCCFG1_PD_D2S_DIV_MASK (~(1 << 1))
+#define AW869XX_BIT_ADCCFG1_AD_SEL_D2S_MASK (~(1 << 0))
+
+/* D2SCFG1: reg:0x76 RW */
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_MASK (~(7 << 0))
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_48K (0 << 0)
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_24K (1 << 0)
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_12K (2 << 0)
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_6K (3 << 0)
+#define AW869XX_BIT_D2SCFG1_CLK_TRIM_MODE_12M (4 << 0)
+
+#endif
diff --git a/drivers/input/misc/aw8697_haptic/ringbuffer.c b/drivers/input/misc/aw8697_haptic/ringbuffer.c
new file mode 100644
index 000000000000..79259e587105
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/ringbuffer.c
@@ -0,0 +1,223 @@
+/*
+* reader shoule NEVER block !!!, if no data is avaliable, just return zero
+* writer will block if there is no space, and wakend up by reader or force exit
+* there is 1 writer and 1 reader for each buffer, so no lock is used
+* writer shoule read rd_index to check if free size is enought, and  then fill this buffer  update wr_index
+* reader shoule read wr_index to check if avaliable size is enought, and then read the buffer and update rd_index
+* empty: wr_index==rd_index
+* full: (wr_index +1) % BUFFER_SIZE == rd_index
+* total avaliable size is BUFFER_SIZE -1
+*/
+#define DEBUG
+#include <linux/errno.h>
+#include "ringbuffer.h"
+
+#define MIN(x, y) ((x) < (y) ? (x) : (y))
+
+#define BUFFER_SIZE (1024 * 8 + 1)
+
+struct rb {
+	char *gbuffer;
+	atomic_t wr_index;
+	atomic_t rd_index;
+	atomic_t eof;
+	volatile int32_t aval_size; // avalibale to write size.
+	atomic_t buf_condition, exit;
+	wait_queue_head_t wait_q;
+};
+
+struct rb *grb;
+
+int32_t get_free_size(int32_t tail, int32_t head)
+{
+	if (head == tail)
+		return BUFFER_SIZE - 1;
+	else if (head < tail)
+		return (head + BUFFER_SIZE - 1 - tail);
+	else
+		return (head - tail - 1);
+}
+
+int write_rb(const char *data, int32_t size)
+{
+	int32_t tail = atomic_read(&grb->wr_index);
+	int32_t head = atomic_read(&grb->rd_index);
+	int32_t part;
+	int32_t ret;
+	grb->aval_size = get_free_size(tail, head);
+
+	pr_debug("write  write index %d, read index %d, free size %d", tail,
+		 head, grb->aval_size);
+
+	while ((grb->aval_size < size) && (!atomic_read(&grb->exit))) {
+		pr_debug("no space avaliable");
+		pr_info("%s  goint to waiting irq exit\n", __func__);
+		ret = wait_event_interruptible(
+			grb->wait_q, atomic_read(&grb->buf_condition) == 1);
+		if (ret == -ERESTARTSYS) {
+			pr_err("%s wake up by signal return erro\n", __func__);
+			return ret;
+		}
+
+		atomic_set(&grb->buf_condition, 0);
+		tail = atomic_read(&grb->wr_index);
+		head = atomic_read(&grb->rd_index);
+		grb->aval_size = get_free_size(tail, head);
+	}
+	if (atomic_read(&grb->exit) == 1) {
+		pr_debug("exit write_rb");
+		return -EPERM;
+	}
+
+	part = BUFFER_SIZE - tail;
+	if (part < size) {
+		memcpy(grb->gbuffer + tail, data, part);
+		memcpy(grb->gbuffer, data + part, size - part);
+		tail = size - part;
+	} else {
+		memcpy(grb->gbuffer + tail, data, size);
+		tail += size;
+		if (tail >= BUFFER_SIZE)
+			tail = tail % BUFFER_SIZE;
+	}
+	atomic_set(&grb->wr_index, tail);
+	grb->aval_size = get_free_size(tail, head);
+	pr_debug("after write %d,  write index %d, read index %d, aval_size %d",
+		 size, tail, head, grb->aval_size);
+	return size;
+}
+
+int read_rb(char *data, int32_t size)
+{
+	int32_t tail;
+	int32_t head;
+	int32_t filled_size;
+	void *buf;
+	int32_t read_bytes, part;
+	buf = data;
+
+	pr_debug("read_rb data:%p, size %d", data, (int)size);
+
+	tail = atomic_read(&grb->wr_index);
+	head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+	filled_size = BUFFER_SIZE - 1 - grb->aval_size; // aready write size.
+
+	pr_debug("write index %d, read index %d, filled size %d", tail, head,
+		 filled_size);
+	read_bytes = MIN(size, filled_size);
+	if (size > filled_size)
+		pr_debug("buffer underrun , req size %d, filled size %d", size,
+			 filled_size);
+	part = BUFFER_SIZE - head;
+	if (part < read_bytes) {
+		memcpy(buf, grb->gbuffer + head, part);
+		memcpy((char *)buf + part, grb->gbuffer, read_bytes - part);
+		head = read_bytes - part;
+	} else {
+		memcpy(buf, grb->gbuffer + head, read_bytes);
+		head += read_bytes;
+		if (head >= BUFFER_SIZE)
+			head = head % BUFFER_SIZE;
+	}
+	atomic_set(&grb->rd_index, head);
+	grb->aval_size = get_free_size(tail, head);
+
+	//add wakeup here
+	atomic_set(&grb->buf_condition, 1);
+	wake_up_interruptible(&grb->wait_q);
+	pr_debug(
+		"read_rb: after read %d  write index %d, read index %d, aval_size %d",
+		read_bytes, tail, head, grb->aval_size);
+
+	return atomic_read(&grb->eof) ? read_bytes : size;
+}
+
+int get_rb_free_size(void)
+{
+	int32_t tail = atomic_read(&grb->wr_index);
+	int32_t head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+	return grb->aval_size;
+}
+
+int get_rb_avalible_size(void)
+{
+	return BUFFER_SIZE - 1 - get_rb_free_size();
+}
+
+int get_rb_max_size(void)
+{
+	return BUFFER_SIZE - 1;
+}
+
+void rb_force_exit(void)
+{
+	pr_debug("rb force exit");
+	atomic_set(&grb->exit, 1);
+	atomic_set(&grb->buf_condition, 1);
+	wake_up_interruptible(&grb->wait_q);
+}
+
+void rb_end(void)
+{
+	atomic_set(&grb->eof, 1);
+}
+
+int rb_shoule_exit(void)
+{
+	return atomic_read(&grb->eof) || atomic_read(&grb->exit);
+}
+
+int create_rb(void)
+{
+	int32_t tail;
+	int32_t head;
+	grb = kzalloc(sizeof(struct rb), GFP_KERNEL);
+	if (grb == NULL) {
+		goto err;
+		;
+	}
+	grb->gbuffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+	if (grb->gbuffer == NULL) {
+		goto err;
+	}
+
+	rb_init();
+
+	init_waitqueue_head(&grb->wait_q);
+	tail = atomic_read(&grb->wr_index);
+	head = atomic_read(&grb->rd_index);
+	grb->aval_size = get_free_size(tail, head);
+
+	return 0;
+err:
+	if (grb)
+		kfree(grb);
+	if (grb->gbuffer)
+		kfree(grb->gbuffer);
+	return -EPERM;
+}
+
+void rb_init(void)
+{
+	pr_debug("rb init");
+	atomic_set(&grb->wr_index, 0);
+	atomic_set(&grb->rd_index, 0);
+	atomic_set(&grb->buf_condition, 0);
+	atomic_set(&grb->exit, 0);
+	atomic_set(&grb->eof, 0);
+}
+
+int release_rb(void)
+{
+	if (grb != NULL) {
+		if (grb->gbuffer) {
+			kfree(grb->gbuffer);
+			grb->gbuffer = NULL;
+		}
+		kfree(grb);
+		grb = NULL;
+	}
+	return 0;
+}
diff --git a/drivers/input/misc/aw8697_haptic/ringbuffer.h b/drivers/input/misc/aw8697_haptic/ringbuffer.h
new file mode 100644
index 000000000000..6ed6843d2b36
--- /dev/null
+++ b/drivers/input/misc/aw8697_haptic/ringbuffer.h
@@ -0,0 +1,34 @@
+/*
+* reader shoule NEVER block !!!, if no data is avaliable, just return zero
+* writer will block if there is no space, and wakend up by reader or force exit
+* there is 1 writer and 1 reader for each buffer, so no lock is used
+* writer shoule read rd_index to check if free size is enought, and  then fill this buffer  update wr_index
+* reader shoule read wr_index to check if avaliable size is enought, and then read the buffer and update rd_index
+* empty: wr_index==rd_index
+* full: (wr_index +1) % BUFFER_SIZE == rd_index
+* total avaliable size is BUFFER_SIZE -1
+*/
+
+#ifndef _RINGBUFFER_H_
+#define _RINGBUFFER_H_
+
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/mutex.h>
+#include <linux/atomic.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+
+int write_rb(const char *data, int32_t size);
+int read_rb(char *data, int32_t size);
+int get_rb_free_size(void);
+int get_rb_max_size(void);
+void rb_force_exit(void);
+void rb_end(void);
+int rb_shoule_exit(void);
+int create_rb(void);
+void rb_init(void);
+int release_rb(void);
+int get_rb_avalible_size(void);
+#endif
-- 
2.48.1

